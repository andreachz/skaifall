const __vite__mapDeps = (i, m=__vite__mapDeps, d=(m.f || (m.f = ["assets/nk7vjso6lqii5i7u.js", "assets/h3v66mipg7khna1m.js", "assets/egv8htilau9pzui2.js", "assets/cphgm26927zo9d84.js", "assets/kw1dn4ciyc11dkpx.js", "assets/ozplb2v7s86mfv04.js", "assets/ff7hu7wi6whn0zne.js", "assets/ff3fdideh9wu5zzm.js", "assets/gpbopsob939ydhph.js", "assets/mohyhqixw8ucsywk.js", "assets/conversation-small-ckm7oz9l.css", "assets/jz0ixzor1qptoh2n.js", "assets/lxqxyuopxa3r1dsp.js", "assets/mk041k5xr296rhm9.js", "assets/gc0kve5uhlwtl2a6.js", "assets/j3b3sezstexk6y74.js", "assets/fj297rfc91hxkh7s.js", "assets/jam1j3xnd0tafrum.js", "assets/og2klt9618t4jfpv.js", "assets/d9i89504oytx9wvs.js", "assets/oka0g8u378wjlih4.js", "assets/fhz6z5f0hse89mm5.js", "assets/kywqk9bi2jd42v72.js", "assets/ic8roysoxqyw2q34.js", "assets/b3u0hh6wyku2yym6.js", "assets/kxj9ugj9s5e14oay.js", "assets/g2qarlisjmavh0rr.js", "assets/fu4f7ifvj4oq4dp5.js", "assets/mywzgo3lf74he3ot.js", "assets/e0ab22sie91sizlo.js", "assets/im6x89c3gy8pc1m4.js", "assets/mevxu5edojk41akq.js", "assets/npgmrubfrm2npsox.js", "assets/fi0140mn584bj9cb.js", "assets/iej0cupg2dqkmejt.js", "assets/dtz3ck139ba6qdee.js", "assets/lfvj5xxuhn47ke56.js", "assets/cfrhwxa0nvmgw0v2.js", "assets/l2tgvpjm5ljsew4k.js", "assets/m8yy1xm1zzps507p.js", "assets/pyhs3wx430cfsww6.js", "assets/jrrpr7l4ip8ecydh.js", "assets/bwsokadt18b5oclx.js", "assets/glkpz4ordbj4tdee.js", "assets/hw9eicz8we0o23pk.js", "assets/np7ordfrlbhycq9s.js", "assets/m0aswx78slj3bi2n.js", "assets/lijvi7yrax0g9sgo.js", "assets/d0anamqj7vkbphy6.js", "assets/h5oawk2zgmmmxiaj.js", "assets/8vvv9cb2cch17vo8.js", "assets/obkrzr4fh7wvaarw.js", "assets/jkl63tcxg6rm6gqu.js", "assets/bk8slwxjkdlmxjxm.js", "assets/bojd1rqhxsat7jvu.js", "assets/gfnu7rj0xqi84ryj.js", "assets/gwd1q79x97phfvtl.js"]))) => i.map(i => d[i]);
import {K as aN, N as lN, O as AS, P as cN, r as h, C as wg, c as De, j as g, Q as gi, S as br, T as o$, U as i$, w as MS, R as Ne, l as IS, V as RS, g as mn, v as Ts, t as Un, L as Bf, z as a$, B as fl, _ as Qi, W as uN, X as l$, e as gt, M as de, d as xt, Y as NS, u as At, i as Lr, k as nr, q as so, s as c$, x as Xc, Z as u$, h as cs, a as oo, $ as d$, m as dN, b as Eg, o as PS, a0 as f$, p as h$, a1 as p$, a2 as fN, a3 as m$, a4 as hN, a5 as pN, a6 as mN, a7 as g$, a8 as v$, a9 as _$, aa as y$} from "./h3v66mipg7khna1m.js";
class Qc {
    static #e;
    #t;
    #r = new Map;
    #n = [];
    static get instance() {
        return Qc.#e || (Qc.#e = new Qc),
        Qc.#e
    }
    setLogger(t) {
        if (this.#t)
            throw new Error("Logger already set");
        this.#t = t;
        for (const [n,r] of this.#r.entries())
            this.#t.addTiming(n, r);
        this.#r.clear();
        for (const {error: n, context: r} of this.#n)
            this.#t.addError(n, r);
        this.#n = []
    }
    addTiming(t, n) {
        this.#t ? this.#t.addTiming(t, n) : this.#r.set(t, n ?? Date.now())
    }
    addError(t, n) {
        this.#t ? this.#t.addError(t, n) : (this.#n.push({
            error: t,
            context: n
        }),
        this.#n.length > 10 && (console.warn("LazyLogger: too many errors"),
        this.#n.shift()))
    }
}
function b$(e) {
    return function() {
        const n = {
            params: cN(),
            loaderData: AS(),
            actionData: lN(),
            matches: wg()
        };
        return h.createElement(e, n)
    }
}
function C$(e) {
    return function() {
        const n = {
            params: cN(),
            loaderData: AS(),
            actionData: lN(),
            error: aN()
        };
        return h.createElement(e, n)
    }
}
function DS(e) {
    return function(n) {
        const r = Symbol(void 0);
        return s => {
            if (!s)
                throw new Error(`Attempted to access scoped value without a ${e}.`);
            const o = s;
            if (r in o) {
                const i = o[r];
                if (i === VE)
                    throw new Error(`[${e}] Dependency cycle during scoped value initialization.`);
                if (i instanceof Error)
                    throw i;
                return i
            }
            try {
                o[r] = VE;
                const i = n(s);
                return o[r] = i,
                i
            } catch (i) {
                const a = i instanceof Error ? i : new Error(`[${e}] Failed to initialize scoped value: ` + i,{
                    cause: i
                });
                throw o[r] = a,
                a
            }
        }
    }
}
const en = DS("SessionContext");
function S$() {
    const e = Symbol(void 0);
    return [r => {
        if (!r)
            throw new Error("[SessionContext] Attempted to access session value without a SessionContext.");
        const s = r;
        if (e in s)
            return s[e];
        throw new Error("[SessionContext] Attempted to access session value before initialization.")
    }
    , (r, s) => {
        const o = r;
        if (e in o)
            throw new Error("[SessionContext] Attempted to initialize session value more than once.");
        o[e] = s
    }
    ]
}
const VE = Symbol();
function ue() {
    "use forget";
    const e = h.useContext(gN);
    if (!e)
        throw new Error("[SessionContext] Attempted to access sessionContext outside of <SessionContextProvider>");
    return e
}
const gN = h.createContext(void 0);
function vN() {
    return {}
}
const w$ = e => {
    "use forget";
    const t = De.c(3)
      , {sessionContext: n, children: r} = e;
    let s;
    return t[0] !== r || t[1] !== n ? (s = g.jsx(gN.Provider, {
        value: n,
        children: r
    }),
    t[0] = r,
    t[1] = n,
    t[2] = s) : s = t[2],
    s
}
;
var E$ = (e => (e.FreeSearchHoldout = "fsh",
e.AnonSearchHoldout = "ash",
e.NoAuthEnableFileUploads = "naefu",
e))(E$ || {});
const [un,x$] = S$();
function T$() {
    const e = ue();
    return un(e)
}
let k$ = vN();
function Ot() {
    return k$
}
let HE = !1;
function O$(e, t) {
    HE || (HE = !0,
    x$(e, t))
}
class _t extends Error {
    constructor(t, n, r, s) {
        const o = typeof r.error == "string" && r.error || typeof r.detail == "string" && r.detail || r.detail?.message || r.detail?.description || r.detail?.error?.message || M$;
        super(o),
        this.url = t,
        this.status = n,
        this.json = r,
        this.requestId = s,
        this.detail = r.detail,
        this.jsonError = r.error
    }
    name = "RequestError";
    detail;
    jsonError;
    static createWithErrorMessage(t, n, r, s) {
        return new _t(t,n === "client" ? 400 : 500,{
            error: r
        },s)
    }
    get code() {
        return this.detail?.code ?? this.jsonError?.code ?? this.jsonError?.error?.code ?? this.detail?.error?.code
    }
    isClientError() {
        return this.status >= 400 && this.status < 500
    }
    isServerError() {
        return this.status >= 500
    }
}
class on extends Error {
    name = "UserFileError";
    code;
    extra;
    constructor(t, n, r) {
        super(t),
        this.code = n,
        this.extra = r
    }
}
const A$ = "If this issue persists please contact us through our help center at help.openai.com."
  , LS = "If this issue persists please contact us through our help center at [help.openai.com](https://help.openai.com/)."
  , M$ = `Something went wrong. ${A$}`
  , I$ = `Something went wrong while generating the response. ${LS}`
  , Al = `A network error occurred. Please check your connection and try again. ${LS}`
  , R$ = "Network connection lost. Attempting to reconnectâ€¦";
function Q9e(e) {
    if (e instanceof _t && typeof e.message == "string" && e.message)
        return e.message
}
var Gp = (e => (e.HistoryDisabledConversationNotFound = "history_disabled_conversation_not_found",
e.ModelCapExceeded = "model_cap_exceeded",
e.MissingLastCompletion = "missing_last_completion",
e.InterruptionServerError = "interruption_server_error",
e))(Gp || {})
  , _N = (e => (e.NetworkErrorWithReconnection = "network_error_with_reconnection",
e))(_N || {});
function N$(e) {
    return e instanceof Error ? e : new Error(typeof e == "string" ? e : "Something went wrong")
}
function zE(e) {
    return e instanceof Error && e.name === "AbortError"
}
function P$(e, t) {
    return e instanceof Error && Error.captureStackTrace?.(e, t),
    e
}
function io(e, t="<unknown>") {
    if (e == null)
        throw P$(new Error(`${t}: unexpected nullish value: ${JSON.stringify(e)}`), io);
    return e
}
const Jh = (e, t, n={}) => {
    const r = {
        level: e,
        message: String(t),
        ...n
    };
    t instanceof Error && (r.error = t),
    r.error instanceof Error && (r.error = r.error.stack ?? String(r.error));
    try {
        console[e](r)
    } catch {
        Qr.error({
            level: "error",
            message: "Error stringifying log object." + (typeof r.message == "string" ? ` Message: ${r.message}` : "")
        })
    }
}
  , Qr = {
    info: (...e) => Jh("info", ...e),
    error: (...e) => Jh("error", ...e),
    warn: (...e) => Jh("warn", ...e),
    debug: (...e) => Jh("debug", ...e)
}
  , D$ = "client-nb0qtYlZuy2tCMN5s5ncnuIBCJncjRViT0IzFm7GqST";
let yN = "development";
yN = "production";
const L$ = yN;
var Ja = {}, Cc = {}, Xh = {}, $E;
function F$() {
    if ($E)
        return Xh;
    $E = 1,
    Object.defineProperty(Xh, "__esModule", {
        value: !0
    });
    const e = gi();
    let t = class {
        constructor(r) {
            this._sdkKey = r,
            this._rawValues = null,
            this._values = null,
            this._source = "Uninitialized",
            this._lcut = 0,
            this._receivedAt = 0,
            this._bootstrapMetadata = null,
            this._warnings = new Set
        }
        reset() {
            this._values = null,
            this._rawValues = null,
            this._source = "Loading",
            this._lcut = 0,
            this._receivedAt = 0,
            this._bootstrapMetadata = null
        }
        finalize() {
            this._values || (this._source = "NoValues")
        }
        getValues() {
            return this._rawValues ? (0,
            e._typedJsonParse)(this._rawValues, "has_updates", "EvaluationStoreValues") : null
        }
        setValues(r, s) {
            var o;
            if (!r)
                return !1;
            const i = (0,
            e._typedJsonParse)(r.data, "has_updates", "EvaluationResponse");
            return i == null ? !1 : (this._source = r.source,
            i?.has_updates !== !0 || (this._rawValues = r.data,
            this._lcut = i.time,
            this._receivedAt = r.receivedAt,
            this._values = i,
            this._bootstrapMetadata = this._extractBootstrapMetadata(r.source, i),
            r.source && i.user && this._setWarningState(s, i),
            e.SDKFlags.setFlags(this._sdkKey, (o = i.sdk_flags) !== null && o !== void 0 ? o : {})),
            !0)
        }
        getWarnings() {
            if (this._warnings.size !== 0)
                return Array.from(this._warnings)
        }
        getGate(r) {
            var s;
            return this._getDetailedStoreResult((s = this._values) === null || s === void 0 ? void 0 : s.feature_gates, r)
        }
        getConfig(r) {
            var s;
            return this._getDetailedStoreResult((s = this._values) === null || s === void 0 ? void 0 : s.dynamic_configs, r)
        }
        getLayer(r) {
            var s;
            return this._getDetailedStoreResult((s = this._values) === null || s === void 0 ? void 0 : s.layer_configs, r)
        }
        getParamStore(r) {
            var s;
            return this._getDetailedStoreResult((s = this._values) === null || s === void 0 ? void 0 : s.param_stores, r)
        }
        getSource() {
            return this._source
        }
        getExposureMapping() {
            var r;
            return (r = this._values) === null || r === void 0 ? void 0 : r.exposures
        }
        _extractBootstrapMetadata(r, s) {
            if (r !== "Bootstrap")
                return null;
            const o = {};
            return s.user && (o.user = s.user),
            s.sdkInfo && (o.generatorSDKInfo = s.sdkInfo),
            o.lcut = s.time,
            o
        }
        _getDetailedStoreResult(r, s) {
            let o = null;
            return r && (o = r[s] ? r[s] : r[(0,
            e._DJB2)(s)]),
            {
                result: o,
                details: this._getDetails(o == null)
            }
        }
        _setWarningState(r, s) {
            var o, i;
            const a = e.StableID.get(this._sdkKey);
            if (((o = r.customIDs) === null || o === void 0 ? void 0 : o.stableID) !== a && (!((i = r.customIDs) === null || i === void 0) && i.stableID || a)) {
                this._warnings.add("StableIDMismatch");
                return
            }
            if ("user"in s) {
                const l = s.user;
                (0,
                e._getFullUserHash)(r) !== (0,
                e._getFullUserHash)(l) && this._warnings.add("PartialUserMatch")
            }
        }
        getCurrentSourceDetails() {
            if (this._source === "Uninitialized" || this._source === "NoValues")
                return {
                    reason: this._source
                };
            const r = {
                reason: this._source,
                lcut: this._lcut,
                receivedAt: this._receivedAt
            };
            return this._warnings.size > 0 && (r.warnings = Array.from(this._warnings)),
            r
        }
        _getDetails(r) {
            var s, o;
            const i = this.getCurrentSourceDetails();
            let a = i.reason;
            const l = (s = i.warnings) !== null && s !== void 0 ? s : [];
            this._source === "Bootstrap" && l.length > 0 && (a = a + l[0]),
            a !== "Uninitialized" && a !== "NoValues" && (a = `${a}:${r ? "Unrecognized" : "Recognized"}`);
            const c = this._source === "Bootstrap" && (o = this._bootstrapMetadata) !== null && o !== void 0 ? o : void 0;
            return c && (i.bootstrapMetadata = c),
            Object.assign(Object.assign({}, i), {
                reason: a
            })
        }
    }
    ;
    return Xh.default = t,
    Xh
}
var Sc = {}, vd = {}, WE;
function j$() {
    if (WE)
        return vd;
    WE = 1,
    Object.defineProperty(vd, "__esModule", {
        value: !0
    }),
    vd._resolveDeltasResponse = void 0;
    const e = gi()
      , t = 2;
    function n(i, a) {
        const l = (0,
        e._typedJsonParse)(a, "checksum", "DeltasEvaluationResponse");
        if (!l)
            return {
                hadBadDeltaChecksum: !0
            };
        const c = r(i, l)
          , u = s(c)
          , d = (0,
        e._DJB2Object)({
            feature_gates: u.feature_gates,
            dynamic_configs: u.dynamic_configs,
            layer_configs: u.layer_configs
        }, t);
        return d === l.checksumV2 ? JSON.stringify(u) : {
            hadBadDeltaChecksum: !0,
            badChecksum: d,
            badMergedConfigs: u,
            badFullResponse: l.deltas_full_response
        }
    }
    vd._resolveDeltasResponse = n;
    function r(i, a) {
        return Object.assign(Object.assign(Object.assign({}, i), a), {
            feature_gates: Object.assign(Object.assign({}, i.feature_gates), a.feature_gates),
            layer_configs: Object.assign(Object.assign({}, i.layer_configs), a.layer_configs),
            dynamic_configs: Object.assign(Object.assign({}, i.dynamic_configs), a.dynamic_configs)
        })
    }
    function s(i) {
        const a = i;
        return o(i.deleted_gates, a.feature_gates),
        delete a.deleted_gates,
        o(i.deleted_configs, a.dynamic_configs),
        delete a.deleted_configs,
        o(i.deleted_layers, a.layer_configs),
        delete a.deleted_layers,
        a
    }
    function o(i, a) {
        i?.forEach(l => {
            delete a[l]
        }
        )
    }
    return vd
}
var KE;
function bN() {
    if (KE)
        return Sc;
    KE = 1;
    var e = Sc && Sc.__awaiter || function(s, o, i, a) {
        function l(c) {
            return c instanceof i ? c : new i(function(u) {
                u(c)
            }
            )
        }
        return new (i || (i = Promise))(function(c, u) {
            function d(m) {
                try {
                    p(a.next(m))
                } catch (v) {
                    u(v)
                }
            }
            function f(m) {
                try {
                    p(a.throw(m))
                } catch (v) {
                    u(v)
                }
            }
            function p(m) {
                m.done ? c(m.value) : l(m.value).then(d, f)
            }
            p((a = a.apply(s, o || [])).next())
        }
        )
    }
    ;
    Object.defineProperty(Sc, "__esModule", {
        value: !0
    });
    const t = gi()
      , n = j$();
    class r extends t.NetworkCore {
        constructor(o, i) {
            super(o, i);
            const a = o?.networkConfig;
            this._option = o,
            this._initializeUrlConfig = new t.UrlConfiguration(t.Endpoint._initialize,a?.initializeUrl,a?.api,a?.initializeFallbackUrls)
        }
        fetchEvaluations(o, i, a, l, c) {
            var u, d, f, p, m, v;
            return e(this, void 0, void 0, function*() {
                const _ = i ? (0,
                t._typedJsonParse)(i, "has_updates", "InitializeResponse") : null;
                let y = {
                    user: l,
                    hash: (f = (d = (u = this._option) === null || u === void 0 ? void 0 : u.networkConfig) === null || d === void 0 ? void 0 : d.initializeHashAlgorithm) !== null && f !== void 0 ? f : "djb2",
                    deltasResponseRequested: !1,
                    full_checksum: null
                };
                if (_?.has_updates) {
                    const b = _?.hash_used !== ((v = (m = (p = this._option) === null || p === void 0 ? void 0 : p.networkConfig) === null || m === void 0 ? void 0 : m.initializeHashAlgorithm) !== null && v !== void 0 ? v : "djb2");
                    y = Object.assign(Object.assign({}, y), {
                        sinceTime: c && !b ? _.time : 0,
                        previousDerivedFields: "derived_fields"in _ && c ? _.derived_fields : {},
                        deltasResponseRequested: !0,
                        full_checksum: _.full_checksum,
                        partialUserMatchSinceTime: b ? 0 : _.time
                    })
                }
                return this._fetchEvaluations(o, _, y, a)
            })
        }
        _fetchEvaluations(o, i, a, l) {
            var c, u;
            return e(this, void 0, void 0, function*() {
                const d = yield this.post({
                    sdkKey: o,
                    urlConfig: this._initializeUrlConfig,
                    data: a,
                    retries: 2,
                    isStatsigEncodable: !0,
                    priority: l
                });
                if (d?.code === 204)
                    return '{"has_updates": false}';
                if (d?.code !== 200)
                    return (c = d?.body) !== null && c !== void 0 ? c : null;
                if (i?.has_updates !== !0 || ((u = d.body) === null || u === void 0 ? void 0 : u.includes('"is_delta":true')) !== !0 || a.deltasResponseRequested !== !0)
                    return d.body;
                const f = (0,
                n._resolveDeltasResponse)(i, d.body);
                return typeof f == "string" ? f : this._fetchEvaluations(o, i, Object.assign(Object.assign(Object.assign({}, a), f), {
                    deltasResponseRequested: !1
                }), l)
            })
        }
    }
    return Sc.default = r,
    Sc
}
var _d = {}, YE;
function U$() {
    if (YE)
        return _d;
    YE = 1,
    Object.defineProperty(_d, "__esModule", {
        value: !0
    }),
    _d._makeParamStoreGetter = void 0;
    const e = gi()
      , t = {
        disableExposureLog: !0
    };
    function n(u) {
        return u == null || u.disableExposureLog === !1
    }
    function r(u, d) {
        return d != null && !(0,
        e._isTypeMatch)(u, d)
    }
    function s(u, d) {
        return u.value
    }
    function o(u, d, f) {
        return u.getFeatureGate(d.gate_name, n(f) ? void 0 : t).value ? d.pass_value : d.fail_value
    }
    function i(u, d, f, p) {
        const v = u.getDynamicConfig(d.config_name, n(p) ? void 0 : t).get(d.param_name);
        return r(v, f) ? f : v
    }
    function a(u, d, f, p) {
        const v = u.getExperiment(d.experiment_name, n(p) ? void 0 : t).get(d.param_name);
        return r(v, f) ? f : v
    }
    function l(u, d, f, p) {
        const v = u.getLayer(d.layer_name, n(p) ? void 0 : t).get(d.param_name);
        return r(v, f) ? f : v
    }
    function c(u, d, f) {
        return (p, m) => {
            if (d == null)
                return m;
            const v = d[p];
            if (v == null || m != null && (0,
            e._typeOf)(m) !== v.param_type)
                return m;
            switch (v.ref_type) {
            case "static":
                return s(v);
            case "gate":
                return o(u, v, f);
            case "dynamic_config":
                return i(u, v, m, f);
            case "experiment":
                return a(u, v, m, f);
            case "layer":
                return l(u, v, m, f);
            default:
                return m
            }
        }
    }
    return _d._makeParamStoreGetter = c,
    _d
}
var Xa = {}, ZE;
function B$() {
    if (ZE)
        return Xa;
    ZE = 1;
    var e = Xa && Xa.__awaiter || function(s, o, i, a) {
        function l(c) {
            return c instanceof i ? c : new i(function(u) {
                u(c)
            }
            )
        }
        return new (i || (i = Promise))(function(c, u) {
            function d(m) {
                try {
                    p(a.next(m))
                } catch (v) {
                    u(v)
                }
            }
            function f(m) {
                try {
                    p(a.throw(m))
                } catch (v) {
                    u(v)
                }
            }
            function p(m) {
                m.done ? c(m.value) : l(m.value).then(d, f)
            }
            p((a = a.apply(s, o || [])).next())
        }
        )
    }
    ;
    Object.defineProperty(Xa, "__esModule", {
        value: !0
    }),
    Xa.StatsigEvaluationsDataAdapter = void 0;
    const t = gi()
      , n = bN();
    let r = class extends t.DataAdapterCore {
        constructor() {
            super("EvaluationsDataAdapter", "evaluations"),
            this._network = null,
            this._options = null
        }
        attach(o, i, a) {
            super.attach(o, i, a),
            a !== null && a instanceof n.default ? this._network = a : this._network = new n.default(i ?? {})
        }
        getDataAsync(o, i, a) {
            return this._getDataAsyncImpl(o, (0,
            t._normalizeUser)(i, this._options), a)
        }
        prefetchData(o, i) {
            return this._prefetchDataImpl(o, i)
        }
        setData(o) {
            const i = (0,
            t._typedJsonParse)(o, "has_updates", "data");
            i && "user"in i ? super.setData(o, i.user) : t.Log.error("StatsigUser not found. You may be using an older server SDK version. Please upgrade your SDK or use setDataLegacy.")
        }
        setDataLegacy(o, i) {
            super.setData(o, i)
        }
        _fetchFromNetwork(o, i, a, l) {
            var c;
            return e(this, void 0, void 0, function*() {
                const u = yield(c = this._network) === null || c === void 0 ? void 0 : c.fetchEvaluations(this._getSdkKey(), o, a?.priority, i, l);
                return u ?? null
            })
        }
        _getCacheKey(o) {
            var i;
            const a = (0,
            t._getStorageKey)(this._getSdkKey(), o, (i = this._options) === null || i === void 0 ? void 0 : i.customUserCacheKeyFunc);
            return `${t.DataAdapterCachePrefix}.${this._cacheSuffix}.${a}`
        }
        _isCachedResultValidFor204(o, i) {
            return o.fullUserHash != null && o.fullUserHash === (0,
            t._getFullUserHash)(i)
        }
    }
    ;
    return Xa.StatsigEvaluationsDataAdapter = r,
    Xa
}
var JE;
function q$() {
    if (JE)
        return Cc;
    JE = 1;
    var e = Cc && Cc.__awaiter || function(a, l, c, u) {
        function d(f) {
            return f instanceof c ? f : new c(function(p) {
                p(f)
            }
            )
        }
        return new (c || (c = Promise))(function(f, p) {
            function m(y) {
                try {
                    _(u.next(y))
                } catch (b) {
                    p(b)
                }
            }
            function v(y) {
                try {
                    _(u.throw(y))
                } catch (b) {
                    p(b)
                }
            }
            function _(y) {
                y.done ? f(y.value) : d(y.value).then(m, v)
            }
            _((u = u.apply(a, l || [])).next())
        }
        )
    }
    ;
    Object.defineProperty(Cc, "__esModule", {
        value: !0
    });
    const t = gi()
      , n = F$()
      , r = bN()
      , s = U$()
      , o = B$();
    let i = class P3 extends t.StatsigClientBase {
        static instance(l) {
            const c = (0,
            t._getStatsigGlobal)().instance(l);
            return c instanceof P3 ? c : (t.Log.warn((0,
            t._isServerEnv)() ? "StatsigClient.instance is not supported in server environments" : "Unable to find StatsigClient instance"),
            new P3(l ?? "",{}))
        }
        constructor(l, c, u=null) {
            var d, f;
            t.SDKType._setClientType(l, "javascript-client");
            const p = new r.default(u,v => {
                this.$emt(v)
            }
            );
            super(l, (d = u?.dataAdapter) !== null && d !== void 0 ? d : new o.StatsigEvaluationsDataAdapter, p, u),
            this.getFeatureGate = this._memoize(t.MemoPrefix._gate, this._getFeatureGateImpl.bind(this)),
            this.getDynamicConfig = this._memoize(t.MemoPrefix._dynamicConfig, this._getDynamicConfigImpl.bind(this)),
            this.getExperiment = this._memoize(t.MemoPrefix._experiment, this._getExperimentImpl.bind(this)),
            this.getLayer = this._memoize(t.MemoPrefix._layer, this._getLayerImpl.bind(this)),
            this.getParameterStore = this._memoize(t.MemoPrefix._paramStore, this._getParameterStoreImpl.bind(this)),
            this._store = new n.default(l),
            this._network = p,
            this._user = this._configureUser(c, u);
            const m = (f = u?.plugins) !== null && f !== void 0 ? f : [];
            for (const v of m)
                v.bind(this)
        }
        initializeSync(l) {
            var c;
            return this.loadingStatus !== "Uninitialized" ? (0,
            t.createUpdateDetails)(!0, this._store.getSource(), -1, null, null, ["MultipleInitializations", ...(c = this._store.getWarnings()) !== null && c !== void 0 ? c : []]) : (this._logger.start(),
            this.updateUserSync(this._user, l))
        }
        initializeAsync(l) {
            return e(this, void 0, void 0, function*() {
                return this._initializePromise ? this._initializePromise : (this._initializePromise = this._initializeAsyncImpl(l),
                this._initializePromise)
            })
        }
        updateUserSync(l, c) {
            var u;
            const d = performance.now()
              , f = [...(u = this._store.getWarnings()) !== null && u !== void 0 ? u : []];
            this._resetForUser(l);
            const p = this.dataAdapter.getDataSync(this._user);
            p == null && f.push("NoCachedValues"),
            this._store.setValues(p, this._user),
            this._finalizeUpdate(p);
            const m = c?.disableBackgroundCacheRefresh;
            return m === !0 || m == null && p?.source === "Bootstrap" ? (0,
            t.createUpdateDetails)(!0, this._store.getSource(), performance.now() - d, this._errorBoundary.getLastSeenErrorAndReset(), this._network.getLastUsedInitUrlAndReset(), f) : (this._runPostUpdate(p ?? null, this._user),
            (0,
            t.createUpdateDetails)(!0, this._store.getSource(), performance.now() - d, this._errorBoundary.getLastSeenErrorAndReset(), this._network.getLastUsedInitUrlAndReset(), f))
        }
        updateUserAsync(l, c) {
            return e(this, void 0, void 0, function*() {
                this._resetForUser(l);
                const u = this._user;
                t.Diagnostics._markInitOverallStart(this._sdkKey);
                let d = this.dataAdapter.getDataSync(u);
                if (this._store.setValues(d, this._user),
                this._setStatus("Loading", d),
                d = yield this.dataAdapter.getDataAsync(d, u, c),
                u !== this._user)
                    return (0,
                    t.createUpdateDetails)(!1, this._store.getSource(), -1, new Error("User changed during update"), this._network.getLastUsedInitUrlAndReset());
                let f = !1;
                d != null && (t.Diagnostics._markInitProcessStart(this._sdkKey),
                f = this._store.setValues(d, this._user),
                t.Diagnostics._markInitProcessEnd(this._sdkKey, {
                    success: f
                })),
                this._finalizeUpdate(d),
                f || (this._errorBoundary.attachErrorIfNoneExists(t.UPDATE_DETAIL_ERROR_MESSAGES.NO_NETWORK_DATA),
                this.$emt({
                    name: "initialization_failure"
                })),
                t.Diagnostics._markInitOverallEnd(this._sdkKey, f, this._store.getCurrentSourceDetails());
                const p = t.Diagnostics._enqueueDiagnosticsEvent(this._user, this._logger, this._sdkKey, this._options);
                return (0,
                t.createUpdateDetails)(f, this._store.getSource(), p, this._errorBoundary.getLastSeenErrorAndReset(), this._network.getLastUsedInitUrlAndReset(), this._store.getWarnings())
            })
        }
        getContext() {
            return {
                sdkKey: this._sdkKey,
                options: this._options,
                values: this._store.getValues(),
                user: JSON.parse(JSON.stringify(this._user)),
                errorBoundary: this._errorBoundary,
                session: t.StatsigSession.get(this._sdkKey),
                stableID: t.StableID.get(this._sdkKey)
            }
        }
        checkGate(l, c) {
            return this.getFeatureGate(l, c).value
        }
        logEvent(l, c, u) {
            const d = typeof l == "string" ? {
                eventName: l,
                value: c,
                metadata: u
            } : l;
            this.$emt({
                name: "log_event_called",
                event: d
            }),
            this._logger.enqueue(Object.assign(Object.assign({}, d), {
                user: this._user,
                time: Date.now()
            }))
        }
        _primeReadyRipcord() {
            this.$on("error", () => {
                this.loadingStatus === "Loading" && this._finalizeUpdate(null)
            }
            )
        }
        _initializeAsyncImpl(l) {
            return e(this, void 0, void 0, function*() {
                return t.Storage.isReady() || (yield t.Storage.isReadyResolver()),
                this._logger.start(),
                this.updateUserAsync(this._user, l)
            })
        }
        _finalizeUpdate(l) {
            this._store.finalize(),
            this._setStatus("Ready", l)
        }
        _runPostUpdate(l, c) {
            this.dataAdapter.getDataAsync(l, c, {
                priority: "low"
            }).catch(u => {
                t.Log.error("An error occurred after update.", u)
            }
            )
        }
        _resetForUser(l) {
            this._logger.reset(),
            this._store.reset(),
            this._user = this._configureUser(l, this._options)
        }
        _configureUser(l, c) {
            var u;
            const d = (0,
            t._normalizeUser)(l, c)
              , f = (u = d.customIDs) === null || u === void 0 ? void 0 : u.stableID;
            return f && t.StableID.setOverride(f, this._sdkKey),
            d
        }
        _getFeatureGateImpl(l, c) {
            var u, d;
            const {result: f, details: p} = this._store.getGate(l)
              , m = (0,
            t._makeFeatureGate)(l, p, f)
              , v = (d = (u = this.overrideAdapter) === null || u === void 0 ? void 0 : u.getGateOverride) === null || d === void 0 ? void 0 : d.call(u, m, this._user, c)
              , _ = v ?? m;
            return this._enqueueExposure(l, (0,
            t._createGateExposure)(this._user, _, this._store.getExposureMapping()), c),
            this.$emt({
                name: "gate_evaluation",
                gate: _
            }),
            _
        }
        _getDynamicConfigImpl(l, c) {
            var u, d;
            const {result: f, details: p} = this._store.getConfig(l)
              , m = (0,
            t._makeDynamicConfig)(l, p, f)
              , v = (d = (u = this.overrideAdapter) === null || u === void 0 ? void 0 : u.getDynamicConfigOverride) === null || d === void 0 ? void 0 : d.call(u, m, this._user, c)
              , _ = v ?? m;
            return this._enqueueExposure(l, (0,
            t._createConfigExposure)(this._user, _, this._store.getExposureMapping()), c),
            this.$emt({
                name: "dynamic_config_evaluation",
                dynamicConfig: _
            }),
            _
        }
        _getExperimentImpl(l, c) {
            var u, d, f, p;
            const {result: m, details: v} = this._store.getConfig(l)
              , _ = (0,
            t._makeExperiment)(l, v, m);
            _.__evaluation != null && (_.__evaluation.secondary_exposures = (0,
            t._mapExposures)((d = (u = _.__evaluation) === null || u === void 0 ? void 0 : u.secondary_exposures) !== null && d !== void 0 ? d : [], this._store.getExposureMapping()));
            const y = (p = (f = this.overrideAdapter) === null || f === void 0 ? void 0 : f.getExperimentOverride) === null || p === void 0 ? void 0 : p.call(f, _, this._user, c)
              , b = y ?? _;
            return this._enqueueExposure(l, (0,
            t._createConfigExposure)(this._user, b, this._store.getExposureMapping()), c),
            this.$emt({
                name: "experiment_evaluation",
                experiment: b
            }),
            b
        }
        _getLayerImpl(l, c) {
            var u, d, f;
            const {result: p, details: m} = this._store.getLayer(l)
              , v = (0,
            t._makeLayer)(l, m, p)
              , _ = (d = (u = this.overrideAdapter) === null || u === void 0 ? void 0 : u.getLayerOverride) === null || d === void 0 ? void 0 : d.call(u, v, this._user, c);
            c?.disableExposureLog && this._logger.incrementNonExposureCount(l);
            const y = (0,
            t._mergeOverride)(v, _, (f = _?.__value) !== null && f !== void 0 ? f : v.__value, b => {
                c?.disableExposureLog || this._enqueueExposure(l, (0,
                t._createLayerParameterExposure)(this._user, y, b, this._store.getExposureMapping()), c)
            }
            );
            return this.$emt({
                name: "layer_evaluation",
                layer: y
            }),
            y
        }
        _getParameterStoreImpl(l, c) {
            var u, d;
            const {result: f, details: p} = this._store.getParamStore(l);
            this._logger.incrementNonExposureCount(l);
            const m = {
                name: l,
                details: p,
                __configuration: f,
                get: (0,
                s._makeParamStoreGetter)(this, f, c)
            }
              , v = (d = (u = this.overrideAdapter) === null || u === void 0 ? void 0 : u.getParamStoreOverride) === null || d === void 0 ? void 0 : d.call(u, m, c);
            return v != null && (m.__configuration = v.config,
            m.details = v.details,
            m.get = (0,
            s._makeParamStoreGetter)(this, v.config, c)),
            m
        }
    }
    ;
    return Cc.default = i,
    Cc
}
var XE;
function G$() {
    return XE || (XE = 1,
    function(e) {
        var t = Ja && Ja.__createBinding || (Object.create ? function(i, a, l, c) {
            c === void 0 && (c = l);
            var u = Object.getOwnPropertyDescriptor(a, l);
            (!u || ("get"in u ? !a.__esModule : u.writable || u.configurable)) && (u = {
                enumerable: !0,
                get: function() {
                    return a[l]
                }
            }),
            Object.defineProperty(i, c, u)
        }
        : function(i, a, l, c) {
            c === void 0 && (c = l),
            i[c] = a[l]
        }
        )
          , n = Ja && Ja.__exportStar || function(i, a) {
            for (var l in i)
                l !== "default" && !Object.prototype.hasOwnProperty.call(a, l) && t(a, i, l)
        }
        ;
        Object.defineProperty(e, "__esModule", {
            value: !0
        }),
        e.StatsigClient = void 0;
        const r = gi()
          , s = q$();
        e.StatsigClient = s.default,
        n(gi(), e);
        const o = Object.assign((0,
        r._getStatsigGlobal)(), {
            StatsigClient: s.default
        });
        e.default = o
    }(Ja)),
    Ja
}
var CN = G$(), Qa = {}, el = {}, QE;
function V$() {
    if (QE)
        return el;
    QE = 1;
    var e = el && el.__awaiter || function(i, a, l, c) {
        function u(d) {
            return d instanceof l ? d : new l(function(f) {
                f(d)
            }
            )
        }
        return new (l || (l = Promise))(function(d, f) {
            function p(_) {
                try {
                    v(c.next(_))
                } catch (y) {
                    f(y)
                }
            }
            function m(_) {
                try {
                    v(c.throw(_))
                } catch (y) {
                    f(y)
                }
            }
            function v(_) {
                _.done ? d(_.value) : u(_.value).then(p, m)
            }
            v((c = c.apply(i, a || [])).next())
        }
        )
    }
    ;
    Object.defineProperty(el, "__esModule", {
        value: !0
    }),
    el.LocalOverrideAdapter = void 0;
    const t = gi()
      , n = "LocalOverride:Recognized";
    function r() {
        return {
            gate: {},
            dynamicConfig: {},
            experiment: {},
            layer: {}
        }
    }
    function s(i, a) {
        return {
            gate: Object.assign({}, i.gate, a.gate),
            dynamicConfig: Object.assign({}, i.dynamicConfig, a.dynamicConfig),
            experiment: Object.assign({}, i.experiment, a.experiment),
            layer: Object.assign({}, i.layer, a.layer)
        }
    }
    let o = class {
        constructor(a) {
            this._overrides = r(),
            this._sdkKey = a ?? null
        }
        _getLocalOverridesStorageKey(a) {
            return `statsig.local-overrides.${(0,
            t._getStorageKey)(a)}`
        }
        loadFromStorage() {
            return e(this, void 0, void 0, function*() {
                if (this._sdkKey == null)
                    return;
                t.Storage.isReady() || (yield t.Storage.isReadyResolver());
                const a = this._getLocalOverridesStorageKey(this._sdkKey)
                  , l = t.Storage.getItem(a)
                  , c = l ? (0,
                t._typedJsonParse)(l, "gate", "LocalOverrideAdapter overrides") : null
                  , u = this._hasInMemoryOverrides();
                c && (this._overrides = u ? s(c, this._overrides) : c),
                u && this._saveOverridesToStorage()
            })
        }
        _saveOverridesToStorage() {
            if (this._sdkKey == null || !t.Storage.isReady())
                return;
            const a = this._getLocalOverridesStorageKey(this._sdkKey);
            t.Storage.setItem(a, JSON.stringify(this._overrides))
        }
        overrideGate(a, l) {
            this._overrides.gate[a] = l,
            this._overrides.gate[(0,
            t._DJB2)(a)] = l,
            this._saveOverridesToStorage()
        }
        _warnIfStorageNotReady() {
            t.Storage.isReady() || t.Log.warn("Storage is not ready. Override removal may not persist.")
        }
        removeGateOverride(a) {
            this._warnIfStorageNotReady(),
            delete this._overrides.gate[a],
            delete this._overrides.gate[(0,
            t._DJB2)(a)],
            this._saveOverridesToStorage()
        }
        getGateOverride(a, l) {
            var c;
            const u = (c = this._overrides.gate[a.name]) !== null && c !== void 0 ? c : this._overrides.gate[(0,
            t._DJB2)(a.name)];
            return u == null ? null : Object.assign(Object.assign({}, a), {
                value: u,
                details: Object.assign(Object.assign({}, a.details), {
                    reason: n
                })
            })
        }
        overrideDynamicConfig(a, l) {
            this._overrides.dynamicConfig[a] = l,
            this._overrides.dynamicConfig[(0,
            t._DJB2)(a)] = l,
            this._saveOverridesToStorage()
        }
        removeDynamicConfigOverride(a) {
            this._warnIfStorageNotReady(),
            delete this._overrides.dynamicConfig[a],
            delete this._overrides.dynamicConfig[(0,
            t._DJB2)(a)],
            this._saveOverridesToStorage()
        }
        getDynamicConfigOverride(a, l) {
            return this._getConfigOverride(a, this._overrides.dynamicConfig)
        }
        overrideExperiment(a, l) {
            this._overrides.experiment[a] = l,
            this._overrides.experiment[(0,
            t._DJB2)(a)] = l,
            this._saveOverridesToStorage()
        }
        removeExperimentOverride(a) {
            this._warnIfStorageNotReady(),
            delete this._overrides.experiment[a],
            delete this._overrides.experiment[(0,
            t._DJB2)(a)],
            this._saveOverridesToStorage()
        }
        getExperimentOverride(a, l) {
            return this._getConfigOverride(a, this._overrides.experiment)
        }
        overrideLayer(a, l) {
            this._overrides.layer[a] = l,
            this._overrides.layer[(0,
            t._DJB2)(a)] = l,
            this._saveOverridesToStorage()
        }
        removeLayerOverride(a) {
            this._warnIfStorageNotReady(),
            delete this._overrides.layer[a],
            delete this._overrides.layer[(0,
            t._DJB2)(a)],
            this._saveOverridesToStorage()
        }
        getAllOverrides() {
            return JSON.parse(JSON.stringify(this._overrides))
        }
        removeAllOverrides() {
            this._warnIfStorageNotReady(),
            this._overrides = r(),
            this._saveOverridesToStorage()
        }
        getLayerOverride(a, l) {
            var c;
            const u = (c = this._overrides.layer[a.name]) !== null && c !== void 0 ? c : this._overrides.layer[(0,
            t._DJB2)(a.name)];
            return u == null ? null : Object.assign(Object.assign({}, a), {
                __value: u,
                get: (0,
                t._makeTypedGet)(a.name, u),
                details: Object.assign(Object.assign({}, a.details), {
                    reason: n
                })
            })
        }
        _getConfigOverride(a, l) {
            var c;
            const u = (c = l[a.name]) !== null && c !== void 0 ? c : l[(0,
            t._DJB2)(a.name)];
            return u == null ? null : Object.assign(Object.assign({}, a), {
                value: u,
                get: (0,
                t._makeTypedGet)(a.name, u),
                details: Object.assign(Object.assign({}, a.details), {
                    reason: n
                })
            })
        }
        _hasInMemoryOverrides() {
            return Object.keys(this._overrides.gate).length > 0 || Object.keys(this._overrides.dynamicConfig).length > 0 || Object.keys(this._overrides.experiment).length > 0 || Object.keys(this._overrides.layer).length > 0
        }
    }
    ;
    return el.LocalOverrideAdapter = o,
    el
}
var e7;
function H$() {
    return e7 || (e7 = 1,
    function(e) {
        var t = Qa && Qa.__createBinding || (Object.create ? function(r, s, o, i) {
            i === void 0 && (i = o);
            var a = Object.getOwnPropertyDescriptor(s, o);
            (!a || ("get"in a ? !s.__esModule : a.writable || a.configurable)) && (a = {
                enumerable: !0,
                get: function() {
                    return s[o]
                }
            }),
            Object.defineProperty(r, i, a)
        }
        : function(r, s, o, i) {
            i === void 0 && (i = o),
            r[i] = s[o]
        }
        )
          , n = Qa && Qa.__exportStar || function(r, s) {
            for (var o in r)
                o !== "default" && !Object.prototype.hasOwnProperty.call(s, o) && t(s, r, o)
        }
        ;
        Object.defineProperty(e, "__esModule", {
            value: !0
        }),
        n(V$(), e)
    }(Qa)),
    Qa
}
var z$ = H$();
function bm(e, t, n, r) {
    return us(e).logEvent(t, n, r)
}
function Xe(e, t, n) {
    return us(e).checkGate(t, n)
}
function Vn(e, t, n) {
    return us(e).getDynamicConfig(t, n)
}
function qf(e, t, n) {
    return us(e).getExperiment(t, n)
}
function $t(e, t, n) {
    return us(e).getLayer(t, n)
}
const $$ = en( () => new z$.LocalOverrideAdapter)
  , W$ = e => {
    const t = {};
    return typeof e?.custom?.auth_status == "string" && (t.auth_status = e.custom.auth_status),
    typeof e?.locale == "string" && (t.browser_locale = e.locale),
    t
}
;
class K$ extends CN.StatsigClient {
    logEvent(t, n, r) {
        const s = {
            ...W$(this.getContext().user),
            ...typeof t == "string" ? r : t.metadata
        };
        super.logEvent(typeof t == "string" ? t : t.eventName, typeof t == "string" ? n : t.value ?? void 0, s)
    }
}
const us = en(e => {
    const t = un(e)
      , n = $$(e)
      , r = new K$(D$,t.statsigPayload.user,{
        environment: {
            tier: L$
        },
        networkConfig: {
            api: "https://ab.chatgpt.com/v1",
            preventAllNetworkTraffic: !1
        },
        loggingBufferMaxSize: 100,
        disableLogging: !1,
        disableStorage: !1,
        overrideAdapter: n,
        logEventCompressionMode: CN.LogEventCompressionMode.Forced
    });
    return r.dataAdapter.setData(JSON.stringify(t.statsigPayload)),
    r.initializeSync(),
    r
}
);
function yd() {
    return us(Ot())
}
const ft = {
    logEvent: (e, t, n) => yd().logEvent(e, t ?? void 0, n),
    checkGate: e => yd().checkGate(e),
    getUser: () => yd().getContext().user,
    getLayerValue(e) {
        return yd().getLayer(e.layerName, {
            disableExposureLog: !e.shouldLogExposure
        }).get(e.key) ?? e.defaultValue
    },
    checkGateWithExposureLoggingDisabled: e => yd().checkGate(e, {
        disableExposureLog: !0
    })
};
function Es() {
    return navigator.userAgent
}
function FS() {
    return /iPad|iPhone|iPod/.test(Es())
}
function jS() {
    return /Android/.test(Es())
}
function Y$() {
    return FS() && Es().includes("CriOS")
}
function xg() {
    return FS() || jS() || Y$()
}
function t7() {
    return /^((?!chrome|android).)*safari/i.test(Es())
}
function r8e() {
    return jS() && Es().includes("Chrome")
}
function Z$() {
    return Es().includes("Mac OS X")
}
function SN() {
    return FS() || Z$()
}
function s8e() {
    return Es().includes("Windows_NT")
}
function o8e() {
    return Es().includes("Chrome/") && !/Android|iPhone|iPad/i.test(Es())
}
function i8e() {
    return Es().includes("Firefox")
}
function US() {
    const e = Es();
    return /iPad/.test(e) || jS() && !/Mobile/.test(e) || /Tablet/.test(e)
}
function J$() {
    return xg() && !US()
}
function wN() {
    return xg() || US()
}
function BS() {
    return !wN()
}
const X$ = /^ChatGPT.+Macintosh;.+ Chrome\/([\d.]+) .*$/;
function ao(e) {
    return e || (e = Es()),
    X$.test(e)
}
const Q$ = ["Fetch is aborted", "Load failed", "Script error.", "Failed to execute 'insertBefore' on 'Node'", "ResizeObserver loop completed with undelivered notifications.", "Object Not Found Matching Id", "Object.hasOwn is not a function"]
  , eW = 100
  , n7 = 1e3
  , Qh = [];
function r7(e, t) {
    const n = e.findIndex(r => r <= t);
    return n === -1 ? e.length : n
}
const tW = e => {
    if (e.stack?.includes("-extension://") || e.source === "console" || Q$.some(s => e?.message?.includes(s)) || e.type === "RequestError")
        return !0;
    const t = Date.now()
      , n = t - 1e3 * 60;
    if (r7(Qh, n) >= eW)
        return !0;
    const r = t - 1e3 * 60 * 60 * 24;
    return r7(Qh, r) >= n7 ? !0 : (Qh.unshift(t),
    Qh.splice(n7),
    !1)
}
;
function EN() {
    return location.origin === "https://chatgpt.com" || !1
}
function xN() {
    return ao() ? "mini-web" : "chatgpt-web"
}
const s7 = typeof window > "u" ? void 0 : window.DesktopHostGateway
  , qn = s7?.getVersion() === 1 ? s7 : void 0
  , Tg = qn !== void 0
  , TN = Tg || !1;
function a8e(e) {
    if (e === void 0)
        return;
    const t = /^ChatGPT\/([\d.]+) \(([^)]+)\) Electron\/([\d.]+) Chrome\/([\d.]+)$/
      , n = e.match(t);
    if (n)
        return n[1]
}
function o7(...e) {
    try {
        return new URL(...e)
    } catch {
        return null
    }
}
function Kd(e) {
    const t = new URL(e);
    return t.searchParams.has("q") && t.searchParams.set("q", "<redacted>"),
    t.toString()
}
const qS = "chatgpt.com/ces"
  , GS = "https"
  , nW = {}
  , rW = nW
  , kN = `${GS}://${qS}`
  , sW = {
    disableClientPersistence: !0,
    integrations: {
        "Segment.io": {
            apiHost: `${qS}/v1`,
            host: kN,
            protocol: GS,
            deliveryStrategy: {
                ...rW
            }
        }
    }
}
  , oW = {
    writeKey: "oai",
    cdnURL: `${GS}://${qS}`
};
var VS = {}
  , Qt = (e => (e[e.Required = 0] = "Required",
e[e.SendIfAvailable = 1] = "SendIfAvailable",
e[e.Anonymous = 2] = "Anonymous",
e))(Qt || {});
const lt = VS.VITE_SHARED_API_URL ?? "https://chatgpt.com/backend-api"
  , HS = VS.VITE_SHARED_ANON_API_URL ?? "https://chatgpt.com/backend-anon"
  , Vp = VS.VITE_PUBLIC_API_URL ?? "https://chatgpt.com/public-api"
  , iW = "v4-2023-04-27"
  , l8e = {
    IT: "Italy",
    KR: "South Korea"
}
  , aW = {
    AD: "Andorra",
    AI: "Anguilla",
    AT: "Austria",
    AW: "Aruba",
    AX: "Ã…land Islands",
    BG: "Bulgaria",
    BL: "Saint BarthÃ©lemy",
    BM: "Bermuda",
    BQ: "Caribbean Netherlands",
    BV: "Bouvet Island",
    CH: "Switzerland",
    CW: "CuraÃ§ao",
    CY: "Cyprus",
    CZ: "Czech Republic",
    DE: "Germany",
    DK: "Denmark",
    EE: "Estonia",
    ES: "Spain",
    FI: "Finland",
    FK: "Falkland Islands",
    FO: "Faroe Islands",
    FR: "France",
    GB: "United Kingdom",
    GF: "French Guiana",
    GG: "Guernsey",
    GI: "Gibraltar",
    GL: "Greenland",
    GP: "Guadeloupe",
    GR: "Greece",
    GS: "South Georgia and the South Sandwich Islands",
    HR: "Croatia",
    HU: "Hungary",
    IC: "Canary Islands",
    IE: "Ireland",
    IM: "Isle of Man",
    IO: "British Indian Ocean Territory",
    IS: "Iceland",
    IT: "Italy",
    JE: "Jersey",
    KY: "Cayman Islands",
    LI: "Liechtenstein",
    LT: "Lithuania",
    LU: "Luxembourg",
    LV: "Latvia",
    MC: "Monaco",
    ME: "Montenegro",
    MF: "Saint Martin",
    MQ: "Martinique",
    MS: "Montserrat",
    MT: "Malta",
    NC: "New Caledonia",
    NL: "Netherlands",
    NO: "Norway",
    PF: "French Polynesia",
    PL: "Poland",
    PM: "Saint Pierre and Miquelon",
    PN: "Pitcairn",
    PT: "Portugal",
    RE: "Reunion",
    SE: "Sweden",
    SH: "Saint Helena, Ascension and Tristan da Cunha",
    SI: "Slovenia",
    SJ: "Svalbard and Jan Mayen",
    SK: "Slovakia",
    SM: "San Marino",
    SX: "Sint Maarten",
    TC: "Turks and Caicos Islands",
    TF: "French Southern Territories",
    VG: "British Virgin Islands",
    WF: "Wallis and Futuna",
    YT: "Mayotte",
    ZA: "South Africa",
    ID: "Indonesia",
    BE: "Belgium",
    IN: "India",
    RO: "Romania",
    CA: "Canada",
    SG: "Singapore"
}
  , ON = [/^https:\/\/ab\.chatgpt\.com\//, e => e.startsWith(kN), e => {
    const t = [lt, HS]
      , n = [/^\/sentinel\//];
    for (const r of t)
        if (e.startsWith(r)) {
            const s = e.slice(r.length);
            return n.some(o => o.test(s))
        }
    return !1
}
];
class lW {
    #e = !1;
    #t = new Set;
    #r = new Set;
    #n = new Map;
    initialize(t) {
        if (!this.#e) {
            {
                const n = Tg ? qn?.getTelemetryConfig?.() : void 0
                  , r = n !== void 0 ? n.datadogService : xN()
                  , s = ao() ? 100 : 1;
                br.init({
                    applicationId: "fd6e06b8-4825-4fbb-8db4-2a243f92c4bc",
                    clientToken: "pub1f79f8ac903a5872ae5f53026d20a77c",
                    site: "datadoghq.com",
                    service: r,
                    env: "prod",
                    version: "9d358314d30a26d59ec2f2390d079c86e2c0018f",
                    sessionSampleRate: s,
                    sessionReplaySampleRate: 0,
                    trackUserInteractions: !1,
                    defaultPrivacyLevel: o$.MASK_USER_INPUT,
                    beforeSend: o => {
                        if (o.type === "error" && tW(o.error))
                            return !1;
                        if (o.view.url = Kd(o.view.url),
                        o.type === "resource") {
                            const i = o7(o.resource.url);
                            if (i != null && (i.hostname === "ab.chatgpt.com" || i.pathname.startsWith("/ces/")))
                                return !1;
                            o.resource.url = Kd(o.resource.url)
                        }
                        return o.type === "error" && o.error.resource && (o.error.resource.url = Kd(o.error.resource.url)),
                        !0
                    }
                    ,
                    allowedTracingUrls: [{
                        match: o => {
                            const i = o7(o);
                            if (i == null)
                                return !1;
                            const {hostname: a, pathname: l} = i;
                            return !(!["openai.com", "chatgpt.com"].some(u => a.endsWith(u)) || a === "ab.chatgpt.com" || l.startsWith("/ces/") || l.startsWith("/healthcheck"))
                        }
                        ,
                        propagatorTypes: ["datadog"]
                    }],
                    traceSampleRate: s,
                    excludedActivityUrls: ON,
                    ...t
                }),
                br.setGlobalContextProperty("track", "stable"),
                n !== void 0 && br.setGlobalContextProperty("is_electron_desktop_app", !0),
                br.setGlobalContextProperty("is_authenticated", !1)
            }
            this.#e = !0,
            Qc.instance.setLogger(this)
        }
    }
    get viewId() {
        return br.getInternalContext()?.view?.id
    }
    get sessionId() {
        return br.getInternalContext()?.session_id
    }
    addAction(t, n) {
        this.#e || (console.error("Should not call addAction before initialize"),
        this.initialize()),
        br.addAction(t, n)
    }
    addError(t, n) {
        if (console.error(t, n),
        this.#e || (console.error("Should not call addError before initialize"),
        this.initialize()),
        t instanceof _t)
            return;
        const r = typeof t == "string" ? new Error(t) : t;
        br.addError(r, n)
    }
    addTiming(t, n) {
        const r = n ?? Date.now();
        this.#n.set(t, r),
        this.#e || (console.error("Should not call addTiming before initialize"),
        this.initialize()),
        performance.mark(t, {
            startTime: Math.max(0, r - performance.timeOrigin)
        }),
        br.addTiming(t, n)
    }
    addFirstTiming(t, n) {
        this.#t.has(t) || (this.#t.add(t),
        this.addTiming(t, n))
    }
    addDurationVital(t, n, r) {
        br.addDurationVital(t, {
            startTime: n,
            duration: r
        })
    }
    addFirstDurationVital(t, n, r) {
        this.#r.has(t) || (this.#r.add(t),
        this.addDurationVital(t, n, r))
    }
    getTimings() {
        return this.#n
    }
    setUser(t, n) {
        br.setGlobalContextProperty("is_authenticated", !0);
        const r = {
            id: t.id,
            account_plan_type: n?.planType ?? "none",
            workspace_id: n?.id
        };
        this.#e || (console.error("Should not call setUser before initialize"),
        this.initialize()),
        br.setUser(r)
    }
    addFeatureFlagEvaluation(t, n) {
        br.addFeatureFlagEvaluation(t, n)
    }
}
const q = new lW
  , AN = 58 * 60 * 1e3
  , cW = AN
  , D3 = {};
function uW(e, t) {
    D3[e] = t
}
function dW(e) {
    return e != null && "__type"in e && e.__type in D3 ? D3[e.__type](e) : e
}
const MN = JSON.stringify
  , Aa = en(fW);
function fW(e) {
    let t = !0;
    return e && (t = $t(e, "892702716").get("react_query_infinite_stale_time", !1),
    q.addFeatureFlagEvaluation("react_query_infinite", t)),
    new i$({
        defaultOptions: {
            queries: {
                gcTime: cW,
                staleTime: t ? 1 / 0 : AN,
                retry: !1,
                retryOnMount: !1,
                refetchOnMount: !1,
                refetchOnWindowFocus: !1,
                refetchOnReconnect: !1,
                networkMode: "always",
                queryKeyHashFn: MN,
                throwOnError: (n, r) => {
                    if (!(n instanceof _t || n instanceof on))
                        try {
                            q.addError(n, {
                                queryKey: r.queryKey.map(String).join(","),
                                queryHash: r.queryHash
                            })
                        } catch (s) {
                            console.error(s)
                        }
                    return !1
                }
            },
            hydrate: {
                deserializeData: dW
            }
        }
    })
}
const IN = h.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
if (!IN)
    throw new Error("Missing react shared internals. Check version.");
function zS() {
    const e = IN?.H;
    return e != null && e.useState !== e.useReducer
}
function it(e) {
    for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++)
        n[r - 1] = arguments[r];
    throw new Error(typeof e == "number" ? "[MobX] minified error nr: " + e + (n.length ? " " + n.map(String).join(",") : "") + ". Find the full error at: https://github.com/mobxjs/mobx/blob/main/packages/mobx/src/errors.ts" : "[MobX] " + e)
}
var hW = {};
function kg() {
    return typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : hW
}
var RN = Object.assign
  , Cm = Object.getOwnPropertyDescriptor
  , Mo = Object.defineProperty
  , Gf = Object.prototype
  , L3 = [];
Object.freeze(L3);
var $S = {};
Object.freeze($S);
var pW = typeof Proxy < "u"
  , mW = Object.toString();
function NN() {
    pW || it("Proxy not available")
}
function PN(e) {
    var t = !1;
    return function() {
        if (!t)
            return t = !0,
            e.apply(this, arguments)
    }
}
var eu = function() {};
function ss(e) {
    return typeof e == "function"
}
function Ml(e) {
    var t = typeof e;
    switch (t) {
    case "string":
    case "symbol":
    case "number":
        return !0
    }
    return !1
}
function Og(e) {
    return e !== null && typeof e == "object"
}
function vi(e) {
    if (!Og(e))
        return !1;
    var t = Object.getPrototypeOf(e);
    if (t == null)
        return !0;
    var n = Object.hasOwnProperty.call(t, "constructor") && t.constructor;
    return typeof n == "function" && n.toString() === mW
}
function DN(e) {
    var t = e?.constructor;
    return t ? t.name === "GeneratorFunction" || t.displayName === "GeneratorFunction" : !1
}
function Vf(e, t, n) {
    Mo(e, t, {
        enumerable: !1,
        writable: !0,
        configurable: !0,
        value: n
    })
}
function LN(e, t, n) {
    Mo(e, t, {
        enumerable: !1,
        writable: !1,
        configurable: !0,
        value: n
    })
}
function Ma(e, t) {
    var n = "isMobX" + e;
    return t.prototype[n] = !0,
    function(r) {
        return Og(r) && r[n] === !0
    }
}
function qu(e) {
    return e != null && Object.prototype.toString.call(e) === "[object Map]"
}
function gW(e) {
    var t = Object.getPrototypeOf(e)
      , n = Object.getPrototypeOf(t)
      , r = Object.getPrototypeOf(n);
    return r === null
}
function ai(e) {
    return e != null && Object.prototype.toString.call(e) === "[object Set]"
}
var FN = typeof Object.getOwnPropertySymbols < "u";
function vW(e) {
    var t = Object.keys(e);
    if (!FN)
        return t;
    var n = Object.getOwnPropertySymbols(e);
    return n.length ? [].concat(t, n.filter(function(r) {
        return Gf.propertyIsEnumerable.call(e, r)
    })) : t
}
var Cu = typeof Reflect < "u" && Reflect.ownKeys ? Reflect.ownKeys : FN ? function(e) {
    return Object.getOwnPropertyNames(e).concat(Object.getOwnPropertySymbols(e))
}
: Object.getOwnPropertyNames;
function jN(e) {
    return e === null ? null : typeof e == "object" ? "" + e : e
}
function ci(e, t) {
    return Gf.hasOwnProperty.call(e, t)
}
var _W = Object.getOwnPropertyDescriptors || function(t) {
    var n = {};
    return Cu(t).forEach(function(r) {
        n[r] = Cm(t, r)
    }),
    n
}
;
function Yr(e, t) {
    return !!(e & t)
}
function Zr(e, t, n) {
    return n ? e |= t : e &= ~t,
    e
}
function i7(e, t) {
    (t == null || t > e.length) && (t = e.length);
    for (var n = 0, r = Array(t); n < t; n++)
        r[n] = e[n];
    return r
}
function yW(e, t) {
    for (var n = 0; n < t.length; n++) {
        var r = t[n];
        r.enumerable = r.enumerable || !1,
        r.configurable = !0,
        "value"in r && (r.writable = !0),
        Object.defineProperty(e, CW(r.key), r)
    }
}
function Gu(e, t, n) {
    return t && yW(e.prototype, t),
    Object.defineProperty(e, "prototype", {
        writable: !1
    }),
    e
}
function tu(e, t) {
    var n = typeof Symbol < "u" && e[Symbol.iterator] || e["@@iterator"];
    if (n)
        return (n = n.call(e)).next.bind(n);
    if (Array.isArray(e) || (n = SW(e)) || t) {
        n && (e = n);
        var r = 0;
        return function() {
            return r >= e.length ? {
                done: !0
            } : {
                done: !1,
                value: e[r++]
            }
        }
    }
    throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
}
function ga() {
    return ga = Object.assign ? Object.assign.bind() : function(e) {
        for (var t = 1; t < arguments.length; t++) {
            var n = arguments[t];
            for (var r in n)
                ({}).hasOwnProperty.call(n, r) && (e[r] = n[r])
        }
        return e
    }
    ,
    ga.apply(null, arguments)
}
function UN(e, t) {
    e.prototype = Object.create(t.prototype),
    e.prototype.constructor = e,
    F3(e, t)
}
function F3(e, t) {
    return F3 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(n, r) {
        return n.__proto__ = r,
        n
    }
    ,
    F3(e, t)
}
function bW(e, t) {
    if (typeof e != "object" || !e)
        return e;
    var n = e[Symbol.toPrimitive];
    if (n !== void 0) {
        var r = n.call(e, t);
        if (typeof r != "object")
            return r;
        throw new TypeError("@@toPrimitive must return a primitive value.")
    }
    return String(e)
}
function CW(e) {
    var t = bW(e, "string");
    return typeof t == "symbol" ? t : t + ""
}
function SW(e, t) {
    if (e) {
        if (typeof e == "string")
            return i7(e, t);
        var n = {}.toString.call(e).slice(8, -1);
        return n === "Object" && e.constructor && (n = e.constructor.name),
        n === "Map" || n === "Set" ? Array.from(e) : n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? i7(e, t) : void 0
    }
}
var ko = Symbol("mobx-stored-annotations");
function Ws(e) {
    function t(n, r) {
        if (zf(r))
            return e.decorate_20223_(n, r);
        Hf(n, r, e)
    }
    return Object.assign(t, e)
}
function Hf(e, t, n) {
    ci(e, ko) || Vf(e, ko, ga({}, e[ko])),
    IW(n) || (e[ko][t] = n)
}
function wW(e) {
    return ci(e, ko) || Vf(e, ko, ga({}, e[ko])),
    e[ko]
}
function zf(e) {
    return typeof e == "object" && typeof e.kind == "string"
}
var qe = Symbol("mobx administration")
  , Ia = function() {
    function e(n) {
        n === void 0 && (n = "Atom"),
        this.name_ = void 0,
        this.flags_ = 0,
        this.observers_ = new Set,
        this.lastAccessedBy_ = 0,
        this.lowestObserverState_ = It.NOT_TRACKING_,
        this.onBOL = void 0,
        this.onBUOL = void 0,
        this.name_ = n
    }
    var t = e.prototype;
    return t.onBO = function() {
        this.onBOL && this.onBOL.forEach(function(r) {
            return r()
        })
    }
    ,
    t.onBUO = function() {
        this.onBUOL && this.onBUOL.forEach(function(r) {
            return r()
        })
    }
    ,
    t.reportObserved = function() {
        return rP(this)
    }
    ,
    t.reportChanged = function() {
        Mr(),
        sP(this),
        Ir()
    }
    ,
    t.toString = function() {
        return this.name_
    }
    ,
    Gu(e, [{
        key: "isBeingObserved",
        get: function() {
            return Yr(this.flags_, e.isBeingObservedMask_)
        },
        set: function(r) {
            this.flags_ = Zr(this.flags_, e.isBeingObservedMask_, r)
        }
    }, {
        key: "isPendingUnobservation",
        get: function() {
            return Yr(this.flags_, e.isPendingUnobservationMask_)
        },
        set: function(r) {
            this.flags_ = Zr(this.flags_, e.isPendingUnobservationMask_, r)
        }
    }, {
        key: "diffValue",
        get: function() {
            return Yr(this.flags_, e.diffValueMask_) ? 1 : 0
        },
        set: function(r) {
            this.flags_ = Zr(this.flags_, e.diffValueMask_, r === 1)
        }
    }])
}();
Ia.isBeingObservedMask_ = 1;
Ia.isPendingUnobservationMask_ = 2;
Ia.diffValueMask_ = 4;
var WS = Ma("Atom", Ia);
function Ag(e, t, n) {
    t === void 0 && (t = eu),
    n === void 0 && (n = eu);
    var r = new Ia(e);
    return t !== eu && hP(r, t),
    n !== eu && JS(r, n),
    r
}
function EW(e, t) {
    return e === t
}
function xW(e, t) {
    return r6(e, t)
}
function TW(e, t) {
    return r6(e, t, 1)
}
function kW(e, t) {
    return Object.is ? Object.is(e, t) : e === t ? e !== 0 || 1 / e === 1 / t : e !== e && t !== t
}
var Il = {
    identity: EW,
    structural: xW,
    default: kW,
    shallow: TW
};
function Rl(e, t, n) {
    return Fg(e) ? e : Array.isArray(e) ? Pn.array(e, {
        name: n
    }) : vi(e) ? Pn.object(e, void 0, {
        name: n
    }) : qu(e) ? Pn.map(e, {
        name: n
    }) : ai(e) ? Pn.set(e, {
        name: n
    }) : typeof e == "function" && !wu(e) && !Eu(e) ? DN(e) ? Pl(e) : Su(n, e) : e
}
function OW(e, t, n) {
    if (e == null || rr(e) || Fr(e) || or(e) || Dn(e))
        return e;
    if (Array.isArray(e))
        return Pn.array(e, {
            name: n,
            deep: !1
        });
    if (vi(e))
        return Pn.object(e, void 0, {
            name: n,
            deep: !1
        });
    if (qu(e))
        return Pn.map(e, {
            name: n,
            deep: !1
        });
    if (ai(e))
        return Pn.set(e, {
            name: n,
            deep: !1
        })
}
function Mg(e) {
    return e
}
function AW(e, t) {
    return r6(e, t) ? t : e
}
var BN = "override"
  , MW = Ws({
    annotationType_: BN,
    make_: RW,
    extend_: NW,
    decorate_20223_: PW
});
function IW(e) {
    return e.annotationType_ === BN
}
function RW(e, t) {
    return 0
}
function NW(e, t, n, r) {
    it("'" + this.annotationType_ + "' can only be used with 'makeObservable'")
}
function PW(e, t) {
    console.warn("'" + this.annotationType_ + "' cannot be used with decorators - this is a no-op")
}
function $f(e, t) {
    return {
        annotationType_: e,
        options_: t,
        make_: DW,
        extend_: LW,
        decorate_20223_: FW
    }
}
function DW(e, t, n, r) {
    var s;
    if ((s = this.options_) != null && s.bound)
        return this.extend_(e, t, n, !1) === null ? 0 : 1;
    if (r === e.target_)
        return this.extend_(e, t, n, !1) === null ? 0 : 2;
    if (wu(n.value))
        return 1;
    var o = qN(e, this, t, n, !1);
    return Mo(r, t, o),
    2
}
function LW(e, t, n, r) {
    var s = qN(e, this, t, n);
    return e.defineProperty_(t, s, r)
}
function FW(e, t) {
    var n = t.kind
      , r = t.name
      , s = t.addInitializer
      , o = this
      , i = function(c) {
        var u, d, f, p;
        return va((u = (d = o.options_) == null ? void 0 : d.name) != null ? u : r.toString(), c, (f = (p = o.options_) == null ? void 0 : p.autoAction) != null ? f : !1)
    };
    if (n == "field")
        return function(l) {
            var c, u = l;
            return wu(u) || (u = i(u)),
            (c = o.options_) != null && c.bound && (u = u.bind(this),
            u.isMobxAction = !0),
            u
        }
        ;
    if (n == "method") {
        var a;
        return wu(e) || (e = i(e)),
        (a = this.options_) != null && a.bound && s(function() {
            var l = this
              , c = l[r].bind(l);
            c.isMobxAction = !0,
            l[r] = c
        }),
        e
    }
    it("Cannot apply '" + o.annotationType_ + "' to '" + String(r) + "' (kind: " + n + "):" + (`
'` + o.annotationType_ + "' can only be used on properties with a function value."))
}
function jW(e, t, n, r) {
    t.annotationType_,
    r.value
}
function qN(e, t, n, r, s) {
    var o, i, a, l, c, u, d;
    s === void 0 && (s = fe.safeDescriptors),
    jW(e, t, n, r);
    var f = r.value;
    if ((o = t.options_) != null && o.bound) {
        var p;
        f = f.bind((p = e.proxy_) != null ? p : e.target_)
    }
    return {
        value: va((i = (a = t.options_) == null ? void 0 : a.name) != null ? i : n.toString(), f, (l = (c = t.options_) == null ? void 0 : c.autoAction) != null ? l : !1, (u = t.options_) != null && u.bound ? (d = e.proxy_) != null ? d : e.target_ : void 0),
        configurable: s ? e.isPlainObject_ : !0,
        enumerable: !1,
        writable: !s
    }
}
function GN(e, t) {
    return {
        annotationType_: e,
        options_: t,
        make_: UW,
        extend_: BW,
        decorate_20223_: qW
    }
}
function UW(e, t, n, r) {
    var s;
    if (r === e.target_)
        return this.extend_(e, t, n, !1) === null ? 0 : 2;
    if ((s = this.options_) != null && s.bound && (!ci(e.target_, t) || !Eu(e.target_[t])) && this.extend_(e, t, n, !1) === null)
        return 0;
    if (Eu(n.value))
        return 1;
    var o = VN(e, this, t, n, !1, !1);
    return Mo(r, t, o),
    2
}
function BW(e, t, n, r) {
    var s, o = VN(e, this, t, n, (s = this.options_) == null ? void 0 : s.bound);
    return e.defineProperty_(t, o, r)
}
function qW(e, t) {
    var n, r = t.name, s = t.addInitializer;
    return Eu(e) || (e = Pl(e)),
    (n = this.options_) != null && n.bound && s(function() {
        var o = this
          , i = o[r].bind(o);
        i.isMobXFlow = !0,
        o[r] = i
    }),
    e
}
function GW(e, t, n, r) {
    t.annotationType_,
    r.value
}
function VN(e, t, n, r, s, o) {
    o === void 0 && (o = fe.safeDescriptors),
    GW(e, t, n, r);
    var i = r.value;
    if (Eu(i) || (i = Pl(i)),
    s) {
        var a;
        i = i.bind((a = e.proxy_) != null ? a : e.target_),
        i.isMobXFlow = !0
    }
    return {
        value: i,
        configurable: o ? e.isPlainObject_ : !0,
        enumerable: !1,
        writable: !o
    }
}
function KS(e, t) {
    return {
        annotationType_: e,
        options_: t,
        make_: VW,
        extend_: HW,
        decorate_20223_: zW
    }
}
function VW(e, t, n) {
    return this.extend_(e, t, n, !1) === null ? 0 : 1
}
function HW(e, t, n, r) {
    return $W(e, this, t, n),
    e.defineComputedProperty_(t, ga({}, this.options_, {
        get: n.get,
        set: n.set
    }), r)
}
function zW(e, t) {
    var n = this
      , r = t.name
      , s = t.addInitializer;
    return s(function() {
        var o = Jl(this)[qe]
          , i = ga({}, n.options_, {
            get: e,
            context: this
        });
        i.name || (i.name = "ObservableObject." + r.toString()),
        o.values_.set(r, new Js(i))
    }),
    function() {
        return this[qe].getObservablePropValue_(r)
    }
}
function $W(e, t, n, r) {
    t.annotationType_,
    r.get
}
function Ig(e, t) {
    return {
        annotationType_: e,
        options_: t,
        make_: WW,
        extend_: KW,
        decorate_20223_: YW
    }
}
function WW(e, t, n) {
    return this.extend_(e, t, n, !1) === null ? 0 : 1
}
function KW(e, t, n, r) {
    var s, o;
    return ZW(e, this),
    e.defineObservableProperty_(t, n.value, (s = (o = this.options_) == null ? void 0 : o.enhancer) != null ? s : Rl, r)
}
function YW(e, t) {
    var n = this
      , r = t.kind
      , s = t.name
      , o = new WeakSet;
    function i(a, l) {
        var c, u, d = Jl(a)[qe], f = new ua(l,(c = (u = n.options_) == null ? void 0 : u.enhancer) != null ? c : Rl,"ObservableObject." + s.toString(),!1);
        d.values_.set(s, f),
        o.add(a)
    }
    if (r == "accessor")
        return {
            get: function() {
                return o.has(this) || i(this, e.get.call(this)),
                this[qe].getObservablePropValue_(s)
            },
            set: function(l) {
                return o.has(this) || i(this, l),
                this[qe].setObservablePropValue_(s, l)
            },
            init: function(l) {
                return o.has(this) || i(this, l),
                l
            }
        }
}
function ZW(e, t, n, r) {
    t.annotationType_
}
var JW = "true"
  , XW = HN();
function HN(e) {
    return {
        annotationType_: JW,
        options_: e,
        make_: QW,
        extend_: eK,
        decorate_20223_: tK
    }
}
function QW(e, t, n, r) {
    var s, o;
    if (n.get)
        return Vu.make_(e, t, n, r);
    if (n.set) {
        var i = va(t.toString(), n.set);
        return r === e.target_ ? e.defineProperty_(t, {
            configurable: fe.safeDescriptors ? e.isPlainObject_ : !0,
            set: i
        }) === null ? 0 : 2 : (Mo(r, t, {
            configurable: !0,
            set: i
        }),
        2)
    }
    if (r !== e.target_ && typeof n.value == "function") {
        var a;
        if (DN(n.value)) {
            var l, c = (l = this.options_) != null && l.autoBind ? Pl.bound : Pl;
            return c.make_(e, t, n, r)
        }
        var u = (a = this.options_) != null && a.autoBind ? Su.bound : Su;
        return u.make_(e, t, n, r)
    }
    var d = ((s = this.options_) == null ? void 0 : s.deep) === !1 ? Pn.ref : Pn;
    if (typeof n.value == "function" && (o = this.options_) != null && o.autoBind) {
        var f;
        n.value = n.value.bind((f = e.proxy_) != null ? f : e.target_)
    }
    return d.make_(e, t, n, r)
}
function eK(e, t, n, r) {
    var s, o;
    if (n.get)
        return Vu.extend_(e, t, n, r);
    if (n.set)
        return e.defineProperty_(t, {
            configurable: fe.safeDescriptors ? e.isPlainObject_ : !0,
            set: va(t.toString(), n.set)
        }, r);
    if (typeof n.value == "function" && (s = this.options_) != null && s.autoBind) {
        var i;
        n.value = n.value.bind((i = e.proxy_) != null ? i : e.target_)
    }
    var a = ((o = this.options_) == null ? void 0 : o.deep) === !1 ? Pn.ref : Pn;
    return a.extend_(e, t, n, r)
}
function tK(e, t) {
    it("'" + this.annotationType_ + "' cannot be used as a decorator")
}
var nK = "observable"
  , rK = "observable.ref"
  , sK = "observable.shallow"
  , oK = "observable.struct"
  , zN = {
    deep: !0,
    name: void 0,
    defaultDecorator: void 0,
    proxy: !0
};
Object.freeze(zN);
function ep(e) {
    return e || zN
}
var j3 = Ig(nK)
  , iK = Ig(rK, {
    enhancer: Mg
})
  , aK = Ig(sK, {
    enhancer: OW
})
  , lK = Ig(oK, {
    enhancer: AW
})
  , $N = Ws(j3);
function tp(e) {
    return e.deep === !0 ? Rl : e.deep === !1 ? Mg : uK(e.defaultDecorator)
}
function cK(e) {
    var t;
    return e ? (t = e.defaultDecorator) != null ? t : HN(e) : void 0
}
function uK(e) {
    var t, n;
    return e && (t = (n = e.options_) == null ? void 0 : n.enhancer) != null ? t : Rl
}
function WN(e, t, n) {
    if (zf(t))
        return j3.decorate_20223_(e, t);
    if (Ml(t)) {
        Hf(e, t, j3);
        return
    }
    return Fg(e) ? e : vi(e) ? Pn.object(e, t, n) : Array.isArray(e) ? Pn.array(e, t) : qu(e) ? Pn.map(e, t) : ai(e) ? Pn.set(e, t) : typeof e == "object" && e !== null ? e : Pn.box(e, t)
}
RN(WN, $N);
var dK = {
    box: function(t, n) {
        var r = ep(n);
        return new ua(t,tp(r),r.name,!0,r.equals)
    },
    array: function(t, n) {
        var r = ep(n);
        return (fe.useProxies === !1 || r.proxy === !1 ? TY : gY)(t, tp(r), r.name)
    },
    map: function(t, n) {
        var r = ep(n);
        return new e6(t,tp(r),r.name)
    },
    set: function(t, n) {
        var r = ep(n);
        return new t6(t,tp(r),r.name)
    },
    object: function(t, n, r) {
        return Ra(function() {
            return XS(fe.useProxies === !1 || r?.proxy === !1 ? Jl({}, r) : fY({}, r), t, n)
        })
    },
    ref: Ws(iK),
    shallow: Ws(aK),
    deep: $N,
    struct: Ws(lK)
}
  , Pn = RN(WN, dK)
  , KN = "computed"
  , fK = "computed.struct"
  , U3 = KS(KN)
  , hK = KS(fK, {
    equals: Il.structural
})
  , Vu = function(t, n) {
    if (zf(n))
        return U3.decorate_20223_(t, n);
    if (Ml(n))
        return Hf(t, n, U3);
    if (vi(t))
        return Ws(KS(KN, t));
    var r = vi(n) ? n : {};
    return r.get = t,
    r.name || (r.name = t.name || ""),
    new Js(r)
};
Object.assign(Vu, U3);
Vu.struct = Ws(hK);
var a7, l7, Sm = 0, pK = 1, mK = (a7 = (l7 = Cm(function() {}, "name")) == null ? void 0 : l7.configurable) != null ? a7 : !1, c7 = {
    value: "action",
    configurable: !0,
    writable: !1,
    enumerable: !1
};
function va(e, t, n, r) {
    n === void 0 && (n = !1);
    function s() {
        return YN(e, n, t, r || this, arguments)
    }
    return s.isMobxAction = !0,
    s.toString = function() {
        return t.toString()
    }
    ,
    mK && (c7.value = e,
    Mo(s, "name", c7)),
    s
}
function YN(e, t, n, r, s) {
    var o = ZN(e, t);
    try {
        return n.apply(r, s)
    } catch (i) {
        throw o.error_ = i,
        i
    } finally {
        JN(o)
    }
}
function ZN(e, t, n, r) {
    var s = !1
      , o = 0
      , i = fe.trackingDerivation
      , a = !t || !i;
    Mr();
    var l = fe.allowStateChanges;
    a && (Zl(),
    l = Rg(!0));
    var c = Pg(!0)
      , u = {
        runAsAction_: a,
        prevDerivation_: i,
        prevAllowStateChanges_: l,
        prevAllowStateReads_: c,
        notifySpy_: s,
        startTime_: o,
        actionId_: pK++,
        parentActionId_: Sm
    };
    return Sm = u.actionId_,
    u
}
function JN(e) {
    Sm !== e.actionId_ && it(30),
    Sm = e.parentActionId_,
    e.error_ !== void 0 && (fe.suppressReactionErrors = !0),
    Ng(e.prevAllowStateChanges_),
    iu(e.prevAllowStateReads_),
    Ir(),
    e.runAsAction_ && ui(e.prevDerivation_),
    fe.suppressReactionErrors = !1
}
function YS(e, t) {
    var n = Rg(e);
    try {
        return t()
    } finally {
        Ng(n)
    }
}
function Rg(e) {
    var t = fe.allowStateChanges;
    return fe.allowStateChanges = e,
    t
}
function Ng(e) {
    fe.allowStateChanges = e
}
var ua = function(e) {
    function t(r, s, o, i, a) {
        var l;
        return o === void 0 && (o = "ObservableValue"),
        a === void 0 && (a = Il.default),
        l = e.call(this, o) || this,
        l.enhancer = void 0,
        l.name_ = void 0,
        l.equals = void 0,
        l.hasUnreportedChange_ = !1,
        l.interceptors_ = void 0,
        l.changeListeners_ = void 0,
        l.value_ = void 0,
        l.dehancer = void 0,
        l.enhancer = s,
        l.name_ = o,
        l.equals = a,
        l.value_ = s(r, void 0, o),
        l
    }
    UN(t, e);
    var n = t.prototype;
    return n.dehanceValue = function(s) {
        return this.dehancer !== void 0 ? this.dehancer(s) : s
    }
    ,
    n.set = function(s) {
        this.value_,
        s = this.prepareNewValue_(s),
        s !== fe.UNCHANGED && this.setNewValue_(s)
    }
    ,
    n.prepareNewValue_ = function(s) {
        if (ys(this)) {
            var o = bs(this, {
                object: this,
                type: Io,
                newValue: s
            });
            if (!o)
                return fe.UNCHANGED;
            s = o.newValue
        }
        return s = this.enhancer(s, this.value_, this.name_),
        this.equals(this.value_, s) ? fe.UNCHANGED : s
    }
    ,
    n.setNewValue_ = function(s) {
        var o = this.value_;
        this.value_ = s,
        this.reportChanged(),
        Ks(this) && Ys(this, {
            type: Io,
            object: this,
            newValue: s,
            oldValue: o
        })
    }
    ,
    n.get = function() {
        return this.reportObserved(),
        this.dehanceValue(this.value_)
    }
    ,
    n.intercept_ = function(s) {
        return Kf(this, s)
    }
    ,
    n.observe_ = function(s, o) {
        return o && s({
            observableKind: "value",
            debugObjectName: this.name_,
            object: this,
            type: Io,
            newValue: this.value_,
            oldValue: void 0
        }),
        Yf(this, s)
    }
    ,
    n.raw = function() {
        return this.value_
    }
    ,
    n.toJSON = function() {
        return this.get()
    }
    ,
    n.toString = function() {
        return this.name_ + "[" + this.value_ + "]"
    }
    ,
    n.valueOf = function() {
        return jN(this.get())
    }
    ,
    n[Symbol.toPrimitive] = function() {
        return this.valueOf()
    }
    ,
    t
}(Ia)
  , ZS = Ma("ObservableValue", ua)
  , Js = function() {
    function e(n) {
        this.dependenciesState_ = It.NOT_TRACKING_,
        this.observing_ = [],
        this.newObserving_ = null,
        this.observers_ = new Set,
        this.runId_ = 0,
        this.lastAccessedBy_ = 0,
        this.lowestObserverState_ = It.UP_TO_DATE_,
        this.unboundDepsCount_ = 0,
        this.value_ = new Em(null),
        this.name_ = void 0,
        this.triggeredBy_ = void 0,
        this.flags_ = 0,
        this.derivation = void 0,
        this.setter_ = void 0,
        this.isTracing_ = wm.NONE,
        this.scope_ = void 0,
        this.equals_ = void 0,
        this.requiresReaction_ = void 0,
        this.keepAlive_ = void 0,
        this.onBOL = void 0,
        this.onBUOL = void 0,
        n.get || it(31),
        this.derivation = n.get,
        this.name_ = n.name || "ComputedValue",
        n.set && (this.setter_ = va("ComputedValue-setter", n.set)),
        this.equals_ = n.equals || (n.compareStructural || n.struct ? Il.structural : Il.default),
        this.scope_ = n.context,
        this.requiresReaction_ = n.requiresReaction,
        this.keepAlive_ = !!n.keepAlive
    }
    var t = e.prototype;
    return t.onBecomeStale_ = function() {
        TK(this)
    }
    ,
    t.onBO = function() {
        this.onBOL && this.onBOL.forEach(function(r) {
            return r()
        })
    }
    ,
    t.onBUO = function() {
        this.onBUOL && this.onBUOL.forEach(function(r) {
            return r()
        })
    }
    ,
    t.get = function() {
        if (this.isComputing && it(32, this.name_, this.derivation),
        fe.inBatch === 0 && this.observers_.size === 0 && !this.keepAlive_)
            B3(this) && (this.warnAboutUntrackedRead_(),
            Mr(),
            this.value_ = this.computeValue_(!1),
            Ir());
        else if (rP(this),
        B3(this)) {
            var r = fe.trackingContext;
            this.keepAlive_ && !r && (fe.trackingContext = this),
            this.trackAndCompute() && xK(this),
            fe.trackingContext = r
        }
        var s = this.value_;
        if (Hp(s))
            throw s.cause;
        return s
    }
    ,
    t.set = function(r) {
        if (this.setter_) {
            this.isRunningSetter && it(33, this.name_),
            this.isRunningSetter = !0;
            try {
                this.setter_.call(this.scope_, r)
            } finally {
                this.isRunningSetter = !1
            }
        } else
            it(34, this.name_)
    }
    ,
    t.trackAndCompute = function() {
        var r = this.value_
          , s = this.dependenciesState_ === It.NOT_TRACKING_
          , o = this.computeValue_(!0)
          , i = s || Hp(r) || Hp(o) || !this.equals_(r, o);
        return i && (this.value_ = o),
        i
    }
    ,
    t.computeValue_ = function(r) {
        this.isComputing = !0;
        var s = Rg(!1), o;
        if (r)
            o = XN(this, this.derivation, this.scope_);
        else if (fe.disableErrorBoundaries === !0)
            o = this.derivation.call(this.scope_);
        else
            try {
                o = this.derivation.call(this.scope_)
            } catch (i) {
                o = new Em(i)
            }
        return Ng(s),
        this.isComputing = !1,
        o
    }
    ,
    t.suspend_ = function() {
        this.keepAlive_ || (q3(this),
        this.value_ = void 0)
    }
    ,
    t.observe_ = function(r, s) {
        var o = this
          , i = !0
          , a = void 0;
        return Dg(function() {
            var l = o.get();
            if (!i || s) {
                var c = Zl();
                r({
                    observableKind: "computed",
                    debugObjectName: o.name_,
                    type: Io,
                    object: o,
                    newValue: l,
                    oldValue: a
                }),
                ui(c)
            }
            i = !1,
            a = l
        })
    }
    ,
    t.warnAboutUntrackedRead_ = function() {}
    ,
    t.toString = function() {
        return this.name_ + "[" + this.derivation.toString() + "]"
    }
    ,
    t.valueOf = function() {
        return jN(this.get())
    }
    ,
    t[Symbol.toPrimitive] = function() {
        return this.valueOf()
    }
    ,
    Gu(e, [{
        key: "isComputing",
        get: function() {
            return Yr(this.flags_, e.isComputingMask_)
        },
        set: function(r) {
            this.flags_ = Zr(this.flags_, e.isComputingMask_, r)
        }
    }, {
        key: "isRunningSetter",
        get: function() {
            return Yr(this.flags_, e.isRunningSetterMask_)
        },
        set: function(r) {
            this.flags_ = Zr(this.flags_, e.isRunningSetterMask_, r)
        }
    }, {
        key: "isBeingObserved",
        get: function() {
            return Yr(this.flags_, e.isBeingObservedMask_)
        },
        set: function(r) {
            this.flags_ = Zr(this.flags_, e.isBeingObservedMask_, r)
        }
    }, {
        key: "isPendingUnobservation",
        get: function() {
            return Yr(this.flags_, e.isPendingUnobservationMask_)
        },
        set: function(r) {
            this.flags_ = Zr(this.flags_, e.isPendingUnobservationMask_, r)
        }
    }, {
        key: "diffValue",
        get: function() {
            return Yr(this.flags_, e.diffValueMask_) ? 1 : 0
        },
        set: function(r) {
            this.flags_ = Zr(this.flags_, e.diffValueMask_, r === 1)
        }
    }])
}();
Js.isComputingMask_ = 1;
Js.isRunningSetterMask_ = 2;
Js.isBeingObservedMask_ = 4;
Js.isPendingUnobservationMask_ = 8;
Js.diffValueMask_ = 16;
var Nl = Ma("ComputedValue", Js), It;
(function(e) {
    e[e.NOT_TRACKING_ = -1] = "NOT_TRACKING_",
    e[e.UP_TO_DATE_ = 0] = "UP_TO_DATE_",
    e[e.POSSIBLY_STALE_ = 1] = "POSSIBLY_STALE_",
    e[e.STALE_ = 2] = "STALE_"
}
)(It || (It = {}));
var wm;
(function(e) {
    e[e.NONE = 0] = "NONE",
    e[e.LOG = 1] = "LOG",
    e[e.BREAK = 2] = "BREAK"
}
)(wm || (wm = {}));
var Em = function(t) {
    this.cause = void 0,
    this.cause = t
};
function Hp(e) {
    return e instanceof Em
}
function B3(e) {
    switch (e.dependenciesState_) {
    case It.UP_TO_DATE_:
        return !1;
    case It.NOT_TRACKING_:
    case It.STALE_:
        return !0;
    case It.POSSIBLY_STALE_:
        {
            for (var t = Pg(!0), n = Zl(), r = e.observing_, s = r.length, o = 0; o < s; o++) {
                var i = r[o];
                if (Nl(i)) {
                    if (fe.disableErrorBoundaries)
                        i.get();
                    else
                        try {
                            i.get()
                        } catch {
                            return ui(n),
                            iu(t),
                            !0
                        }
                    if (e.dependenciesState_ === It.STALE_)
                        return ui(n),
                        iu(t),
                        !0
                }
            }
            return QN(e),
            ui(n),
            iu(t),
            !1
        }
    }
}
function gK() {
    return fe.trackingDerivation !== null
}
function XN(e, t, n) {
    var r = Pg(!0);
    QN(e),
    e.newObserving_ = new Array(e.runId_ === 0 ? 100 : e.observing_.length),
    e.unboundDepsCount_ = 0,
    e.runId_ = ++fe.runId;
    var s = fe.trackingDerivation;
    fe.trackingDerivation = e,
    fe.inBatch++;
    var o;
    if (fe.disableErrorBoundaries === !0)
        o = t.call(n);
    else
        try {
            o = t.call(n)
        } catch (i) {
            o = new Em(i)
        }
    return fe.inBatch--,
    fe.trackingDerivation = s,
    vK(e),
    iu(r),
    o
}
function vK(e) {
    for (var t = e.observing_, n = e.observing_ = e.newObserving_, r = It.UP_TO_DATE_, s = 0, o = e.unboundDepsCount_, i = 0; i < o; i++) {
        var a = n[i];
        a.diffValue === 0 && (a.diffValue = 1,
        s !== i && (n[s] = a),
        s++),
        a.dependenciesState_ > r && (r = a.dependenciesState_)
    }
    for (n.length = s,
    e.newObserving_ = null,
    o = t.length; o--; ) {
        var l = t[o];
        l.diffValue === 0 && tP(l, e),
        l.diffValue = 0
    }
    for (; s--; ) {
        var c = n[s];
        c.diffValue === 1 && (c.diffValue = 0,
        EK(c, e))
    }
    r !== It.UP_TO_DATE_ && (e.dependenciesState_ = r,
    e.onBecomeStale_())
}
function q3(e) {
    var t = e.observing_;
    e.observing_ = [];
    for (var n = t.length; n--; )
        tP(t[n], e);
    e.dependenciesState_ = It.NOT_TRACKING_
}
function Wf(e) {
    var t = Zl();
    try {
        return e()
    } finally {
        ui(t)
    }
}
function Zl() {
    var e = fe.trackingDerivation;
    return fe.trackingDerivation = null,
    e
}
function ui(e) {
    fe.trackingDerivation = e
}
function Pg(e) {
    var t = fe.allowStateReads;
    return fe.allowStateReads = e,
    t
}
function iu(e) {
    fe.allowStateReads = e
}
function QN(e) {
    if (e.dependenciesState_ !== It.UP_TO_DATE_) {
        e.dependenciesState_ = It.UP_TO_DATE_;
        for (var t = e.observing_, n = t.length; n--; )
            t[n].lowestObserverState_ = It.UP_TO_DATE_
    }
}
var _K = ["mobxGuid", "spyListeners", "enforceActions", "computedRequiresReaction", "reactionRequiresObservable", "observableRequiresReaction", "allowStateReads", "disableErrorBoundaries", "runId", "UNCHANGED", "useProxies"]
  , Yd = function() {
    this.version = 6,
    this.UNCHANGED = {},
    this.trackingDerivation = null,
    this.trackingContext = null,
    this.runId = 0,
    this.mobxGuid = 0,
    this.inBatch = 0,
    this.pendingUnobservations = [],
    this.pendingReactions = [],
    this.isRunningReactions = !1,
    this.allowStateChanges = !1,
    this.allowStateReads = !0,
    this.enforceActions = !0,
    this.spyListeners = [],
    this.globalReactionErrorHandlers = [],
    this.computedRequiresReaction = !1,
    this.reactionRequiresObservable = !1,
    this.observableRequiresReaction = !1,
    this.disableErrorBoundaries = !1,
    this.suppressReactionErrors = !1,
    this.useProxies = !0,
    this.verifyProxies = !1,
    this.safeDescriptors = !0
}
  , zp = !0
  , eP = !1
  , fe = function() {
    var e = kg();
    return e.__mobxInstanceCount > 0 && !e.__mobxGlobals && (zp = !1),
    e.__mobxGlobals && e.__mobxGlobals.version !== new Yd().version && (zp = !1),
    zp ? e.__mobxGlobals ? (e.__mobxInstanceCount += 1,
    e.__mobxGlobals.UNCHANGED || (e.__mobxGlobals.UNCHANGED = {}),
    e.__mobxGlobals) : (e.__mobxInstanceCount = 1,
    e.__mobxGlobals = new Yd) : (setTimeout(function() {
        eP || it(35)
    }, 1),
    new Yd)
}();
function yK() {
    if ((fe.pendingReactions.length || fe.inBatch || fe.isRunningReactions) && it(36),
    eP = !0,
    zp) {
        var e = kg();
        --e.__mobxInstanceCount === 0 && (e.__mobxGlobals = void 0),
        fe = new Yd
    }
}
function bK() {
    return fe
}
function CK() {
    var e = new Yd;
    for (var t in e)
        _K.indexOf(t) === -1 && (fe[t] = e[t]);
    fe.allowStateChanges = !fe.enforceActions
}
function SK(e) {
    return e.observers_ && e.observers_.size > 0
}
function wK(e) {
    return e.observers_
}
function EK(e, t) {
    e.observers_.add(t),
    e.lowestObserverState_ > t.dependenciesState_ && (e.lowestObserverState_ = t.dependenciesState_)
}
function tP(e, t) {
    e.observers_.delete(t),
    e.observers_.size === 0 && nP(e)
}
function nP(e) {
    e.isPendingUnobservation === !1 && (e.isPendingUnobservation = !0,
    fe.pendingUnobservations.push(e))
}
function Mr() {
    fe.inBatch++
}
function Ir() {
    if (--fe.inBatch === 0) {
        oP();
        for (var e = fe.pendingUnobservations, t = 0; t < e.length; t++) {
            var n = e[t];
            n.isPendingUnobservation = !1,
            n.observers_.size === 0 && (n.isBeingObserved && (n.isBeingObserved = !1,
            n.onBUO()),
            n instanceof Js && n.suspend_())
        }
        fe.pendingUnobservations = []
    }
}
function rP(e) {
    var t = fe.trackingDerivation;
    return t !== null ? (t.runId_ !== e.lastAccessedBy_ && (e.lastAccessedBy_ = t.runId_,
    t.newObserving_[t.unboundDepsCount_++] = e,
    !e.isBeingObserved && fe.trackingContext && (e.isBeingObserved = !0,
    e.onBO())),
    e.isBeingObserved) : (e.observers_.size === 0 && fe.inBatch > 0 && nP(e),
    !1)
}
function sP(e) {
    e.lowestObserverState_ !== It.STALE_ && (e.lowestObserverState_ = It.STALE_,
    e.observers_.forEach(function(t) {
        t.dependenciesState_ === It.UP_TO_DATE_ && t.onBecomeStale_(),
        t.dependenciesState_ = It.STALE_
    }))
}
function xK(e) {
    e.lowestObserverState_ !== It.STALE_ && (e.lowestObserverState_ = It.STALE_,
    e.observers_.forEach(function(t) {
        t.dependenciesState_ === It.POSSIBLY_STALE_ ? t.dependenciesState_ = It.STALE_ : t.dependenciesState_ === It.UP_TO_DATE_ && (e.lowestObserverState_ = It.UP_TO_DATE_)
    }))
}
function TK(e) {
    e.lowestObserverState_ === It.UP_TO_DATE_ && (e.lowestObserverState_ = It.POSSIBLY_STALE_,
    e.observers_.forEach(function(t) {
        t.dependenciesState_ === It.UP_TO_DATE_ && (t.dependenciesState_ = It.POSSIBLY_STALE_,
        t.onBecomeStale_())
    }))
}
var Xs = function() {
    function e(n, r, s, o) {
        n === void 0 && (n = "Reaction"),
        this.name_ = void 0,
        this.onInvalidate_ = void 0,
        this.errorHandler_ = void 0,
        this.requiresObservable_ = void 0,
        this.observing_ = [],
        this.newObserving_ = [],
        this.dependenciesState_ = It.NOT_TRACKING_,
        this.runId_ = 0,
        this.unboundDepsCount_ = 0,
        this.flags_ = 0,
        this.isTracing_ = wm.NONE,
        this.name_ = n,
        this.onInvalidate_ = r,
        this.errorHandler_ = s,
        this.requiresObservable_ = o
    }
    var t = e.prototype;
    return t.onBecomeStale_ = function() {
        this.schedule_()
    }
    ,
    t.schedule_ = function() {
        this.isScheduled || (this.isScheduled = !0,
        fe.pendingReactions.push(this),
        oP())
    }
    ,
    t.runReaction_ = function() {
        if (!this.isDisposed) {
            Mr(),
            this.isScheduled = !1;
            var r = fe.trackingContext;
            if (fe.trackingContext = this,
            B3(this)) {
                this.isTrackPending = !0;
                try {
                    this.onInvalidate_()
                } catch (s) {
                    this.reportExceptionInDerivation_(s)
                }
            }
            fe.trackingContext = r,
            Ir()
        }
    }
    ,
    t.track = function(r) {
        if (!this.isDisposed) {
            Mr(),
            this.isRunning = !0;
            var s = fe.trackingContext;
            fe.trackingContext = this;
            var o = XN(this, r, void 0);
            fe.trackingContext = s,
            this.isRunning = !1,
            this.isTrackPending = !1,
            this.isDisposed && q3(this),
            Hp(o) && this.reportExceptionInDerivation_(o.cause),
            Ir()
        }
    }
    ,
    t.reportExceptionInDerivation_ = function(r) {
        var s = this;
        if (this.errorHandler_) {
            this.errorHandler_(r, this);
            return
        }
        if (fe.disableErrorBoundaries)
            throw r;
        var o = "[mobx] uncaught error in '" + this + "'";
        fe.suppressReactionErrors || console.error(o, r),
        fe.globalReactionErrorHandlers.forEach(function(i) {
            return i(r, s)
        })
    }
    ,
    t.dispose = function() {
        this.isDisposed || (this.isDisposed = !0,
        this.isRunning || (Mr(),
        q3(this),
        Ir()))
    }
    ,
    t.getDisposer_ = function(r) {
        var s = this
          , o = function i() {
            s.dispose(),
            r == null || r.removeEventListener == null || r.removeEventListener("abort", i)
        };
        return r == null || r.addEventListener == null || r.addEventListener("abort", o),
        o[qe] = this,
        o
    }
    ,
    t.toString = function() {
        return "Reaction[" + this.name_ + "]"
    }
    ,
    t.trace = function(r) {}
    ,
    Gu(e, [{
        key: "isDisposed",
        get: function() {
            return Yr(this.flags_, e.isDisposedMask_)
        },
        set: function(r) {
            this.flags_ = Zr(this.flags_, e.isDisposedMask_, r)
        }
    }, {
        key: "isScheduled",
        get: function() {
            return Yr(this.flags_, e.isScheduledMask_)
        },
        set: function(r) {
            this.flags_ = Zr(this.flags_, e.isScheduledMask_, r)
        }
    }, {
        key: "isTrackPending",
        get: function() {
            return Yr(this.flags_, e.isTrackPendingMask_)
        },
        set: function(r) {
            this.flags_ = Zr(this.flags_, e.isTrackPendingMask_, r)
        }
    }, {
        key: "isRunning",
        get: function() {
            return Yr(this.flags_, e.isRunningMask_)
        },
        set: function(r) {
            this.flags_ = Zr(this.flags_, e.isRunningMask_, r)
        }
    }, {
        key: "diffValue",
        get: function() {
            return Yr(this.flags_, e.diffValueMask_) ? 1 : 0
        },
        set: function(r) {
            this.flags_ = Zr(this.flags_, e.diffValueMask_, r === 1)
        }
    }])
}();
Xs.isDisposedMask_ = 1;
Xs.isScheduledMask_ = 2;
Xs.isTrackPendingMask_ = 4;
Xs.isRunningMask_ = 8;
Xs.diffValueMask_ = 16;
function kK(e) {
    return fe.globalReactionErrorHandlers.push(e),
    function() {
        var t = fe.globalReactionErrorHandlers.indexOf(e);
        t >= 0 && fe.globalReactionErrorHandlers.splice(t, 1)
    }
}
var OK = 100
  , G3 = function(t) {
    return t()
};
function oP() {
    fe.inBatch > 0 || fe.isRunningReactions || G3(AK)
}
function AK() {
    fe.isRunningReactions = !0;
    for (var e = fe.pendingReactions, t = 0; e.length > 0; ) {
        ++t === OK && (console.error("[mobx] cycle in reaction: " + e[0]),
        e.splice(0));
        for (var n = e.splice(0), r = 0, s = n.length; r < s; r++)
            n[r].runReaction_()
    }
    fe.isRunningReactions = !1
}
var xm = Ma("Reaction", Xs);
function MK(e) {
    var t = G3;
    G3 = function(r) {
        return e(function() {
            return t(r)
        })
    }
}
function Zd() {
    return !1
}
function iP(e) {
    return console.warn("[mobx.spy] Is a no-op in production builds"),
    function() {}
}
var aP = "action"
  , IK = "action.bound"
  , lP = "autoAction"
  , RK = "autoAction.bound"
  , cP = "<unnamed action>"
  , V3 = $f(aP)
  , NK = $f(IK, {
    bound: !0
})
  , H3 = $f(lP, {
    autoAction: !0
})
  , PK = $f(RK, {
    autoAction: !0,
    bound: !0
});
function uP(e) {
    var t = function(r, s) {
        if (ss(r))
            return va(r.name || cP, r, e);
        if (ss(s))
            return va(r, s, e);
        if (zf(s))
            return (e ? H3 : V3).decorate_20223_(r, s);
        if (Ml(s))
            return Hf(r, s, e ? H3 : V3);
        if (Ml(r))
            return Ws($f(e ? lP : aP, {
                name: r,
                autoAction: e
            }))
    };
    return t
}
var ta = uP(!1);
Object.assign(ta, V3);
var Su = uP(!0);
Object.assign(Su, H3);
ta.bound = Ws(NK);
Su.bound = Ws(PK);
function Tm(e) {
    return YN(e.name || cP, !1, e, this, void 0)
}
function wu(e) {
    return ss(e) && e.isMobxAction === !0
}
function Dg(e, t) {
    var n, r, s, o;
    t === void 0 && (t = $S);
    var i = (n = (r = t) == null ? void 0 : r.name) != null ? n : "Autorun", a = !t.scheduler && !t.delay, l;
    if (a)
        l = new Xs(i,function() {
            this.track(d)
        }
        ,t.onError,t.requiresObservable);
    else {
        var c = dP(t)
          , u = !1;
        l = new Xs(i,function() {
            u || (u = !0,
            c(function() {
                u = !1,
                l.isDisposed || l.track(d)
            }))
        }
        ,t.onError,t.requiresObservable)
    }
    function d() {
        e(l)
    }
    return (s = t) != null && (s = s.signal) != null && s.aborted || l.schedule_(),
    l.getDisposer_((o = t) == null ? void 0 : o.signal)
}
var DK = function(t) {
    return t()
};
function dP(e) {
    return e.scheduler ? e.scheduler : e.delay ? function(t) {
        return setTimeout(t, e.delay)
    }
    : DK
}
function fP(e, t, n) {
    var r, s, o;
    n === void 0 && (n = $S);
    var i = (r = n.name) != null ? r : "Reaction", a = ta(i, n.onError ? LK(n.onError, t) : t), l = !n.scheduler && !n.delay, c = dP(n), u = !0, d = !1, f, p = n.compareStructural ? Il.structural : n.equals || Il.default, m = new Xs(i,function() {
        u || l ? v() : d || (d = !0,
        c(v))
    }
    ,n.onError,n.requiresObservable);
    function v() {
        if (d = !1,
        !m.isDisposed) {
            var _ = !1
              , y = f;
            m.track(function() {
                var b = YS(!1, function() {
                    return e(m)
                });
                _ = u || !p(f, b),
                f = b
            }),
            (u && n.fireImmediately || !u && _) && a(f, y, m),
            u = !1
        }
    }
    return (s = n) != null && (s = s.signal) != null && s.aborted || m.schedule_(),
    m.getDisposer_((o = n) == null ? void 0 : o.signal)
}
function LK(e, t) {
    return function() {
        try {
            return t.apply(this, arguments)
        } catch (n) {
            e.call(this, n)
        }
    }
}
var FK = "onBO"
  , jK = "onBUO";
function hP(e, t, n) {
    return pP(FK, e, t, n)
}
function JS(e, t, n) {
    return pP(jK, e, t, n)
}
function pP(e, t, n, r) {
    var s = typeof r == "function" ? _i(t, n) : _i(t)
      , o = ss(r) ? r : n
      , i = e + "L";
    return s[i] ? s[i].add(o) : s[i] = new Set([o]),
    function() {
        var a = s[i];
        a && (a.delete(o),
        a.size === 0 && delete s[i])
    }
}
var UK = "never"
  , np = "always"
  , BK = "observed";
function mP(e) {
    e.isolateGlobalState === !0 && yK();
    var t = e.useProxies
      , n = e.enforceActions;
    if (t !== void 0 && (fe.useProxies = t === np ? !0 : t === UK ? !1 : typeof Proxy < "u"),
    t === "ifavailable" && (fe.verifyProxies = !0),
    n !== void 0) {
        var r = n === np ? np : n === BK;
        fe.enforceActions = r,
        fe.allowStateChanges = !(r === !0 || r === np)
    }
    ["computedRequiresReaction", "reactionRequiresObservable", "observableRequiresReaction", "disableErrorBoundaries", "safeDescriptors"].forEach(function(s) {
        s in e && (fe[s] = !!e[s])
    }),
    fe.allowStateReads = !fe.observableRequiresReaction,
    e.reactionScheduler && MK(e.reactionScheduler)
}
function XS(e, t, n, r) {
    var s = _W(t);
    return Ra(function() {
        var o = Jl(e, r)[qe];
        Cu(s).forEach(function(i) {
            o.extend_(i, s[i], n && i in n ? n[i] : !0)
        })
    }),
    e
}
function gP(e, t) {
    return vP(_i(e, t))
}
function vP(e) {
    var t = {
        name: e.name_
    };
    return e.observing_ && e.observing_.length > 0 && (t.dependencies = GK(e.observing_).map(vP)),
    t
}
function qK(e, t) {
    return _P(_i(e, t))
}
function _P(e) {
    var t = {
        name: e.name_
    };
    return SK(e) && (t.observers = Array.from(wK(e)).map(_P)),
    t
}
function GK(e) {
    return Array.from(new Set(e))
}
var VK = 0;
function Lg() {
    this.message = "FLOW_CANCELLED"
}
Lg.prototype = Object.create(Error.prototype);
function HK(e) {
    return e instanceof Lg
}
var m0 = GN("flow")
  , zK = GN("flow.bound", {
    bound: !0
})
  , Pl = Object.assign(function(t, n) {
    if (zf(n))
        return m0.decorate_20223_(t, n);
    if (Ml(n))
        return Hf(t, n, m0);
    var r = t
      , s = r.name || "<unnamed flow>"
      , o = function() {
        var a = this, l = arguments, c = ++VK, u = ta(s + " - runid: " + c + " - init", r).apply(a, l), d, f = void 0, p = new Promise(function(m, v) {
            var _ = 0;
            d = v;
            function y(C) {
                f = void 0;
                var w;
                try {
                    w = ta(s + " - runid: " + c + " - yield " + _++, u.next).call(u, C)
                } catch (x) {
                    return v(x)
                }
                S(w)
            }
            function b(C) {
                f = void 0;
                var w;
                try {
                    w = ta(s + " - runid: " + c + " - yield " + _++, u.throw).call(u, C)
                } catch (x) {
                    return v(x)
                }
                S(w)
            }
            function S(C) {
                if (ss(C?.then)) {
                    C.then(S, v);
                    return
                }
                return C.done ? m(C.value) : (f = Promise.resolve(C.value),
                f.then(y, b))
            }
            y(void 0)
        }
        );
        return p.cancel = ta(s + " - runid: " + c + " - cancel", function() {
            try {
                f && u7(f);
                var m = u.return(void 0)
                  , v = Promise.resolve(m.value);
                v.then(eu, eu),
                u7(v),
                d(new Lg)
            } catch (_) {
                d(_)
            }
        }),
        p
    };
    return o.isMobXFlow = !0,
    o
}, m0);
Pl.bound = Ws(zK);
function u7(e) {
    ss(e.cancel) && e.cancel()
}
function $K(e) {
    return e
}
function Eu(e) {
    return e?.isMobXFlow === !0
}
function WK(e, t, n) {
    var r;
    return or(e) || Fr(e) || ZS(e) ? r = yi(e) : rr(e) && (r = yi(e, t)),
    r.dehancer = typeof t == "function" ? t : n,
    function() {
        r.dehancer = void 0
    }
}
function KK(e, t, n) {
    return ss(n) ? ZK(e, t, n) : YK(e, t)
}
function YK(e, t) {
    return yi(e).intercept_(t)
}
function ZK(e, t, n) {
    return yi(e, t).intercept_(n)
}
function yP(e, t) {
    if (t === void 0)
        return Nl(e);
    if (rr(e) === !1 || !e[qe].values_.has(t))
        return !1;
    var n = _i(e, t);
    return Nl(n)
}
function JK(e) {
    return yP(e)
}
function XK(e, t) {
    return yP(e, t)
}
function bP(e, t) {
    return e ? t !== void 0 ? rr(e) ? e[qe].values_.has(t) : !1 : rr(e) || !!e[qe] || WS(e) || xm(e) || Nl(e) : !1
}
function Fg(e) {
    return bP(e)
}
function QK(e, t) {
    return bP(e, t)
}
function pf(e) {
    if (rr(e))
        return e[qe].keys_();
    if (or(e) || Dn(e))
        return Array.from(e.keys());
    if (Fr(e))
        return e.map(function(t, n) {
            return n
        });
    it(5)
}
function eY(e) {
    if (rr(e))
        return pf(e).map(function(t) {
            return e[t]
        });
    if (or(e))
        return pf(e).map(function(t) {
            return e.get(t)
        });
    if (Dn(e))
        return Array.from(e.values());
    if (Fr(e))
        return e.slice();
    it(6)
}
function tY(e) {
    if (rr(e))
        return pf(e).map(function(t) {
            return [t, e[t]]
        });
    if (or(e))
        return pf(e).map(function(t) {
            return [t, e.get(t)]
        });
    if (Dn(e))
        return Array.from(e.entries());
    if (Fr(e))
        return e.map(function(t, n) {
            return [n, t]
        });
    it(7)
}
function CP(e, t, n) {
    if (arguments.length === 2 && !Dn(e)) {
        Mr();
        var r = t;
        try {
            for (var s in r)
                CP(e, s, r[s])
        } finally {
            Ir()
        }
        return
    }
    rr(e) ? e[qe].set_(t, n) : or(e) ? e.set(t, n) : Dn(e) ? e.add(t) : Fr(e) ? (typeof t != "number" && (t = parseInt(t, 10)),
    t < 0 && it("Invalid index: '" + t + "'"),
    Mr(),
    t >= e.length && (e.length = t + 1),
    e[t] = n,
    Ir()) : it(8)
}
function nY(e, t) {
    rr(e) ? e[qe].delete_(t) : or(e) || Dn(e) ? e.delete(t) : Fr(e) ? (typeof t != "number" && (t = parseInt(t, 10)),
    e.splice(t, 1)) : it(9)
}
function SP(e, t) {
    if (rr(e))
        return e[qe].has_(t);
    if (or(e))
        return e.has(t);
    if (Dn(e))
        return e.has(t);
    if (Fr(e))
        return t >= 0 && t < e.length;
    it(10)
}
function rY(e, t) {
    if (SP(e, t)) {
        if (rr(e))
            return e[qe].get_(t);
        if (or(e))
            return e.get(t);
        if (Fr(e))
            return e[t];
        it(11)
    }
}
function sY(e, t, n) {
    if (rr(e))
        return e[qe].defineProperty_(t, n);
    it(39)
}
function wP(e) {
    if (rr(e))
        return e[qe].ownKeys_();
    it(38)
}
function oY(e, t, n, r) {
    return ss(n) ? aY(e, t, n, r) : iY(e, t, n)
}
function iY(e, t, n) {
    return yi(e).observe_(t, n)
}
function aY(e, t, n, r) {
    return yi(e, t).observe_(n, r)
}
function rp(e, t, n) {
    return e.set(t, n),
    n
}
function qc(e, t) {
    if (e == null || typeof e != "object" || e instanceof Date || !Fg(e))
        return e;
    if (ZS(e) || Nl(e))
        return qc(e.get(), t);
    if (t.has(e))
        return t.get(e);
    if (Fr(e)) {
        var n = rp(t, e, new Array(e.length));
        return e.forEach(function(i, a) {
            n[a] = qc(i, t)
        }),
        n
    }
    if (Dn(e)) {
        var r = rp(t, e, new Set);
        return e.forEach(function(i) {
            r.add(qc(i, t))
        }),
        r
    }
    if (or(e)) {
        var s = rp(t, e, new Map);
        return e.forEach(function(i, a) {
            s.set(a, qc(i, t))
        }),
        s
    } else {
        var o = rp(t, e, {});
        return wP(e).forEach(function(i) {
            Gf.propertyIsEnumerable.call(e, i) && (o[i] = qc(e[i], t))
        }),
        o
    }
}
function lY(e, t) {
    return qc(e, new Map)
}
function cY() {}
function Eo(e, t) {
    t === void 0 && (t = void 0),
    Mr();
    try {
        return e.apply(t)
    } finally {
        Ir()
    }
}
function z3(e, t, n) {
    return arguments.length === 1 || t && typeof t == "object" ? uY(e, t) : EP(e, t, n || {})
}
function EP(e, t, n) {
    var r;
    if (typeof n.timeout == "number") {
        var s = new Error("WHEN_TIMEOUT");
        r = setTimeout(function() {
            if (!i[qe].isDisposed)
                if (i(),
                n.onError)
                    n.onError(s);
                else
                    throw s
        }, n.timeout)
    }
    n.name = "When";
    var o = va("When-effect", t)
      , i = Dg(function(a) {
        var l = YS(!1, e);
        l && (a.dispose(),
        r && clearTimeout(r),
        o())
    }, n);
    return i
}
function uY(e, t) {
    var n;
    if (t != null && (n = t.signal) != null && n.aborted)
        return Object.assign(Promise.reject(new Error("WHEN_ABORTED")), {
            cancel: function() {
                return null
            }
        });
    var r, s, o = new Promise(function(i, a) {
        var l, c = EP(e, i, ga({}, t, {
            onError: a
        }));
        r = function() {
            c(),
            a(new Error("WHEN_CANCELLED"))
        }
        ,
        s = function() {
            c(),
            a(new Error("WHEN_ABORTED"))
        }
        ,
        t == null || (l = t.signal) == null || l.addEventListener == null || l.addEventListener("abort", s)
    }
    ).finally(function() {
        var i;
        return t == null || (i = t.signal) == null || i.removeEventListener == null ? void 0 : i.removeEventListener("abort", s)
    });
    return o.cancel = r,
    o
}
function wc(e) {
    return e[qe]
}
var dY = {
    has: function(t, n) {
        return wc(t).has_(n)
    },
    get: function(t, n) {
        return wc(t).get_(n)
    },
    set: function(t, n, r) {
        var s;
        return Ml(n) ? (s = wc(t).set_(n, r, !0)) != null ? s : !0 : !1
    },
    deleteProperty: function(t, n) {
        var r;
        return Ml(n) ? (r = wc(t).delete_(n, !0)) != null ? r : !0 : !1
    },
    defineProperty: function(t, n, r) {
        var s;
        return (s = wc(t).defineProperty_(n, r)) != null ? s : !0
    },
    ownKeys: function(t) {
        return wc(t).ownKeys_()
    },
    preventExtensions: function(t) {
        it(13)
    }
};
function fY(e, t) {
    var n, r;
    return NN(),
    e = Jl(e, t),
    (r = (n = e[qe]).proxy_) != null ? r : n.proxy_ = new Proxy(e,dY)
}
function ys(e) {
    return e.interceptors_ !== void 0 && e.interceptors_.length > 0
}
function Kf(e, t) {
    var n = e.interceptors_ || (e.interceptors_ = []);
    return n.push(t),
    PN(function() {
        var r = n.indexOf(t);
        r !== -1 && n.splice(r, 1)
    })
}
function bs(e, t) {
    var n = Zl();
    try {
        for (var r = [].concat(e.interceptors_ || []), s = 0, o = r.length; s < o && (t = r[s](t),
        t && !t.type && it(14),
        !!t); s++)
            ;
        return t
    } finally {
        ui(n)
    }
}
function Ks(e) {
    return e.changeListeners_ !== void 0 && e.changeListeners_.length > 0
}
function Yf(e, t) {
    var n = e.changeListeners_ || (e.changeListeners_ = []);
    return n.push(t),
    PN(function() {
        var r = n.indexOf(t);
        r !== -1 && n.splice(r, 1)
    })
}
function Ys(e, t) {
    var n = Zl()
      , r = e.changeListeners_;
    if (r) {
        r = r.slice();
        for (var s = 0, o = r.length; s < o; s++)
            r[s](t);
        ui(n)
    }
}
function xP(e, t, n) {
    return Ra(function() {
        var r, s = Jl(e, n)[qe];
        (r = t) != null || (t = wW(e)),
        Cu(t).forEach(function(o) {
            return s.make_(o, t[o])
        })
    }),
    e
}
var g0 = Symbol("mobx-keys");
function hY(e, t, n) {
    return vi(e) ? XS(e, e, t, n) : (Ra(function() {
        var r = Jl(e, n)[qe];
        if (!e[g0]) {
            var s = Object.getPrototypeOf(e)
              , o = new Set([].concat(Cu(e), Cu(s)));
            o.delete("constructor"),
            o.delete(qe),
            Vf(s, g0, o)
        }
        e[g0].forEach(function(i) {
            return r.make_(i, t && i in t ? t[i] : !0)
        })
    }),
    e)
}
var d7 = "splice"
  , Io = "update"
  , pY = 1e4
  , mY = {
    get: function(t, n) {
        var r = t[qe];
        return n === qe ? r : n === "length" ? r.getArrayLength_() : typeof n == "string" && !isNaN(n) ? r.get_(parseInt(n)) : ci(km, n) ? km[n] : t[n]
    },
    set: function(t, n, r) {
        var s = t[qe];
        return n === "length" && s.setArrayLength_(r),
        typeof n == "symbol" || isNaN(n) ? t[n] = r : s.set_(parseInt(n), r),
        !0
    },
    preventExtensions: function() {
        it(15)
    }
}
  , QS = function() {
    function e(n, r, s, o) {
        n === void 0 && (n = "ObservableArray"),
        this.owned_ = void 0,
        this.legacyMode_ = void 0,
        this.atom_ = void 0,
        this.values_ = [],
        this.interceptors_ = void 0,
        this.changeListeners_ = void 0,
        this.enhancer_ = void 0,
        this.dehancer = void 0,
        this.proxy_ = void 0,
        this.lastKnownLength_ = 0,
        this.owned_ = s,
        this.legacyMode_ = o,
        this.atom_ = new Ia(n),
        this.enhancer_ = function(i, a) {
            return r(i, a, "ObservableArray[..]")
        }
    }
    var t = e.prototype;
    return t.dehanceValue_ = function(r) {
        return this.dehancer !== void 0 ? this.dehancer(r) : r
    }
    ,
    t.dehanceValues_ = function(r) {
        return this.dehancer !== void 0 && r.length > 0 ? r.map(this.dehancer) : r
    }
    ,
    t.intercept_ = function(r) {
        return Kf(this, r)
    }
    ,
    t.observe_ = function(r, s) {
        return s === void 0 && (s = !1),
        s && r({
            observableKind: "array",
            object: this.proxy_,
            debugObjectName: this.atom_.name_,
            type: "splice",
            index: 0,
            added: this.values_.slice(),
            addedCount: this.values_.length,
            removed: [],
            removedCount: 0
        }),
        Yf(this, r)
    }
    ,
    t.getArrayLength_ = function() {
        return this.atom_.reportObserved(),
        this.values_.length
    }
    ,
    t.setArrayLength_ = function(r) {
        (typeof r != "number" || isNaN(r) || r < 0) && it("Out of range: " + r);
        var s = this.values_.length;
        if (r !== s)
            if (r > s) {
                for (var o = new Array(r - s), i = 0; i < r - s; i++)
                    o[i] = void 0;
                this.spliceWithArray_(s, 0, o)
            } else
                this.spliceWithArray_(r, s - r)
    }
    ,
    t.updateArrayLength_ = function(r, s) {
        r !== this.lastKnownLength_ && it(16),
        this.lastKnownLength_ += s,
        this.legacyMode_ && s > 0 && MP(r + s + 1)
    }
    ,
    t.spliceWithArray_ = function(r, s, o) {
        var i = this;
        this.atom_;
        var a = this.values_.length;
        if (r === void 0 ? r = 0 : r > a ? r = a : r < 0 && (r = Math.max(0, a + r)),
        arguments.length === 1 ? s = a - r : s == null ? s = 0 : s = Math.max(0, Math.min(s, a - r)),
        o === void 0 && (o = L3),
        ys(this)) {
            var l = bs(this, {
                object: this.proxy_,
                type: d7,
                index: r,
                removedCount: s,
                added: o
            });
            if (!l)
                return L3;
            s = l.removedCount,
            o = l.added
        }
        if (o = o.length === 0 ? o : o.map(function(d) {
            return i.enhancer_(d, void 0)
        }),
        this.legacyMode_) {
            var c = o.length - s;
            this.updateArrayLength_(a, c)
        }
        var u = this.spliceItemsIntoValues_(r, s, o);
        return (s !== 0 || o.length !== 0) && this.notifyArraySplice_(r, o, u),
        this.dehanceValues_(u)
    }
    ,
    t.spliceItemsIntoValues_ = function(r, s, o) {
        if (o.length < pY) {
            var i;
            return (i = this.values_).splice.apply(i, [r, s].concat(o))
        } else {
            var a = this.values_.slice(r, r + s)
              , l = this.values_.slice(r + s);
            this.values_.length += o.length - s;
            for (var c = 0; c < o.length; c++)
                this.values_[r + c] = o[c];
            for (var u = 0; u < l.length; u++)
                this.values_[r + o.length + u] = l[u];
            return a
        }
    }
    ,
    t.notifyArrayChildUpdate_ = function(r, s, o) {
        var i = !this.owned_ && Zd()
          , a = Ks(this)
          , l = a || i ? {
            observableKind: "array",
            object: this.proxy_,
            type: Io,
            debugObjectName: this.atom_.name_,
            index: r,
            newValue: s,
            oldValue: o
        } : null;
        this.atom_.reportChanged(),
        a && Ys(this, l)
    }
    ,
    t.notifyArraySplice_ = function(r, s, o) {
        var i = !this.owned_ && Zd()
          , a = Ks(this)
          , l = a || i ? {
            observableKind: "array",
            object: this.proxy_,
            debugObjectName: this.atom_.name_,
            type: d7,
            index: r,
            removed: o,
            added: s,
            removedCount: o.length,
            addedCount: s.length
        } : null;
        this.atom_.reportChanged(),
        a && Ys(this, l)
    }
    ,
    t.get_ = function(r) {
        if (this.legacyMode_ && r >= this.values_.length) {
            console.warn("[mobx] Out of bounds read: " + r);
            return
        }
        return this.atom_.reportObserved(),
        this.dehanceValue_(this.values_[r])
    }
    ,
    t.set_ = function(r, s) {
        var o = this.values_;
        if (this.legacyMode_ && r > o.length && it(17, r, o.length),
        r < o.length) {
            this.atom_;
            var i = o[r];
            if (ys(this)) {
                var a = bs(this, {
                    type: Io,
                    object: this.proxy_,
                    index: r,
                    newValue: s
                });
                if (!a)
                    return;
                s = a.newValue
            }
            s = this.enhancer_(s, i);
            var l = s !== i;
            l && (o[r] = s,
            this.notifyArrayChildUpdate_(r, s, i))
        } else {
            for (var c = new Array(r + 1 - o.length), u = 0; u < c.length - 1; u++)
                c[u] = void 0;
            c[c.length - 1] = s,
            this.spliceWithArray_(o.length, 0, c)
        }
    }
    ,
    e
}();
function gY(e, t, n, r) {
    return n === void 0 && (n = "ObservableArray"),
    r === void 0 && (r = !1),
    NN(),
    Ra(function() {
        var s = new QS(n,t,r,!1);
        LN(s.values_, qe, s);
        var o = new Proxy(s.values_,mY);
        return s.proxy_ = o,
        e && e.length && s.spliceWithArray_(0, 0, e),
        o
    })
}
var km = {
    clear: function() {
        return this.splice(0)
    },
    replace: function(t) {
        var n = this[qe];
        return n.spliceWithArray_(0, n.values_.length, t)
    },
    toJSON: function() {
        return this.slice()
    },
    splice: function(t, n) {
        for (var r = arguments.length, s = new Array(r > 2 ? r - 2 : 0), o = 2; o < r; o++)
            s[o - 2] = arguments[o];
        var i = this[qe];
        switch (arguments.length) {
        case 0:
            return [];
        case 1:
            return i.spliceWithArray_(t);
        case 2:
            return i.spliceWithArray_(t, n)
        }
        return i.spliceWithArray_(t, n, s)
    },
    spliceWithArray: function(t, n, r) {
        return this[qe].spliceWithArray_(t, n, r)
    },
    push: function() {
        for (var t = this[qe], n = arguments.length, r = new Array(n), s = 0; s < n; s++)
            r[s] = arguments[s];
        return t.spliceWithArray_(t.values_.length, 0, r),
        t.values_.length
    },
    pop: function() {
        return this.splice(Math.max(this[qe].values_.length - 1, 0), 1)[0]
    },
    shift: function() {
        return this.splice(0, 1)[0]
    },
    unshift: function() {
        for (var t = this[qe], n = arguments.length, r = new Array(n), s = 0; s < n; s++)
            r[s] = arguments[s];
        return t.spliceWithArray_(0, 0, r),
        t.values_.length
    },
    reverse: function() {
        return fe.trackingDerivation && it(37, "reverse"),
        this.replace(this.slice().reverse()),
        this
    },
    sort: function() {
        fe.trackingDerivation && it(37, "sort");
        var t = this.slice();
        return t.sort.apply(t, arguments),
        this.replace(t),
        this
    },
    remove: function(t) {
        var n = this[qe]
          , r = n.dehanceValues_(n.values_).indexOf(t);
        return r > -1 ? (this.splice(r, 1),
        !0) : !1
    }
};
Kt("at", ds);
Kt("concat", ds);
Kt("flat", ds);
Kt("includes", ds);
Kt("indexOf", ds);
Kt("join", ds);
Kt("lastIndexOf", ds);
Kt("slice", ds);
Kt("toString", ds);
Kt("toLocaleString", ds);
Kt("toSorted", ds);
Kt("toSpliced", ds);
Kt("with", ds);
Kt("every", lo);
Kt("filter", lo);
Kt("find", lo);
Kt("findIndex", lo);
Kt("findLast", lo);
Kt("findLastIndex", lo);
Kt("flatMap", lo);
Kt("forEach", lo);
Kt("map", lo);
Kt("some", lo);
Kt("toReversed", lo);
Kt("reduce", TP);
Kt("reduceRight", TP);
function Kt(e, t) {
    typeof Array.prototype[e] == "function" && (km[e] = t(e))
}
function ds(e) {
    return function() {
        var t = this[qe];
        t.atom_.reportObserved();
        var n = t.dehanceValues_(t.values_);
        return n[e].apply(n, arguments)
    }
}
function lo(e) {
    return function(t, n) {
        var r = this
          , s = this[qe];
        s.atom_.reportObserved();
        var o = s.dehanceValues_(s.values_);
        return o[e](function(i, a) {
            return t.call(n, i, a, r)
        })
    }
}
function TP(e) {
    return function() {
        var t = this
          , n = this[qe];
        n.atom_.reportObserved();
        var r = n.dehanceValues_(n.values_)
          , s = arguments[0];
        return arguments[0] = function(o, i, a) {
            return s(o, i, a, t)
        }
        ,
        r[e].apply(r, arguments)
    }
}
var vY = Ma("ObservableArrayAdministration", QS);
function Fr(e) {
    return Og(e) && vY(e[qe])
}
var _Y = {}
  , na = "add"
  , Om = "delete"
  , e6 = function() {
    function e(n, r, s) {
        var o = this;
        r === void 0 && (r = Rl),
        s === void 0 && (s = "ObservableMap"),
        this.enhancer_ = void 0,
        this.name_ = void 0,
        this[qe] = _Y,
        this.data_ = void 0,
        this.hasMap_ = void 0,
        this.keysAtom_ = void 0,
        this.interceptors_ = void 0,
        this.changeListeners_ = void 0,
        this.dehancer = void 0,
        this.enhancer_ = r,
        this.name_ = s,
        ss(Map) || it(18),
        Ra(function() {
            o.keysAtom_ = Ag("ObservableMap.keys()"),
            o.data_ = new Map,
            o.hasMap_ = new Map,
            n && o.merge(n)
        })
    }
    var t = e.prototype;
    return t.has_ = function(r) {
        return this.data_.has(r)
    }
    ,
    t.has = function(r) {
        var s = this;
        if (!fe.trackingDerivation)
            return this.has_(r);
        var o = this.hasMap_.get(r);
        if (!o) {
            var i = o = new ua(this.has_(r),Mg,"ObservableMap.key?",!1);
            this.hasMap_.set(r, i),
            JS(i, function() {
                return s.hasMap_.delete(r)
            })
        }
        return o.get()
    }
    ,
    t.set = function(r, s) {
        var o = this.has_(r);
        if (ys(this)) {
            var i = bs(this, {
                type: o ? Io : na,
                object: this,
                newValue: s,
                name: r
            });
            if (!i)
                return this;
            s = i.newValue
        }
        return o ? this.updateValue_(r, s) : this.addValue_(r, s),
        this
    }
    ,
    t.delete = function(r) {
        var s = this;
        if (this.keysAtom_,
        ys(this)) {
            var o = bs(this, {
                type: Om,
                object: this,
                name: r
            });
            if (!o)
                return !1
        }
        if (this.has_(r)) {
            var i = Zd()
              , a = Ks(this)
              , l = a || i ? {
                observableKind: "map",
                debugObjectName: this.name_,
                type: Om,
                object: this,
                oldValue: this.data_.get(r).value_,
                name: r
            } : null;
            return Eo(function() {
                var c;
                s.keysAtom_.reportChanged(),
                (c = s.hasMap_.get(r)) == null || c.setNewValue_(!1);
                var u = s.data_.get(r);
                u.setNewValue_(void 0),
                s.data_.delete(r)
            }),
            a && Ys(this, l),
            !0
        }
        return !1
    }
    ,
    t.updateValue_ = function(r, s) {
        var o = this.data_.get(r);
        if (s = o.prepareNewValue_(s),
        s !== fe.UNCHANGED) {
            var i = Zd()
              , a = Ks(this)
              , l = a || i ? {
                observableKind: "map",
                debugObjectName: this.name_,
                type: Io,
                object: this,
                oldValue: o.value_,
                name: r,
                newValue: s
            } : null;
            o.setNewValue_(s),
            a && Ys(this, l)
        }
    }
    ,
    t.addValue_ = function(r, s) {
        var o = this;
        this.keysAtom_,
        Eo(function() {
            var c, u = new ua(s,o.enhancer_,"ObservableMap.key",!1);
            o.data_.set(r, u),
            s = u.value_,
            (c = o.hasMap_.get(r)) == null || c.setNewValue_(!0),
            o.keysAtom_.reportChanged()
        });
        var i = Zd()
          , a = Ks(this)
          , l = a || i ? {
            observableKind: "map",
            debugObjectName: this.name_,
            type: na,
            object: this,
            name: r,
            newValue: s
        } : null;
        a && Ys(this, l)
    }
    ,
    t.get = function(r) {
        return this.has(r) ? this.dehanceValue_(this.data_.get(r).get()) : this.dehanceValue_(void 0)
    }
    ,
    t.dehanceValue_ = function(r) {
        return this.dehancer !== void 0 ? this.dehancer(r) : r
    }
    ,
    t.keys = function() {
        return this.keysAtom_.reportObserved(),
        this.data_.keys()
    }
    ,
    t.values = function() {
        var r = this
          , s = this.keys();
        return f7({
            next: function() {
                var i = s.next()
                  , a = i.done
                  , l = i.value;
                return {
                    done: a,
                    value: a ? void 0 : r.get(l)
                }
            }
        })
    }
    ,
    t.entries = function() {
        var r = this
          , s = this.keys();
        return f7({
            next: function() {
                var i = s.next()
                  , a = i.done
                  , l = i.value;
                return {
                    done: a,
                    value: a ? void 0 : [l, r.get(l)]
                }
            }
        })
    }
    ,
    t[Symbol.iterator] = function() {
        return this.entries()
    }
    ,
    t.forEach = function(r, s) {
        for (var o = tu(this), i; !(i = o()).done; ) {
            var a = i.value
              , l = a[0]
              , c = a[1];
            r.call(s, c, l, this)
        }
    }
    ,
    t.merge = function(r) {
        var s = this;
        return or(r) && (r = new Map(r)),
        Eo(function() {
            vi(r) ? vW(r).forEach(function(o) {
                return s.set(o, r[o])
            }) : Array.isArray(r) ? r.forEach(function(o) {
                var i = o[0]
                  , a = o[1];
                return s.set(i, a)
            }) : qu(r) ? (gW(r) || it(19, r),
            r.forEach(function(o, i) {
                return s.set(i, o)
            })) : r != null && it(20, r)
        }),
        this
    }
    ,
    t.clear = function() {
        var r = this;
        Eo(function() {
            Wf(function() {
                for (var s = tu(r.keys()), o; !(o = s()).done; ) {
                    var i = o.value;
                    r.delete(i)
                }
            })
        })
    }
    ,
    t.replace = function(r) {
        var s = this;
        return Eo(function() {
            for (var o = yY(r), i = new Map, a = !1, l = tu(s.data_.keys()), c; !(c = l()).done; ) {
                var u = c.value;
                if (!o.has(u)) {
                    var d = s.delete(u);
                    if (d)
                        a = !0;
                    else {
                        var f = s.data_.get(u);
                        i.set(u, f)
                    }
                }
            }
            for (var p = tu(o.entries()), m; !(m = p()).done; ) {
                var v = m.value
                  , _ = v[0]
                  , y = v[1]
                  , b = s.data_.has(_);
                if (s.set(_, y),
                s.data_.has(_)) {
                    var S = s.data_.get(_);
                    i.set(_, S),
                    b || (a = !0)
                }
            }
            if (!a)
                if (s.data_.size !== i.size)
                    s.keysAtom_.reportChanged();
                else
                    for (var C = s.data_.keys(), w = i.keys(), x = C.next(), E = w.next(); !x.done; ) {
                        if (x.value !== E.value) {
                            s.keysAtom_.reportChanged();
                            break
                        }
                        x = C.next(),
                        E = w.next()
                    }
            s.data_ = i
        }),
        this
    }
    ,
    t.toString = function() {
        return "[object ObservableMap]"
    }
    ,
    t.toJSON = function() {
        return Array.from(this)
    }
    ,
    t.observe_ = function(r, s) {
        return Yf(this, r)
    }
    ,
    t.intercept_ = function(r) {
        return Kf(this, r)
    }
    ,
    Gu(e, [{
        key: "size",
        get: function() {
            return this.keysAtom_.reportObserved(),
            this.data_.size
        }
    }, {
        key: Symbol.toStringTag,
        get: function() {
            return "Map"
        }
    }])
}()
  , or = Ma("ObservableMap", e6);
function f7(e) {
    return e[Symbol.toStringTag] = "MapIterator",
    s6(e)
}
function yY(e) {
    if (qu(e) || or(e))
        return e;
    if (Array.isArray(e))
        return new Map(e);
    if (vi(e)) {
        var t = new Map;
        for (var n in e)
            t.set(n, e[n]);
        return t
    } else
        return it(21, e)
}
var bY = {}
  , t6 = function() {
    function e(n, r, s) {
        var o = this;
        r === void 0 && (r = Rl),
        s === void 0 && (s = "ObservableSet"),
        this.name_ = void 0,
        this[qe] = bY,
        this.data_ = new Set,
        this.atom_ = void 0,
        this.changeListeners_ = void 0,
        this.interceptors_ = void 0,
        this.dehancer = void 0,
        this.enhancer_ = void 0,
        this.name_ = s,
        ss(Set) || it(22),
        this.enhancer_ = function(i, a) {
            return r(i, a, s)
        }
        ,
        Ra(function() {
            o.atom_ = Ag(o.name_),
            n && o.replace(n)
        })
    }
    var t = e.prototype;
    return t.dehanceValue_ = function(r) {
        return this.dehancer !== void 0 ? this.dehancer(r) : r
    }
    ,
    t.clear = function() {
        var r = this;
        Eo(function() {
            Wf(function() {
                for (var s = tu(r.data_.values()), o; !(o = s()).done; ) {
                    var i = o.value;
                    r.delete(i)
                }
            })
        })
    }
    ,
    t.forEach = function(r, s) {
        for (var o = tu(this), i; !(i = o()).done; ) {
            var a = i.value;
            r.call(s, a, a, this)
        }
    }
    ,
    t.add = function(r) {
        var s = this;
        if (this.atom_,
        ys(this)) {
            var o = bs(this, {
                type: na,
                object: this,
                newValue: r
            });
            if (!o)
                return this;
            r = o.newValue
        }
        if (!this.has(r)) {
            Eo(function() {
                s.data_.add(s.enhancer_(r, void 0)),
                s.atom_.reportChanged()
            });
            var i = !1
              , a = Ks(this)
              , l = a || i ? {
                observableKind: "set",
                debugObjectName: this.name_,
                type: na,
                object: this,
                newValue: r
            } : null;
            a && Ys(this, l)
        }
        return this
    }
    ,
    t.delete = function(r) {
        var s = this;
        if (ys(this)) {
            var o = bs(this, {
                type: Om,
                object: this,
                oldValue: r
            });
            if (!o)
                return !1
        }
        if (this.has(r)) {
            var i = !1
              , a = Ks(this)
              , l = a || i ? {
                observableKind: "set",
                debugObjectName: this.name_,
                type: Om,
                object: this,
                oldValue: r
            } : null;
            return Eo(function() {
                s.atom_.reportChanged(),
                s.data_.delete(r)
            }),
            a && Ys(this, l),
            !0
        }
        return !1
    }
    ,
    t.has = function(r) {
        return this.atom_.reportObserved(),
        this.data_.has(this.dehanceValue_(r))
    }
    ,
    t.entries = function() {
        var r = this.values();
        return h7({
            next: function() {
                var o = r.next()
                  , i = o.value
                  , a = o.done;
                return a ? {
                    value: void 0,
                    done: a
                } : {
                    value: [i, i],
                    done: a
                }
            }
        })
    }
    ,
    t.keys = function() {
        return this.values()
    }
    ,
    t.values = function() {
        this.atom_.reportObserved();
        var r = this
          , s = this.data_.values();
        return h7({
            next: function() {
                var i = s.next()
                  , a = i.value
                  , l = i.done;
                return l ? {
                    value: void 0,
                    done: l
                } : {
                    value: r.dehanceValue_(a),
                    done: l
                }
            }
        })
    }
    ,
    t.intersection = function(r) {
        if (ai(r) && !Dn(r))
            return r.intersection(this);
        var s = new Set(this);
        return s.intersection(r)
    }
    ,
    t.union = function(r) {
        if (ai(r) && !Dn(r))
            return r.union(this);
        var s = new Set(this);
        return s.union(r)
    }
    ,
    t.difference = function(r) {
        return new Set(this).difference(r)
    }
    ,
    t.symmetricDifference = function(r) {
        if (ai(r) && !Dn(r))
            return r.symmetricDifference(this);
        var s = new Set(this);
        return s.symmetricDifference(r)
    }
    ,
    t.isSubsetOf = function(r) {
        return new Set(this).isSubsetOf(r)
    }
    ,
    t.isSupersetOf = function(r) {
        return new Set(this).isSupersetOf(r)
    }
    ,
    t.isDisjointFrom = function(r) {
        if (ai(r) && !Dn(r))
            return r.isDisjointFrom(this);
        var s = new Set(this);
        return s.isDisjointFrom(r)
    }
    ,
    t.replace = function(r) {
        var s = this;
        return Dn(r) && (r = new Set(r)),
        Eo(function() {
            Array.isArray(r) ? (s.clear(),
            r.forEach(function(o) {
                return s.add(o)
            })) : ai(r) ? (s.clear(),
            r.forEach(function(o) {
                return s.add(o)
            })) : r != null && it("Cannot initialize set from " + r)
        }),
        this
    }
    ,
    t.observe_ = function(r, s) {
        return Yf(this, r)
    }
    ,
    t.intercept_ = function(r) {
        return Kf(this, r)
    }
    ,
    t.toJSON = function() {
        return Array.from(this)
    }
    ,
    t.toString = function() {
        return "[object ObservableSet]"
    }
    ,
    t[Symbol.iterator] = function() {
        return this.values()
    }
    ,
    Gu(e, [{
        key: "size",
        get: function() {
            return this.atom_.reportObserved(),
            this.data_.size
        }
    }, {
        key: Symbol.toStringTag,
        get: function() {
            return "Set"
        }
    }])
}()
  , Dn = Ma("ObservableSet", t6);
function h7(e) {
    return e[Symbol.toStringTag] = "SetIterator",
    s6(e)
}
var p7 = Object.create(null)
  , m7 = "remove"
  , kP = function() {
    function e(n, r, s, o) {
        r === void 0 && (r = new Map),
        o === void 0 && (o = XW),
        this.target_ = void 0,
        this.values_ = void 0,
        this.name_ = void 0,
        this.defaultAnnotation_ = void 0,
        this.keysAtom_ = void 0,
        this.changeListeners_ = void 0,
        this.interceptors_ = void 0,
        this.proxy_ = void 0,
        this.isPlainObject_ = void 0,
        this.appliedAnnotations_ = void 0,
        this.pendingKeys_ = void 0,
        this.target_ = n,
        this.values_ = r,
        this.name_ = s,
        this.defaultAnnotation_ = o,
        this.keysAtom_ = new Ia("ObservableObject.keys"),
        this.isPlainObject_ = vi(this.target_)
    }
    var t = e.prototype;
    return t.getObservablePropValue_ = function(r) {
        return this.values_.get(r).get()
    }
    ,
    t.setObservablePropValue_ = function(r, s) {
        var o = this.values_.get(r);
        if (o instanceof Js)
            return o.set(s),
            !0;
        if (ys(this)) {
            var i = bs(this, {
                type: Io,
                object: this.proxy_ || this.target_,
                name: r,
                newValue: s
            });
            if (!i)
                return null;
            s = i.newValue
        }
        if (s = o.prepareNewValue_(s),
        s !== fe.UNCHANGED) {
            var a = Ks(this)
              , l = !1
              , c = a || l ? {
                type: Io,
                observableKind: "object",
                debugObjectName: this.name_,
                object: this.proxy_ || this.target_,
                oldValue: o.value_,
                name: r,
                newValue: s
            } : null;
            o.setNewValue_(s),
            a && Ys(this, c)
        }
        return !0
    }
    ,
    t.get_ = function(r) {
        return fe.trackingDerivation && !ci(this.target_, r) && this.has_(r),
        this.target_[r]
    }
    ,
    t.set_ = function(r, s, o) {
        return o === void 0 && (o = !1),
        ci(this.target_, r) ? this.values_.has(r) ? this.setObservablePropValue_(r, s) : o ? Reflect.set(this.target_, r, s) : (this.target_[r] = s,
        !0) : this.extend_(r, {
            value: s,
            enumerable: !0,
            writable: !0,
            configurable: !0
        }, this.defaultAnnotation_, o)
    }
    ,
    t.has_ = function(r) {
        if (!fe.trackingDerivation)
            return r in this.target_;
        this.pendingKeys_ || (this.pendingKeys_ = new Map);
        var s = this.pendingKeys_.get(r);
        return s || (s = new ua(r in this.target_,Mg,"ObservableObject.key?",!1),
        this.pendingKeys_.set(r, s)),
        s.get()
    }
    ,
    t.make_ = function(r, s) {
        if (s === !0 && (s = this.defaultAnnotation_),
        s !== !1) {
            if (!(r in this.target_)) {
                var o;
                if ((o = this.target_[ko]) != null && o[r])
                    return;
                it(1, s.annotationType_, this.name_ + "." + r.toString())
            }
            for (var i = this.target_; i && i !== Gf; ) {
                var a = Cm(i, r);
                if (a) {
                    var l = s.make_(this, r, a, i);
                    if (l === 0)
                        return;
                    if (l === 1)
                        break
                }
                i = Object.getPrototypeOf(i)
            }
            v7(this, s, r)
        }
    }
    ,
    t.extend_ = function(r, s, o, i) {
        if (i === void 0 && (i = !1),
        o === !0 && (o = this.defaultAnnotation_),
        o === !1)
            return this.defineProperty_(r, s, i);
        var a = o.extend_(this, r, s, i);
        return a && v7(this, o, r),
        a
    }
    ,
    t.defineProperty_ = function(r, s, o) {
        o === void 0 && (o = !1),
        this.keysAtom_;
        try {
            Mr();
            var i = this.delete_(r);
            if (!i)
                return i;
            if (ys(this)) {
                var a = bs(this, {
                    object: this.proxy_ || this.target_,
                    name: r,
                    type: na,
                    newValue: s.value
                });
                if (!a)
                    return null;
                var l = a.newValue;
                s.value !== l && (s = ga({}, s, {
                    value: l
                }))
            }
            if (o) {
                if (!Reflect.defineProperty(this.target_, r, s))
                    return !1
            } else
                Mo(this.target_, r, s);
            this.notifyPropertyAddition_(r, s.value)
        } finally {
            Ir()
        }
        return !0
    }
    ,
    t.defineObservableProperty_ = function(r, s, o, i) {
        i === void 0 && (i = !1),
        this.keysAtom_;
        try {
            Mr();
            var a = this.delete_(r);
            if (!a)
                return a;
            if (ys(this)) {
                var l = bs(this, {
                    object: this.proxy_ || this.target_,
                    name: r,
                    type: na,
                    newValue: s
                });
                if (!l)
                    return null;
                s = l.newValue
            }
            var c = g7(r)
              , u = {
                configurable: fe.safeDescriptors ? this.isPlainObject_ : !0,
                enumerable: !0,
                get: c.get,
                set: c.set
            };
            if (i) {
                if (!Reflect.defineProperty(this.target_, r, u))
                    return !1
            } else
                Mo(this.target_, r, u);
            var d = new ua(s,o,"ObservableObject.key",!1);
            this.values_.set(r, d),
            this.notifyPropertyAddition_(r, d.value_)
        } finally {
            Ir()
        }
        return !0
    }
    ,
    t.defineComputedProperty_ = function(r, s, o) {
        o === void 0 && (o = !1),
        this.keysAtom_;
        try {
            Mr();
            var i = this.delete_(r);
            if (!i)
                return i;
            if (ys(this)) {
                var a = bs(this, {
                    object: this.proxy_ || this.target_,
                    name: r,
                    type: na,
                    newValue: void 0
                });
                if (!a)
                    return null
            }
            s.name || (s.name = "ObservableObject.key"),
            s.context = this.proxy_ || this.target_;
            var l = g7(r)
              , c = {
                configurable: fe.safeDescriptors ? this.isPlainObject_ : !0,
                enumerable: !1,
                get: l.get,
                set: l.set
            };
            if (o) {
                if (!Reflect.defineProperty(this.target_, r, c))
                    return !1
            } else
                Mo(this.target_, r, c);
            this.values_.set(r, new Js(s)),
            this.notifyPropertyAddition_(r, void 0)
        } finally {
            Ir()
        }
        return !0
    }
    ,
    t.delete_ = function(r, s) {
        if (s === void 0 && (s = !1),
        this.keysAtom_,
        !ci(this.target_, r))
            return !0;
        if (ys(this)) {
            var o = bs(this, {
                object: this.proxy_ || this.target_,
                name: r,
                type: m7
            });
            if (!o)
                return null
        }
        try {
            var i;
            Mr();
            var a = Ks(this)
              , l = !1
              , c = this.values_.get(r)
              , u = void 0;
            if (!c && (a || l)) {
                var d;
                u = (d = Cm(this.target_, r)) == null ? void 0 : d.value
            }
            if (s) {
                if (!Reflect.deleteProperty(this.target_, r))
                    return !1
            } else
                delete this.target_[r];
            if (c && (this.values_.delete(r),
            c instanceof ua && (u = c.value_),
            sP(c)),
            this.keysAtom_.reportChanged(),
            (i = this.pendingKeys_) == null || (i = i.get(r)) == null || i.set(r in this.target_),
            a || l) {
                var f = {
                    type: m7,
                    observableKind: "object",
                    object: this.proxy_ || this.target_,
                    debugObjectName: this.name_,
                    oldValue: u,
                    name: r
                };
                a && Ys(this, f)
            }
        } finally {
            Ir()
        }
        return !0
    }
    ,
    t.observe_ = function(r, s) {
        return Yf(this, r)
    }
    ,
    t.intercept_ = function(r) {
        return Kf(this, r)
    }
    ,
    t.notifyPropertyAddition_ = function(r, s) {
        var o, i = Ks(this), a = !1;
        if (i || a) {
            var l = i || a ? {
                type: na,
                observableKind: "object",
                debugObjectName: this.name_,
                object: this.proxy_ || this.target_,
                name: r,
                newValue: s
            } : null;
            i && Ys(this, l)
        }
        (o = this.pendingKeys_) == null || (o = o.get(r)) == null || o.set(!0),
        this.keysAtom_.reportChanged()
    }
    ,
    t.ownKeys_ = function() {
        return this.keysAtom_.reportObserved(),
        Cu(this.target_)
    }
    ,
    t.keys_ = function() {
        return this.keysAtom_.reportObserved(),
        Object.keys(this.target_)
    }
    ,
    e
}();
function Jl(e, t) {
    var n;
    if (ci(e, qe))
        return e;
    var r = (n = t?.name) != null ? n : "ObservableObject"
      , s = new kP(e,new Map,String(r),cK(t));
    return Vf(e, qe, s),
    e
}
var CY = Ma("ObservableObjectAdministration", kP);
function g7(e) {
    return p7[e] || (p7[e] = {
        get: function() {
            return this[qe].getObservablePropValue_(e)
        },
        set: function(n) {
            return this[qe].setObservablePropValue_(e, n)
        }
    })
}
function rr(e) {
    return Og(e) ? CY(e[qe]) : !1
}
function v7(e, t, n) {
    var r;
    (r = e.target_[ko]) == null || delete r[n]
}
var SY = AP(0)
  , wY = function() {
    var e = !1
      , t = {};
    return Object.defineProperty(t, "0", {
        set: function() {
            e = !0
        }
    }),
    Object.create(t)[0] = 1,
    e === !1
}()
  , v0 = 0
  , OP = function() {};
function EY(e, t) {
    Object.setPrototypeOf ? Object.setPrototypeOf(e.prototype, t) : e.prototype.__proto__ !== void 0 ? e.prototype.__proto__ = t : e.prototype = t
}
EY(OP, Array.prototype);
var n6 = function(e) {
    function t(r, s, o, i) {
        var a;
        return o === void 0 && (o = "ObservableArray"),
        i === void 0 && (i = !1),
        a = e.call(this) || this,
        Ra(function() {
            var l = new QS(o,s,i,!0);
            l.proxy_ = a,
            LN(a, qe, l),
            r && r.length && a.spliceWithArray(0, 0, r),
            wY && Object.defineProperty(a, "0", SY)
        }),
        a
    }
    UN(t, e);
    var n = t.prototype;
    return n.concat = function() {
        this[qe].atom_.reportObserved();
        for (var s = arguments.length, o = new Array(s), i = 0; i < s; i++)
            o[i] = arguments[i];
        return Array.prototype.concat.apply(this.slice(), o.map(function(a) {
            return Fr(a) ? a.slice() : a
        }))
    }
    ,
    n[Symbol.iterator] = function() {
        var r = this
          , s = 0;
        return s6({
            next: function() {
                return s < r.length ? {
                    value: r[s++],
                    done: !1
                } : {
                    done: !0,
                    value: void 0
                }
            }
        })
    }
    ,
    Gu(t, [{
        key: "length",
        get: function() {
            return this[qe].getArrayLength_()
        },
        set: function(s) {
            this[qe].setArrayLength_(s)
        }
    }, {
        key: Symbol.toStringTag,
        get: function() {
            return "Array"
        }
    }])
}(OP);
Object.entries(km).forEach(function(e) {
    var t = e[0]
      , n = e[1];
    t !== "concat" && Vf(n6.prototype, t, n)
});
function AP(e) {
    return {
        enumerable: !1,
        configurable: !0,
        get: function() {
            return this[qe].get_(e)
        },
        set: function(n) {
            this[qe].set_(e, n)
        }
    }
}
function xY(e) {
    Mo(n6.prototype, "" + e, AP(e))
}
function MP(e) {
    if (e > v0) {
        for (var t = v0; t < e + 100; t++)
            xY(t);
        v0 = e
    }
}
MP(1e3);
function TY(e, t, n) {
    return new n6(e,t,n)
}
function _i(e, t) {
    if (typeof e == "object" && e !== null) {
        if (Fr(e))
            return t !== void 0 && it(23),
            e[qe].atom_;
        if (Dn(e))
            return e.atom_;
        if (or(e)) {
            if (t === void 0)
                return e.keysAtom_;
            var n = e.data_.get(t) || e.hasMap_.get(t);
            return n || it(25, t, Am(e)),
            n
        }
        if (rr(e)) {
            if (!t)
                return it(26);
            var r = e[qe].values_.get(t);
            return r || it(27, t, Am(e)),
            r
        }
        if (WS(e) || Nl(e) || xm(e))
            return e
    } else if (ss(e) && xm(e[qe]))
        return e[qe];
    it(28)
}
function yi(e, t) {
    if (e || it(29),
    t !== void 0)
        return yi(_i(e, t));
    if (WS(e) || Nl(e) || xm(e) || or(e) || Dn(e))
        return e;
    if (e[qe])
        return e[qe];
    it(24, e)
}
function Am(e, t) {
    var n;
    if (t !== void 0)
        n = _i(e, t);
    else {
        if (wu(e))
            return e.name;
        rr(e) || or(e) || Dn(e) ? n = yi(e) : n = _i(e)
    }
    return n.name_
}
function Ra(e) {
    var t = Zl()
      , n = Rg(!0);
    Mr();
    try {
        return e()
    } finally {
        Ir(),
        Ng(n),
        ui(t)
    }
}
var _7 = Gf.toString;
function r6(e, t, n) {
    return n === void 0 && (n = -1),
    $3(e, t, n)
}
function $3(e, t, n, r, s) {
    if (e === t)
        return e !== 0 || 1 / e === 1 / t;
    if (e == null || t == null)
        return !1;
    if (e !== e)
        return t !== t;
    var o = typeof e;
    if (o !== "function" && o !== "object" && typeof t != "object")
        return !1;
    var i = _7.call(e);
    if (i !== _7.call(t))
        return !1;
    switch (i) {
    case "[object RegExp]":
    case "[object String]":
        return "" + e == "" + t;
    case "[object Number]":
        return +e != +e ? +t != +t : +e == 0 ? 1 / +e === 1 / t : +e == +t;
    case "[object Date]":
    case "[object Boolean]":
        return +e == +t;
    case "[object Symbol]":
        return typeof Symbol < "u" && Symbol.valueOf.call(e) === Symbol.valueOf.call(t);
    case "[object Map]":
    case "[object Set]":
        n >= 0 && n++;
        break
    }
    e = y7(e),
    t = y7(t);
    var a = i === "[object Array]";
    if (!a) {
        if (typeof e != "object" || typeof t != "object")
            return !1;
        var l = e.constructor
          , c = t.constructor;
        if (l !== c && !(ss(l) && l instanceof l && ss(c) && c instanceof c) && "constructor"in e && "constructor"in t)
            return !1
    }
    if (n === 0)
        return !1;
    n < 0 && (n = -1),
    r = r || [],
    s = s || [];
    for (var u = r.length; u--; )
        if (r[u] === e)
            return s[u] === t;
    if (r.push(e),
    s.push(t),
    a) {
        if (u = e.length,
        u !== t.length)
            return !1;
        for (; u--; )
            if (!$3(e[u], t[u], n - 1, r, s))
                return !1
    } else {
        var d = Object.keys(e)
          , f = d.length;
        if (Object.keys(t).length !== f)
            return !1;
        for (var p = 0; p < f; p++) {
            var m = d[p];
            if (!(ci(t, m) && $3(e[m], t[m], n - 1, r, s)))
                return !1
        }
    }
    return r.pop(),
    s.pop(),
    !0
}
function y7(e) {
    return Fr(e) ? e.slice() : qu(e) || or(e) || ai(e) || Dn(e) ? Array.from(e.entries()) : e
}
var b7, kY = ((b7 = kg().Iterator) == null ? void 0 : b7.prototype) || {};
function s6(e) {
    return e[Symbol.iterator] = OY,
    Object.assign(Object.create(kY), e)
}
function OY() {
    return this
}
["Symbol", "Map", "Set"].forEach(function(e) {
    var t = kg();
    typeof t[e] > "u" && it("MobX requires global '" + e + "' to be available or polyfilled")
});
typeof __MOBX_DEVTOOLS_GLOBAL_HOOK__ == "object" && __MOBX_DEVTOOLS_GLOBAL_HOOK__.injectMobx({
    spy: iP,
    extras: {
        getDebugName: Am
    },
    $mobx: qe
});
const c8e = Object.freeze(Object.defineProperty({
    __proto__: null,
    $mobx: qe,
    FlowCancellationError: Lg,
    ObservableMap: e6,
    ObservableSet: t6,
    Reaction: Xs,
    _allowStateChanges: YS,
    _allowStateChangesInsideComputed: Tm,
    _allowStateReadsEnd: iu,
    _allowStateReadsStart: Pg,
    _autoAction: Su,
    _endAction: JN,
    _getAdministration: yi,
    _getGlobalState: bK,
    _interceptReads: WK,
    _isComputingDerivation: gK,
    _resetGlobalState: CK,
    _startAction: ZN,
    action: ta,
    autorun: Dg,
    comparer: Il,
    computed: Vu,
    configure: mP,
    createAtom: Ag,
    defineProperty: sY,
    entries: tY,
    extendObservable: XS,
    flow: Pl,
    flowResult: $K,
    get: rY,
    getAtom: _i,
    getDebugName: Am,
    getDependencyTree: gP,
    getObserverTree: qK,
    has: SP,
    intercept: KK,
    isAction: wu,
    isBoxedObservable: ZS,
    isComputed: JK,
    isComputedProp: XK,
    isFlow: Eu,
    isFlowCancellationError: HK,
    isObservable: Fg,
    isObservableArray: Fr,
    isObservableMap: or,
    isObservableObject: rr,
    isObservableProp: QK,
    isObservableSet: Dn,
    keys: pf,
    makeAutoObservable: hY,
    makeObservable: xP,
    observable: Pn,
    observe: oY,
    onBecomeObserved: hP,
    onBecomeUnobserved: JS,
    onReactionError: kK,
    override: MW,
    ownKeys: wP,
    reaction: fP,
    remove: nY,
    runInAction: Tm,
    set: CP,
    spy: iP,
    toJS: lY,
    trace: cY,
    transaction: Eo,
    untracked: Wf,
    values: eY,
    when: z3
}, Symbol.toStringTag, {
    value: "Module"
}));
if (!h.useState)
    throw new Error("mobx-react-lite requires React with Hooks support");
if (!xP)
    throw new Error("mobx-react-lite@3 requires mobx at least version 6 to be available");
function AY(e) {
    e()
}
function MY(e) {
    e || (e = AY),
    mP({
        reactionScheduler: e
    })
}
function IY(e) {
    return gP(e)
}
var RY = 1e4
  , NY = 1e4
  , PY = function() {
    function e(t) {
        var n = this;
        Object.defineProperty(this, "finalize", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: t
        }),
        Object.defineProperty(this, "registrations", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: new Map
        }),
        Object.defineProperty(this, "sweepTimeout", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }),
        Object.defineProperty(this, "sweep", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: function(r) {
                r === void 0 && (r = RY),
                clearTimeout(n.sweepTimeout),
                n.sweepTimeout = void 0;
                var s = Date.now();
                n.registrations.forEach(function(o, i) {
                    s - o.registeredAt >= r && (n.finalize(o.value),
                    n.registrations.delete(i))
                }),
                n.registrations.size > 0 && n.scheduleSweep()
            }
        }),
        Object.defineProperty(this, "finalizeAllImmediately", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: function() {
                n.sweep(0)
            }
        })
    }
    return Object.defineProperty(e.prototype, "register", {
        enumerable: !1,
        configurable: !0,
        writable: !0,
        value: function(t, n, r) {
            this.registrations.set(r, {
                value: n,
                registeredAt: Date.now()
            }),
            this.scheduleSweep()
        }
    }),
    Object.defineProperty(e.prototype, "unregister", {
        enumerable: !1,
        configurable: !0,
        writable: !0,
        value: function(t) {
            this.registrations.delete(t)
        }
    }),
    Object.defineProperty(e.prototype, "scheduleSweep", {
        enumerable: !1,
        configurable: !0,
        writable: !0,
        value: function() {
            this.sweepTimeout === void 0 && (this.sweepTimeout = setTimeout(this.sweep, NY))
        }
    }),
    e
}()
  , DY = typeof FinalizationRegistry < "u" ? FinalizationRegistry : PY
  , W3 = new DY(function(e) {
    var t;
    (t = e.reaction) === null || t === void 0 || t.dispose(),
    e.reaction = null
}
)
  , _0 = {
    exports: {}
}
  , y0 = {};
/**
 * @license React
 * use-sync-external-store-shim.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var C7;
function LY() {
    if (C7)
        return y0;
    C7 = 1;
    var e = MS();
    function t(d, f) {
        return d === f && (d !== 0 || 1 / d === 1 / f) || d !== d && f !== f
    }
    var n = typeof Object.is == "function" ? Object.is : t
      , r = e.useState
      , s = e.useEffect
      , o = e.useLayoutEffect
      , i = e.useDebugValue;
    function a(d, f) {
        var p = f()
          , m = r({
            inst: {
                value: p,
                getSnapshot: f
            }
        })
          , v = m[0].inst
          , _ = m[1];
        return o(function() {
            v.value = p,
            v.getSnapshot = f,
            l(v) && _({
                inst: v
            })
        }, [d, p, f]),
        s(function() {
            return l(v) && _({
                inst: v
            }),
            d(function() {
                l(v) && _({
                    inst: v
                })
            })
        }, [d]),
        i(p),
        p
    }
    function l(d) {
        var f = d.getSnapshot;
        d = d.value;
        try {
            var p = f();
            return !n(d, p)
        } catch {
            return !0
        }
    }
    function c(d, f) {
        return f()
    }
    var u = typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u" ? c : a;
    return y0.useSyncExternalStore = e.useSyncExternalStore !== void 0 ? e.useSyncExternalStore : u,
    y0
}
var S7;
function FY() {
    return S7 || (S7 = 1,
    _0.exports = LY()),
    _0.exports
}
var jY = FY();
function w7(e) {
    e.reaction = new Xs("observer".concat(e.name),function() {
        var t;
        e.stateVersion = Symbol(),
        (t = e.onStoreChange) === null || t === void 0 || t.call(e)
    }
    )
}
function UY(e, t) {
    t === void 0 && (t = "observed");
    var n = Ne.useRef(null);
    if (!n.current) {
        var r = {
            reaction: null,
            onStoreChange: null,
            stateVersion: Symbol(),
            name: t,
            subscribe: function(a) {
                return W3.unregister(r),
                r.onStoreChange = a,
                r.reaction || (w7(r),
                r.stateVersion = Symbol()),
                function() {
                    var l;
                    r.onStoreChange = null,
                    (l = r.reaction) === null || l === void 0 || l.dispose(),
                    r.reaction = null
                }
            },
            getSnapshot: function() {
                return r.stateVersion
            }
        };
        n.current = r
    }
    var s = n.current;
    s.reaction || (w7(s),
    W3.register(n, s, s)),
    Ne.useDebugValue(s.reaction, IY),
    jY.useSyncExternalStore(s.subscribe, s.getSnapshot, s.getSnapshot);
    var o, i;
    if (s.reaction.track(function() {
        try {
            o = e()
        } catch (a) {
            i = a
        }
    }),
    i)
        throw i;
    return o
}
var b0, C0, IP = typeof Symbol == "function" && Symbol.for;
C0 = (b0 = Object.getOwnPropertyDescriptor(function() {}, "name")) === null || b0 === void 0 ? void 0 : b0.configurable;
IP ? Symbol.for("react.forward_ref") : typeof h.forwardRef == "function" && h.forwardRef(function(e) {
    return null
}).$$typeof;
IP ? Symbol.for("react.memo") : typeof h.memo == "function" && h.memo(function(e) {
    return null
}).$$typeof;
var S0;
MY(IS.unstable_batchedUpdates);
S0 = W3.finalizeAllImmediately;
function BY(e, t) {
    return t === void 0 && (t = "observed"),
    UY(e, t)
}
function Ct(e, t) {
    const n = zY(e)
      , r = Pn.box(n ? void 0 : e, {
        deep: !1,
        name: t?.name,
        equals: t?.equals
    });
    let s = n ? () => {
        s = void 0,
        r.set(e())
    }
    : void 0;
    const o = () => (s?.(),
    r.get())
      , i = t?.getServerFallback
      , a = LP(o)
      , l = i ? Na(a, {
        name: t.name,
        getServerFallback: i
    }) : a;
    return l.set = c => {
        FP(),
        Tm( () => {
            r?.set(DP(c) ? c(Wf(o)) : c)
        }
        )
    }
    ,
    l
}
function is(e) {
    return BY( () => _a(e))
}
function Na(e, t) {
    const n = t?.getServerFallback
      , r = Vu(n ? () => PP() ? n() : _a(e) : () => _a(e), {
        name: t?.name,
        equals: t?.equals
    });
    return LP( () => r.get())
}
function qY(e) {
    if (zS())
        throw new Error("[signal] Cannot run effect directly within React component");
    let t;
    const n = Dg( () => {
        t?.(),
        t = _a(e)
    }
    );
    return () => {
        n(),
        t?.()
    }
}
function RP(e, t, n) {
    return fP( () => _a(e), t, {
        equals: n?.equals,
        fireImmediately: n?.fireImmediately
    })
}
function da(e) {
    return Wf( () => _a(e))
}
function GY(e, t) {
    return typeof t == "function" ? z3( () => _a(e), t) : z3( () => _a(e))
}
function VY(e) {
    return Tm(e)
}
function Pa(e, t, n) {
    let r;
    const s = Ag(n?.name ?? "syncExternalStoreSignal", () => {
        let i = t();
        r = e( () => {
            FP();
            const a = t();
            i !== a && (i = a,
            s.reportChanged())
        }
        )
    }
    , () => {
        r?.()
    }
    )
      , o = n?.getServerFallback;
    return Na( () => o && PP() ? o() : (s.reportObserved(),
    t()))
}
const NP = Ct(!0, {
    name: "isServerRendering"
})
  , PP = NP;
function HY() {
    h.useLayoutEffect( () => {
        NP.set(!1)
    }
    , [])
}
function zY(e) {
    return typeof e == "function"
}
function DP(e) {
    return typeof e == "function"
}
function LP(e) {
    return () => ($Y(),
    e())
}
let Mm = 0;
function _a(e) {
    try {
        return Mm++,
        e()
    } finally {
        Mm--
    }
}
function $Y() {
    !Mm && zS() && K3(new Error("[signal] Must read signal with useObserve() or untracked() within React component"))
}
function FP() {
    Mm && K3(new Error("[signal] Cannot update signal value directly within useObserve(), computed() or effect()")),
    zS() && K3(new Error("[signal] Cannot update signal value directly within React component"))
}
function K3(e) {
    q.addError(e)
}
function Zf(e, t, n) {
    const r = Aa(e)
      , s = E7( () => r.defaultQueryOptions({
        ...t(),
        notifyOnChangeProps: ["data", "isLoading", "error", "status"]
    }))
      , o = E7( () => new RS(r,s()));
    return Pa(i => {
        let a = !1;
        const l = o().subscribe( () => {
            a && i()
        }
        );
        return a = !0,
        l
    }
    , () => o().getOptimisticResult(s()), {
        name: n?.name ?? "reactQuerySignal",
        getServerFallback: n?.forcePendingOnServer ? () => WY(e) : void 0
    })
}
const WY = en(e => {
    const t = Aa(e)
      , n = t.defaultQueryOptions({
        queryKey: ["__empty"]
    });
    return new RS(t,n).getOptimisticResult(n)
}
);
function E7(e) {
    let t;
    return () => t ?? (t = e())
}
function u8e(e, t, n) {
    return Pa(r => e.subscribe( (s, o) => {
        t(s) !== t(o) && r()
    }
    ), () => t(e.getState()), {
        name: "storeWithSelectorSignal",
        getServerFallback: () => t(e.getInitialState())
    })
}
const KY = "OAI-Language"
  , jg = "OAI-Client-Version"
  , Ug = "OAI-Device-Id"
  , pr = "OAI-Product-Sku"
  , YY = {}
  , x7 = e => {
    let t;
    const n = new Set
      , r = (u, d) => {
        const f = typeof u == "function" ? u(t) : u;
        if (!Object.is(f, t)) {
            const p = t;
            t = d ?? (typeof f != "object" || f === null) ? f : Object.assign({}, t, f),
            n.forEach(m => m(t, p))
        }
    }
      , s = () => t
      , l = {
        setState: r,
        getState: s,
        getInitialState: () => c,
        subscribe: u => (n.add(u),
        () => n.delete(u)),
        destroy: () => {
            (YY ? "production" : void 0) !== "production" && console.warn("[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected."),
            n.clear()
        }
    }
      , c = t = e(r, s, l);
    return l
}
  , Ei = e => e ? x7(e) : x7;
var w0 = {
    exports: {}
}
  , E0 = {}
  , x0 = {
    exports: {}
}
  , T0 = {};
/**
 * @license React
 * use-sync-external-store-shim.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var T7;
function ZY() {
    if (T7)
        return T0;
    T7 = 1;
    var e = MS();
    function t(d, f) {
        return d === f && (d !== 0 || 1 / d === 1 / f) || d !== d && f !== f
    }
    var n = typeof Object.is == "function" ? Object.is : t
      , r = e.useState
      , s = e.useEffect
      , o = e.useLayoutEffect
      , i = e.useDebugValue;
    function a(d, f) {
        var p = f()
          , m = r({
            inst: {
                value: p,
                getSnapshot: f
            }
        })
          , v = m[0].inst
          , _ = m[1];
        return o(function() {
            v.value = p,
            v.getSnapshot = f,
            l(v) && _({
                inst: v
            })
        }, [d, p, f]),
        s(function() {
            return l(v) && _({
                inst: v
            }),
            d(function() {
                l(v) && _({
                    inst: v
                })
            })
        }, [d]),
        i(p),
        p
    }
    function l(d) {
        var f = d.getSnapshot;
        d = d.value;
        try {
            var p = f();
            return !n(d, p)
        } catch {
            return !0
        }
    }
    function c(d, f) {
        return f()
    }
    var u = typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u" ? c : a;
    return T0.useSyncExternalStore = e.useSyncExternalStore !== void 0 ? e.useSyncExternalStore : u,
    T0
}
var k7;
function JY() {
    return k7 || (k7 = 1,
    x0.exports = ZY()),
    x0.exports
}
/**
 * @license React
 * use-sync-external-store-shim/with-selector.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var O7;
function XY() {
    if (O7)
        return E0;
    O7 = 1;
    var e = MS()
      , t = JY();
    function n(c, u) {
        return c === u && (c !== 0 || 1 / c === 1 / u) || c !== c && u !== u
    }
    var r = typeof Object.is == "function" ? Object.is : n
      , s = t.useSyncExternalStore
      , o = e.useRef
      , i = e.useEffect
      , a = e.useMemo
      , l = e.useDebugValue;
    return E0.useSyncExternalStoreWithSelector = function(c, u, d, f, p) {
        var m = o(null);
        if (m.current === null) {
            var v = {
                hasValue: !1,
                value: null
            };
            m.current = v
        } else
            v = m.current;
        m = a(function() {
            function y(x) {
                if (!b) {
                    if (b = !0,
                    S = x,
                    x = f(x),
                    p !== void 0 && v.hasValue) {
                        var E = v.value;
                        if (p(E, x))
                            return C = E
                    }
                    return C = x
                }
                if (E = C,
                r(S, x))
                    return E;
                var T = f(x);
                return p !== void 0 && p(E, T) ? E : (S = x,
                C = T)
            }
            var b = !1, S, C, w = d === void 0 ? null : d;
            return [function() {
                return y(u())
            }
            , w === null ? void 0 : function() {
                return y(w())
            }
            ]
        }, [u, d, f, p]);
        var _ = s(c, m[0], m[1]);
        return i(function() {
            v.hasValue = !0,
            v.value = _
        }, [_]),
        l(_),
        _
    }
    ,
    E0
}
var A7;
function QY() {
    return A7 || (A7 = 1,
    w0.exports = XY()),
    w0.exports
}
var eZ = QY();
const jP = mn(eZ)
  , UP = {}
  , {useDebugValue: tZ} = Ne
  , {useSyncExternalStoreWithSelector: nZ} = jP;
let M7 = !1;
const rZ = e => e;
function Xl(e, t=rZ, n) {
    (UP ? "production" : void 0) !== "production" && n && !M7 && (console.warn("[DEPRECATED] Use `createWithEqualityFn` instead of `create` or use `useStoreWithEqualityFn` instead of `useStore`. They can be imported from 'zustand/traditional'. https://github.com/pmndrs/zustand/discussions/1937"),
    M7 = !0);
    const r = nZ(e.subscribe, e.getState, e.getServerState || e.getInitialState, t, n);
    return tZ(r),
    r
}
const I7 = e => {
    (UP ? "production" : void 0) !== "production" && typeof e != "function" && console.warn("[DEPRECATED] Passing a vanilla store will be unsupported in a future version. Instead use `import { useStore } from 'zustand'`.");
    const t = typeof e == "function" ? Ei(e) : e
      , n = (r, s) => Xl(t, r, s);
    return Object.assign(n, t),
    n
}
  , dn = e => e ? I7(e) : I7
  , sZ = "9d358314d30a26d59ec2f2390d079c86e2c0018f"
  , oZ = "prod"
  , iZ = ""
  , aZ = ""
  , Hu = `${oZ}-${sZ}${iZ}${aZ}`;
var tl = {}
  , sp = {};
/*!
 * cookie
 * Copyright(c) 2012-2014 Roman Shtylman
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var R7;
function lZ() {
    if (R7)
        return sp;
    R7 = 1,
    sp.parse = r,
    sp.serialize = s;
    var e = decodeURIComponent
      , t = encodeURIComponent
      , n = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;
    function r(i, a) {
        if (typeof i != "string")
            throw new TypeError("argument str must be a string");
        for (var l = {}, c = a || {}, u = i.split(";"), d = c.decode || e, f = 0; f < u.length; f++) {
            var p = u[f]
              , m = p.indexOf("=");
            if (!(m < 0)) {
                var v = p.substring(0, m).trim();
                if (l[v] == null) {
                    var _ = p.substring(m + 1, p.length).trim();
                    _[0] === '"' && (_ = _.slice(1, -1)),
                    l[v] = o(_, d)
                }
            }
        }
        return l
    }
    function s(i, a, l) {
        var c = l || {}
          , u = c.encode || t;
        if (typeof u != "function")
            throw new TypeError("option encode is invalid");
        if (!n.test(i))
            throw new TypeError("argument name is invalid");
        var d = u(a);
        if (d && !n.test(d))
            throw new TypeError("argument val is invalid");
        var f = i + "=" + d;
        if (c.maxAge != null) {
            var p = c.maxAge - 0;
            if (isNaN(p) || !isFinite(p))
                throw new TypeError("option maxAge is invalid");
            f += "; Max-Age=" + Math.floor(p)
        }
        if (c.domain) {
            if (!n.test(c.domain))
                throw new TypeError("option domain is invalid");
            f += "; Domain=" + c.domain
        }
        if (c.path) {
            if (!n.test(c.path))
                throw new TypeError("option path is invalid");
            f += "; Path=" + c.path
        }
        if (c.expires) {
            if (typeof c.expires.toUTCString != "function")
                throw new TypeError("option expires is invalid");
            f += "; Expires=" + c.expires.toUTCString()
        }
        if (c.httpOnly && (f += "; HttpOnly"),
        c.secure && (f += "; Secure"),
        c.sameSite) {
            var m = typeof c.sameSite == "string" ? c.sameSite.toLowerCase() : c.sameSite;
            switch (m) {
            case !0:
                f += "; SameSite=Strict";
                break;
            case "lax":
                f += "; SameSite=Lax";
                break;
            case "strict":
                f += "; SameSite=Strict";
                break;
            case "none":
                f += "; SameSite=None";
                break;
            default:
                throw new TypeError("option sameSite is invalid")
            }
        }
        return f
    }
    function o(i, a) {
        try {
            return a(i)
        } catch {
            return i
        }
    }
    return sp
}
var N7;
function cZ() {
    return N7 || (N7 = 1,
    function(e) {
        var t = tl && tl.__assign || function() {
            return t = Object.assign || function(_) {
                for (var y, b = 1, S = arguments.length; b < S; b++) {
                    y = arguments[b];
                    for (var C in y)
                        Object.prototype.hasOwnProperty.call(y, C) && (_[C] = y[C])
                }
                return _
            }
            ,
            t.apply(this, arguments)
        }
          , n = tl && tl.__rest || function(_, y) {
            var b = {};
            for (var S in _)
                Object.prototype.hasOwnProperty.call(_, S) && y.indexOf(S) < 0 && (b[S] = _[S]);
            if (_ != null && typeof Object.getOwnPropertySymbols == "function")
                for (var C = 0, S = Object.getOwnPropertySymbols(_); C < S.length; C++)
                    y.indexOf(S[C]) < 0 && Object.prototype.propertyIsEnumerable.call(_, S[C]) && (b[S[C]] = _[S[C]]);
            return b
        }
        ;
        Object.defineProperty(e, "__esModule", {
            value: !0
        }),
        e.checkCookies = e.hasCookie = e.removeCookies = e.deleteCookie = e.setCookies = e.setCookie = e.getCookie = e.getCookies = void 0;
        var r = lZ()
          , s = function() {
            return typeof window < "u"
        }
          , o = function(_) {
            if (_ === "true")
                return !0;
            if (_ === "false")
                return !1;
            if (_ !== "undefined")
                return _ === "null" ? null : _
        }
          , i = function(_) {
            _ === void 0 && (_ = "");
            try {
                var y = JSON.stringify(_);
                return /^[\{\[]/.test(y) ? y : _
            } catch {
                return _
            }
        }
          , a = function(_) {
            return _ && _.replace(/(%[0-9A-Z]{2})+/g, decodeURIComponent)
        }
          , l = function(_) {
            var y;
            if (_ && (y = _.req),
            !s())
                return y && y.cookies ? y.cookies : y && y.headers && y.headers.cookie ? (0,
                r.parse)(y.headers.cookie) : {};
            for (var b = {}, S = document.cookie ? document.cookie.split("; ") : [], C = 0, w = S.length; C < w; C++) {
                var x = S[C].split("=")
                  , E = x.slice(1).join("=")
                  , T = x[0];
                b[T] = E
            }
            return b
        };
        e.getCookies = l;
        var c = function(_, y) {
            var b = (0,
            e.getCookies)(y)
              , S = b[_];
            if (S !== void 0)
                return o(a(S))
        };
        e.getCookie = c;
        var u = function(_, y, b) {
            var S, C, w;
            if (b) {
                var x = b.req
                  , E = b.res
                  , T = n(b, ["req", "res"]);
                C = x,
                w = E,
                S = T
            }
            var k = (0,
            r.serialize)(_, i(y), t({
                path: "/"
            }, S));
            if (s())
                document.cookie = k;
            else if (w && C) {
                var A = w.getHeader("Set-Cookie");
                if (Array.isArray(A) || (A = A ? [String(A)] : []),
                w.setHeader("Set-Cookie", A.concat(k)),
                C && C.cookies) {
                    var O = C.cookies;
                    y === "" ? delete O[_] : O[_] = i(y)
                }
                if (C && C.headers && C.headers.cookie) {
                    var O = (0,
                    r.parse)(C.headers.cookie);
                    y === "" ? delete O[_] : O[_] = i(y),
                    C.headers.cookie = Object.entries(O).reduce(function(I, R) {
                        return I.concat("".concat(R[0], "=").concat(R[1], ";"))
                    }, "")
                }
            }
        };
        e.setCookie = u;
        var d = function(_, y, b) {
            return console.warn("[WARN]: setCookies was deprecated. It will be deleted in the new version. Use setCookie instead."),
            (0,
            e.setCookie)(_, y, b)
        };
        e.setCookies = d;
        var f = function(_, y) {
            return (0,
            e.setCookie)(_, "", t(t({}, y), {
                maxAge: -1
            }))
        };
        e.deleteCookie = f;
        var p = function(_, y) {
            return console.warn("[WARN]: removeCookies was deprecated. It will be deleted in the new version. Use deleteCookie instead."),
            (0,
            e.deleteCookie)(_, y)
        };
        e.removeCookies = p;
        var m = function(_, y) {
            if (!_)
                return !1;
            var b = (0,
            e.getCookies)(y);
            return b.hasOwnProperty(_)
        };
        e.hasCookie = m;
        var v = function(_, y) {
            return console.warn("[WARN]: checkCookies was deprecated. It will be deleted in the new version. Use hasCookie instead."),
            (0,
            e.hasCookie)(_, y)
        };
        e.checkCookies = v
    }(tl)),
    tl
}
var op = cZ()
  , Be = (e => (e.AgeVerification = "oai-av-seen",
e.AllowNonessential = "oai-allow-ne",
e.CookieBannerShownPath = "oai-cbs",
e.CookieBannerIgnored = "oai-cbi",
e.LastVoiceInteraction = "oai-lvi",
e.DeviceId = "oai-did",
e.WaId = "oai-wid",
e.IpOverride = "oai-ip-country",
e.GeohashOverride = "oai-geohash-override",
e.IpCityOverride = "oai-ip-city",
e.ShowPaymentModal = "ui-show-payment-modal",
e.TempEnableUnauthedCompliance = "temp-oai-compliance",
e.Workspace = "_account",
e.WorkspaceResidencyRegion = "_account_residency_region",
e.LastLocation = "oai-ll",
e.HideLoggedOutBanner = "hide-logged-out-banner",
e.HasLoggedInBefore = "oai-hlib",
e.PunchOutInfoToken = "oai-poit",
e.PunchOutRequireLoginInfo = "oai-porli",
e.SharedConversationId = "oai-sh-c-i",
e.AuthSessionLoggingId = "oai-asli",
e.PunchOutRequireAnonToAuthedToken = "oai-po-ra2a",
e.PunchOutAnonToAuthedEnabled = "oai-po-a2a",
e.DowngradeAccountEnabled = "oai-downgrade-account-enabled",
e.DogfoodingAccountType = "oai-dogfooding-account-type",
e.SegmentUserId = "ajs_user_id",
e.SegmentUserTraits = "ajs_user_traits",
e.HasClickedOnTryItFirstLink = "oai-tif-20240402",
e.IntercomDeviceIdProd = "intercom-device-id-dgkjq2bp",
e.IntercomDeviceIdDev = "intercom-device-id-izw1u7l7",
e.DomainMigrationSourceCompleted = "oai-dm-src-c-240329",
e.DomainMigrationTargetCompleted = "oai-dm-tgt-c-240329",
e.SignupRedirectUrl = "signup_redirect_url",
e.DesktopResultsTab = "sonic_desktop_results_tab",
e.NavigationState = "oai-nav-state",
e.PreferredLocale = "oai-locale",
e.ThreadSidebarState = "oai-thread-sidebar",
e.InternalSearchSettings = "oai-internal-search-settings",
e.LastUsedModel = "oai-last-model",
e.LastUsedEffortMode = "oai-last-effort-mode",
e.IsSpecificModel = "oai-is-specific-model",
e.ModelStickyForNewChats = "oai-model-sticky-for-new-chats",
e.GreetingName = "oai-gn",
e.headlineMessage = "oai-hm",
e.ConsentAnalytics = "oai_consent_analytics",
e.ConsentMarketing = "oai_consent_marketing",
e.Gclid = "gclid",
e.Fbclid = "fbclid",
e.Rdtcid = "rdt_cid",
e.Tiktokclid = "ttclid",
e.Liclid = "li_fat_id",
e.LastSelectedGithubRepo = "oai-last-selected-github-repo",
e.ShowInternalModels = "oai-show-internal-models",
e.SidebarSections = "oai-sidebar-sections",
e))(Be || {});
const uZ = ["gclid", "fbclid", "rdt_cid", "ttclid", "li_fat_id"]
  , dZ = ["ajs_user_id", "ajs_user_traits"]
  , fZ = {
    sameSite: "lax"
}
  , k0 = ".chatgpt.com"
  , BP = window !== window.top
  , hZ = e => e && e.replace(/(%[0-9A-Z]{2})+/g, decodeURIComponent);
class qP {
    allowAnalyticsCookies = !1;
    allowMarketingCookies = !1;
    constructor() {
        BP || (this.synchronizeWithLocalStorage(),
        setInterval( () => this.synchronizeWithLocalStorage(), 6e4))
    }
    setAllowAnalyticsCookies_CLIENT_ONLY(t) {
        this.allowAnalyticsCookies = t,
        t === !1 && this.clearAnalyticsCookies()
    }
    setAllowMarketingCookies_CLIENT_ONLY(t) {
        this.allowMarketingCookies = t,
        t === !1 && this.clearMarketingCookies()
    }
    clearAnalyticsCookies() {
        for (const t of dZ)
            this.deleteCookie(t)
    }
    clearMarketingCookies() {
        for (const t of uZ)
            this.deleteCookie(t)
    }
    synchronizeWithLocalStorage() {
        [Be.Workspace, Be.WorkspaceResidencyRegion, Be.DeviceId].forEach(n => {
            const r = op.getCookie(n);
            r != null ? localStorage.setItem(n, JSON.stringify(r)) : localStorage.removeItem(n)
        }
        )
    }
    _getCookie(t) {
        const n = op.getCookies()[t];
        return n === void 0 ? void 0 : hZ(n)
    }
    getCookie(t) {
        return this._getCookie(t)
    }
    getBooleanCookie(t) {
        const n = this._getCookie(t);
        return n == null ? void 0 : n === "true"
    }
    getAnalyticsCookie(t) {
        if (this.allowAnalyticsCookies)
            return this._getCookie(t);
        this.deleteCookie(t)
    }
    getMarketingCookie(t) {
        if (this.allowMarketingCookies)
            return this._getCookie(t);
        this.deleteCookie(t)
    }
    _setCookie(t, n, r) {
        op.setCookie(t, n, {
            ...fZ,
            ...r
        })
    }
    setCookie(t, n, r) {
        this._setCookie(t, n, r)
    }
    setBooleanCookie(t, n, r) {
        this._setCookie(t, n != null ? n ? "true" : "false" : void 0, r)
    }
    setAnalyticsCookie(t, n, r) {
        this.allowAnalyticsCookies ? this._setCookie(t, n, r) : this.deleteCookie(t)
    }
    setMarketingCookie(t, n, r) {
        this.allowMarketingCookies ? this._setCookie(t, n, r) : this.deleteCookie(t)
    }
    deleteCookie(t) {
        const n = {};
        op.deleteCookie(t, n)
    }
}
class pZ extends qP {
    getCookie(t) {
        const n = localStorage.getItem(t);
        return typeof n == "string" ? JSON.parse(n) : n
    }
    setCookie() {}
    setAnalyticsCookie() {}
    setMarketingCookie() {}
    deleteCookie() {}
    setAllowAnalyticsCookies_CLIENT_ONLY() {}
    setAllowMarketingCookies_CLIENT_ONLY() {}
}
const ze = BP ? new pZ : new qP
  , mZ = 60 * 60 * 24 * 30 * 12
  , gZ = () => Ts()
  , vZ = e => typeof e == "string" && e.length > 0
  , _Z = e => {
    const t = {
        maxAge: mZ
    };
    return e.endsWith("openai.com") ? t.domain = ".openai.com" : e.endsWith("chatgpt.com") && (t.domain = ".chatgpt.com"),
    t
}
;
function yZ() {
    return window.location.hostname ?? void 0
}
function xi(e=yZ()) {
    const t = ze.getCookie(Be.DeviceId);
    if (vZ(t))
        return t;
    const n = gZ()
      , r = _Z(e);
    return ze.setCookie(Be.DeviceId, n, r),
    n
}
function d8e() {
    window.location.href = window.location.origin + "/auth/logout"
}
const bZ = "auth_session_logging_id";
var o6 = (e => (e.OpenAI = "openai",
e.OpenAIDev = "openai-dev",
e.Mocked = "mocked",
e.OpenAISidetron = "openai-sidetron",
e.OpenAISidetronDev = "openai-sidetron-dev",
e))(o6 || {})
  , CZ = (e => (e[e.Auth0 = 1] = "Auth0",
e[e.WorkOS = 2] = "WorkOS",
e))(CZ || {});
const GP = en(e => {
    const t = un(e)
      , n = t.authStatus === "logged_in" ? t.session : null;
    return Ei( () => ({
        session: n
    }))
}
);
function yn(e) {
    return un(e).authStatus === "logged_in"
}
function Jf(e) {
    return GP(e).getState().session
}
function Xf(e) {
    return Jf(e)?.accessToken
}
async function SZ(e) {
    try {
        const t = Date.now()
          , n = new URL("/api/auth/session",location.origin);
        n.searchParams.set("refresh", "true");
        for (const [l,c] of Object.entries(e))
            n.searchParams.set(l, c);
        const r = xi();
        q.addAction(`Refreshing access token due to ${e.reason} error.`, {
            ...e,
            url: location.origin + (e.path ?? ""),
            deviceId: r
        });
        const s = await fetch(n, {
            headers: {
                [Ug]: r,
                [jg]: Hu
            }
        })
          , o = await s.json()
          , a = (Date.now() - t) / 1e3;
        if (s.status !== 200 && q.addAction("fetchSession.statusNon200", {
            status: s.status,
            reqDuration: a
        }),
        Object.keys(o).length)
            return o.accessToken == null && o.error == null && q.addAction("missing_access_token_error", {
                error: `Missing access token for User: ${o.user?.id} (${o.accessToken})`
            }),
            o.error === "RefreshAccessTokenError" && window._oaiHandleSessionExpired?.("page load", o.error),
            o.error && q.addAction("fetchSession.error", {
                error: o.error
            }),
            o
    } catch {}
    return null
}
function Qf() {
    const e = ue();
    return {
        session: Jf(e),
        isLoading: !1
    }
}
function wZ(e) {
    return !e || !e.email ? !1 : e.email.endsWith("@openai.com")
}
var fr = (e => (e.LoggedOut = "logged_out",
e.LoggedIn = "logged_in",
e))(fr || {});
const f8e = "https://api.openai.com/mfa"
  , EZ = en( () => ({
    pending: null
}));
function VP(e, t) {
    const n = GP(e)
      , r = n.getState().session;
    r && n.setState({
        session: {
            ...r,
            accessToken: t
        }
    })
}
function HP(e, t) {
    const n = EZ(e);
    return n.pending || (n.pending = (async () => {
        try {
            const r = await SZ(t);
            r?.accessToken && VP(e, r.accessToken)
        } finally {
            n.pending = null
        }
    }
    )()),
    n.pending
}
class xZ {
    windowStyle$ = Ct(void 0);
    wantsModelSlug$ = Ct(void 0);
    selectedConversationId$ = Ct(void 0);
    wantsNewConversation$ = Ct(!1);
    prepareConversationDetails;
    attachments;
    whisperContent;
    tabContext;
    requestCompletion;
    wantsRequestCompletion$ = Ct(!1);
    populatePrompt;
    wantsPopulatePrompt$ = Ct(!1);
    context$ = Ct(void 0);
    promptOrigin = void 0;
    authSessionContext = void 0;
    wantsAuthSessionContext$ = Ct(!1);
    agentRequest;
    wantsHandleAgentRequest$ = Ct(!1);
    wantsAgentConversationSentMessage$ = Ct(!1);
    agentConversationSentMessage;
    signalAgentConversationSentMessage(t) {
        this.agentConversationSentMessage = {
            clientThreadId: t
        },
        this.wantsAgentConversationSentMessage$.set(!0)
    }
    sidebarUrlTrayOpen$ = Ct(!0);
    sidebarUrlTrayForcedOpen$ = Ct(!1);
    wantsAttachUserFile$ = Ct(!1);
    attachUserFileRequest
}
const $r = new xZ
  , Im = "new_page_view"
  , Y3 = "sidebar_view"
  , TZ = {
    name: "ref",
    value: "mini"
}
  , kZ = {
    name: "ref",
    value: "mini-sidebar"
};
let mf;
function zP(e) {
    mf = e
}
function h8e() {
    zP(Y3)
}
function p8e() {
    zP(Im)
}
function Bg(e) {
    return i6(e) || $P(e)
}
function i6(e) {
    return mf ? mf === Im : un(e).windowStyle === Im
}
function $P(e) {
    return mf ? mf === Y3 : un(e).windowStyle === Y3
}
function m8e(e) {
    return un(e).windowStyle === Im
}
function OZ(e) {
    return Bg(e) && un(e).isContainerOTR === !0
}
function g8e(e) {
    const t = "gpt-5";
    if (e?.has(t))
        return t;
    const n = "gpt-4o";
    if (e?.has(n))
        return n
}
function v8e(e) {
    return i6(e)
}
function WP(e) {
    is($r.windowStyle$);
    const t = ue();
    return e(t)
}
function _8e() {
    const e = ue();
    return OZ(e) ? !0 : Bg(e) && !yn(e)
}
function y8e(e) {
    return Xe(e, "1224064188")
}
class AZ extends TypeError {
    constructor(t, n) {
        let r;
        const {message: s, explanation: o, ...i} = t
          , {path: a} = t
          , l = a.length === 0 ? s : `At path: ${a.join(".")} -- ${s}`;
        super(o ?? l),
        o != null && (this.cause = l),
        Object.assign(this, i),
        this.name = this.constructor.name,
        this.failures = () => r ?? (r = [t, ...n()])
    }
}
function MZ(e) {
    return qg(e) && typeof e[Symbol.iterator] == "function"
}
function qg(e) {
    return typeof e == "object" && e != null
}
function P7(e) {
    return qg(e) && !Array.isArray(e)
}
function a6(e) {
    return typeof e == "symbol" ? e.toString() : typeof e == "string" ? JSON.stringify(e) : `${e}`
}
function IZ(e) {
    const {done: t, value: n} = e.next();
    return t ? void 0 : n
}
function RZ(e, t, n, r) {
    if (e === !0)
        return;
    e === !1 ? e = {} : typeof e == "string" && (e = {
        message: e
    });
    const {path: s, branch: o} = t
      , {type: i} = n
      , {refinement: a, message: l=`Expected a value of type \`${i}\`${a ? ` with refinement \`${a}\`` : ""}, but received: \`${a6(r)}\``} = e;
    return {
        value: r,
        type: i,
        refinement: a,
        key: s[s.length - 1],
        path: s,
        branch: o,
        ...e,
        message: l
    }
}
function *D7(e, t, n, r) {
    MZ(e) || (e = [e]);
    for (const s of e) {
        const o = RZ(s, t, n, r);
        o && (yield o)
    }
}
function *KP(e, t, n={}) {
    const {path: r=[], branch: s=[e], coerce: o=!1, mask: i=!1} = n
      , a = {
        path: r,
        branch: s,
        mask: i
    };
    o && (e = t.coercer(e, a));
    let l = "valid";
    for (const c of t.validator(e, a))
        c.explanation = n.message,
        l = "not_valid",
        yield[c, void 0];
    for (let[c,u,d] of t.entries(e, a)) {
        const f = KP(u, d, {
            path: c === void 0 ? r : [...r, c],
            branch: c === void 0 ? s : [...s, u],
            coerce: o,
            mask: i,
            message: n.message
        });
        for (const p of f)
            p[0] ? (l = p[0].refinement != null ? "not_refined" : "not_valid",
            yield[p[0], void 0]) : o && (u = p[1],
            c === void 0 ? e = u : e instanceof Map ? e.set(c, u) : e instanceof Set ? e.add(u) : qg(e) && (u !== void 0 || c in e) && (e[c] = u))
    }
    if (l !== "not_valid")
        for (const c of t.refiner(e, a))
            c.explanation = n.message,
            l = "not_refined",
            yield[c, void 0];
    l === "valid" && (yield[void 0, e])
}
class YP {
    constructor(t) {
        const {type: n, schema: r, validator: s, refiner: o, coercer: i=l => l, entries: a=function*() {}
        } = t;
        this.type = n,
        this.schema = r,
        this.entries = a,
        this.coercer = i,
        s ? this.validator = (l, c) => {
            const u = s(l, c);
            return D7(u, c, this, l)
        }
        : this.validator = () => [],
        o ? this.refiner = (l, c) => {
            const u = o(l, c);
            return D7(u, c, this, l)
        }
        : this.refiner = () => []
    }
    assert(t, n) {
        return NZ(t, this, n)
    }
    create(t, n) {
        return PZ(t, this, n)
    }
    is(t) {
        return LZ(t, this)
    }
    mask(t, n) {
        return DZ(t, this, n)
    }
    validate(t, n={}) {
        return eh(t, this, n)
    }
}
function NZ(e, t, n) {
    const r = eh(e, t, {
        message: n
    });
    if (r[0])
        throw r[0]
}
function PZ(e, t, n) {
    const r = eh(e, t, {
        coerce: !0,
        message: n
    });
    if (r[0])
        throw r[0];
    return r[1]
}
function DZ(e, t, n) {
    const r = eh(e, t, {
        coerce: !0,
        mask: !0,
        message: n
    });
    if (r[0])
        throw r[0];
    return r[1]
}
function LZ(e, t) {
    return !eh(e, t)[0]
}
function eh(e, t, n={}) {
    const r = KP(e, t, n)
      , s = IZ(r);
    return s[0] ? [new AZ(s[0],function*() {
        for (const i of r)
            i[0] && (yield i[0])
    }
    ), void 0] : [void 0, s[1]]
}
function ZP(e, t) {
    return new YP({
        type: e,
        schema: null,
        validator: t
    })
}
function FZ() {
    return ZP("never", () => !1)
}
function jZ(e) {
    const t = e ? Object.keys(e) : []
      , n = FZ();
    return new YP({
        type: "object",
        schema: e || null,
        *entries(r) {
            if (e && qg(r)) {
                const s = new Set(Object.keys(r));
                for (const o of t)
                    s.delete(o),
                    yield[o, r[o], e[o]];
                for (const o of s)
                    yield[o, r[o], n]
            }
        },
        validator(r) {
            return P7(r) || `Expected an object, but received: ${a6(r)}`
        },
        coercer(r, s) {
            if (!P7(r))
                return r;
            const o = {
                ...r
            };
            if (s.mask && e)
                for (const i in o)
                    e[i] === void 0 && delete o[i];
            return o
        }
    })
}
function L7() {
    return ZP("string", e => typeof e == "string" || `Expected a string, but received: ${a6(e)}`)
}
var zu = (e => (e.Sunshine = "sunshine",
e.TrainingAllowed = "training_allowed",
e.ShowExpandedCodeView = "show_expanded_code_view",
e.VoiceName = "voice_name",
e.VoiceMainLanguage = "voice_main_language",
e.MemoryInSearch = "memory_in_search",
e.VoiceTrainingAllowed = "voice_training_allowed",
e.VideoTrainingAllowed = "video_training_allowed",
e.Moonshine = "moonshine",
e.CodexTrainingAllowed = "codex_training_allowed_v2",
e.ModelStickyForNewChats = "model_sticky_for_new_chats",
e.ShowLegacyModels = "show_legacy_models",
e.HiveReferencedInInternalKnowledge = "hive_referenced_in_internal_knowledge",
e.DeveloperMode = "developer_mode",
e.Gift = "gift",
e.ChatTheme = "chat_theme",
e.LastUsedModelConfig = "last_used_model_config",
e.VoiceSpeed = "voice_speed",
e.EnableRemoteBrowserData = "enable_remote_browser_data",
e.H17180rGmail = "h17180r_gmail",
e.H17180rGoogleCalendar = "h17180r_google_calendar",
e.H17180rGoogleContacts = "h17180r_google_contacts",
e.EditInCanvas = "edit_in_canvas",
e))(zu || {})
  , Wi = (e => (e.DEEP_RESEARCH = "deep_research",
e.WORKSPACE_GPT_CUSTOM_ACTIONS = "workspace_gpt_custom_actions",
e.APP_PAIRING = "app_pairing",
e.BROWSING = "browsing",
e.CANVAS = "canvas",
e.CANVAS_CODE_EXECUTION = "canvas_code_execution",
e.CANVAS_CODE_NETWORK_ACCESS = "canvas_code_network_access",
e.DALLE = "dalle",
e.MEMORY = "sunshine",
e.LEGACY_MODELS = "legacy_models",
e.CONTEXT_CONNECTOR_CONFLUENCE = "context_connector_confluence",
e.CONTEXT_CONNECTOR_GDRIVE = "context_connector_gdrive",
e.CONTEXT_CONNECTOR_JIRA = "context_connector_java",
e.CONTEXT_CONNECTOR_NOTION = "context_connector_notion",
e.CONTEXT_CONNECTOR_O365_PERSONAL = "context_connector_o365_personal",
e.CONTEXT_CONNECTOR_O365_BUSINESS = "context_connector_o365_business",
e.CONTEXT_CONNECTOR_SLACK = "context_connector_slack",
e.CONTEXT_CONNECTOR_GITHUB = "context_connector_github",
e.CLIENT_APPLICATION_APPLE = "client_application_apple",
e.CLIENT_APPLICATION_APPLE_MDM_REQUIRED = "client_application_apple_mdm_required",
e.MEMORY_IN_SEARCH = "memory_in_search_2",
e.VIDEO_SCREEN_SHARING = "video_screen_sharing",
e.HIVE = "hive",
e.HIVE_KNOWLEDGE_RETRIEVAL = "hive_knowledge_retrieval",
e.ALLOW_CODEX_ACCESS = "wham_access",
e.ALLOW_CODEX_LOCAL_ACCESS = "wham_local_access",
e.CODEX_AGENT_NETWORK_ACCESS = "codex_agent_network_access",
e))(Wi || {})
  , UZ = (e => (e.FREE = "chatgptfreeplan",
e.GO = "chatgptgoplan",
e.PLUS = "chatgptplusplan",
e.PRO = "chatgptpro",
e.PRO_FREE = "chatgptprofreeplan",
e.PLUS_FREE = "chatgptplusfreeplan",
e.SELF_SERVE_BUSINESS = "chatgptteamplan",
e.ENTERPRISE_CBP_SEAT_USAGE = "chatgptbusiness_seat_usage",
e.ENTERPRISE_CBP_FLAT = "chatgptbusiness_flat",
e.EDUCATION_CBP_FLAT = "chatgpteducation_flat",
e.QUORUM = "chatgptquorumplan",
e.DEPRECATED_ENTERPRISE = "chatgptenterpriseplan",
e.DEPRECATED_EDU = "chatgpteduplan",
e))(UZ || {})
  , We = (e => (e.FREE = "free",
e.GO = "go",
e.PLUS = "plus",
e.PRO = "pro",
e.SELF_SERVE_BUSINESS = "team",
e.ENTERPRISE_CBP = "business",
e.EDUCATION_CBP = "education",
e.QUORUM = "quorum",
e.DEPRECATED_ENTERPRISE = "enterprise",
e.DEPRECATED_EDU = "edu",
e))(We || {})
  , BZ = (e => (e.ANYONE = "anyone",
e.NO_ONE = "no_one",
e.WORKSPACE_ONLY = "workspace_only",
e))(BZ || {});
const b8e = {
    ALLOW_ALL: "allow_all",
    ALLOW_SPECIFIC: "allow_specific",
    ALLOW_NONE: "allow_none"
};
var qZ = (e => (e.GPT_SHARE_SETTINGS = "gpt_share_setting",
e.CHAT_SHARE_SETTINGS = "chat_share_setting",
e))(qZ || {})
  , GZ = (e => (e.WORKSPACE = "workspace",
e.THIRD_PARTY = "third_party",
e.UNASSIGNED = "unassigned",
e))(GZ || {})
  , Z3 = (e => (e.WEB = "web",
e.IOS_APP = "ios_app",
e.ANDROID_APP = "android_app",
e.WINDOWS_APP = "windows_app",
e.MAC_APP = "mac_os_app",
e.DEFAULT = "default",
e))(Z3 || {})
  , hl = (e => (e.CodeInterpreter = "code_interpreter",
e.Multimodal = "multimodal",
e.Retrieval = "retrieval",
e.ContextConnector = "context_connector",
e))(hl || {})
  , VZ = (e => (e.FREE = "free",
e.PLUS = "plus",
e))(VZ || {})
  , bo = (e => (e.TOOL_USE = "tool_use",
e.IMAGE = "image",
e.ATTACHMENT = "attachment",
e.AUDIO = "audio",
e.TARGETED_REPLY = "targeted_reply",
e.CANVAS_SUPPORTED = "canvas_supported",
e.TOOL_SEARCH = "tool_search",
e.CUSTOM_INSTRUCTIONS = "custom_instructions",
e.GIZMO_PROJECT = "gizmo_project",
e))(bo || {})
  , HZ = (e => (e.SHORT_LABEL = "short_label",
e.TITLE = "title",
e))(HZ || {})
  , Ar = (e => (e[e.DEPRECATED_PENDING = 1] = "DEPRECATED_PENDING",
e[e.DEPRECATED_FINISHED = 2] = "DEPRECATED_FINISHED",
e[e.STREAMING = 3] = "STREAMING",
e[e.UNREAD = 4] = "UNREAD",
e[e.REALTIME = 5] = "REALTIME",
e))(Ar || {})
  , wo = (e => (e[e.CLIENT = 1] = "CLIENT",
e[e.SERVER = 2] = "SERVER",
e))(wo || {})
  , Dr = (e => (e.PERSONAL = "personal",
e.WORKSPACE = "workspace",
e))(Dr || {})
  , Jd = (e => (e.OWNER = "account-owner",
e.ADMIN = "account-admin",
e.STANDARD = "standard-user",
e))(Jd || {})
  , zZ = (e => (e.VERIFIED = "verified",
e.PENDING = "pending",
e.EXPIRED = "expired",
e))(zZ || {})
  , $Z = (e => (e.PERCENTAGE = "percentage",
e.FIXED = "fixed",
e))($Z || {})
  , Nn = (e => (e.AceUpload = "ace_upload",
e.MyFiles = "my_files",
e.LibraryFiles = "library_files",
e.Multimodal = "multimodal",
e.ProfilePicture = "profile_picture",
e.Gizmo = "agent",
e.DalleAgent = "dalle_agent",
e.Codex = "codex",
e))(Nn || {})
  , Jr = (e => (e.Initial = "initial",
e.FileCreated = "file_created",
e.FileUploaded = "file_uploaded",
e.FileProcessed = "file_processed",
e.RetrievalIndexCreated = "retrieval_index_created",
e))(Jr || {})
  , gf = (e => (e.Success = "success",
e.Retry = "retry",
e.Error = "error",
e))(gf || {})
  , au = (e => (e.Success = "success",
e.Failed = "failed",
e.Processing = "processing",
e.Skipped = "skipped",
e))(au || {})
  , Ae = (e => (e.GDRIVE = "gdrive",
e.O365 = "o365",
e.O365_PERSONAL = "o365_personal",
e.O365_BUSINESS = "o365_business",
e.CONFLUENCE = "confluence",
e.JIRA = "java",
e.NOTION_OPEN_CONNECTOR = "notion_open_connector",
e.SLACK_OPEN_CONNECTOR = "slack_open_connector",
e))(Ae || {});
const U = {
    GDRIVE_ACTION_CONNECTOR: "gdrive_action_connector",
    GITHUB_CONNECTOR: "github_connector",
    LINEAR_CONNECTOR: "linear_connector",
    DROPBOX_CONNECTOR: "dropbox_connector",
    SHAREPOINT_CONNECTOR: "sharepoint_connector",
    GCAL_CONNECTOR: "google_calendar_connector",
    GMAIL_CONNECTOR: "gmail_connector",
    GOOGLE_CONTACTS_CONNECTOR: "google_contacts_connector",
    TEAMS_CONNECTOR: "teams_connector",
    OUTLOOK_CALENDAR_CONNECTOR: "outlook_calendar_connector",
    OUTLOOK_EMAIL_CONNECTOR: "outlook_email_connector",
    BOX_CONNECTOR: "box_connector",
    INTERCOM_CONNECTOR: "intercom_connector",
    NOTION_CONNECTOR: "notion_connector",
    HUBSPOT_CONNECTOR: "hubspot_connector",
    CANVA_CONNECTOR: "canva_connector",
    SLACK_CONNECTOR: "slack_connector",
    UAE_PASS_CONNECTOR: "uae_pass_connector"
};
var th = (e => (e.MCP_CONNECTOR = "mcp_connector",
e))(th || {})
  , JP = (e => (e.GDRIVE_SYNC_CONNECTOR = "gdrive_sync_connector",
e.SLACK_SYNC_CONNECTOR = "slack_sync_connector",
e))(JP || {})
  , WZ = (e => (e.GCAL_CONNECTOR = "gcal_action_connector",
e.GMAIL_CONNECTOR = "gmail_action_connector",
e.GOOGLE_CONTACTS_CONNECTOR = "google_contacts_action_connector",
e))(WZ || {})
  , KZ = (e => (e.PAGE = "page",
e))(KZ || {})
  , YZ = (e => (e.PAGE = "page",
e.DATABASE = "database",
e))(YZ || {})
  , ZZ = (e => (e.MESSAGE = "message",
e))(ZZ || {})
  , JZ = (e => (e.PYTHON = "python",
e.RETRIEVAL = "retrieval",
e.BROWSER = "browser",
e.CANVAS = "canvas",
e.FUNCTION = "function",
e.DALLE = "dalle",
e.API = "api",
e.PARALLEL_BROWSE = "parallel_browse",
e.MEMORY = "memory",
e.CONTEXT_CONNECTOR = "context_connector",
e.JIT_PLUGIN = "plugins_prototype",
e.IMAGE_GEN = "image_gen",
e))(JZ || {})
  , XZ = (e => (e.Gizmo = "gizmo",
e.ShareableConversation = "share_link",
e.Conversation = "conversation",
e.Post = "post",
e.CommerceProduct = "commerce_product",
e))(XZ || {})
  , QZ = (e => (e.UserName = "user_name",
e.UserEmail = "user_email",
e.EntityName = "entity_name",
e.EntityUrl = "entity_url",
e.SampleLongerInput = "sample_longer_input",
e.SampleUrl = "sample_url_input",
e.SampleIntInput = "sample_int_input",
e))(QZ || {});
const C8e = {
    shouldnt_have_created: Un({
        id: "ImageGenFeedback.ShouldNotHaveCreated",
        defaultMessage: "Shouldn't have created an image"
    }),
    dont_like_style: Un({
        id: "ImageGenFeedback.DontLikeStyle",
        defaultMessage: "Don't like the style"
    }),
    didnt_fully_follow_instructions: Un({
        id: "ImageGenFeedback.DidntFollowInstructions",
        defaultMessage: "Didn't fully follow instructions"
    }),
    low_quality_or_distorted: Un({
        id: "ImageGenFeedback.LowQualityOrDistorted",
        defaultMessage: "Low quality or distorted"
    }),
    odd_cropping: Un({
        id: "ImageGenFeedback.OddCropping",
        defaultMessage: "Odd cropping"
    }),
    inaccurate_editing: Un({
        id: "ImageGenFeedback.InaccurateEditing",
        defaultMessage: "Inaccurate editing"
    }),
    inaccurate_text_rendering: Un({
        id: "ImageGenFeedback.InaccurateTextRendering",
        defaultMessage: "Inaccurate text rendering"
    }),
    unsafe_or_problematic: Un({
        id: "ImageGenFeedback.UnsafeOrProblematic",
        defaultMessage: "Unsafe or problematic"
    }),
    biased: Un({
        id: "ImageGenFeedback.Biased",
        defaultMessage: "Biased"
    }),
    other: Un({
        id: "ImageGenFeedback.Other",
        defaultMessage: "Other"
    })
};
var eJ = (e => (e.AUDIO_ISSUES = "audio_issues",
e.RESPONSE_QUALITY = "response_quality",
e.INTERRUPTIONS = "interruptions",
e.TRANSCRIPTION_ISSUES = "transcription_issues",
e.INAUDIBLE_ISSUES = "inaudible_issues",
e.OTHER = "other",
e))(eJ || {});
const S8e = {
    audio_issues: Un({
        id: "VoiceFeedback.AudioIssues",
        defaultMessage: "Audio issues"
    }),
    response_quality: Un({
        id: "VoiceFeedback.ResponseQuality",
        defaultMessage: "I didn't like the responses"
    }),
    interruptions: Un({
        id: "VoiceFeedback.Interruptions",
        defaultMessage: "It interrupted me"
    }),
    transcription_issues: Un({
        id: "VoiceFeedback.TranscriptionIssues",
        defaultMessage: "It misheard me"
    }),
    inaudible_issues: Un({
        id: "VoiceFeedback.InaudibleIssues",
        defaultMessage: "It couldn't hear me"
    }),
    other: Un({
        id: "VoiceFeedback.Other",
        defaultMessage: "Other"
    })
};
var tJ = (e => (e.THUMBS_UP = "thumbs_up",
e.THUMBS_DOWN = "thumbs_down",
e))(tJ || {})
  , nJ = (e => (e.Auto = "auto",
e.Arabic = "ar",
e.Bosnian = "bs",
e.Bulgarian = "bg",
e.Catalan = "ca",
e.Chinese = "zh",
e.Croatian = "hr",
e.Czech = "cs",
e.Danish = "da",
e.Dutch = "nl",
e.English = "en",
e.Finnish = "fi",
e.French = "fr",
e.Galician = "gl",
e.German = "de",
e.Greek = "el",
e.Hindi = "hi",
e.Hungarian = "hu",
e.Indonesian = "id",
e.Italian = "it",
e.Japanese = "ja",
e.Korean = "ko",
e.Macedonian = "mk",
e.Malay = "ms",
e.Norwegian = "no",
e.Polish = "pl",
e.Portuguese = "pt",
e.Romanian = "ro",
e.Russian = "ru",
e.Slovak = "sk",
e.Spanish = "es",
e.Tagalog = "tl",
e.Tamil = "ta",
e.Thai = "th",
e.Turkish = "tr",
e.Swedish = "sv",
e.Ukrainian = "uk",
e.Vietnamese = "vi",
e))(nJ || {});
const w8e = ["new_chat", "switch_to_standard", "ok", "upgrade_to_plus", "upgrade_to_pro"]
  , O0 = "account_switch"
  , A0 = "error"
  , E8e = jZ({
    email: L7(),
    token: L7()
});
var rJ = (e => (e.InvalidProof = "invalid_proof",
e.ExternalAccountAlreadyLinked = "external_account_already_linked",
e.InternalAccountAlreadyLinked = "account_already_linked",
e.UnsupportedPlatform = "unsupported_platform",
e.UnsupportedPlanType = "unsupported_plan_type",
e.SessionExpired = "user_session_expired",
e))(rJ || {});
function x8e(e) {
    if (typeof e != "object" || e == null)
        return !1;
    const t = Object.getPrototypeOf(e);
    return t == null || t === Object.prototype
}
function T8e(e) {
    return e != null
}
const sJ = (e, t) => e.includes(t)
  , oJ = (e, t, n=[]) => {
    if (e == null)
        return n;
    const r = Array.isArray(e) ? e : [e];
    return t ? r.map(t) : r
}
  , k8e = (e, t=[]) => n => oJ(n, e, t)
  , iJ = (e, t=void 0) => typeof e != "object" || e == null || Array.isArray(e) ? t : e
  , aJ = (e, t) => {
    const n = iJ(e)
      , r = {};
    for (const s in t)
        r[s] = t[s](n?.[s]);
    return r
}
  , O8e = e => t => aJ(t, e)
  , A8e = (e, t="") => typeof e == "object" || e == null ? t : String(e)
  , M8e = (e, t=0) => {
    if (typeof e == "object" || e == null)
        return t;
    const n = Number(e);
    return isNaN(n) ? t : n
}
  , I8e = (e, t=!1) => {
    if (typeof e == "boolean")
        return e;
    if (typeof e == "number") {
        if (e === 0)
            return !1;
        if (e === 1)
            return !0
    }
    if (typeof e == "string") {
        const n = e.toLowerCase();
        if (n === "false")
            return !1;
        if (n === "true")
            return !0
    }
    return t
}
  , XP = (e, t, n=t[0]) => sJ(t, e) ? e : n
  , R8e = (e, t=e[0]) => n => XP(n, e, t)
  , N8e = e => t => t === void 0 ? void 0 : e(t)
  , lJ = e => h.createElement("svg", {
    width: 20,
    height: 20,
    viewBox: "0 0 20 20",
    fill: "currentColor",
    xmlns: "http://www.w3.org/2000/svg",
    ...e
}, h.createElement("path", {
    d: "M10 10.168C10.8271 10.1681 11.4987 10.8389 11.499 11.666C11.499 12.2542 11.1583 12.7616 10.665 13.0068V14.166C10.665 14.5332 10.3671 14.8309 10 14.8311C9.63288 14.8309 9.33496 14.5332 9.33496 14.166V13.0068C8.84181 12.7616 8.50195 12.2542 8.50195 11.666C8.50231 10.8389 9.17286 10.1681 10 10.168Z"
}), h.createElement("path", {
    fillRule: "evenodd",
    clipRule: "evenodd",
    d: "M10 1.83496C12.6683 1.83514 14.8311 3.99865 14.8311 6.66699V6.93262C15.1047 6.98164 15.3605 7.05589 15.6035 7.17969L15.8213 7.30176C16.3171 7.60583 16.7208 8.04242 16.9863 8.56348L17.0527 8.70605C17.197 9.04236 17.2622 9.40304 17.2949 9.80371C17.3317 10.254 17.3311 10.8109 17.3311 11.5V13.5C17.3311 14.1891 17.3317 14.746 17.2949 15.1963C17.2622 15.597 17.197 15.9576 17.0527 16.2939L16.9863 16.4365C16.7208 16.9576 16.3171 17.3942 15.8213 17.6982L15.6035 17.8203C15.2268 18.0122 14.8202 18.0915 14.3623 18.1289C13.9122 18.1656 13.3548 18.165 12.666 18.165H7.33301C6.64407 18.165 6.08689 18.1657 5.63672 18.1289C5.23621 18.0962 4.87526 18.0309 4.53906 17.8867L4.39649 17.8203C3.87557 17.5548 3.43881 17.1509 3.13477 16.6553L3.0127 16.4365C2.82094 16.0599 2.74151 15.654 2.7041 15.1963C2.66732 14.7461 2.66797 14.1891 2.66797 13.5V11.5C2.66797 10.8109 2.66732 10.2539 2.7041 9.80371C2.74151 9.34597 2.82094 8.94005 3.0127 8.56348L3.13477 8.34473C3.43881 7.8491 3.87557 7.44517 4.39649 7.17969L4.53906 7.11328C4.7388 7.02761 4.94775 6.97131 5.16797 6.93164V6.66699C5.16797 3.99865 7.3317 1.83514 10 1.83496ZM7.33301 8.16504C6.62215 8.16504 6.12858 8.16594 5.74512 8.19727C5.46345 8.2203 5.27358 8.25718 5.12988 8.30859L5 8.36523C4.69786 8.51925 4.44482 8.75346 4.26856 9.04102L4.19824 9.16699C4.11777 9.32498 4.06097 9.53651 4.03027 9.91211C3.99894 10.2956 3.99805 10.789 3.99805 11.5V13.5C3.99805 14.211 3.99894 14.7044 4.03027 15.0879C4.06097 15.4635 4.11777 15.675 4.19824 15.833L4.26856 15.959C4.44482 16.2465 4.69786 16.4807 5 16.6348L5.12988 16.6914C5.27358 16.7428 5.46345 16.7797 5.74512 16.8027C6.12858 16.8341 6.62215 16.835 7.33301 16.835H12.666C13.3767 16.835 13.8705 16.834 14.2539 16.8027C14.6293 16.7721 14.8411 16.7151 14.999 16.6348L15.126 16.5645C15.4134 16.3882 15.6478 16.1351 15.8018 15.833L15.8574 15.7031C15.9089 15.5594 15.9467 15.3698 15.9697 15.0879C16.0011 14.7044 16.001 14.211 16.001 13.5V11.5C16.001 10.789 16.0011 10.2956 15.9697 9.91211C15.9467 9.63017 15.9089 9.44064 15.8574 9.29688L15.8018 9.16699C15.6478 8.86494 15.4134 8.61183 15.126 8.43555L14.999 8.36523C14.8411 8.28485 14.6293 8.22793 14.2539 8.19727C13.8705 8.16598 13.3767 8.16504 12.666 8.16504H7.33301ZM10 3.16504C8.06624 3.16522 6.49805 4.73319 6.49805 6.66699V6.83789C6.75223 6.8349 7.02983 6.83496 7.33301 6.83496H12.666C12.969 6.83496 13.2469 6.8349 13.501 6.83789V6.66699C13.501 4.73318 11.9338 3.16522 10 3.16504Z"
}))
  , l6 = en( () => Ei( () => ({
    modals: [],
    nextKey: 1
})));
function Gg(e, t, n) {
    l6(e).setState(r => {
        const s = r.modals.find(o => o.ModalComponent === t);
        return s ? {
            modals: [...r.modals.filter(o => o.ModalComponent !== t), {
                key: s.key,
                ModalComponent: t,
                props: n
            }]
        } : {
            modals: [...r.modals, {
                key: r.nextKey,
                ModalComponent: t,
                props: n
            }],
            nextKey: r.nextKey + 1
        }
    }
    )
}
function cJ(e, t) {
    l6(e).setState(n => ({
        modals: n.modals.filter(r => r.ModalComponent !== t)
    }))
}
const uJ = h.memo(function({modal: {ModalComponent: t, props: n}}) {
    const r = ue();
    return g.jsx(t, {
        ...n,
        onClose: () => {
            n?.onClose?.(),
            cJ(r, t)
        }
    })
});
function dJ() {
    const e = ue()
      , t = l6(e)
      , n = Xl(t, r => r.modals);
    return g.jsx(g.Fragment, {
        children: n.map(r => g.jsx(uJ, {
            modal: r
        }, r.key))
    })
}
var M0, F7;
function QP() {
    if (F7)
        return M0;
    F7 = 1;
    function e() {}
    return M0 = e,
    M0
}
var fJ = QP();
const eD = mn(fJ);
function tD(e) {
    var t, n, r = "";
    if (typeof e == "string" || typeof e == "number")
        r += e;
    else if (typeof e == "object")
        if (Array.isArray(e)) {
            var s = e.length;
            for (t = 0; t < s; t++)
                e[t] && (n = tD(e[t])) && (r && (r += " "),
                r += n)
        } else
            for (n in e)
                e[n] && (r && (r += " "),
                r += n);
    return r
}
function we() {
    for (var e, t, n = 0, r = "", s = arguments.length; n < s; n++)
        (e = arguments[n]) && (t = tD(e)) && (r && (r += " "),
        r += t);
    return r
}
const hJ = e => h.createElement("svg", {
    width: 20,
    height: 20,
    viewBox: "0 0 19 19",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ...e
}, h.createElement("path", {
    d: "M9.5 2.9375V5.5625M9.5 13.4375V16.0625M2.9375 9.5H5.5625M13.4375 9.5H16.0625",
    stroke: "currentColor",
    strokeWidth: 1.875,
    strokeLinecap: "round"
}), h.createElement("path", {
    d: "M4.86011 4.85961L6.71627 6.71577M12.2847 12.2842L14.1409 14.1404M4.86011 14.1404L6.71627 12.2842M12.2847 6.71577L14.1409 4.85961",
    stroke: "currentColor",
    strokeWidth: 1.875,
    strokeLinecap: "round"
}));
function vf({className: e}) {
    return g.jsx(hJ, {
        className: we("motion-safe:animate-spin", e)
    })
}
function P8e({className: e}) {
    return g.jsx("div", {
        className: "flex h-full w-full items-center justify-center",
        children: g.jsx(vf, {
            className: e
        })
    })
}
function an({children: e, onClick: t, className: n, contentWrapperClassName: r, color: s="primary", label: o, disabled: i=!1, visuallyDisabled: a=!1, loading: l=!1, size: c="medium", fullWidth: u=!1, contentsFullWidth: d=!1, icon: f, style: p, ...m}) {
    const v = a || i || l
      , _ = l || i
      , y = we(v && "opacity-50", _ && "cursor-not-allowed", "btn relative", s === "primary" && "btn-primary", s === "primary-inverse" && "btn-primary-inverse", s === "green" && "btn-green", s === "purple" && "btn-purple", s === "secondary" && "btn-secondary", s === "secondary-filled" && "btn-secondary-filled", s === "danger" && "btn-danger", s === "danger-outline" && "btn-danger-outline", s === "blue" && "btn-blue", s === "ghost" && "btn-ghost", c === "small" && "btn-small", c === "large" && "btn-large", u && "w-full", n)
      , b = f ? g.jsxs("div", {
        className: we("flex w-full", "items-center justify-center", r, {
            "gap-1.5": c === "medium" || c === "large",
            "gap-1": c === "small"
        }),
        children: [l ? g.jsx(vf, {
            className: we(e ? "-ms-0.5" : "-mx-1", c === "small" && "icon-sm", (c === "medium" || c === "large") && "icon")
        }) : g.jsx(f, {
            "aria-label": "",
            className: we(e ? "-ms-0.5" : "-mx-1", c === "small" && "icon-sm", (c === "medium" || c === "large") && "icon")
        }), e]
    }) : g.jsxs("div", {
        className: we("flex items-center justify-center", r, d && "w-full"),
        children: [e, l && g.jsx(vf, {
            className: we(c === "small" && "icon-sm ms-1", (c === "medium" || c === "large") && "icon ms-1.5")
        })]
    });
    switch (m.as) {
    case "link":
    case "a":
        {
            const {openNewTab: S, ...C} = m;
            return g.jsx(Bf, {
                ...C,
                "aria-label": o,
                to: m.to ?? "/",
                target: S === !0 ? "_blank" : "_self",
                onClick: t,
                className: y,
                style: p,
                children: b
            })
        }
    default:
        return g.jsx("button", {
            className: y,
            ref: m.ref,
            "aria-label": o,
            onClick: t,
            disabled: _,
            ...m,
            style: p,
            children: b
        })
    }
}
an.displayName = "Button";
const nD = () => {}
  , pJ = () => nD;
function J3(e, t=nD) {
    return h.useSyncExternalStore(pJ, e, t)
}
function Vg() {
    return J3( () => !0, () => !1)
}
function rD() {
    return Vg() ? window : null
}
function Qe(e, t, {checkForDefaultPrevented: n=!0}={}) {
    return function(s) {
        if (e?.(s),
        n === !1 || !s.defaultPrevented)
            return t?.(s)
    }
}
function mJ(e, t) {
    typeof e == "function" ? e(t) : e != null && (e.current = t)
}
function Hg(...e) {
    return t => e.forEach(n => mJ(n, t))
}
function xn(...e) {
    return h.useCallback(Hg(...e), e)
}
function gJ(e, t) {
    const n = h.createContext(t)
      , r = o => {
        const {children: i, ...a} = o
          , l = h.useMemo( () => a, Object.values(a));
        return g.jsx(n.Provider, {
            value: l,
            children: i
        })
    }
    ;
    r.displayName = e + "Provider";
    function s(o) {
        const i = h.useContext(n);
        if (i)
            return i;
        if (t !== void 0)
            return t;
        throw new Error(`\`${o}\` must be used within \`${e}\``)
    }
    return [r, s]
}
function $u(e, t=[]) {
    let n = [];
    function r(o, i) {
        const a = h.createContext(i)
          , l = n.length;
        n = [...n, i];
        const c = d => {
            const {scope: f, children: p, ...m} = d
              , v = f?.[e]?.[l] || a
              , _ = h.useMemo( () => m, Object.values(m));
            return g.jsx(v.Provider, {
                value: _,
                children: p
            })
        }
        ;
        c.displayName = o + "Provider";
        function u(d, f) {
            const p = f?.[e]?.[l] || a
              , m = h.useContext(p);
            if (m)
                return m;
            if (i !== void 0)
                return i;
            throw new Error(`\`${d}\` must be used within \`${o}\``)
        }
        return [c, u]
    }
    const s = () => {
        const o = n.map(i => h.createContext(i));
        return function(a) {
            const l = a?.[e] || o;
            return h.useMemo( () => ({
                [`__scope${e}`]: {
                    ...a,
                    [e]: l
                }
            }), [a, l])
        }
    }
    ;
    return s.scopeName = e,
    [r, vJ(s, ...t)]
}
function vJ(...e) {
    const t = e[0];
    if (e.length === 1)
        return t;
    const n = () => {
        const r = e.map(s => ({
            useScope: s(),
            scopeName: s.scopeName
        }));
        return function(o) {
            const i = r.reduce( (a, {useScope: l, scopeName: c}) => {
                const d = l(o)[`__scope${c}`];
                return {
                    ...a,
                    ...d
                }
            }
            , {});
            return h.useMemo( () => ({
                [`__scope${t.scopeName}`]: i
            }), [i])
        }
    }
    ;
    return n.scopeName = t.scopeName,
    n
}
var Dl = globalThis?.document ? h.useLayoutEffect : () => {}
  , _J = a$.useId || ( () => {}
)
  , yJ = 0;
function Ro(e) {
    const [t,n] = h.useState(_J());
    return Dl( () => {
        n(r => r ?? String(yJ++))
    }
    , [e]),
    e || (t ? `radix-${t}` : "")
}
function xs(e) {
    const t = h.useRef(e);
    return h.useEffect( () => {
        t.current = e
    }
    ),
    h.useMemo( () => (...n) => t.current?.(...n), [])
}
function Ql({prop: e, defaultProp: t, onChange: n= () => {}
}) {
    const [r,s] = bJ({
        defaultProp: t,
        onChange: n
    })
      , o = e !== void 0
      , i = o ? e : r
      , a = xs(n)
      , l = h.useCallback(c => {
        if (o) {
            const d = typeof c == "function" ? c(e) : c;
            d !== e && a(d)
        } else
            s(c)
    }
    , [o, e, s, a]);
    return [i, l]
}
function bJ({defaultProp: e, onChange: t}) {
    const n = h.useState(e)
      , [r] = n
      , s = h.useRef(r)
      , o = xs(t);
    return h.useEffect( () => {
        s.current !== r && (o(r),
        s.current = r)
    }
    , [r, s, o]),
    n
}
var xu = h.forwardRef( (e, t) => {
    const {children: n, ...r} = e
      , s = h.Children.toArray(n)
      , o = s.find(CJ);
    if (o) {
        const i = o.props.children
          , a = s.map(l => l === o ? h.Children.count(i) > 1 ? h.Children.only(null) : h.isValidElement(i) ? i.props.children : null : l);
        return g.jsx(X3, {
            ...r,
            ref: t,
            children: h.isValidElement(i) ? h.cloneElement(i, void 0, a) : null
        })
    }
    return g.jsx(X3, {
        ...r,
        ref: t,
        children: n
    })
}
);
xu.displayName = "Slot";
var X3 = h.forwardRef( (e, t) => {
    const {children: n, ...r} = e;
    if (h.isValidElement(n)) {
        const s = wJ(n);
        return h.cloneElement(n, {
            ...SJ(r, n.props),
            ref: t ? Hg(t, s) : s
        })
    }
    return h.Children.count(n) > 1 ? h.Children.only(null) : null
}
);
X3.displayName = "SlotClone";
var sD = ({children: e}) => g.jsx(g.Fragment, {
    children: e
});
function CJ(e) {
    return h.isValidElement(e) && e.type === sD
}
function SJ(e, t) {
    const n = {
        ...t
    };
    for (const r in t) {
        const s = e[r]
          , o = t[r];
        /^on[A-Z]/.test(r) ? s && o ? n[r] = (...a) => {
            o(...a),
            s(...a)
        }
        : s && (n[r] = s) : r === "style" ? n[r] = {
            ...s,
            ...o
        } : r === "className" && (n[r] = [s, o].filter(Boolean).join(" "))
    }
    return {
        ...e,
        ...n
    }
}
function wJ(e) {
    let t = Object.getOwnPropertyDescriptor(e.props, "ref")?.get
      , n = t && "isReactWarning"in t && t.isReactWarning;
    return n ? e.ref : (t = Object.getOwnPropertyDescriptor(e, "ref")?.get,
    n = t && "isReactWarning"in t && t.isReactWarning,
    n ? e.props.ref : e.props.ref || e.ref)
}
var EJ = ["a", "button", "div", "form", "h2", "h3", "img", "input", "label", "li", "nav", "ol", "p", "span", "svg", "ul"]
  , Vt = EJ.reduce( (e, t) => {
    const n = h.forwardRef( (r, s) => {
        const {asChild: o, ...i} = r
          , a = o ? xu : t;
        return typeof window < "u" && (window[Symbol.for("radix-ui")] = !0),
        g.jsx(a, {
            ...i,
            ref: s
        })
    }
    );
    return n.displayName = `Primitive.${t}`,
    {
        ...e,
        [t]: n
    }
}
, {});
function oD(e, t) {
    e && IS.flushSync( () => e.dispatchEvent(t))
}
function xJ(e, t=globalThis?.document) {
    const n = xs(e);
    h.useEffect( () => {
        const r = s => {
            s.key === "Escape" && n(s)
        }
        ;
        return t.addEventListener("keydown", r, {
            capture: !0
        }),
        () => t.removeEventListener("keydown", r, {
            capture: !0
        })
    }
    , [n, t])
}
var TJ = "DismissableLayer", Q3 = "dismissableLayer.update", kJ = "dismissableLayer.pointerDownOutside", OJ = "dismissableLayer.focusOutside", j7, iD = h.createContext({
    layers: new Set,
    layersWithOutsidePointerEventsDisabled: new Set,
    branches: new Set
}), nh = h.forwardRef( (e, t) => {
    const {disableOutsidePointerEvents: n=!1, onEscapeKeyDown: r, onPointerDownOutside: s, onFocusOutside: o, onInteractOutside: i, onDismiss: a, ...l} = e
      , c = h.useContext(iD)
      , [u,d] = h.useState(null)
      , f = u?.ownerDocument ?? globalThis?.document
      , [,p] = h.useState({})
      , m = xn(t, E => d(E))
      , v = Array.from(c.layers)
      , [_] = [...c.layersWithOutsidePointerEventsDisabled].slice(-1)
      , y = v.indexOf(_)
      , b = u ? v.indexOf(u) : -1
      , S = c.layersWithOutsidePointerEventsDisabled.size > 0
      , C = b >= y
      , w = MJ(E => {
        const T = E.target
          , k = [...c.branches].some(A => A.contains(T));
        !C || k || (s?.(E),
        i?.(E),
        E.defaultPrevented || a?.())
    }
    , f)
      , x = IJ(E => {
        const T = E.target;
        [...c.branches].some(A => A.contains(T)) || (o?.(E),
        i?.(E),
        E.defaultPrevented || a?.())
    }
    , f);
    return xJ(E => {
        b === c.layers.size - 1 && (r?.(E),
        !E.defaultPrevented && a && (E.preventDefault(),
        a()))
    }
    , f),
    h.useEffect( () => {
        if (u)
            return n && (c.layersWithOutsidePointerEventsDisabled.size === 0 && (j7 = f.body.style.pointerEvents,
            f.body.style.pointerEvents = "none"),
            c.layersWithOutsidePointerEventsDisabled.add(u)),
            c.layers.add(u),
            U7(),
            () => {
                n && c.layersWithOutsidePointerEventsDisabled.size === 1 && (f.body.style.pointerEvents = j7)
            }
    }
    , [u, f, n, c]),
    h.useEffect( () => () => {
        u && (c.layers.delete(u),
        c.layersWithOutsidePointerEventsDisabled.delete(u),
        U7())
    }
    , [u, c]),
    h.useEffect( () => {
        const E = () => p({});
        return document.addEventListener(Q3, E),
        () => document.removeEventListener(Q3, E)
    }
    , []),
    g.jsx(Vt.div, {
        ...l,
        ref: m,
        style: {
            pointerEvents: S ? C ? "auto" : "none" : void 0,
            ...e.style
        },
        onFocusCapture: Qe(e.onFocusCapture, x.onFocusCapture),
        onBlurCapture: Qe(e.onBlurCapture, x.onBlurCapture),
        onPointerDownCapture: Qe(e.onPointerDownCapture, w.onPointerDownCapture)
    })
}
);
nh.displayName = TJ;
var AJ = "DismissableLayerBranch"
  , aD = h.forwardRef( (e, t) => {
    const n = h.useContext(iD)
      , r = h.useRef(null)
      , s = xn(t, r);
    return h.useEffect( () => {
        const o = r.current;
        if (o)
            return n.branches.add(o),
            () => {
                n.branches.delete(o)
            }
    }
    , [n.branches]),
    g.jsx(Vt.div, {
        ...e,
        ref: s
    })
}
);
aD.displayName = AJ;
function MJ(e, t=globalThis?.document) {
    const n = xs(e)
      , r = h.useRef(!1)
      , s = h.useRef( () => {}
    );
    return h.useEffect( () => {
        const o = a => {
            if (a.target && !r.current) {
                let l = function() {
                    lD(kJ, n, c, {
                        discrete: !0
                    })
                };
                const c = {
                    originalEvent: a
                };
                a.pointerType === "touch" ? (t.removeEventListener("click", s.current),
                s.current = l,
                t.addEventListener("click", s.current, {
                    once: !0
                })) : l()
            } else
                t.removeEventListener("click", s.current);
            r.current = !1
        }
          , i = window.setTimeout( () => {
            t.addEventListener("pointerdown", o)
        }
        , 0);
        return () => {
            window.clearTimeout(i),
            t.removeEventListener("pointerdown", o),
            t.removeEventListener("click", s.current)
        }
    }
    , [t, n]),
    {
        onPointerDownCapture: () => r.current = !0
    }
}
function IJ(e, t=globalThis?.document) {
    const n = xs(e)
      , r = h.useRef(!1);
    return h.useEffect( () => {
        const s = o => {
            o.target && !r.current && lD(OJ, n, {
                originalEvent: o
            }, {
                discrete: !1
            })
        }
        ;
        return t.addEventListener("focusin", s),
        () => t.removeEventListener("focusin", s)
    }
    , [t, n]),
    {
        onFocusCapture: () => r.current = !0,
        onBlurCapture: () => r.current = !1
    }
}
function U7() {
    const e = new CustomEvent(Q3);
    document.dispatchEvent(e)
}
function lD(e, t, n, {discrete: r}) {
    const s = n.originalEvent.target
      , o = new CustomEvent(e,{
        bubbles: !1,
        cancelable: !0,
        detail: n
    });
    t && s.addEventListener(e, t, {
        once: !0
    }),
    r ? oD(s, o) : s.dispatchEvent(o)
}
var D8e = nh
  , L8e = aD
  , I0 = "focusScope.autoFocusOnMount"
  , R0 = "focusScope.autoFocusOnUnmount"
  , B7 = {
    bubbles: !1,
    cancelable: !0
}
  , RJ = "FocusScope"
  , c6 = h.forwardRef( (e, t) => {
    const {loop: n=!1, trapped: r=!1, onMountAutoFocus: s, onUnmountAutoFocus: o, ...i} = e
      , [a,l] = h.useState(null)
      , c = xs(s)
      , u = xs(o)
      , d = h.useRef(null)
      , f = xn(t, v => l(v))
      , p = h.useRef({
        paused: !1,
        pause() {
            this.paused = !0
        },
        resume() {
            this.paused = !1
        }
    }).current;
    h.useEffect( () => {
        if (r) {
            let v = function(S) {
                if (p.paused || !a)
                    return;
                const C = S.target;
                a.contains(C) ? d.current = C : Ki(d.current, {
                    select: !0
                })
            }
              , _ = function(S) {
                if (p.paused || !a)
                    return;
                const C = S.relatedTarget;
                C !== null && (a.contains(C) || Ki(d.current, {
                    select: !0
                }))
            }
              , y = function(S) {
                if (document.activeElement === document.body)
                    for (const w of S)
                        w.removedNodes.length > 0 && Ki(a)
            };
            document.addEventListener("focusin", v),
            document.addEventListener("focusout", _);
            const b = new MutationObserver(y);
            return a && b.observe(a, {
                childList: !0,
                subtree: !0
            }),
            () => {
                document.removeEventListener("focusin", v),
                document.removeEventListener("focusout", _),
                b.disconnect()
            }
        }
    }
    , [r, a, p.paused]),
    h.useEffect( () => {
        if (a) {
            G7.add(p);
            const v = document.activeElement;
            if (!a.contains(v)) {
                const y = new CustomEvent(I0,B7);
                a.addEventListener(I0, c),
                a.dispatchEvent(y),
                y.defaultPrevented || (NJ(jJ(cD(a)), {
                    select: !0
                }),
                document.activeElement === v && Ki(a))
            }
            return () => {
                a.removeEventListener(I0, c),
                setTimeout( () => {
                    const y = new CustomEvent(R0,B7);
                    a.addEventListener(R0, u),
                    a.dispatchEvent(y),
                    y.defaultPrevented || Ki(v ?? document.body, {
                        select: !0
                    }),
                    a.removeEventListener(R0, u),
                    G7.remove(p)
                }
                , 0)
            }
        }
    }
    , [a, c, u, p]);
    const m = h.useCallback(v => {
        if (!n && !r || p.paused)
            return;
        const _ = v.key === "Tab" && !v.altKey && !v.ctrlKey && !v.metaKey
          , y = document.activeElement;
        if (_ && y) {
            const b = v.currentTarget
              , [S,C] = PJ(b);
            S && C ? !v.shiftKey && y === C ? (v.preventDefault(),
            n && Ki(S, {
                select: !0
            })) : v.shiftKey && y === S && (v.preventDefault(),
            n && Ki(C, {
                select: !0
            })) : y === b && v.preventDefault()
        }
    }
    , [n, r, p.paused]);
    return g.jsx(Vt.div, {
        tabIndex: -1,
        ...i,
        ref: f,
        onKeyDown: m
    })
}
);
c6.displayName = RJ;
function NJ(e, {select: t=!1}={}) {
    const n = document.activeElement;
    for (const r of e)
        if (Ki(r, {
            select: t
        }),
        document.activeElement !== n)
            return
}
function PJ(e) {
    const t = cD(e)
      , n = q7(t, e)
      , r = q7(t.reverse(), e);
    return [n, r]
}
function cD(e) {
    const t = []
      , n = document.createTreeWalker(e, NodeFilter.SHOW_ELEMENT, {
        acceptNode: r => {
            const s = r.tagName === "INPUT" && r.type === "hidden";
            return r.disabled || r.hidden || s ? NodeFilter.FILTER_SKIP : r.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP
        }
    });
    for (; n.nextNode(); )
        t.push(n.currentNode);
    return t
}
function q7(e, t) {
    for (const n of e)
        if (!DJ(n, {
            upTo: t
        }))
            return n
}
function DJ(e, {upTo: t}) {
    if (getComputedStyle(e).visibility === "hidden")
        return !0;
    for (; e; ) {
        if (t !== void 0 && e === t)
            return !1;
        if (getComputedStyle(e).display === "none")
            return !0;
        e = e.parentElement
    }
    return !1
}
function LJ(e) {
    return e instanceof HTMLInputElement && "select"in e
}
function Ki(e, {select: t=!1}={}) {
    if (e && e.focus) {
        const n = document.activeElement;
        e.focus({
            preventScroll: !0
        }),
        e !== n && LJ(e) && t && e.select()
    }
}
var G7 = FJ();
function FJ() {
    let e = [];
    return {
        add(t) {
            const n = e[0];
            t !== n && n?.pause(),
            e = V7(e, t),
            e.unshift(t)
        },
        remove(t) {
            e = V7(e, t),
            e[0]?.resume()
        }
    }
}
function V7(e, t) {
    const n = [...e]
      , r = n.indexOf(t);
    return r !== -1 && n.splice(r, 1),
    n
}
function jJ(e) {
    return e.filter(t => t.tagName !== "A")
}
var UJ = "Portal"
  , rh = h.forwardRef( (e, t) => {
    const {container: n, ...r} = e
      , [s,o] = h.useState(!1);
    Dl( () => o(!0), []);
    const i = n || s && globalThis?.document?.body;
    return i ? fl.createPortal(g.jsx(Vt.div, {
        ...r,
        ref: t
    }), i) : null
}
);
rh.displayName = UJ;
var F8e = rh;
function BJ(e, t) {
    return h.useReducer( (n, r) => t[n][r] ?? n, e)
}
var co = e => {
    const {present: t, children: n} = e
      , r = qJ(t)
      , s = typeof n == "function" ? n({
        present: r.isPresent
    }) : h.Children.only(n)
      , o = xn(r.ref, GJ(s));
    return typeof n == "function" || r.isPresent ? h.cloneElement(s, {
        ref: o
    }) : null
}
;
co.displayName = "Presence";
function qJ(e) {
    const [t,n] = h.useState()
      , r = h.useRef({})
      , s = h.useRef(e)
      , o = h.useRef("none")
      , i = e ? "mounted" : "unmounted"
      , [a,l] = BJ(i, {
        mounted: {
            UNMOUNT: "unmounted",
            ANIMATION_OUT: "unmountSuspended"
        },
        unmountSuspended: {
            MOUNT: "mounted",
            ANIMATION_END: "unmounted"
        },
        unmounted: {
            MOUNT: "mounted"
        }
    });
    return h.useEffect( () => {
        const c = ip(r.current);
        o.current = a === "mounted" ? c : "none"
    }
    , [a]),
    Dl( () => {
        const c = r.current
          , u = s.current;
        if (u !== e) {
            const f = o.current
              , p = ip(c);
            e ? l("MOUNT") : p === "none" || c?.display === "none" ? l("UNMOUNT") : l(u && f !== p ? "ANIMATION_OUT" : "UNMOUNT"),
            s.current = e
        }
    }
    , [e, l]),
    Dl( () => {
        if (t) {
            let c;
            const u = t.ownerDocument.defaultView ?? window
              , d = p => {
                const v = ip(r.current).includes(p.animationName);
                if (p.target === t && v && (l("ANIMATION_END"),
                !s.current)) {
                    const _ = t.style.animationFillMode;
                    t.style.animationFillMode = "forwards",
                    c = u.setTimeout( () => {
                        t.style.animationFillMode === "forwards" && (t.style.animationFillMode = _)
                    }
                    )
                }
            }
              , f = p => {
                p.target === t && (o.current = ip(r.current))
            }
            ;
            return t.addEventListener("animationstart", f),
            t.addEventListener("animationcancel", d),
            t.addEventListener("animationend", d),
            () => {
                u.clearTimeout(c),
                t.removeEventListener("animationstart", f),
                t.removeEventListener("animationcancel", d),
                t.removeEventListener("animationend", d)
            }
        } else
            l("ANIMATION_END")
    }
    , [t, l]),
    {
        isPresent: ["mounted", "unmountSuspended"].includes(a),
        ref: h.useCallback(c => {
            c && (r.current = getComputedStyle(c)),
            n(c)
        }
        , [])
    }
}
function ip(e) {
    return e?.animationName || "none"
}
function GJ(e) {
    let t = Object.getOwnPropertyDescriptor(e.props, "ref")?.get
      , n = t && "isReactWarning"in t && t.isReactWarning;
    return n ? e.ref : (t = Object.getOwnPropertyDescriptor(e, "ref")?.get,
    n = t && "isReactWarning"in t && t.isReactWarning,
    n ? e.props.ref : e.props.ref || e.ref)
}
var N0 = 0;
function uD() {
    h.useEffect( () => {
        const e = document.querySelectorAll("[data-radix-focus-guard]");
        return document.body.insertAdjacentElement("afterbegin", e[0] ?? H7()),
        document.body.insertAdjacentElement("beforeend", e[1] ?? H7()),
        N0++,
        () => {
            N0 === 1 && document.querySelectorAll("[data-radix-focus-guard]").forEach(t => t.remove()),
            N0--
        }
    }
    , [])
}
function H7() {
    const e = document.createElement("span");
    return e.setAttribute("data-radix-focus-guard", ""),
    e.tabIndex = 0,
    e.style.outline = "none",
    e.style.opacity = "0",
    e.style.position = "fixed",
    e.style.pointerEvents = "none",
    e
}
var $p = "right-scroll-bar-position"
  , Wp = "width-before-scroll-bar"
  , VJ = "with-scroll-bars-hidden"
  , HJ = "--removed-body-scroll-bar-size";
function P0(e, t) {
    return typeof e == "function" ? e(t) : e && (e.current = t),
    e
}
function zJ(e, t) {
    var n = h.useState(function() {
        return {
            value: e,
            callback: t,
            facade: {
                get current() {
                    return n.value
                },
                set current(r) {
                    var s = n.value;
                    s !== r && (n.value = r,
                    n.callback(r, s))
                }
            }
        }
    })[0];
    return n.callback = t,
    n.facade
}
var z7 = new WeakMap;
function $J(e, t) {
    var n = zJ(null, function(r) {
        return e.forEach(function(s) {
            return P0(s, r)
        })
    });
    return h.useLayoutEffect(function() {
        var r = z7.get(n);
        if (r) {
            var s = new Set(r)
              , o = new Set(e)
              , i = n.current;
            s.forEach(function(a) {
                o.has(a) || P0(a, null)
            }),
            o.forEach(function(a) {
                s.has(a) || P0(a, i)
            })
        }
        z7.set(n, e)
    }, [e]),
    n
}
function WJ(e) {
    return e
}
function KJ(e, t) {
    t === void 0 && (t = WJ);
    var n = []
      , r = !1
      , s = {
        read: function() {
            if (r)
                throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.");
            return n.length ? n[n.length - 1] : e
        },
        useMedium: function(o) {
            var i = t(o, r);
            return n.push(i),
            function() {
                n = n.filter(function(a) {
                    return a !== i
                })
            }
        },
        assignSyncMedium: function(o) {
            for (r = !0; n.length; ) {
                var i = n;
                n = [],
                i.forEach(o)
            }
            n = {
                push: function(a) {
                    return o(a)
                },
                filter: function() {
                    return n
                }
            }
        },
        assignMedium: function(o) {
            r = !0;
            var i = [];
            if (n.length) {
                var a = n;
                n = [],
                a.forEach(o),
                i = n
            }
            var l = function() {
                var u = i;
                i = [],
                u.forEach(o)
            }
              , c = function() {
                return Promise.resolve().then(l)
            };
            c(),
            n = {
                push: function(u) {
                    i.push(u),
                    c()
                },
                filter: function(u) {
                    return i = i.filter(u),
                    n
                }
            }
        }
    };
    return s
}
function YJ(e) {
    e === void 0 && (e = {});
    var t = KJ(null);
    return t.options = Qi({
        async: !0,
        ssr: !1
    }, e),
    t
}
var dD = function(e) {
    var t = e.sideCar
      , n = uN(e, ["sideCar"]);
    if (!t)
        throw new Error("Sidecar: please provide `sideCar` property to import the right car");
    var r = t.read();
    if (!r)
        throw new Error("Sidecar medium not found");
    return h.createElement(r, Qi({}, n))
};
dD.isSideCarExport = !0;
function ZJ(e, t) {
    return e.useMedium(t),
    dD
}
var fD = YJ()
  , D0 = function() {}
  , zg = h.forwardRef(function(e, t) {
    var n = h.useRef(null)
      , r = h.useState({
        onScrollCapture: D0,
        onWheelCapture: D0,
        onTouchMoveCapture: D0
    })
      , s = r[0]
      , o = r[1]
      , i = e.forwardProps
      , a = e.children
      , l = e.className
      , c = e.removeScrollBar
      , u = e.enabled
      , d = e.shards
      , f = e.sideCar
      , p = e.noIsolation
      , m = e.inert
      , v = e.allowPinchZoom
      , _ = e.as
      , y = _ === void 0 ? "div" : _
      , b = e.gapMode
      , S = uN(e, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noIsolation", "inert", "allowPinchZoom", "as", "gapMode"])
      , C = f
      , w = $J([n, t])
      , x = Qi(Qi({}, S), s);
    return h.createElement(h.Fragment, null, u && h.createElement(C, {
        sideCar: fD,
        removeScrollBar: c,
        shards: d,
        noIsolation: p,
        inert: m,
        setCallbacks: o,
        allowPinchZoom: !!v,
        lockRef: n,
        gapMode: b
    }), i ? h.cloneElement(h.Children.only(a), Qi(Qi({}, x), {
        ref: w
    })) : h.createElement(y, Qi({}, x, {
        className: l,
        ref: w
    }), a))
});
zg.defaultProps = {
    enabled: !0,
    removeScrollBar: !0,
    inert: !1
};
zg.classNames = {
    fullWidth: Wp,
    zeroRight: $p
};
var JJ = function() {
    if (typeof __webpack_nonce__ < "u")
        return __webpack_nonce__
};
function XJ() {
    if (!document)
        return null;
    var e = document.createElement("style");
    e.type = "text/css";
    var t = JJ();
    return t && e.setAttribute("nonce", t),
    e
}
function QJ(e, t) {
    e.styleSheet ? e.styleSheet.cssText = t : e.appendChild(document.createTextNode(t))
}
function eX(e) {
    var t = document.head || document.getElementsByTagName("head")[0];
    t.appendChild(e)
}
var tX = function() {
    var e = 0
      , t = null;
    return {
        add: function(n) {
            e == 0 && (t = XJ()) && (QJ(t, n),
            eX(t)),
            e++
        },
        remove: function() {
            e--,
            !e && t && (t.parentNode && t.parentNode.removeChild(t),
            t = null)
        }
    }
}
  , nX = function() {
    var e = tX();
    return function(t, n) {
        h.useEffect(function() {
            return e.add(t),
            function() {
                e.remove()
            }
        }, [t && n])
    }
}
  , hD = function() {
    var e = nX()
      , t = function(n) {
        var r = n.styles
          , s = n.dynamic;
        return e(r, s),
        null
    };
    return t
}
  , rX = {
    left: 0,
    top: 0,
    right: 0,
    gap: 0
}
  , L0 = function(e) {
    return parseInt(e || "", 10) || 0
}
  , sX = function(e) {
    var t = window.getComputedStyle(document.body)
      , n = t[e === "padding" ? "paddingLeft" : "marginLeft"]
      , r = t[e === "padding" ? "paddingTop" : "marginTop"]
      , s = t[e === "padding" ? "paddingRight" : "marginRight"];
    return [L0(n), L0(r), L0(s)]
}
  , oX = function(e) {
    if (e === void 0 && (e = "margin"),
    typeof window > "u")
        return rX;
    var t = sX(e)
      , n = document.documentElement.clientWidth
      , r = window.innerWidth;
    return {
        left: t[0],
        top: t[1],
        right: t[2],
        gap: Math.max(0, r - n + t[2] - t[0])
    }
}
  , iX = hD()
  , lu = "data-scroll-locked"
  , aX = function(e, t, n, r) {
    var s = e.left
      , o = e.top
      , i = e.right
      , a = e.gap;
    return n === void 0 && (n = "margin"),
    `
  .`.concat(VJ, ` {
   overflow: hidden `).concat(r, `;
   padding-right: `).concat(a, "px ").concat(r, `;
  }
  body[`).concat(lu, `] {
    overflow: hidden `).concat(r, `;
    overscroll-behavior: contain;
    `).concat([t && "position: relative ".concat(r, ";"), n === "margin" && `
    padding-left: `.concat(s, `px;
    padding-top: `).concat(o, `px;
    padding-right: `).concat(i, `px;
    margin-left:0;
    margin-top:0;
    margin-right: `).concat(a, "px ").concat(r, `;
    `), n === "padding" && "padding-right: ".concat(a, "px ").concat(r, ";")].filter(Boolean).join(""), `
  }
  
  .`).concat($p, ` {
    right: `).concat(a, "px ").concat(r, `;
  }
  
  .`).concat(Wp, ` {
    margin-right: `).concat(a, "px ").concat(r, `;
  }
  
  .`).concat($p, " .").concat($p, ` {
    right: 0 `).concat(r, `;
  }
  
  .`).concat(Wp, " .").concat(Wp, ` {
    margin-right: 0 `).concat(r, `;
  }
  
  body[`).concat(lu, `] {
    `).concat(HJ, ": ").concat(a, `px;
  }
`)
}
  , $7 = function() {
    var e = parseInt(document.body.getAttribute(lu) || "0", 10);
    return isFinite(e) ? e : 0
}
  , lX = function() {
    h.useEffect(function() {
        return document.body.setAttribute(lu, ($7() + 1).toString()),
        function() {
            var e = $7() - 1;
            e <= 0 ? document.body.removeAttribute(lu) : document.body.setAttribute(lu, e.toString())
        }
    }, [])
}
  , cX = function(e) {
    var t = e.noRelative
      , n = e.noImportant
      , r = e.gapMode
      , s = r === void 0 ? "margin" : r;
    lX();
    var o = h.useMemo(function() {
        return oX(s)
    }, [s]);
    return h.createElement(iX, {
        styles: aX(o, !t, s, n ? "" : "!important")
    })
}
  , e5 = !1;
if (typeof window < "u")
    try {
        var ap = Object.defineProperty({}, "passive", {
            get: function() {
                return e5 = !0,
                !0
            }
        });
        window.addEventListener("test", ap, ap),
        window.removeEventListener("test", ap, ap)
    } catch {
        e5 = !1
    }
var Ec = e5 ? {
    passive: !1
} : !1
  , uX = function(e) {
    return e.tagName === "TEXTAREA"
}
  , pD = function(e, t) {
    if (!(e instanceof Element))
        return !1;
    var n = window.getComputedStyle(e);
    return n[t] !== "hidden" && !(n.overflowY === n.overflowX && !uX(e) && n[t] === "visible")
}
  , dX = function(e) {
    return pD(e, "overflowY")
}
  , fX = function(e) {
    return pD(e, "overflowX")
}
  , W7 = function(e, t) {
    var n = t.ownerDocument
      , r = t;
    do {
        typeof ShadowRoot < "u" && r instanceof ShadowRoot && (r = r.host);
        var s = mD(e, r);
        if (s) {
            var o = gD(e, r)
              , i = o[1]
              , a = o[2];
            if (i > a)
                return !0
        }
        r = r.parentNode
    } while (r && r !== n.body);
    return !1
}
  , hX = function(e) {
    var t = e.scrollTop
      , n = e.scrollHeight
      , r = e.clientHeight;
    return [t, n, r]
}
  , pX = function(e) {
    var t = e.scrollLeft
      , n = e.scrollWidth
      , r = e.clientWidth;
    return [t, n, r]
}
  , mD = function(e, t) {
    return e === "v" ? dX(t) : fX(t)
}
  , gD = function(e, t) {
    return e === "v" ? hX(t) : pX(t)
}
  , mX = function(e, t) {
    return e === "h" && t === "rtl" ? -1 : 1
}
  , gX = function(e, t, n, r, s) {
    var o = mX(e, window.getComputedStyle(t).direction)
      , i = o * r
      , a = n.target
      , l = t.contains(a)
      , c = !1
      , u = i > 0
      , d = 0
      , f = 0;
    do {
        var p = gD(e, a)
          , m = p[0]
          , v = p[1]
          , _ = p[2]
          , y = v - _ - o * m;
        (m || y) && mD(e, a) && (d += y,
        f += m),
        a instanceof ShadowRoot ? a = a.host : a = a.parentNode
    } while (!l && a !== document.body || l && (t.contains(a) || t === a));
    return (u && Math.abs(d) < 1 || !u && Math.abs(f) < 1) && (c = !0),
    c
}
  , lp = function(e) {
    return "changedTouches"in e ? [e.changedTouches[0].clientX, e.changedTouches[0].clientY] : [0, 0]
}
  , K7 = function(e) {
    return [e.deltaX, e.deltaY]
}
  , Y7 = function(e) {
    return e && "current"in e ? e.current : e
}
  , vX = function(e, t) {
    return e[0] === t[0] && e[1] === t[1]
}
  , _X = function(e) {
    return `
  .block-interactivity-`.concat(e, ` {pointer-events: none;}
  .allow-interactivity-`).concat(e, ` {pointer-events: all;}
`)
}
  , yX = 0
  , xc = [];
function bX(e) {
    var t = h.useRef([])
      , n = h.useRef([0, 0])
      , r = h.useRef()
      , s = h.useState(yX++)[0]
      , o = h.useState(hD)[0]
      , i = h.useRef(e);
    h.useEffect(function() {
        i.current = e
    }, [e]),
    h.useEffect(function() {
        if (e.inert) {
            document.body.classList.add("block-interactivity-".concat(s));
            var v = l$([e.lockRef.current], (e.shards || []).map(Y7), !0).filter(Boolean);
            return v.forEach(function(_) {
                return _.classList.add("allow-interactivity-".concat(s))
            }),
            function() {
                document.body.classList.remove("block-interactivity-".concat(s)),
                v.forEach(function(_) {
                    return _.classList.remove("allow-interactivity-".concat(s))
                })
            }
        }
    }, [e.inert, e.lockRef.current, e.shards]);
    var a = h.useCallback(function(v, _) {
        if ("touches"in v && v.touches.length === 2 || v.type === "wheel" && v.ctrlKey)
            return !i.current.allowPinchZoom;
        var y = lp(v), b = n.current, S = "deltaX"in v ? v.deltaX : b[0] - y[0], C = "deltaY"in v ? v.deltaY : b[1] - y[1], w, x = v.target, E = Math.abs(S) > Math.abs(C) ? "h" : "v";
        if ("touches"in v && E === "h" && x.type === "range")
            return !1;
        var T = W7(E, x);
        if (!T)
            return !0;
        if (T ? w = E : (w = E === "v" ? "h" : "v",
        T = W7(E, x)),
        !T)
            return !1;
        if (!r.current && "changedTouches"in v && (S || C) && (r.current = w),
        !w)
            return !0;
        var k = r.current || w;
        return gX(k, _, v, k === "h" ? S : C)
    }, [])
      , l = h.useCallback(function(v) {
        var _ = v;
        if (!(!xc.length || xc[xc.length - 1] !== o)) {
            var y = "deltaY"in _ ? K7(_) : lp(_)
              , b = t.current.filter(function(w) {
                return w.name === _.type && (w.target === _.target || _.target === w.shadowParent) && vX(w.delta, y)
            })[0];
            if (b && b.should) {
                _.cancelable && _.preventDefault();
                return
            }
            if (!b) {
                var S = (i.current.shards || []).map(Y7).filter(Boolean).filter(function(w) {
                    return w.contains(_.target)
                })
                  , C = S.length > 0 ? a(_, S[0]) : !i.current.noIsolation;
                C && _.cancelable && _.preventDefault()
            }
        }
    }, [])
      , c = h.useCallback(function(v, _, y, b) {
        var S = {
            name: v,
            delta: _,
            target: y,
            should: b,
            shadowParent: CX(y)
        };
        t.current.push(S),
        setTimeout(function() {
            t.current = t.current.filter(function(C) {
                return C !== S
            })
        }, 1)
    }, [])
      , u = h.useCallback(function(v) {
        n.current = lp(v),
        r.current = void 0
    }, [])
      , d = h.useCallback(function(v) {
        c(v.type, K7(v), v.target, a(v, e.lockRef.current))
    }, [])
      , f = h.useCallback(function(v) {
        c(v.type, lp(v), v.target, a(v, e.lockRef.current))
    }, []);
    h.useEffect(function() {
        return xc.push(o),
        e.setCallbacks({
            onScrollCapture: d,
            onWheelCapture: d,
            onTouchMoveCapture: f
        }),
        document.addEventListener("wheel", l, Ec),
        document.addEventListener("touchmove", l, Ec),
        document.addEventListener("touchstart", u, Ec),
        function() {
            xc = xc.filter(function(v) {
                return v !== o
            }),
            document.removeEventListener("wheel", l, Ec),
            document.removeEventListener("touchmove", l, Ec),
            document.removeEventListener("touchstart", u, Ec)
        }
    }, []);
    var p = e.removeScrollBar
      , m = e.inert;
    return h.createElement(h.Fragment, null, m ? h.createElement(o, {
        styles: _X(s)
    }) : null, p ? h.createElement(cX, {
        gapMode: e.gapMode
    }) : null)
}
function CX(e) {
    for (var t = null; e !== null; )
        e instanceof ShadowRoot && (t = e.host,
        e = e.host),
        e = e.parentNode;
    return t
}
const SX = ZJ(fD, bX);
var u6 = h.forwardRef(function(e, t) {
    return h.createElement(zg, Qi({}, e, {
        ref: t,
        sideCar: SX
    }))
});
u6.classNames = zg.classNames;
var wX = function(e) {
    if (typeof document > "u")
        return null;
    var t = Array.isArray(e) ? e[0] : e;
    return t.ownerDocument.body
}
  , Tc = new WeakMap
  , cp = new WeakMap
  , up = {}
  , F0 = 0
  , vD = function(e) {
    return e && (e.host || vD(e.parentNode))
}
  , EX = function(e, t) {
    return t.map(function(n) {
        if (e.contains(n))
            return n;
        var r = vD(n);
        return r && e.contains(r) ? r : (console.error("aria-hidden", n, "in not contained inside", e, ". Doing nothing"),
        null)
    }).filter(function(n) {
        return !!n
    })
}
  , xX = function(e, t, n, r) {
    var s = EX(t, Array.isArray(e) ? e : [e]);
    up[n] || (up[n] = new WeakMap);
    var o = up[n]
      , i = []
      , a = new Set
      , l = new Set(s)
      , c = function(d) {
        !d || a.has(d) || (a.add(d),
        c(d.parentNode))
    };
    s.forEach(c);
    var u = function(d) {
        !d || l.has(d) || Array.prototype.forEach.call(d.children, function(f) {
            if (a.has(f))
                u(f);
            else {
                var p = f.getAttribute(r)
                  , m = p !== null && p !== "false"
                  , v = (Tc.get(f) || 0) + 1
                  , _ = (o.get(f) || 0) + 1;
                Tc.set(f, v),
                o.set(f, _),
                i.push(f),
                v === 1 && m && cp.set(f, !0),
                _ === 1 && f.setAttribute(n, "true"),
                m || f.setAttribute(r, "true")
            }
        })
    };
    return u(t),
    a.clear(),
    F0++,
    function() {
        i.forEach(function(d) {
            var f = Tc.get(d) - 1
              , p = o.get(d) - 1;
            Tc.set(d, f),
            o.set(d, p),
            f || (cp.has(d) || d.removeAttribute(r),
            cp.delete(d)),
            p || d.removeAttribute(n)
        }),
        F0--,
        F0 || (Tc = new WeakMap,
        Tc = new WeakMap,
        cp = new WeakMap,
        up = {})
    }
}
  , TX = function(e, t, n) {
    n === void 0 && (n = "data-aria-hidden");
    var r = Array.from(Array.isArray(e) ? e : [e])
      , s = wX(e);
    return s ? (r.push.apply(r, Array.from(s.querySelectorAll("[aria-live]"))),
    xX(r, s, n, "aria-hidden")) : function() {
        return null
    }
}
  , d6 = "Dialog"
  , [_D,kX] = $u(d6)
  , [OX,uo] = _D(d6)
  , f6 = e => {
    const {__scopeDialog: t, children: n, open: r, defaultOpen: s, onOpenChange: o, modal: i=!0} = e
      , a = h.useRef(null)
      , l = h.useRef(null)
      , [c=!1,u] = Ql({
        prop: r,
        defaultProp: s,
        onChange: o
    });
    return g.jsx(OX, {
        scope: t,
        triggerRef: a,
        contentRef: l,
        contentId: Ro(),
        titleId: Ro(),
        descriptionId: Ro(),
        open: c,
        onOpenChange: u,
        onOpenToggle: h.useCallback( () => u(d => !d), [u]),
        modal: i,
        children: n
    })
}
;
f6.displayName = d6;
var yD = "DialogTrigger"
  , h6 = h.forwardRef( (e, t) => {
    const {__scopeDialog: n, ...r} = e
      , s = uo(yD, n)
      , o = xn(t, s.triggerRef);
    return g.jsx(Vt.button, {
        type: "button",
        "aria-haspopup": "dialog",
        "aria-expanded": s.open,
        "aria-controls": s.contentId,
        "data-state": S6(s.open),
        ...r,
        ref: o,
        onClick: Qe(e.onClick, s.onOpenToggle)
    })
}
);
h6.displayName = yD;
var p6 = "DialogPortal"
  , [AX,bD] = _D(p6, {
    forceMount: void 0
})
  , m6 = e => {
    const {__scopeDialog: t, forceMount: n, children: r, container: s} = e
      , o = uo(p6, t);
    return g.jsx(AX, {
        scope: t,
        forceMount: n,
        children: h.Children.map(r, i => g.jsx(co, {
            present: n || o.open,
            children: g.jsx(rh, {
                asChild: !0,
                container: s,
                children: i
            })
        }))
    })
}
;
m6.displayName = p6;
var Rm = "DialogOverlay"
  , g6 = h.forwardRef( (e, t) => {
    const n = bD(Rm, e.__scopeDialog)
      , {forceMount: r=n.forceMount, ...s} = e
      , o = uo(Rm, e.__scopeDialog);
    return o.modal ? g.jsx(co, {
        present: r || o.open,
        children: g.jsx(MX, {
            ...s,
            ref: t
        })
    }) : null
}
);
g6.displayName = Rm;
var MX = h.forwardRef( (e, t) => {
    const {__scopeDialog: n, ...r} = e
      , s = uo(Rm, n);
    return g.jsx(u6, {
        as: xu,
        allowPinchZoom: !0,
        shards: [s.contentRef],
        children: g.jsx(Vt.div, {
            "data-state": S6(s.open),
            ...r,
            ref: t,
            style: {
                pointerEvents: "auto",
                ...r.style
            }
        })
    })
}
)
  , Ll = "DialogContent"
  , v6 = h.forwardRef( (e, t) => {
    const n = bD(Ll, e.__scopeDialog)
      , {forceMount: r=n.forceMount, ...s} = e
      , o = uo(Ll, e.__scopeDialog);
    return g.jsx(co, {
        present: r || o.open,
        children: o.modal ? g.jsx(IX, {
            ...s,
            ref: t
        }) : g.jsx(RX, {
            ...s,
            ref: t
        })
    })
}
);
v6.displayName = Ll;
var IX = h.forwardRef( (e, t) => {
    const n = uo(Ll, e.__scopeDialog)
      , r = h.useRef(null)
      , s = xn(t, n.contentRef, r);
    return h.useEffect( () => {
        const o = r.current;
        if (o)
            return TX(o)
    }
    , []),
    g.jsx(CD, {
        ...e,
        ref: s,
        trapFocus: n.open,
        disableOutsidePointerEvents: !0,
        onCloseAutoFocus: Qe(e.onCloseAutoFocus, o => {
            o.preventDefault(),
            n.triggerRef.current?.focus()
        }
        ),
        onPointerDownOutside: Qe(e.onPointerDownOutside, o => {
            const i = o.detail.originalEvent
              , a = i.button === 0 && i.ctrlKey === !0;
            (i.button === 2 || a) && o.preventDefault()
        }
        ),
        onFocusOutside: Qe(e.onFocusOutside, o => o.preventDefault())
    })
}
)
  , RX = h.forwardRef( (e, t) => {
    const n = uo(Ll, e.__scopeDialog)
      , r = h.useRef(!1)
      , s = h.useRef(!1);
    return g.jsx(CD, {
        ...e,
        ref: t,
        trapFocus: !1,
        disableOutsidePointerEvents: !1,
        onCloseAutoFocus: o => {
            e.onCloseAutoFocus?.(o),
            o.defaultPrevented || (r.current || n.triggerRef.current?.focus(),
            o.preventDefault()),
            r.current = !1,
            s.current = !1
        }
        ,
        onInteractOutside: o => {
            e.onInteractOutside?.(o),
            o.defaultPrevented || (r.current = !0,
            o.detail.originalEvent.type === "pointerdown" && (s.current = !0));
            const i = o.target;
            n.triggerRef.current?.contains(i) && o.preventDefault(),
            o.detail.originalEvent.type === "focusin" && s.current && o.preventDefault()
        }
    })
}
)
  , CD = h.forwardRef( (e, t) => {
    const {__scopeDialog: n, trapFocus: r, onOpenAutoFocus: s, onCloseAutoFocus: o, ...i} = e
      , a = uo(Ll, n)
      , l = h.useRef(null)
      , c = xn(t, l);
    return uD(),
    g.jsxs(g.Fragment, {
        children: [g.jsx(c6, {
            asChild: !0,
            loop: !0,
            trapped: r,
            onMountAutoFocus: s,
            onUnmountAutoFocus: o,
            children: g.jsx(nh, {
                role: "dialog",
                id: a.contentId,
                "aria-describedby": a.descriptionId,
                "aria-labelledby": a.titleId,
                "data-state": S6(a.open),
                ...i,
                ref: c,
                onDismiss: () => a.onOpenChange(!1)
            })
        }), g.jsxs(g.Fragment, {
            children: [g.jsx(PX, {
                titleId: a.titleId
            }), g.jsx(LX, {
                contentRef: l,
                descriptionId: a.descriptionId
            })]
        })]
    })
}
)
  , _6 = "DialogTitle"
  , y6 = h.forwardRef( (e, t) => {
    const {__scopeDialog: n, ...r} = e
      , s = uo(_6, n);
    return g.jsx(Vt.h2, {
        id: s.titleId,
        ...r,
        ref: t
    })
}
);
y6.displayName = _6;
var SD = "DialogDescription"
  , b6 = h.forwardRef( (e, t) => {
    const {__scopeDialog: n, ...r} = e
      , s = uo(SD, n);
    return g.jsx(Vt.p, {
        id: s.descriptionId,
        ...r,
        ref: t
    })
}
);
b6.displayName = SD;
var wD = "DialogClose"
  , C6 = h.forwardRef( (e, t) => {
    const {__scopeDialog: n, ...r} = e
      , s = uo(wD, n);
    return g.jsx(Vt.button, {
        type: "button",
        ...r,
        ref: t,
        onClick: Qe(e.onClick, () => s.onOpenChange(!1))
    })
}
);
C6.displayName = wD;
function S6(e) {
    return e ? "open" : "closed"
}
var ED = "DialogTitleWarning"
  , [NX,xD] = gJ(ED, {
    contentName: Ll,
    titleName: _6,
    docsSlug: "dialog"
})
  , PX = ({titleId: e}) => {
    const t = xD(ED)
      , n = `\`${t.contentName}\` requires a \`${t.titleName}\` for the component to be accessible for screen reader users.

If you want to hide the \`${t.titleName}\`, you can wrap it with our VisuallyHidden component.

For more information, see https://radix-ui.com/primitives/docs/components/${t.docsSlug}`;
    return h.useEffect( () => {
        e && (document.getElementById(e) || console.error(n))
    }
    , [n, e]),
    null
}
  , DX = "DialogDescriptionWarning"
  , LX = ({contentRef: e, descriptionId: t}) => {
    const r = `Warning: Missing \`Description\` or \`aria-describedby={undefined}\` for {${xD(DX).contentName}}.`;
    return h.useEffect( () => {
        const s = e.current?.getAttribute("aria-describedby");
        t && s && (document.getElementById(t) || console.warn(r))
    }
    , [r, e, t]),
    null
}
  , TD = f6
  , FX = h6
  , kD = m6
  , OD = g6
  , AD = v6
  , MD = y6
  , ID = b6
  , RD = C6;
const j8e = Object.freeze(Object.defineProperty({
    __proto__: null,
    Close: RD,
    Content: AD,
    Description: ID,
    Dialog: f6,
    DialogClose: C6,
    DialogContent: v6,
    DialogDescription: b6,
    DialogOverlay: g6,
    DialogPortal: m6,
    DialogTitle: y6,
    DialogTrigger: h6,
    Overlay: OD,
    Portal: kD,
    Root: TD,
    Title: MD,
    Trigger: FX,
    WarningProvider: NX,
    createDialogScope: kX
}, Symbol.toStringTag, {
    value: "Module"
}));
var jX = "VisuallyHidden"
  , w6 = h.forwardRef( (e, t) => g.jsx(Vt.span, {
    ...e,
    ref: t,
    style: {
        position: "absolute",
        border: 0,
        width: 1,
        height: 1,
        padding: 0,
        margin: -1,
        overflow: "hidden",
        clip: "rect(0, 0, 0, 0)",
        whiteSpace: "nowrap",
        wordWrap: "normal",
        ...e.style
    }
}));
w6.displayName = jX;
var UX = w6;
function Xd(e) {
    "use forget";
    const t = De.c(9);
    let n, r, s, o;
    t[0] !== e ? ({color: s, title: o, children: r, ...n} = e,
    t[0] = e,
    t[1] = n,
    t[2] = r,
    t[3] = s,
    t[4] = o) : (n = t[1],
    r = t[2],
    s = t[3],
    o = t[4]);
    const i = s === void 0 ? "secondary" : s
      , a = o ?? r;
    let l;
    return t[5] !== n || t[6] !== i || t[7] !== a ? (l = g.jsx(an, {
        as: "button",
        color: i,
        ...n,
        children: a
    }),
    t[5] = n,
    t[6] = i,
    t[7] = a,
    t[8] = l) : l = t[8],
    l
}
function BX(e) {
    "use forget";
    const t = De.c(16)
      , {isOpen: n, onClose: r, children: s, shouldIgnoreClickOutside: o, className: i, testId: a} = e
      , l = o === void 0 ? !1 : o;
    let c;
    t[0] !== r || t[1] !== l ? (c = v => {
        l || v === !1 && r(!1)
    }
    ,
    t[0] = r,
    t[1] = l,
    t[2] = c) : c = t[2];
    const u = rD()?.document.body;
    let d;
    t[3] !== i ? (d = we("absolute inset-0", i),
    t[3] = i,
    t[4] = d) : d = t[4];
    let f;
    t[5] !== s || t[6] !== d || t[7] !== a ? (f = g.jsx("div", {
        className: d,
        "data-testid": a,
        "data-ignore-for-page-load": !0,
        children: s
    }),
    t[5] = s,
    t[6] = d,
    t[7] = a,
    t[8] = f) : f = t[8];
    let p;
    t[9] !== u || t[10] !== f ? (p = g.jsx(kD, {
        container: u,
        children: f
    }),
    t[9] = u,
    t[10] = f,
    t[11] = p) : p = t[11];
    let m;
    return t[12] !== n || t[13] !== c || t[14] !== p ? (m = g.jsx(TD, {
        open: n,
        onOpenChange: c,
        children: p
    }),
    t[12] = n,
    t[13] = c,
    t[14] = p,
    t[15] = m) : m = t[15],
    m
}
function qX(e) {
    "use forget";
    const t = De.c(6)
      , {className: n, children: r, showBackground: s} = e
      , i = (s === void 0 ? !0 : s) && "before:starting:backdrop-blur-0 before:absolute before:inset-0 before:bg-gray-200/50 before:backdrop-blur-[1px] before:transition before:duration-250 dark:before:bg-black/50 before:starting:opacity-0";
    let a;
    t[0] !== n || t[1] !== i ? (a = we("fixed inset-0 z-50", i, n),
    t[0] = n,
    t[1] = i,
    t[2] = a) : a = t[2];
    let l;
    return t[3] !== r || t[4] !== a ? (l = g.jsx(OD, {
        className: a,
        children: r
    }),
    t[3] = r,
    t[4] = a,
    t[5] = l) : l = t[5],
    l
}
function GX(e) {
    "use forget";
    const t = De.c(18)
      , {className: n, children: r, position: s, size: o, removePopoverStyling: i, shadow: a, onEscapeKeyDown: l, removeBackground: c} = e
      , u = s === void 0 ? "center" : s
      , d = i === void 0 ? !1 : i
      , f = a === void 0 ? "normal" : a
      , p = c === void 0 ? !1 : c
      , m = o !== "fullscreen" && "grid grid-cols-[10px_1fr_10px]"
      , v = o !== "fullscreen" && u === "center" && "grid-rows-[minmax(10px,1fr)_auto_minmax(10px,1fr)] md:grid-rows-[minmax(20px,0.8fr)_auto_minmax(20px,1fr)]"
      , _ = o !== "fullscreen" && u === "bottom" && "grid-rows-[minmax(10px,1fr)_auto_10px] md:grid-rows-[minmax(20px,1fr)_auto_20px]"
      , y = o !== "fullscreen" && u === "top" && "grid-rows-[10px_auto_minmax(10px,1fr)] md:grid-rows-[20px_auto_minmax(20px,1fr)]";
    let b;
    t[0] !== m || t[1] !== v || t[2] !== _ || t[3] !== y ? (b = we("z-50 h-full w-full overflow-y-auto", m, v, _, y),
    t[0] = m,
    t[1] = v,
    t[2] = _,
    t[3] = y,
    t[4] = b) : b = t[4];
    const S = !d && "popover"
      , C = !p && "bg-token-main-surface-primary"
      , w = o !== "fullscreen" && "rounded-2xl"
      , x = f === "normal" && "shadow-long";
    let E;
    t[5] !== n || t[6] !== S || t[7] !== C || t[8] !== w || t[9] !== x ? (E = we(S, C, "relative start-1/2 col-auto col-start-2 row-auto row-start-2 h-full w-full text-start ltr:-translate-x-1/2 rtl:translate-x-1/2", w, x, n),
    t[5] = n,
    t[6] = S,
    t[7] = C,
    t[8] = w,
    t[9] = x,
    t[10] = E) : E = t[10];
    let T;
    t[11] !== r || t[12] !== l || t[13] !== E ? (T = g.jsx(AD, {
        onEscapeKeyDown: l,
        className: E,
        children: r
    }),
    t[11] = r,
    t[12] = l,
    t[13] = E,
    t[14] = T) : T = t[14];
    let k;
    return t[15] !== T || t[16] !== b ? (k = g.jsx("div", {
        className: b,
        children: T
    }),
    t[15] = T,
    t[16] = b,
    t[17] = k) : k = t[17],
    k
}
function VX(e) {
    "use forget";
    const t = De.c(16)
      , {title: n, description: r, icon: s} = e;
    let o;
    t[0] !== n ? (o = n && g.jsx(MD, {
        className: "text-token-text-primary text-lg font-normal",
        children: n
    }),
    t[0] = n,
    t[1] = o) : o = t[1];
    let i;
    t[2] !== r ? (i = r && g.jsx(ID, {
        asChild: !0,
        children: g.jsx("div", {
            className: "text-token-text-tertiary ms-0.5 mt-0.5 text-xs",
            children: r
        })
    }),
    t[2] = r,
    t[3] = i) : i = t[3];
    let a;
    t[4] !== o || t[5] !== i ? (a = g.jsxs("div", {
        className: "flex max-w-full min-w-0 grow flex-col",
        children: [o, i]
    }),
    t[4] = o,
    t[5] = i,
    t[6] = a) : a = t[6];
    const l = a;
    if (!s)
        return l;
    const c = !r && "items-center";
    let u;
    t[7] !== c ? (u = we("flex max-w-full min-w-0 gap-1.5", c),
    t[7] = c,
    t[8] = u) : u = t[8];
    let d;
    t[9] !== s || t[10] !== r ? (d = typeof s != "function" ? s : g.jsx(s, {
        className: we("icon", r && "mt-1"),
        "aria-label": ""
    }),
    t[9] = s,
    t[10] = r,
    t[11] = d) : d = t[11];
    let f;
    return t[12] !== l || t[13] !== u || t[14] !== d ? (f = g.jsxs("div", {
        className: u,
        children: [d, l]
    }),
    t[12] = l,
    t[13] = u,
    t[14] = d,
    t[15] = f) : f = t[15],
    f
}
function HX(e) {
    "use forget";
    const t = De.c(23)
      , {title: n, accessory: r, description: s, hasSeparator: o, icon: i, closeButton: a, textCenter: l, visuallyHiddenHeader: c, className: u, closeButtonSide: d} = e
      , f = o === void 0 ? !1 : o
      , p = c === void 0 ? !1 : c
      , m = d === void 0 ? "right" : d;
    if (!n)
        return null;
    let v;
    t[0] !== a ? (v = a && g.jsx(RD, {
        asChild: !0,
        children: a
    }),
    t[0] = a,
    t[1] = v) : v = t[1];
    const _ = v
      , y = l && "flex-1 justify-center text-center";
    let b;
    t[2] !== y ? (b = we("flex max-w-full items-center", y),
    t[2] = y,
    t[3] = b) : b = t[3];
    const S = m === "left" && _;
    let C;
    t[4] !== s || t[5] !== i || t[6] !== n ? (C = g.jsx(VX, {
        title: n,
        description: s,
        icon: i
    }),
    t[4] = s,
    t[5] = i,
    t[6] = n,
    t[7] = C) : C = t[7];
    let w;
    t[8] !== b || t[9] !== S || t[10] !== C ? (w = g.jsxs("div", {
        className: b,
        children: [S, C]
    }),
    t[8] = b,
    t[9] = S,
    t[10] = C,
    t[11] = w) : w = t[11];
    const x = m === "right" && _;
    let E;
    t[12] !== r || t[13] !== x ? (E = g.jsxs("div", {
        className: "flex h-[max-content] items-center gap-2",
        children: [r, x]
    }),
    t[12] = r,
    t[13] = x,
    t[14] = E) : E = t[14];
    let T;
    t[15] !== u || t[16] !== f || t[17] !== E || t[18] !== w ? (T = g.jsxs($X, {
        hasSeparator: f,
        className: u,
        children: [w, E]
    }),
    t[15] = u,
    t[16] = f,
    t[17] = E,
    t[18] = w,
    t[19] = T) : T = t[19];
    const k = T;
    let A;
    return t[20] !== k || t[21] !== p ? (A = p ? g.jsx(w6, {
        children: k
    }) : k,
    t[20] = k,
    t[21] = p,
    t[22] = A) : A = t[22],
    A
}
function zX(e) {
    "use forget";
    const t = De.c(9)
      , {primaryButton: n, secondaryButton: r, isSpacedBetween: s, modalHasContent: o, textCenter: i, className: a} = e
      , l = s === void 0 ? !1 : s
      , c = o === void 0 ? !0 : o
      , u = i === void 0 ? !1 : i
      , d = a === void 0 ? "" : a;
    if (n == null && r == null)
        return null;
    const f = u && "justify-center"
      , p = l && "justify-between"
      , m = c && "mt-5 sm:mt-4";
    let v;
    t[0] !== d || t[1] !== f || t[2] !== p || t[3] !== m ? (v = we("flex flex-col gap-3 sm:flex-row-reverse", f, p, m, d),
    t[0] = d,
    t[1] = f,
    t[2] = p,
    t[3] = m,
    t[4] = v) : v = t[4];
    let _;
    return t[5] !== n || t[6] !== r || t[7] !== v ? (_ = g.jsxs("div", {
        className: v,
        children: [n, r]
    }),
    t[5] = n,
    t[6] = r,
    t[7] = v,
    t[8] = _) : _ = t[8],
    _
}
const $X = ({hasSeparator: e, className: t, children: n}) => g.jsx("header", {
    className: we("min-h-header-height flex justify-between py-2.5 ps-4 pe-2 select-none", e && "border-token-border-light border-b", t),
    children: n
})
  , pl = {
    Root: BX,
    Overlay: qX,
    Content: GX,
    Header: HX,
    Actions: zX,
    Button: Xd
}
  , ND = e => h.createElement("svg", {
    width: 20,
    height: 20,
    viewBox: "0 0 20 20",
    fill: "currentColor",
    xmlns: "http://www.w3.org/2000/svg",
    ...e
}, h.createElement("path", {
    d: "M14.2548 4.75488C14.5282 4.48152 14.9717 4.48152 15.2451 4.75488C15.5184 5.02825 15.5184 5.47175 15.2451 5.74512L10.9902 10L15.2451 14.2549L15.3349 14.3652C15.514 14.6369 15.4841 15.006 15.2451 15.2451C15.006 15.4842 14.6368 15.5141 14.3652 15.335L14.2548 15.2451L9.99995 10.9902L5.74506 15.2451C5.4717 15.5185 5.0282 15.5185 4.75483 15.2451C4.48146 14.9718 4.48146 14.5282 4.75483 14.2549L9.00971 10L4.75483 5.74512L4.66499 5.63477C4.48589 5.3631 4.51575 4.99396 4.75483 4.75488C4.99391 4.51581 5.36305 4.48594 5.63471 4.66504L5.74506 4.75488L9.99995 9.00977L14.2548 4.75488Z"
}))
  , E6 = ({onClick: e, bg: t="transparent", className: n, iconSize: r="md", ref: s, ...o}) => {
    const i = gt();
    return g.jsx("button", {
        "data-testid": "close-button",
        ref: s,
        onClick: e,
        className: we("hover:bg-token-main-surface-secondary dark:hover:bg-token-main-surface-tertiary keyboard-focused:focus-ring flex h-8 w-8 items-center justify-center rounded-full", t === "transparent" ? "bg-transparent" : "bg-token-main-surface-primary", n),
        "aria-label": i.formatMessage({
            id: "Px7S/2",
            defaultMessage: "Close"
        }),
        ...o,
        children: g.jsx(ND, {
            className: r === "lg" ? "icon-lg" : "icon"
        })
    })
}
;
E6.displayName = "CloseButton";
const WX = "modulepreload"
  , KX = function(e) {
    return "https://cdn.oaistatic.com/" + e
}
  , Z7 = {}
  , he = function(t, n, r) {
    let s = Promise.resolve();
    if (n && n.length > 0) {
        let i = function(c) {
            return Promise.all(c.map(u => Promise.resolve(u).then(d => ({
                status: "fulfilled",
                value: d
            }), d => ({
                status: "rejected",
                reason: d
            }))))
        };
        document.getElementsByTagName("link");
        const a = document.querySelector("meta[property=csp-nonce]")
          , l = a?.nonce || a?.getAttribute("nonce");
        s = i(n.map(c => {
            if (c = KX(c),
            c in Z7)
                return;
            Z7[c] = !0;
            const u = c.endsWith(".css")
              , d = u ? '[rel="stylesheet"]' : "";
            if (document.querySelector(`link[href="${c}"]${d}`))
                return;
            const f = document.createElement("link");
            if (f.rel = u ? "stylesheet" : WX,
            u || (f.as = "script"),
            f.crossOrigin = "",
            f.href = c,
            l && f.setAttribute("nonce", l),
            document.head.appendChild(f),
            u)
                return new Promise( (p, m) => {
                    f.addEventListener("load", p),
                    f.addEventListener("error", () => m(new Error(`Unable to preload CSS for ${c}`)))
                }
                )
        }
        ))
    }
    function o(i) {
        const a = new Event("vite:preloadError",{
            cancelable: !0
        });
        if (a.payload = i,
        window.dispatchEvent(a),
        !a.defaultPrevented)
            throw i
    }
    return s.then(i => {
        for (const a of i || [])
            a.status === "rejected" && o(a.reason);
        return t().catch(o)
    }
    )
};
function YX() {
    return null
}
function $g(e, t) {
    const n = async () => {
        try {
            const l = await e();
            return "default"in l ? l : {
                default: l
            }
        } catch (l) {
            return q.addAction("Failed importing dynamic component", {
                error: l
            }),
            {
                default: t?.fallback ?? YX
            }
        }
    }
      , r = h.lazy(n)
      , s = t?.loading;
    function o(l) {
        const [c] = h.useState( () => a);
        return Vg() ? c ? g.jsx(c, {
            ...l
        }) : g.jsx(h.Suspense, {
            fallback: s == null ? null : g.jsx(s, {
                ...l
            }),
            children: g.jsx(r, {
                ...l
            })
        }) : s != null ? g.jsx(s, {
            ...l
        }) : null
    }
    let i, a;
    return o.prefetch = () => (i || (i = n().then(l => {
        a = l.default
    }
    )),
    i),
    o
}
const ZX = $g( () => he( () => import("./nk7vjso6lqii5i7u.js"), __vite__mapDeps([0, 1])).then(e => e.ContentModalSheet), {
    fallback: () => null
});
function Ti(e) {
    "use forget";
    const t = De.c(65)
      , {children: n, rootClassName: r, textCenter: s, className: o, description: i, icon: a, isBottomSheet: l, isOpen: c, onClose: u, onCloseComplete: d, primaryButton: f, secondaryButton: p, footerContent: m, size: v, title: _, headerAccessory: y, type: b, noPadding: S, hasSeparator: C, hideSeparator: w, showCloseButton: x, shouldIgnoreClickOutside: E, closeButton: T, isScrollable: k, allowVerticalContentToOverflow: A, position: O, removePopoverStyling: M, showOverlayBackground: I, shadow: R, visuallyHiddenHeader: D, headerClassName: P, contentClassName: L, footerClassName: N, modalActionsClassName: B, footerIsSpacedBetween: H, onEscapeKeyDown: ye, testId: Ie, contentRef: be} = e
      , me = c === void 0 ? !1 : c
      , ge = v === void 0 ? "normal" : v
      , ce = S === void 0 ? !1 : S
      , Z = C === void 0 ? !1 : C
      , ne = w === void 0 ? !0 : w
      , _e = x === void 0 ? !1 : x
      , ee = E === void 0 ? !1 : E
      , oe = k === void 0 ? !0 : k
      , te = A === void 0 ? !1 : A
      , ve = O === void 0 ? "center" : O
      , Ue = M === void 0 ? !1 : M
      , re = I === void 0 ? !0 : I
      , W = R === void 0 ? "normal" : R
      , X = D === void 0 ? !1 : D
      , Te = !!_ && !X
      , se = !!n
      , G = Z || !ne;
    if (l) {
        let On;
        return t[0] !== e ? (On = g.jsx(ZX, {
            ...e
        }),
        t[0] = e,
        t[1] = On) : On = t[1],
        On
    }
    let F;
    t[2] !== d || t[3] !== u ? (F = () => {
        u(!0),
        d?.()
    }
    ,
    t[2] = d,
    t[3] = u,
    t[4] = F) : F = t[4];
    const ke = s && "text-center"
      , Ee = ge === "normal"
      , Y = ge === "large"
      , le = ge === "xlarge"
      , Oe = ge === "fullscreen"
      , ae = !te;
    let je;
    t[5] !== o || t[6] !== ke || t[7] !== Ee || t[8] !== Y || t[9] !== le || t[10] !== Oe || t[11] !== ae ? (je = we("flex flex-col focus:outline-hidden", ke, {
        "max-w-md": Ee,
        "max-w-lg": Y,
        "max-w-xl": le,
        "h-full w-full": Oe,
        "overflow-hidden": ae
    }, o),
    t[5] = o,
    t[6] = ke,
    t[7] = Ee,
    t[8] = Y,
    t[9] = le,
    t[10] = Oe,
    t[11] = ae,
    t[12] = je) : je = t[12];
    let ot;
    t[13] !== T || t[14] !== u || t[15] !== _e ? (ot = _e && (T ?? g.jsx(E6, {
        onClick: () => u(!0)
    })),
    t[13] = T,
    t[14] = u,
    t[15] = _e,
    t[16] = ot) : ot = t[16];
    let St;
    t[17] !== i || t[18] !== y || t[19] !== P || t[20] !== a || t[21] !== G || t[22] !== ot || t[23] !== s || t[24] !== _ || t[25] !== b || t[26] !== X ? (St = g.jsx(pl.Header, {
        icon: a,
        title: _,
        accessory: y,
        type: b,
        textCenter: s,
        closeButton: ot,
        description: i,
        hasSeparator: G,
        visuallyHiddenHeader: X,
        className: P
    }),
    t[17] = i,
    t[18] = y,
    t[19] = P,
    t[20] = a,
    t[21] = G,
    t[22] = ot,
    t[23] = s,
    t[24] = _,
    t[25] = b,
    t[26] = X,
    t[27] = St) : St = t[27];
    const Tt = te ? "overflow-y-visible" : oe ? "overflow-y-auto" : "overflow-y-hidden"
      , wt = ge !== "fullscreen" && !ce
      , ut = !G && Te && !ce;
    let Mt;
    t[28] !== L || t[29] !== Tt || t[30] !== wt || t[31] !== ut ? (Mt = we("grow", Tt, {
        "p-4": wt,
        "pt-1": ut
    }, L),
    t[28] = L,
    t[29] = Tt,
    t[30] = wt,
    t[31] = ut,
    t[32] = Mt) : Mt = t[32];
    let fn;
    t[33] !== N || t[34] !== m || t[35] !== H || t[36] !== se || t[37] !== B || t[38] !== f || t[39] !== p ? (fn = g.jsx(JX, {
        primaryButton: f,
        secondaryButton: p,
        footerContent: m,
        modalHasContent: se,
        className: N,
        isSpacedBetween: H,
        modalActionsClassName: B
    }),
    t[33] = N,
    t[34] = m,
    t[35] = H,
    t[36] = se,
    t[37] = B,
    t[38] = f,
    t[39] = p,
    t[40] = fn) : fn = t[40];
    let Yt;
    t[41] !== n || t[42] !== be || t[43] !== Mt || t[44] !== fn ? (Yt = g.jsxs("div", {
        className: Mt,
        ref: be,
        children: [n, fn]
    }),
    t[41] = n,
    t[42] = be,
    t[43] = Mt,
    t[44] = fn,
    t[45] = Yt) : Yt = t[45];
    let jt;
    t[46] !== ye || t[47] !== ve || t[48] !== Ue || t[49] !== W || t[50] !== ge || t[51] !== je || t[52] !== St || t[53] !== Yt ? (jt = g.jsxs(pl.Content, {
        size: ge,
        position: ve,
        className: je,
        removePopoverStyling: Ue,
        shadow: W,
        onEscapeKeyDown: ye,
        children: [St, Yt]
    }),
    t[46] = ye,
    t[47] = ve,
    t[48] = Ue,
    t[49] = W,
    t[50] = ge,
    t[51] = je,
    t[52] = St,
    t[53] = Yt,
    t[54] = jt) : jt = t[54];
    let gn;
    t[55] !== re || t[56] !== jt ? (gn = g.jsx(pl.Overlay, {
        showBackground: re,
        children: jt
    }),
    t[55] = re,
    t[56] = jt,
    t[57] = gn) : gn = t[57];
    let kn;
    return t[58] !== me || t[59] !== r || t[60] !== ee || t[61] !== F || t[62] !== gn || t[63] !== Ie ? (kn = g.jsx(pl.Root, {
        isOpen: me,
        onClose: F,
        shouldIgnoreClickOutside: ee,
        className: r,
        testId: Ie,
        children: gn
    }),
    t[58] = me,
    t[59] = r,
    t[60] = ee,
    t[61] = F,
    t[62] = gn,
    t[63] = Ie,
    t[64] = kn) : kn = t[64],
    kn
}
function JX(e) {
    "use forget";
    const t = De.c(14)
      , {primaryButton: n, secondaryButton: r, footerContent: s, textCenter: o, className: i, isSpacedBetween: a, modalActionsClassName: l, modalHasContent: c} = e
      , u = n != null || r != null;
    if (!(u || s))
        return null;
    let d;
    t[0] !== i ? (d = we("flex w-full flex-row items-center justify-end text-sm select-none", i),
    t[0] = i,
    t[1] = d) : d = t[1];
    let f;
    t[2] !== u || t[3] !== a || t[4] !== l || t[5] !== c || t[6] !== n || t[7] !== r || t[8] !== o ? (f = u ? g.jsx("div", {
        className: we(a ? "grow" : "flex-0"),
        children: g.jsx(pl.Actions, {
            className: we(l, "flex w-full flex-row-reverse"),
            textCenter: o,
            primaryButton: n,
            secondaryButton: r,
            modalHasContent: c,
            isSpacedBetween: a
        })
    }) : null,
    t[2] = u,
    t[3] = a,
    t[4] = l,
    t[5] = c,
    t[6] = n,
    t[7] = r,
    t[8] = o,
    t[9] = f) : f = t[9];
    let p;
    return t[10] !== s || t[11] !== d || t[12] !== f ? (p = g.jsxs("div", {
        className: d,
        children: [s, f]
    }),
    t[10] = s,
    t[11] = d,
    t[12] = f,
    t[13] = p) : p = t[13],
    p
}
function XX(e, t) {
    Gg(e, QX, {
        userEmail: t
    })
}
function QX({userEmail: e}) {
    const t = gt();
    return g.jsx(Ti, {
        testId: "modal-all-workspaces-blocked",
        isOpen: !0,
        onClose: eD,
        type: "warning",
        size: "custom",
        className: "max-w-3xl",
        title: g.jsxs("div", {
            className: "flex flex-col",
            children: [g.jsx("div", {
                className: "text-lg",
                children: g.jsx(de, {
                    ...dp.title
                })
            }), g.jsx("div", {
                className: "text-sm font-normal",
                children: g.jsx(de, {
                    ...dp.subtitle
                })
            })]
        }),
        icon: lJ,
        primaryButton: g.jsx(pl.Button, {
            onClick: async () => {
                const n = await NS.signOut({
                    redirect: !1,
                    callbackUrl: `/auth/login?next=${encodeURIComponent(location.pathname + location.search + location.hash)}`
                });
                location.href = n.url
            }
            ,
            color: "primary",
            title: t.formatMessage(dp.signOutButton)
        }),
        children: g.jsx("div", {
            className: "flex flex-col space-y-4",
            children: g.jsx("div", {
                children: g.jsx(de, {
                    ...dp.detail,
                    values: {
                        email: g.jsx("span", {
                            className: "font-semibold",
                            children: e
                        })
                    }
                })
            })
        })
    })
}
const dp = xt({
    title: {
        id: "AllWorkspacesBlockedModal.title",
        defaultMessage: "Access Denied"
    },
    subtitle: {
        id: "AllWorkspacesBlockedModal.subtitle",
        defaultMessage: "Your IT administrator has blocked access to this workspace"
    },
    detail: {
        id: "AllWorkspacesBlockedModal.detail",
        defaultMessage: "It looks like youâ€™re either trying to login using a personal email or you donâ€™t have access to a workspace thatâ€™s been approved by your IT administrator. Please use an authorized work email to access your workspace, or contact your IT administrator for access."
    },
    signOutButton: {
        id: "AllWorkspacesBlockedModal.signOutButton",
        defaultMessage: "Sign Out"
    }
});
var eQ = {};
const tQ = "https://chatgpt.com/backend/se"
  , U8e = eQ.VITE_VZA493Q_SERVICE_URL ?? "https://operator.chatgpt.com" ?? "https://operator.chatgpt.com"
  , di = "personal"
  , PD = 60 * 60 * 24 * 90
  , li = xt({
    signUpButtonText: {
        id: "Kiuf8K",
        defaultMessage: "Sign up"
    },
    logInButtonText: {
        id: "Yx8BXg",
        defaultMessage: "Log in"
    },
    cancelButtonText: {
        id: "DR1Cxg",
        defaultMessage: "Cancel"
    },
    continueButtonText: {
        id: "bT1n8o",
        defaultMessage: "Continue"
    },
    gotItButtonText: {
        id: "Eomb3Y",
        defaultMessage: "Got it"
    },
    stayLoggedOut: {
        id: "JpuO4U",
        defaultMessage: "Stay logged out"
    },
    somethingWentWrong: {
        id: "SJ1B8J",
        defaultMessage: "Something went wrong. Please try again later"
    },
    getPlus: {
        id: "nPUS9f",
        defaultMessage: "Get Plus"
    },
    getPro: {
        id: "MC/MAr",
        defaultMessage: "Get Pro"
    },
    tryPlus: {
        id: "lhUk0N",
        defaultMessage: "Try Plus"
    },
    tryGo: {
        id: "OkPnQG",
        defaultMessage: "Try Go"
    },
    upgradeToPlus: {
        id: "LIJKv1",
        defaultMessage: "Upgrade to Plus"
    },
    upgradeToPro: {
        id: "U92S4K",
        defaultMessage: "Upgrade to Pro"
    },
    upgradeToGo: {
        id: "xbeQTB",
        defaultMessage: "Upgrade to Go"
    },
    joinGo: {
        id: "w4EEKa",
        defaultMessage: "Join Go"
    },
    joinPlus: {
        id: "HmtUzT",
        defaultMessage: "Join Plus"
    },
    joinPro: {
        id: "Ehp9lH",
        defaultMessage: "Join Pro"
    },
    unlockGo: {
        id: "C3xzfi",
        defaultMessage: "Unlock Go"
    },
    unlockPlus: {
        id: "W3hk8e",
        defaultMessage: "Unlock Plus"
    },
    unlockPro: {
        id: "TXstaY",
        defaultMessage: "Unlock Pro"
    },
    longCtaPlus: {
        id: "kp6hSg",
        defaultMessage: "Get better, faster answers"
    },
    longCtaPro: {
        id: "SEKq+P",
        defaultMessage: "Unlock all of ChatGPT"
    },
    upgradeYourPlan: {
        id: "aWGaHN",
        defaultMessage: "Upgrade your plan"
    },
    upgradePlan: {
        id: "N8cHz1",
        defaultMessage: "Upgrade plan"
    },
    upgrade: {
        id: "0CZNA2",
        defaultMessage: "Upgrade"
    },
    upgradeForFree: {
        id: "c1Drc7",
        defaultMessage: "Upgrade for free"
    },
    featureProjectsTasksCustomGPTs: {
        id: "pricing.plusRedesign.feature.projectsTasksCustomGPTs",
        defaultMessage: "Projects, tasks, custom GPTs"
    },
    maybeLater: {
        id: "common-message.maybeLater",
        defaultMessage: "Maybe later"
    },
    confirm: {
        id: "common-message.confirm",
        defaultMessage: "Confirm"
    },
    cancel: {
        id: "common-message.cancel",
        defaultMessage: "Cancel"
    }
});
var nQ = (e => (e.APPLE = "apple",
e))(nQ || {});
const rQ = "gpt-4o"
  , B8e = rQ;
var sQ = (e => (e.NoAuthGo = "ifpazk",
e))(sQ || {});
const q8e = {
    ifpazk: "zkl"
};
var x6 = (e => (e.GPT_3_5 = "gpt3.5",
e.GPT_4 = "gpt4",
e.GPT_4o = "gpt4o",
e.HIDDEN = "hidden",
e))(x6 || {});
const T6 = "WEB:"
  , G8e = `${T6}:DUMMY`;
var cu = (e => (e.Next = "next",
e.Variant = "variant",
e.Continue = "continue",
e))(cu || {})
  , Ke = (e => (e.Root = "root",
e.User = "user",
e.Assistant = "assistant",
e.System = "system",
e.Critic = "critic",
e.Tool = "tool",
e.Developer = "developer",
e))(Ke || {})
  , cn = (e => (e.PrimaryAssistant = "primary_assistant",
e.GizmoInteraction = "gizmo_interaction",
e.GizmoMagicCreate = "gizmo_magic_create",
e.GizmoTest = "gizmo_test",
e.FlyingCircusCustomization = "flying_circus_customization",
e))(cn || {});
const Rn = {
    Web: "web",
    Cloud: "cloud",
    GitHub: "github",
    GoogleDrive: "google_drive",
    GoogleCalendar: "google_calendar",
    Gmail: "gmail",
    GoogleContacts: "google_contacts",
    Dropbox: "dropbox",
    Linear: "linear",
    Sharepoint: "sharepoint",
    Teams: "teams",
    OutlookEmail: "outlook_email",
    OutlookCalendar: "outlook_calendar",
    Box: "box",
    Intercom: "intercom",
    Hubspot: "hubspot",
    Canva: "canva",
    Notion: "notion",
    Slack: "slack"
};
var oQ = (e => (e.None = "none",
e.OAuth = "oauth",
e.ServiceHTTP = "service_http",
e))(oQ || {})
  , Pd = (e => (e.CONVERSATION = "conversation",
e.REGENERATE = "regenerate",
e))(Pd || {})
  , gs = (e => (e.UNSUPPORTED_ATTACHMENT = "unsupported_attachment",
e.UNSUPPORTED_AUDIO = "unsupported_audio",
e.UNSUPPORTED_IMAGE = "unsupported_image",
e.UNSUPPORTED_TOOL_USE = "unsupported_tool_use",
e.UNSUPPORTED_GIZMO = "unsupported_gizmo",
e.UNSUPPORTED_CUSTOM_INSTRUCTIONS = "unsupported_custom_instructions",
e.UNSUPPORTED_TEMPORARY_CHAT = "unsupported_temporary_chat",
e.UNSUPPORTED_CANVAS = "unsupported_canvas",
e))(gs || {})
  , k6 = (e => (e.RATE_LIMIT = "rate_limit",
e))(k6 || {})
  , iQ = (e => (e.USER_VISIBLE_TOKEN = "user_visible_token",
e.COT_TOKEN = "cot_token",
e.NAVLINK_TOKEN = "navlink_token",
e))(iQ || {})
  , rt = (e => (e.Text = "text",
e.MultimodalText = "multimodal_text",
e.StructuredThoughts = "thoughts",
e.ReasoningRecap = "reasoning_recap",
e.TetherBrowsingCode = "tether_browsing_code",
e.Code = "code",
e.ExecutionOutput = "execution_output",
e.SystemError = "system_error",
e.SystemMessage = "system_message",
e.SystemContent = "system_content",
e.DeveloperContent = "developer_content",
e.TetherBrowsingDisplay = "tether_browsing_display",
e.TetherQuote = "tether_quote",
e.UserEditableContext = "user_editable_context",
e.ModelEditableContext = "model_editable_context",
e.SonicWebpage = "sonic_webpage",
e.ComputerOutput = "computer_output",
e.Error = "error",
e.SuperWidget = "super_widget",
e.CitableCodeOutput = "citable_code_output",
e))(rt || {})
  , Jn = (e => (e.Audio = "audio",
e.AudioAssetPointer = "audio_asset_pointer",
e.ImageAssetPointer = "image_asset_pointer",
e.Image = "image",
e.AudioTranscription = "audio_transcription",
e.RealTimeUserAudioVideoAssetPointer = "real_time_user_audio_video_asset_pointer",
e.SimpleImageAssetPointer = "simple_image_asset_pointer",
e.ArbitraryAssetPointer = "arbitrary_asset_pointer",
e))(Jn || {})
  , _f = (e => (e.Picker = "Picker",
e.Link = "Link",
e))(_f || {})
  , No = (e => (e.SEND = "send",
e.GIZMO_TAG = "gizmo_tag",
e.FILE_UPLOAD = "file_upload",
e.REASON = "reason",
e.DEEP_RESEARCH = "deep_research",
e.IMAGE_GEN = "image_gen",
e.WHAM = "wham",
e.ODYSSEY = "odyssey",
e))(No || {})
  , aQ = (e => (e.AUTHENTICATE = "authenticate",
e.AUTHENTICATE_SECONDARY = "authenticate_secondary",
e.NEW_CHAT = "new_chat",
e.FREE_USER_O3_MINI_HIGH = "free_user_o3_mini_high",
e.PAID_USER_O3_MINI_HIGH = "paid_user_o3_mini_high",
e.DEEP_RESEARCH_IN_CONTEXT_UPSELL = "deep_research_in_context_upsell",
e.TRY_CODEX = "try_codex",
e.TRY_TATERTOT = "try_tatertot",
e.NOTIFY_ADMIN_FOR_CREDITS = "notify_admin_for_credits",
e.ADD_CREDITS = "add_credits",
e.UPGRADE_TO_GO = "upgrade_to_go",
e.GET_PLUS = "get_plus",
e.GET_PRO = "get_pro",
e))(aQ || {})
  , O6 = (e => (e.DEEP_RESEARCH = "deep_research",
e.ODYSSEY = "odyssey",
e))(O6 || {})
  , lQ = (e => (e.VIEW = "view",
e.CLICK = "click",
e.DISMISS = "dismiss",
e))(lQ || {})
  , cQ = (e => (e.FILE_UPLOAD = "file_upload",
e.PHOTO_UPLOAD = "photo_upload",
e.AUTHENTICATE_LOGIN = "authenticate_login",
e.AUTHENTICATE_SIGNUP = "authenticate_signup",
e.GET_PLUS = "get_plus",
e.GET_PRO = "get_pro",
e.SYSTEM_HINT = "system_hint",
e.DISMISS = "dismiss",
e.GET_GO = "get_go",
e.GET_TEAM = "get_team",
e.OPEN_URL = "open_url",
e))(cQ || {})
  , DD = (e => (e.SystemHint = "systemHint",
e))(DD || {});
function V8e(e) {
    return "start_index"in e ? {
        startIndex: e.start_index,
        endIndex: e.end_index,
        symbol: e.symbol
    } : e
}
var uQ = (e => (e.InstantQuery = "instant_query",
e.ComposerSearch = "composer_search",
e.UrlSearch = "url_search",
e))(uQ || {})
  , dQ = (e => (e.RiskyDomainNotWatching = "risky_domain_not_watching",
e.UserInterrupted = "user_interrupted",
e.MaliciousInstructionDetected = "malicious_instruction_detected",
e.ModerationBlocked = "moderation_blocked",
e.Unknown = "unknown",
e))(dQ || {})
  , fQ = (e => (e.ToolWeb = "tool:web",
e.Onboarding = "onboarding",
e.AppPairing = "tool:app-pairing",
e.IPL = "campaign:ipl",
e))(fQ || {})
  , LD = (e => (e.Search = "search",
e.Canvas = "canvas",
e.ImageGen = "image_gen_tool_enabled",
e))(LD || {})
  , FD = (e => (e.Search = "search",
e.Click = "click",
e.MultiClick = "mclick",
e.Lookup = "lookup",
e.OpenUrl = "open_url",
e.Open = "open",
e.Quote = "quote",
e.QuoteFull = "quote_full",
e.QuoteLines = "quote_lines",
e.Back = "back",
e.Scroll = "scroll",
e.Spinner = "spinner",
e))(FD || {})
  , hQ = (e => (e.Bing = "bing",
e.Fortis = "fortis",
e))(hQ || {})
  , pQ = (e => (e.Starting = "starting",
e.Running = "running",
e.Done = "done",
e.Timeout = "timeout",
e.Error = "error",
e.Cancelled = "cancelled",
e))(pQ || {})
  , t5 = (e => (e.AUTO = "auto",
e))(t5 || {})
  , mQ = (e => (e.AUTO = "auto",
e.ON = "reasoning",
e.OFF = "none",
e.PRO = "pro",
e))(mQ || {});
const Zs = "agent"
  , gQ = "~oai~s1~";
function vQ(e) {
    let t = 2166136261;
    for (let n = 0, r = e.length; n < r; n++) {
        const s = e.charCodeAt(n);
        t = Math.imul(t ^ s & 255, 16777619),
        t = Math.imul(t ^ s & 65280, 16777619)
    }
    return t >>> 0
}
function Rr(e, t) {
    if (typeof e != "number")
        throw new Error(`Unexpected: ${e}`);
    return t != null && e === _Q(t)
}
const J7 = {};
function _Q(e) {
    return J7[e] ?? (J7[e] = vQ(gQ + e))
}
const H8e = "n7jupd"
  , jD = "-0dy553y"
  , yQ = 1338619165;
function UD(e) {
    return Rr(yQ, e + jD)
}
const bQ = 3675352570;
function z8e(e) {
    return Rr(bQ, e + jD)
}
var CQ = (e => (e[e.Setup = 0] = "Setup",
e[e.Random = 1] = "Random",
e[e.Animation = 2] = "Animation",
e[e.Done = 3] = "Done",
e[e.Thinking = 4] = "Thinking",
e[e.Research = 5] = "Research",
e))(CQ || {});
const xe = {
    Search: "search",
    Think: "reason",
    Research: "research",
    Canvas: "canvas",
    Picture: "picture",
    PictureV2: "picture_v2",
    Video: "video",
    ContextualAnswers: "contextual_answers",
    Slurm: "slurm",
    ApiTool: "api_tool",
    Moonshine: "moonshine",
    Tatertot: "tatertot",
    Agent: "agent"
};
function SQ(e) {
    return Object.values(xe).includes(e)
}
function wQ(e) {
    return SQ(e) ? e : xQ[e]
}
const EQ = "study"
  , xQ = {
    connectors: xe.Slurm,
    image: xe.PictureV2,
    think: xe.Think,
    [EQ]: xe.Tatertot
};
var BD = Symbol.for("immer-nothing")
  , X7 = Symbol.for("immer-draftable")
  , Bt = Symbol.for("immer-state");
function Cs(e, ...t) {
    throw new Error(`[Immer] minified error nr: ${e}. Full error at: https://bit.ly/3cXEKWf`)
}
var Tu = Object.getPrototypeOf;
function ku(e) {
    return !!e && !!e[Bt]
}
function bi(e) {
    return e ? qD(e) || Array.isArray(e) || !!e[X7] || !!e.constructor?.[X7] || Kg(e) || Yg(e) : !1
}
var TQ = Object.prototype.constructor.toString();
function qD(e) {
    if (!e || typeof e != "object")
        return !1;
    const t = Tu(e);
    if (t === null)
        return !0;
    const n = Object.hasOwnProperty.call(t, "constructor") && t.constructor;
    return n === Object ? !0 : typeof n == "function" && Function.toString.call(n) === TQ
}
function Ou(e, t) {
    Wg(e) === 0 ? Object.entries(e).forEach( ([n,r]) => {
        t(n, r, e)
    }
    ) : e.forEach( (n, r) => t(r, n, e))
}
function Wg(e) {
    const t = e[Bt];
    return t ? t.type_ : Array.isArray(e) ? 1 : Kg(e) ? 2 : Yg(e) ? 3 : 0
}
function n5(e, t) {
    return Wg(e) === 2 ? e.has(t) : Object.prototype.hasOwnProperty.call(e, t)
}
function GD(e, t, n) {
    const r = Wg(e);
    r === 2 ? e.set(t, n) : r === 3 ? e.add(n) : e[t] = n
}
function kQ(e, t) {
    return e === t ? e !== 0 || 1 / e === 1 / t : e !== e && t !== t
}
function Kg(e) {
    return e instanceof Map
}
function Yg(e) {
    return e instanceof Set
}
function jn(e) {
    return e.copy_ || e.base_
}
function r5(e, t) {
    if (Kg(e))
        return new Map(e);
    if (Yg(e))
        return new Set(e);
    if (Array.isArray(e))
        return Array.prototype.slice.call(e);
    if (!t && qD(e))
        return Tu(e) ? {
            ...e
        } : Object.assign(Object.create(null), e);
    const n = Object.getOwnPropertyDescriptors(e);
    delete n[Bt];
    let r = Reflect.ownKeys(n);
    for (let s = 0; s < r.length; s++) {
        const o = r[s]
          , i = n[o];
        i.writable === !1 && (i.writable = !0,
        i.configurable = !0),
        (i.get || i.set) && (n[o] = {
            configurable: !0,
            writable: !0,
            enumerable: i.enumerable,
            value: e[o]
        })
    }
    return Object.create(Tu(e), n)
}
function A6(e, t=!1) {
    return Zg(e) || ku(e) || !bi(e) || (Wg(e) > 1 && (e.set = e.add = e.clear = e.delete = OQ),
    Object.freeze(e),
    t && Ou(e, (n, r) => A6(r, !0))),
    e
}
function OQ() {
    Cs(2)
}
function Zg(e) {
    return Object.isFrozen(e)
}
var s5 = {};
function Fl(e) {
    const t = s5[e];
    return t || Cs(0, e),
    t
}
function AQ(e, t) {
    s5[e] || (s5[e] = t)
}
var yf;
function Nm() {
    return yf
}
function MQ(e, t) {
    return {
        drafts_: [],
        parent_: e,
        immer_: t,
        canAutoFreeze_: !0,
        unfinalizedDrafts_: 0
    }
}
function Q7(e, t) {
    t && (Fl("Patches"),
    e.patches_ = [],
    e.inversePatches_ = [],
    e.patchListener_ = t)
}
function o5(e) {
    i5(e),
    e.drafts_.forEach(IQ),
    e.drafts_ = null
}
function i5(e) {
    e === yf && (yf = e.parent_)
}
function e9(e) {
    return yf = MQ(yf, e)
}
function IQ(e) {
    const t = e[Bt];
    t.type_ === 0 || t.type_ === 1 ? t.revoke_() : t.revoked_ = !0
}
function t9(e, t) {
    t.unfinalizedDrafts_ = t.drafts_.length;
    const n = t.drafts_[0];
    return e !== void 0 && e !== n ? (n[Bt].modified_ && (o5(t),
    Cs(4)),
    bi(e) && (e = Pm(t, e),
    t.parent_ || Dm(t, e)),
    t.patches_ && Fl("Patches").generateReplacementPatches_(n[Bt].base_, e, t.patches_, t.inversePatches_)) : e = Pm(t, n, []),
    o5(t),
    t.patches_ && t.patchListener_(t.patches_, t.inversePatches_),
    e !== BD ? e : void 0
}
function Pm(e, t, n) {
    if (Zg(t))
        return t;
    const r = t[Bt];
    if (!r)
        return Ou(t, (s, o) => n9(e, r, t, s, o, n)),
        t;
    if (r.scope_ !== e)
        return t;
    if (!r.modified_)
        return Dm(e, r.base_, !0),
        r.base_;
    if (!r.finalized_) {
        r.finalized_ = !0,
        r.scope_.unfinalizedDrafts_--;
        const s = r.copy_;
        let o = s
          , i = !1;
        r.type_ === 3 && (o = new Set(s),
        s.clear(),
        i = !0),
        Ou(o, (a, l) => n9(e, r, s, a, l, n, i)),
        Dm(e, s, !1),
        n && e.patches_ && Fl("Patches").generatePatches_(r, n, e.patches_, e.inversePatches_)
    }
    return r.copy_
}
function n9(e, t, n, r, s, o, i) {
    if (ku(s)) {
        const a = o && t && t.type_ !== 3 && !n5(t.assigned_, r) ? o.concat(r) : void 0
          , l = Pm(e, s, a);
        if (GD(n, r, l),
        ku(l))
            e.canAutoFreeze_ = !1;
        else
            return
    } else
        i && n.add(s);
    if (bi(s) && !Zg(s)) {
        if (!e.immer_.autoFreeze_ && e.unfinalizedDrafts_ < 1)
            return;
        Pm(e, s),
        (!t || !t.scope_.parent_) && Dm(e, s)
    }
}
function Dm(e, t, n=!1) {
    !e.parent_ && e.immer_.autoFreeze_ && e.canAutoFreeze_ && A6(t, n)
}
function RQ(e, t) {
    const n = Array.isArray(e)
      , r = {
        type_: n ? 1 : 0,
        scope_: t ? t.scope_ : Nm(),
        modified_: !1,
        finalized_: !1,
        assigned_: {},
        parent_: t,
        base_: e,
        draft_: null,
        copy_: null,
        revoke_: null,
        isManual_: !1
    };
    let s = r
      , o = M6;
    n && (s = [r],
    o = bf);
    const {revoke: i, proxy: a} = Proxy.revocable(s, o);
    return r.draft_ = a,
    r.revoke_ = i,
    a
}
var M6 = {
    get(e, t) {
        if (t === Bt)
            return e;
        const n = jn(e);
        if (!n5(n, t))
            return NQ(e, n, t);
        const r = n[t];
        return e.finalized_ || !bi(r) ? r : r === j0(e.base_, t) ? (U0(e),
        e.copy_[t] = Cf(r, e)) : r
    },
    has(e, t) {
        return t in jn(e)
    },
    ownKeys(e) {
        return Reflect.ownKeys(jn(e))
    },
    set(e, t, n) {
        const r = VD(jn(e), t);
        if (r?.set)
            return r.set.call(e.draft_, n),
            !0;
        if (!e.modified_) {
            const s = j0(jn(e), t)
              , o = s?.[Bt];
            if (o && o.base_ === n)
                return e.copy_[t] = n,
                e.assigned_[t] = !1,
                !0;
            if (kQ(n, s) && (n !== void 0 || n5(e.base_, t)))
                return !0;
            U0(e),
            ri(e)
        }
        return e.copy_[t] === n && (n !== void 0 || t in e.copy_) || Number.isNaN(n) && Number.isNaN(e.copy_[t]) || (e.copy_[t] = n,
        e.assigned_[t] = !0),
        !0
    },
    deleteProperty(e, t) {
        return j0(e.base_, t) !== void 0 || t in e.base_ ? (e.assigned_[t] = !1,
        U0(e),
        ri(e)) : delete e.assigned_[t],
        e.copy_ && delete e.copy_[t],
        !0
    },
    getOwnPropertyDescriptor(e, t) {
        const n = jn(e)
          , r = Reflect.getOwnPropertyDescriptor(n, t);
        return r && {
            writable: !0,
            configurable: e.type_ !== 1 || t !== "length",
            enumerable: r.enumerable,
            value: n[t]
        }
    },
    defineProperty() {
        Cs(11)
    },
    getPrototypeOf(e) {
        return Tu(e.base_)
    },
    setPrototypeOf() {
        Cs(12)
    }
}
  , bf = {};
Ou(M6, (e, t) => {
    bf[e] = function() {
        return arguments[0] = arguments[0][0],
        t.apply(this, arguments)
    }
}
);
bf.deleteProperty = function(e, t) {
    return bf.set.call(this, e, t, void 0)
}
;
bf.set = function(e, t, n) {
    return M6.set.call(this, e[0], t, n, e[0])
}
;
function j0(e, t) {
    const n = e[Bt];
    return (n ? jn(n) : e)[t]
}
function NQ(e, t, n) {
    const r = VD(t, n);
    return r ? "value"in r ? r.value : r.get?.call(e.draft_) : void 0
}
function VD(e, t) {
    if (!(t in e))
        return;
    let n = Tu(e);
    for (; n; ) {
        const r = Object.getOwnPropertyDescriptor(n, t);
        if (r)
            return r;
        n = Tu(n)
    }
}
function ri(e) {
    e.modified_ || (e.modified_ = !0,
    e.parent_ && ri(e.parent_))
}
function U0(e) {
    e.copy_ || (e.copy_ = r5(e.base_, e.scope_.immer_.useStrictShallowCopy_))
}
var PQ = class {
    constructor(e) {
        this.autoFreeze_ = !0,
        this.useStrictShallowCopy_ = !1,
        this.produce = (t, n, r) => {
            if (typeof t == "function" && typeof n != "function") {
                const o = n;
                n = t;
                const i = this;
                return function(l=o, ...c) {
                    return i.produce(l, u => n.call(this, u, ...c))
                }
            }
            typeof n != "function" && Cs(6),
            r !== void 0 && typeof r != "function" && Cs(7);
            let s;
            if (bi(t)) {
                const o = e9(this)
                  , i = Cf(t, void 0);
                let a = !0;
                try {
                    s = n(i),
                    a = !1
                } finally {
                    a ? o5(o) : i5(o)
                }
                return Q7(o, r),
                t9(s, o)
            } else if (!t || typeof t != "object") {
                if (s = n(t),
                s === void 0 && (s = t),
                s === BD && (s = void 0),
                this.autoFreeze_ && A6(s, !0),
                r) {
                    const o = []
                      , i = [];
                    Fl("Patches").generateReplacementPatches_(t, s, o, i),
                    r(o, i)
                }
                return s
            } else
                Cs(1, t)
        }
        ,
        this.produceWithPatches = (t, n) => {
            if (typeof t == "function")
                return (i, ...a) => this.produceWithPatches(i, l => t(l, ...a));
            let r, s;
            return [this.produce(t, n, (i, a) => {
                r = i,
                s = a
            }
            ), r, s]
        }
        ,
        typeof e?.autoFreeze == "boolean" && this.setAutoFreeze(e.autoFreeze),
        typeof e?.useStrictShallowCopy == "boolean" && this.setUseStrictShallowCopy(e.useStrictShallowCopy)
    }
    createDraft(e) {
        bi(e) || Cs(8),
        ku(e) && (e = DQ(e));
        const t = e9(this)
          , n = Cf(e, void 0);
        return n[Bt].isManual_ = !0,
        i5(t),
        n
    }
    finishDraft(e, t) {
        const n = e && e[Bt];
        (!n || !n.isManual_) && Cs(9);
        const {scope_: r} = n;
        return Q7(r, t),
        t9(void 0, r)
    }
    setAutoFreeze(e) {
        this.autoFreeze_ = e
    }
    setUseStrictShallowCopy(e) {
        this.useStrictShallowCopy_ = e
    }
    applyPatches(e, t) {
        let n;
        for (n = t.length - 1; n >= 0; n--) {
            const s = t[n];
            if (s.path.length === 0 && s.op === "replace") {
                e = s.value;
                break
            }
        }
        n > -1 && (t = t.slice(n + 1));
        const r = Fl("Patches").applyPatches_;
        return ku(e) ? r(e, t) : this.produce(e, s => r(s, t))
    }
}
;
function Cf(e, t) {
    const n = Kg(e) ? Fl("MapSet").proxyMap_(e, t) : Yg(e) ? Fl("MapSet").proxySet_(e, t) : RQ(e, t);
    return (t ? t.scope_ : Nm()).drafts_.push(n),
    n
}
function DQ(e) {
    return ku(e) || Cs(10, e),
    HD(e)
}
function HD(e) {
    if (!bi(e) || Zg(e))
        return e;
    const t = e[Bt];
    let n;
    if (t) {
        if (!t.modified_)
            return t.base_;
        t.finalized_ = !0,
        n = r5(e, t.scope_.immer_.useStrictShallowCopy_)
    } else
        n = r5(e, !0);
    return Ou(n, (r, s) => {
        GD(n, r, HD(s))
    }
    ),
    t && (t.finalized_ = !1),
    n
}
function LQ() {
    class e extends Map {
        constructor(l, c) {
            super(),
            this[Bt] = {
                type_: 2,
                parent_: c,
                scope_: c ? c.scope_ : Nm(),
                modified_: !1,
                finalized_: !1,
                copy_: void 0,
                assigned_: void 0,
                base_: l,
                draft_: this,
                isManual_: !1,
                revoked_: !1
            }
        }
        get size() {
            return jn(this[Bt]).size
        }
        has(l) {
            return jn(this[Bt]).has(l)
        }
        set(l, c) {
            const u = this[Bt];
            return i(u),
            (!jn(u).has(l) || jn(u).get(l) !== c) && (n(u),
            ri(u),
            u.assigned_.set(l, !0),
            u.copy_.set(l, c),
            u.assigned_.set(l, !0)),
            this
        }
        delete(l) {
            if (!this.has(l))
                return !1;
            const c = this[Bt];
            return i(c),
            n(c),
            ri(c),
            c.base_.has(l) ? c.assigned_.set(l, !1) : c.assigned_.delete(l),
            c.copy_.delete(l),
            !0
        }
        clear() {
            const l = this[Bt];
            i(l),
            jn(l).size && (n(l),
            ri(l),
            l.assigned_ = new Map,
            Ou(l.base_, c => {
                l.assigned_.set(c, !1)
            }
            ),
            l.copy_.clear())
        }
        forEach(l, c) {
            const u = this[Bt];
            jn(u).forEach( (d, f, p) => {
                l.call(c, this.get(f), f, this)
            }
            )
        }
        get(l) {
            const c = this[Bt];
            i(c);
            const u = jn(c).get(l);
            if (c.finalized_ || !bi(u) || u !== c.base_.get(l))
                return u;
            const d = Cf(u, c);
            return n(c),
            c.copy_.set(l, d),
            d
        }
        keys() {
            return jn(this[Bt]).keys()
        }
        values() {
            const l = this.keys();
            return {
                [Symbol.iterator]: () => this.values(),
                next: () => {
                    const c = l.next();
                    return c.done ? c : {
                        done: !1,
                        value: this.get(c.value)
                    }
                }
            }
        }
        entries() {
            const l = this.keys();
            return {
                [Symbol.iterator]: () => this.entries(),
                next: () => {
                    const c = l.next();
                    if (c.done)
                        return c;
                    const u = this.get(c.value);
                    return {
                        done: !1,
                        value: [c.value, u]
                    }
                }
            }
        }
        [Symbol.iterator]() {
            return this.entries()
        }
    }
    function t(a, l) {
        return new e(a,l)
    }
    function n(a) {
        a.copy_ || (a.assigned_ = new Map,
        a.copy_ = new Map(a.base_))
    }
    class r extends Set {
        constructor(l, c) {
            super(),
            this[Bt] = {
                type_: 3,
                parent_: c,
                scope_: c ? c.scope_ : Nm(),
                modified_: !1,
                finalized_: !1,
                copy_: void 0,
                base_: l,
                draft_: this,
                drafts_: new Map,
                revoked_: !1,
                isManual_: !1
            }
        }
        get size() {
            return jn(this[Bt]).size
        }
        has(l) {
            const c = this[Bt];
            return i(c),
            c.copy_ ? !!(c.copy_.has(l) || c.drafts_.has(l) && c.copy_.has(c.drafts_.get(l))) : c.base_.has(l)
        }
        add(l) {
            const c = this[Bt];
            return i(c),
            this.has(l) || (o(c),
            ri(c),
            c.copy_.add(l)),
            this
        }
        delete(l) {
            if (!this.has(l))
                return !1;
            const c = this[Bt];
            return i(c),
            o(c),
            ri(c),
            c.copy_.delete(l) || (c.drafts_.has(l) ? c.copy_.delete(c.drafts_.get(l)) : !1)
        }
        clear() {
            const l = this[Bt];
            i(l),
            jn(l).size && (o(l),
            ri(l),
            l.copy_.clear())
        }
        values() {
            const l = this[Bt];
            return i(l),
            o(l),
            l.copy_.values()
        }
        entries() {
            const l = this[Bt];
            return i(l),
            o(l),
            l.copy_.entries()
        }
        keys() {
            return this.values()
        }
        [Symbol.iterator]() {
            return this.values()
        }
        forEach(l, c) {
            const u = this.values();
            let d = u.next();
            for (; !d.done; )
                l.call(c, d.value, d.value, this),
                d = u.next()
        }
    }
    function s(a, l) {
        return new r(a,l)
    }
    function o(a) {
        a.copy_ || (a.copy_ = new Set,
        a.base_.forEach(l => {
            if (bi(l)) {
                const c = Cf(l, a);
                a.drafts_.set(l, c),
                a.copy_.add(c)
            } else
                a.copy_.add(l)
        }
        ))
    }
    function i(a) {
        a.revoked_ && Cs(3, JSON.stringify(jn(a)))
    }
    AQ("MapSet", {
        proxyMap_: t,
        proxySet_: s
    })
}
var as = new PQ
  , Bs = as.produce;
as.produceWithPatches.bind(as);
as.setAutoFreeze.bind(as);
as.setUseStrictShallowCopy.bind(as);
as.applyPatches.bind(as);
as.createDraft.bind(as);
as.finishDraft.bind(as);
const FQ = e => (t, n, r) => (r.setState = (s, o, ...i) => {
    const a = typeof s == "function" ? Bs(s) : s;
    return t(a, o, ...i)
}
,
e(r.setState, n, r))
  , Da = FQ
  , jQ = {
    bannerInfo: null,
    modelLimits: [],
    blockedFeatures: [],
    isInitialLoad: !0,
    limitsProgress: []
}
  , fi = dn(Da( () => ({
    ...jQ
})))
  , I6 = {
    [xe.Research]: No.DEEP_RESEARCH,
    [xe.PictureV2]: No.IMAGE_GEN,
    [xe.Think]: No.REASON
};
I6[Zs] = No.ODYSSEY;
const $8e = e => UD(e) ? No.ODYSSEY : I6[e] ?? null
  , W8e = e => {
    for (const [t,n] of Object.entries(I6))
        if (n === e)
            return t;
    return null
}
  , UQ = {
    [xe.Research]: O6.DEEP_RESEARCH
};
function BQ(e) {
    return UD(e) ? O6.ODYSSEY : UQ[e] ?? null
}
function ya(e) {
    return new Date(e.resets_after) > new Date
}
const qQ = e => {
    const t = (e.model_limits?.filter(ya) ?? []).map(r => r.model_slug)
      , n = new Set(fi.getState().modelLimits.filter(ya).map(r => r.model_slug));
    return t.length !== n.size || !t.every(r => n.has(r))
}
  , zD = {
    updateDetails: ({banner_info: e, model_limits: t, blocked_features: n, limits_progress: r}) => {
        fi.setState(s => {
            const o = Ot();
            $t(o, "3886886465").get("should_overwrite_banner_info", !1) ? s.bannerInfo = e : s.bannerInfo ??= e,
            s.isInitialLoad = !1,
            s.blockedFeatures = s.blockedFeatures.concat(n).filter(ya),
            s.modelLimits = s.modelLimits.concat(t ?? []).filter(ya),
            s.limitsProgress = r ?? []
        }
        )
    }
    ,
    dismissBanner: () => {
        fi.setState(e => {
            e.bannerInfo = null
        }
        )
    }
    ,
    reset: () => {
        fi.setState(e => {
            e.blockedFeatures = [],
            e.bannerInfo = null
        }
        )
    }
};
function K8e() {
    return fi( ({bannerInfo: e}) => {
        const {resets_after: t} = e ?? {};
        return !e || t != null && !ya({
            resets_after: t
        }) ? null : e
    }
    )
}
function Jg(e) {
    return fi( ({blockedFeatures: t}) => {
        if (!e)
            return null;
        const n = t.find( ({name: r}) => r === e);
        return n && ya(n) ? n : null
    }
    )
}
function GQ() {
    return Jg(No.SEND)
}
function Y8e() {
    return !!GQ()
}
function Z8e() {
    return Jg(No.FILE_UPLOAD)
}
function J8e() {
    return Jg(No.GIZMO_TAG)
}
function X8e() {
    return Jg(No.DEEP_RESEARCH)
}
function VQ() {
    return fi( ({modelLimits: t}) => t).filter(ya)
}
function Q8e(e) {
    return fi( ({limitsProgress: n}) => n).filter(n => e({
        ...n,
        bySystemHint: r => n.feature_name === BQ(r)
    }))[0]
}
function exe() {
    return fi( ({blockedFeatures: t}) => t).filter(ya)
}
const HQ = dn( () => null)
  , zQ = dn( () => null);
var $D = (e => (e.UnexpectedSSOLogin = "unexpected_sso_login",
e.SSOMismatch = "sso_mismatch",
e.RequireSSOLogin = "require_sso_login",
e))($D || {});
const $Q = Object.freeze(new Set(Object.values($D)));
function WQ(e) {
    return e ? $Q.has(e) : !1
}
const KQ = dn( () => null)
  , r9 = (e, t, n) => {
    const r = e[t];
    return r ? typeof r == "function" ? r() : Promise.resolve(r) : new Promise( (s, o) => {
        (typeof queueMicrotask == "function" ? queueMicrotask : setTimeout)(o.bind(null, new Error("Unknown variable dynamic import: " + t + (t.split("/").length !== n ? ". Note that variables only represent file names one level deep." : ""))))
    }
    )
}
  , Xg = "en-US"
  , txe = ["am", "ar", "bg-BG", "bn-BD", "bs-BA", "ca-ES", "cs-CZ", "da-DK", "de-DE", "el-GR", "en-US", "es-419", "es-ES", "et-EE", "fi-FI", "fr-CA", "fr-FR", "gu-IN", "hi-IN", "hr-HR", "hu-HU", "hy-AM", "id-ID", "is-IS", "it-IT", "ja-JP", "ka-GE", "kk", "kn-IN", "ko-KR", "lt", "lv-LV", "mk-MK", "ml", "mn", "mr-IN", "ms-MY", "my-MM", "nb-NO", "nl-NL", "pa", "pl-PL", "pt-BR", "pt-PT", "ro-RO", "ru-RU", "sk-SK", "sl-SI", "so-SO", "sq-AL", "sr-RS", "sv-SE", "sw-TZ", "ta-IN", "te-IN", "th-TH", "tl", "tr-TR", "uk-UA", "ur", "vi-VN", "zh-CN", "zh-HK", "zh-TW"]
  , YQ = ["es-419", "fr-FR", "zh-TW"]
  , nxe = {
    am: "áŠ áˆ›áˆ­áŠ›",
    ar: "Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©",
    "bg-BG": "Ð±ÑŠÐ»Ð³Ð°Ñ€ÑÐºÐ¸",
    "bn-BD": "à¦¬à¦¾à¦‚à¦²à¦¾",
    "bs-BA": "bosanski",
    "ca-ES": "catalÃ ",
    "cs-CZ": "ÄeÅ¡tina",
    "da-DK": "dansk",
    "de-DE": "Deutsch",
    "el-GR": "Î•Î»Î»Î·Î½Î¹ÎºÎ¬",
    "en-US": "English (US)",
    "es-419": "espaÃ±ol (LatinoamÃ©rica)",
    "es-ES": "espaÃ±ol (EspaÃ±a)",
    "et-EE": "eesti",
    "fi-FI": "suomi",
    "fr-CA": "franÃ§ais (Canada)",
    "fr-FR": "franÃ§ais (France)",
    "gu-IN": "àª—à«àªœàª°àª¾àª¤à«€",
    "hi-IN": "à¤¹à¤¿à¤¨à¥à¤¦à¥€",
    "hr-HR": "hrvatski",
    "hu-HU": "magyar",
    "hy-AM": "Õ°Õ¡ÕµÕ¥Ö€Õ¥Õ¶",
    "id-ID": "Indonesia",
    "is-IS": "Ã­slenska",
    "it-IT": "italiano",
    "ja-JP": "æ—¥æœ¬èªž",
    "ka-GE": "áƒ¥áƒáƒ áƒ—áƒ£áƒšáƒ˜",
    kk: "Ò›Ð°Ð·Ð°Ò› Ñ‚Ñ–Ð»Ñ–",
    "kn-IN": "à²•à²¨à³à²¨à²¡",
    "ko-KR": "í•œêµ­ì–´",
    lt: "lietuviÅ³",
    "lv-LV": "latvieÅ¡u",
    "mk-MK": "Ð¼Ð°ÐºÐµÐ´Ð¾Ð½ÑÐºÐ¸",
    ml: "à´®à´²à´¯à´¾à´³à´‚",
    mn: "Ð¼Ð¾Ð½Ð³Ð¾Ð»",
    "mr-IN": "à¤®à¤°à¤¾à¤ à¥€",
    "ms-MY": "Bahasa Melayu",
    "my-MM": "á€™á€¼á€”á€ºá€™á€¬",
    "nb-NO": "norsk bokmÃ¥l",
    "nl-NL": "Nederlands",
    pa: "à¨ªà©°à¨œà¨¾à¨¬à©€",
    "pl-PL": "polski",
    "pt-BR": "portuguÃªs (Brasil)",
    "pt-PT": "portuguÃªs (Portugal)",
    "ro-RO": "romÃ¢nÄƒ",
    "ru-RU": "Ñ€ÑƒÑÑÐºÐ¸Ð¹",
    "sk-SK": "slovenÄina",
    "sl-SI": "slovenÅ¡Äina",
    "so-SO": "Soomaali",
    "sq-AL": "shqip",
    "sr-RS": "ÑÑ€Ð¿ÑÐºÐ¸",
    "sv-SE": "svenska",
    "sw-TZ": "Kiswahili",
    "ta-IN": "à®¤à®®à®¿à®´à¯",
    "te-IN": "à°¤à±†à°²à±à°—à±",
    "th-TH": "à¹„à¸—à¸¢",
    tl: "Tagalog",
    "tr-TR": "TÃ¼rkÃ§e",
    "uk-UA": "ÑƒÐºÑ€Ð°Ñ—Ð½ÑÑŒÐºÐ°",
    ur: "Ø§Ø±Ø¯Ùˆ",
    "vi-VN": "Tiáº¿ng Viá»‡t",
    "zh-CN": "ç®€ä½“ä¸­æ–‡",
    "zh-HK": "ç¹é«”ä¸­æ–‡ï¼ˆé¦™æ¸¯ï¼‰",
    "zh-TW": "ç¹é«”ä¸­æ–‡ï¼ˆå°ç£ï¼‰"
};
function ZQ() {
    return Array.from(new Set(Object.values(Dd)))
}
const Dd = {
    am: "am",
    ar: "ar",
    bg: "bg-BG",
    "bg-bg": "bg-BG",
    bn: "bn-BD",
    "bn-bd": "bn-BD",
    bs: "bs-BA",
    "bs-ba": "bs-BA",
    ca: "ca-ES",
    "ca-es": "ca-ES",
    cs: "cs-CZ",
    "cs-cz": "cs-CZ",
    da: "da-DK",
    "da-dk": "da-DK",
    de: "de-DE",
    "de-de": "de-DE",
    el: "el-GR",
    "el-gr": "el-GR",
    en: "en-US",
    "en-us": "en-US",
    es: "es-ES",
    "es-es": "es-ES",
    "es-419": "es-419",
    "es-ar": "es-419",
    "es-bo": "es-419",
    "es-br": "es-419",
    "es-bz": "es-419",
    "es-cl": "es-419",
    "es-co": "es-419",
    "es-cr": "es-419",
    "es-cu": "es-419",
    "es-do": "es-419",
    "es-ec": "es-419",
    "es-gt": "es-419",
    "es-hn": "es-419",
    "es-jp": "es-419",
    "es-mx": "es-419",
    "es-ni": "es-419",
    "es-pa": "es-419",
    "es-pe": "es-419",
    "es-pr": "es-419",
    "es-py": "es-419",
    "es-sv": "es-419",
    "es-us": "es-419",
    "es-uy": "es-419",
    "es-ve": "es-419",
    et: "et-EE",
    "et-ee": "et-EE",
    fi: "fi-FI",
    "fi-fi": "fi-FI",
    fr: "fr-FR",
    "fr-ca": "fr-CA",
    "fr-fr": "fr-FR",
    gu: "gu-IN",
    "gu-in": "gu-IN",
    hi: "hi-IN",
    "hi-in": "hi-IN",
    hr: "hr-HR",
    "hr-hr": "hr-HR",
    hu: "hu-HU",
    "hu-hu": "hu-HU",
    hy: "hy-AM",
    "hy-am": "hy-AM",
    id: "id-ID",
    "id-id": "id-ID",
    is: "is-IS",
    "is-is": "is-IS",
    it: "it-IT",
    "it-it": "it-IT",
    ja: "ja-JP",
    "ja-jp": "ja-JP",
    ka: "ka-GE",
    "ka-ge": "ka-GE",
    kk: "kk",
    kn: "kn-IN",
    "kn-in": "kn-IN",
    ko: "ko-KR",
    "ko-kr": "ko-KR",
    lt: "lt",
    lv: "lv-LV",
    "lv-lv": "lv-LV",
    mk: "mk-MK",
    "mk-mk": "mk-MK",
    ml: "ml",
    mn: "mn",
    mr: "mr-IN",
    "mr-in": "mr-IN",
    ms: "ms-MY",
    "ms-my": "ms-MY",
    my: "my-MM",
    "my-mm": "my-MM",
    nb: "nb-NO",
    "nb-no": "nb-NO",
    nl: "nl-NL",
    "nl-nl": "nl-NL",
    pa: "pa",
    pl: "pl-PL",
    "pl-pl": "pl-PL",
    pt: "pt-BR",
    "pt-br": "pt-BR",
    "pt-pt": "pt-PT",
    "pt-ao": "pt-PT",
    "pt-ch": "pt-PT",
    "pt-cv": "pt-PT",
    "pt-fr": "pt-PT",
    "pt-gq": "pt-PT",
    "pt-gw": "pt-PT",
    "pt-lu": "pt-PT",
    "pt-mo": "pt-PT",
    "pt-mz": "pt-PT",
    "pt-st": "pt-PT",
    "pt-tl": "pt-PT",
    ro: "ro-RO",
    "ro-ro": "ro-RO",
    ru: "ru-RU",
    "ru-ru": "ru-RU",
    sk: "sk-SK",
    "sk-sk": "sk-SK",
    sl: "sl-SI",
    "sl-si": "sl-SI",
    so: "so-SO",
    "so-so": "so-SO",
    sq: "sq-AL",
    "sq-al": "sq-AL",
    sr: "sr-RS",
    "sr-rs": "sr-RS",
    sv: "sv-SE",
    "sv-se": "sv-SE",
    sw: "sw-TZ",
    "sw-tz": "sw-TZ",
    ta: "ta-IN",
    "ta-in": "ta-IN",
    te: "te-IN",
    "te-in": "te-IN",
    th: "th-TH",
    "th-th": "th-TH",
    tl: "tl",
    tr: "tr-TR",
    "tr-tr": "tr-TR",
    uk: "uk-UA",
    "uk-ua": "uk-UA",
    ur: "ur",
    vi: "vi-VN",
    "vi-vn": "vi-VN",
    zh: "zh-CN",
    "zh-cn": "zh-CN",
    "zh-hans": "zh-CN",
    "zh-hans-cn": "zh-CN",
    "zh-tw": "zh-TW",
    "zh-hant": "zh-TW",
    "zh-hant-tw": "zh-TW",
    "zh-hk": "zh-HK",
    "zh-hant-hk": "zh-HK"
}
  , WD = new Set(["ar"]);
function R6(e) {
    const t = e.replace("_", "-").toLowerCase();
    if (t in Dd)
        return Dd[t];
    const n = t.split("-");
    for (let r = n.length - 1; r >= 1; r--) {
        const s = n.slice(0, r).join("-");
        if (s in Dd)
            return Dd[s]
    }
    return null
}
const Qd = {};
function KD(e) {
    return YQ.includes(e)
}
async function JQ(e, t) {
    return e === Xg ? Qd : (await (KD(e) && t ? r9(Object.assign({
        "./locales-mt/es-419.json": () => he( () => import("./bh7d4pw39pv2nzrn.js"), []),
        "./locales-mt/fr-FR.json": () => he( () => import("./kfj9rg259olnxtxk.js"), []),
        "./locales-mt/zh-TW.json": () => he( () => import("./l1uy6eag2dzk1d9l.js"), [])
    }), `./locales-mt/${e}.json`, 3) : r9(Object.assign({
        "./locales/am.json": () => he( () => import("./n7xgt57fsm7jfzyu.js"), []),
        "./locales/ar.json": () => he( () => import("./fwkrgm6zwghsdb4r.js"), []),
        "./locales/bg-BG.json": () => he( () => import("./lhnhi0osy5ixnw9i.js"), []),
        "./locales/bn-BD.json": () => he( () => import("./kyu1aew9g1x1fpqw.js"), []),
        "./locales/bs-BA.json": () => he( () => import("./d3devmwftd7pvz05.js"), []),
        "./locales/ca-ES.json": () => he( () => import("./fxdrxs6oi3aaj6s6.js"), []),
        "./locales/cs-CZ.json": () => he( () => import("./fl0qnidml3hs7ttk.js"), []),
        "./locales/da-DK.json": () => he( () => import("./96s0lwj49zg2col3.js"), []),
        "./locales/de-DE.json": () => he( () => import("./ja9mp8j22cqh3rc2.js"), []),
        "./locales/el-GR.json": () => he( () => import("./hhyuieqk78sm5iht.js"), []),
        "./locales/es-419.json": () => he( () => import("./ie3m979a7i9mcd7i.js"), []),
        "./locales/es-ES.json": () => he( () => import("./iifwgchngz8yg7f4.js"), []),
        "./locales/et-EE.json": () => he( () => import("./qpmd1c5w2263nqnt.js"), []),
        "./locales/fi-FI.json": () => he( () => import("./lld330c7ehwq1o1p.js"), []),
        "./locales/fr-CA.json": () => he( () => import("./e4b0ydf2ixgxfhf9.js"), []),
        "./locales/fr-FR.json": () => he( () => import("./hb0m4bohrwk23zao.js"), []),
        "./locales/gu-IN.json": () => he( () => import("./lzdcq1dciaj4f88z.js"), []),
        "./locales/he-IL.json": () => he( () => import("./h0pte8pfxhise50n.js"), []),
        "./locales/hi-IN.json": () => he( () => import("./lck98hds6w3oacwk.js"), []),
        "./locales/hr-HR.json": () => he( () => import("./23saey7erzg5slvb.js"), []),
        "./locales/hu-HU.json": () => he( () => import("./h0c0xcujg5zngo6c.js"), []),
        "./locales/hy-AM.json": () => he( () => import("./b37swoi570tpvh8y.js"), []),
        "./locales/id-ID.json": () => he( () => import("./n3d3ekvw9uu6fhdk.js"), []),
        "./locales/is-IS.json": () => he( () => import("./i22wjzapvkvgxoe5.js"), []),
        "./locales/it-IT.json": () => he( () => import("./kv528je916le1x9m.js"), []),
        "./locales/ja-JP.json": () => he( () => import("./j6z8ilpa4yk9s16f.js"), []),
        "./locales/ka-GE.json": () => he( () => import("./hylujrytko8ruk0l.js"), []),
        "./locales/kk.json": () => he( () => import("./hyeuyi8kc14fjw5o.js"), []),
        "./locales/kn-IN.json": () => he( () => import("./cw92atzlhcvgwnry.js"), []),
        "./locales/ko-KR.json": () => he( () => import("./ix2kn64ii33s75fe.js"), []),
        "./locales/lt.json": () => he( () => import("./k6knexdw238c5m6k.js"), []),
        "./locales/lv-LV.json": () => he( () => import("./lodd94q691cp0ihk.js"), []),
        "./locales/mk-MK.json": () => he( () => import("./gb9ven79g5w25jye.js"), []),
        "./locales/ml.json": () => he( () => import("./b16xn59sq36pj2t4.js"), []),
        "./locales/mn.json": () => he( () => import("./fj666g3iufq2s16q.js"), []),
        "./locales/mr-IN.json": () => he( () => import("./gpqd1eplrlxfb2nw.js"), []),
        "./locales/ms-MY.json": () => he( () => import("./gfsgjr048dltf0wb.js"), []),
        "./locales/my-MM.json": () => he( () => import("./2d0vxzxvzw9e0shs.js"), []),
        "./locales/nb-NO.json": () => he( () => import("./nt2ijivaadpdkqtn.js"), []),
        "./locales/nl-NL.json": () => he( () => import("./onvnciigab2vknla.js"), []),
        "./locales/pa.json": () => he( () => import("./fji0cahdchrkvehg.js"), []),
        "./locales/pl-PL.json": () => he( () => import("./pd5pa08x5745ijvv.js"), []),
        "./locales/pt-BR.json": () => he( () => import("./gxqb0c8gbnasr495.js"), []),
        "./locales/pt-PT.json": () => he( () => import("./d1v71vapv1wl61or.js"), []),
        "./locales/ro-RO.json": () => he( () => import("./fy3m5ow3ifwpbm96.js"), []),
        "./locales/ru-RU.json": () => he( () => import("./m7qi700jh0pw3qpg.js"), []),
        "./locales/sk-SK.json": () => he( () => import("./okfrsygzf0tihrsb.js"), []),
        "./locales/sl-SI.json": () => he( () => import("./nd56vu1n5zy7jxfs.js"), []),
        "./locales/so-SO.json": () => he( () => import("./dpvkgwftjjnbajow.js"), []),
        "./locales/sq-AL.json": () => he( () => import("./b8jx5joo11gqivc1.js"), []),
        "./locales/sr-RS.json": () => he( () => import("./hyrp27jq59gxc4q0.js"), []),
        "./locales/sv-SE.json": () => he( () => import("./o1wk07pmjsibt5g1.js"), []),
        "./locales/sw-TZ.json": () => he( () => import("./byf3jhvmexwdid1x.js"), []),
        "./locales/ta-IN.json": () => he( () => import("./4db6vp2it9srheyt.js"), []),
        "./locales/te-IN.json": () => he( () => import("./hfuco1o0225cqs6p.js"), []),
        "./locales/th-TH.json": () => he( () => import("./gvjzrq0gsndu2vo3.js"), []),
        "./locales/tl.json": () => he( () => import("./ki1rvv2lun8pwguk.js"), []),
        "./locales/tr-TR.json": () => he( () => import("./j5rqrsys49ykis1u.js"), []),
        "./locales/uk-UA.json": () => he( () => import("./mo8eerhdc17jnjil.js"), []),
        "./locales/ur.json": () => he( () => import("./jqsuttyky4hsvo5x.js"), []),
        "./locales/vi-VN.json": () => he( () => import("./blqia6hemgo0lc4t.js"), []),
        "./locales/zh-CN.json": () => he( () => import("./b3t1byw2j7kuig7g.js"), []),
        "./locales/zh-HK.json": () => he( () => import("./ms19c9al6epzryqk.js"), []),
        "./locales/zh-TW.json": () => he( () => import("./lidnrtf7gr0ms3gw.js"), [])
    }), `./locales/${e}.json`, 3))).default
}
const XQ = 365 * 24 * 60 * 60
  , rxe = e => {
    e == null ? ze.deleteCookie(Be.PreferredLocale) : ze.setCookie(Be.PreferredLocale, e, {
        maxAge: XQ
    }),
    window.location.reload()
}
  , QQ = () => {
    const e = ze.getCookie(Be.PreferredLocale);
    return e != null ? R6(e) : null
}
  , sxe = () => {
    const e = ue()
      , t = un(e).locale
      , n = J3( () => QQ()) ?? null
      , r = J3( () => {
        const s = navigator.language;
        return s ? R6(s) : null
    }
    );
    return Array.from(new Set([t, n, r].filter(Boolean)))
}
  , _o = window.localStorage;
var Ft = (e => (e.Theme = "theme",
e.NextAuth = "nextauth.message",
e.IsNoAuthChatTrainingEnabled = "oai/apps/isNoAuthChatTrainingEnabled",
e.IsNavigationCollapsed = "UiState.isNavigationCollapsed.1",
e.IsHistoryCollapsed = "UiState.isOnlyShowingRecents.1",
e.ChatThreadFlyoutState = "UiState.chatThreadFlyoutState",
e.IsGptListCollapsed = "UiState.isGptListCollapsed",
e.LastUsedModel = "oai/apps/lastModelUsed",
e.EnabledPlugins = "oai/enabledPluginIds",
e.HasSeenNewChatModal = "oai/apps/hasSeenNewChatModal",
e.HasSeenMeetChatGptModal = "oai/apps/hasSeenMeetChatGptModal",
e.HasSignedUpForPlusUpgradeWaitlistV1 = "oai/apps/HasSignedUpForPlusUpgradeWaitlist",
e.HasSignedUpForPlusUpgradeWaitlistV2 = "oai/apps/HasSignedUpForPlusUpgradeWaitlistV2",
e.HasSignedUpForTeamUpgradeWaitlistV1 = "oai/apps/HasSignedUpForTeamUpgradeWaitlist",
e.HasSignedUpForTeamUpgradeWaitlistV2 = "oai/apps/HasSignedUpForTeamUpgradeWaitlistV2",
e.HasDismissedUpgradeInviteModal = "oai/apps/hasDismissedUpgradeInviteModal",
e.GizmoEditorTab = "oai/apps/gizmoEditorTab",
e.GizmoDiscoveryLocale = "oai/apps/gizmoDiscoveryLocale",
e.NoAuthRateLimitState = "oai/apps/noAuthRateLimitState",
e.RestoreMessageAfterOauthRedirect = "oai/apps/restoreMessageAfterOauthRedirect",
e.HasSeenAdaInteractiveChart = "oai/apps/hasSeenAdaInteractiveChart",
e.HasSeenAdaInteractiveTable = "oai/apps/hasSeenAdaInteractiveTable",
e.SearchSettings = "oai/apps/searchSettings",
e.NoAuthBannerDisclaimerClientThreadId = "oai/apps/noAuthBannerDisclaimerClientThreadId",
e.NoAuthHasAcceptedFooterDisclaimer = "oai/apps/noAuthHasAcceptedFooterDisclaimer",
e.NoAuthUserMessageCount = "oai/apps/noAuthUserMessageCount",
e.HasSeenNoAuthImagegenNux = "oai/apps/hasSeenNoAuthImagegenNux",
e.LoggedInUserMessageCount = "oai/apps/loggedInUserMessageCount",
e.NoAuthHasDismissedSoftRateLimitModal = "oai/apps/noAuthHasDismissedSoftRateLimitModal",
e.NoAuthHasSeenGpt4oModal = "oai/apps/noAuthHasSeenGpt4oModal",
e.MemoryFullBannerDismissed = "oai/apps/memoryFullBannerDismissed",
e.MemoryAlmostFullBannerDismissed = "oai/apps/memoryAlmostFullBannerDismissed",
e.IndepthFeedbackDismissedAt = "oai/apps/indepthFeedbackDismissedAt",
e.AdvancedVoiceOnMobileAnnouncementCount = "oai/apps/oai/apps/hasSeenAdvancedVoiceOnMobile/2024-09-26",
e.CheckoutFrom = "oai/apps/checkout_from",
e.HasConfirmedCanvasCodeExecution = "oai/apps/hasConfirmedCanvasCodeExecution",
e.CODE_EXECUTION_DOMAIN_ALLOW_LIST = "oai/apps/codeExecutionDomainAllowlistWithTTL",
e.TasksHasSeenProjectDisclaimerBanner = "oai/apps/tasksHasSeenProjectDisclaimerBanner",
e.ExpandSummarizedCoT = "oai/apps/ExpandSummarizedCoT",
e.PromoCode = "oai/apps/promoCode",
e.LastPageLoadDate = "oai/apps/lastPageLoadDate",
e.NoAuthMadlibsModalState = "oai/apps/noAuthMadlibsModalState",
e.d2dee219 = "oai/apps/d2dee219",
e.ReferralCode = "oai/apps/referralCode",
e.LastFeedLoad = "oai/apps/2dc5214a",
e.VoiceLastUsed = "oai/apps/voiceLastUsed",
e.ModelCustomConfig = "oai/modelCustomConfig",
e.ChatTheme = "oai/apps/chatTheme",
e.ConversationDrafts = "oai/apps/conversationDrafts",
e.DebugSettings = "oai/apps/debugSettings",
e.GlauxUsePromptOverride = "oai/apps/glauxUsePromptOverride",
e.GlauxPromptOverride = "oai/apps/glauxPromptOverride",
e.GlauxJuiceScore = "oai/apps/glauxJuiceScore",
e.LastEnvironment = "oai/apps/l1239dk1/a3f4b29d",
e.PromptDraft = "oai/apps/l1239dk1/c7e2d18f",
e.ProposedTasks = "oai/apps/l1239dk1/8fa94c1e",
e.ReactQueryDevtoolsVisible = "oai/apps/l1239dk1/3e2d18f",
e.WhamForcedRateLimitRemaining = "oai/apps/l1239dk1/49292001",
e.WhamChangelogClickedDate = "oai/apps/l1239dk1/4b7d9e2f",
e.WhamRepoDownloadDurations = "oai/apps/l1239dk1/9182cd99",
e.WhamBestOfN = "oai/apps/l1239dk1/109b6e28",
e.WhamImageSnapshot = "oai/apps/l1239dk1/4kdf92l2",
e.WhamShowFullDiff = "oai/apps/l1239dk1/7a8d45ff",
e.WhamPreferredEditor = "oai/apps/l1239dk1/e2b7ab3c",
e.WhamCodexOnboardingState = "oai/apps/l1239dk1/codexOnboardingState",
e.SegmentUserId = "ajs_user_id",
e.SegmentUserTraits = "ajs_user_traits",
e.MessageFollowupsStoreState = "oai/apps/messageFollowupsStoreState",
e.JumpToShade = "jump-to-shade",
e.HasManuallyClosedLanguageUpsellBanner = "oai/apps/hasManuallyClosedLanguageUpsellBanner",
e.PluginsAuthRedirect = "oai/apps/plugins/authRedirect",
e.SelectedSources = "oai/apps/connectors/selectedSources",
e.SelectedGithubRepos = "oai/apps/connectors/selectedGithubRepos",
e.ConnectorOAuthFlowType = "oai/apps/connectors/oauthFlowType",
e.SubscriptionFailedBanner = "oai/apps/subscriptionFailedBanner",
e.HasDismissedTeamsNoAuthUpsell = "oai/apps/hasDismissedTeamsNoAuthUpsell",
e.FinchAdminNotified = "oai/apps/finchAdminNotified",
e.GetTeamPillDismissed = "oai/apps/getTeamPillDismissed",
e.CARecommendedPromptsUpsell = "oai/apps/caRecommendedPromptsUpsell",
e.ChinookStartupInfo = "oai/apps/chinookStartupInfo",
e.ModelSlugStatsOverride = "oai/apps/modelSlugStatsOverride",
e.ShortcutLinks = "oai/apps/shortcutLinks",
e.HomeDiscoveryDismissed = "oai/apps/homeDiscoveryDismissed",
e.O3MiniHighInContextUpsellBanner = "oai/apps/o3MiniHighInContextUpsellBanner",
e.TatertotInContextUpsellBannerV2 = "oai/apps/tatertotInContextUpsellBannerV2",
e.ImageGenProgressUpsellV2 = "oai/apps/imageGenProgressUpsellV2",
e.NoAuthGoUpsellModalDismissed = "oai/apps/noAuthGoUpsellModalDismissed",
e.HasDismissedMobileAppUpsellBanner = "oai/apps/hasDismissedMobileAppUpsellBanner",
e.HasDismissedMoodengUpsellBanner = "oai/apps/hasDismissedMoodengUpsellBanner",
e.LastSeenPlusUpsellBannerAt = "oai/apps/lastSeenPlusUpsellBannerAt",
e.HasDismissedOnboardingSidebarEntry = "oai/apps/hasDismissedOnboardingSidebarEntry",
e))(Ft || {});
class Wt {
    static setItem(t, n, r) {
        if (!_o)
            return;
        const s = Kp(t, r);
        _o.setItem(s, JSON.stringify(n))
    }
    static getItem(t, n) {
        if (!_o)
            return null;
        try {
            const r = Kp(t, n)
              , s = _o.getItem(r);
            return typeof s == "string" ? JSON.parse(s) : s
        } catch {
            return null
        }
    }
    static removeItem(t, n) {
        if (_o) {
            const r = Kp(t, n);
            return _o.removeItem(r)
        }
    }
    static DANGER_SECRET_FOLDERS_ONLY_setItem(t, n) {
        if (!_o) {
            console.warn(`You cannot set localStorage server-side (${t})`);
            return
        }
        _o.setItem(t, JSON.stringify(n))
    }
    static DANGER_SECRET_FOLDERS_ONLY_getItem(t) {
        if (!_o)
            return console.warn(`You cannot get localStorage server-side (${t})`),
            null;
        const n = _o.getItem(t);
        return typeof n == "string" ? JSON.parse(n) : n
    }
}
function Kp(e, t) {
    const n = [e];
    return t !== void 0 && (t.userId != null && n.push(t.userId),
    t.workspaceId != null && n.push(t.workspaceId)),
    n.join("/")
}
const s9 = 100
  , Sf = dn()(Da( () => Wt.getItem(Ft.ConversationDrafts) ?? {
    drafts: [],
    userId: null
}))
  , N6 = e => {
    Sf.setState(e),
    Wt.setItem(Ft.ConversationDrafts, e)
}
  , P6 = e => e ?? "null_thread"
  , oxe = (e, t, n) => {
    const r = P6(e);
    let o = Sf.getState().userId === n ? Sf.getState().drafts : [];
    const i = o.findIndex(l => l.id === r)
      , a = {
        id: r,
        content: t,
        timestamp: Date.now()
    };
    i !== -1 ? o[i] = a : o.push(a),
    o.length > s9 && (o = o.sort( (l, c) => c.timestamp - l.timestamp).slice(0, s9)),
    N6({
        drafts: o,
        userId: n
    })
}
  , eee = e => {
    const t = P6(e);
    return Sf.getState().drafts.find(n => n.id === t)
}
  , ixe = e => {
    const t = P6(e)
      , n = Sf.getState().drafts.filter(r => r.id !== t);
    N6({
        drafts: n,
        userId: null
    })
}
  , tee = () => {
    N6({
        drafts: [],
        userId: null
    })
}
;
function nee(e, t, n) {
    if (n)
        return t ?? void 0;
    if (!e)
        return;
    const r = e.trim();
    if (!r)
        return;
    const s = r.split(/\s+/);
    if (s.length === 0)
        return;
    const o = s[0];
    return o.indexOf("@") !== -1 || /^\d+$/.test(o) ? void 0 : o.replace(/[^a-zA-ZÃ€-Å¾]+/g, "")
}
function axe(e, t, n) {
    const r = nee(t?.name, t?.first_name, n);
    let s = "";
    e && ("object"in e && e.object === "user_system_message_detail" ? s = e.name_user_message : s = e.nameUserMessage ?? "");
    const o = s.trim();
    return (e?.enabled ?? !0) && o ? o : r
}
function ree() {
    ze.deleteCookie(Be.GreetingName)
}
const nu = "@@"
  , D6 = []
  , Lm = new Map;
function kc(e, t, n, r) {
    if (Lm.has(e) || e === "Ref")
        throw new Error(`Already registered pickler ${e}`);
    const s = {
        key: e,
        test: t,
        pickle: n,
        unpickle: r
    };
    Lm.set(e, s),
    D6.push(s)
}
function YD() {
    const e = []
      , t = new Map;
    return function(n, r) {
        for (; e.length && e[e.length - 1][0] !== this; ) {
            const o = e.pop()[1];
            typeof o == "object" && o != null && t.set(o, t.size)
        }
        const s = this[n];
        if (typeof s == "object" && s != null) {
            const o = t.get(s);
            if (o != null)
                return {
                    [nu]: "Ref",
                    "": o
                }
        }
        for (const o of D6)
            if (o.test(s)) {
                const i = {
                    [nu]: o.key,
                    "": o.pickle(s)
                };
                return e.push([i, s]),
                i
            }
        if (typeof r == "object" && r != null) {
            if (nu in r)
                throw new Error(`Unexpected ${nu} property`);
            e.push([r, s])
        }
        return r
    }
}
function see() {
    const e = [];
    return function(t, n) {
        if (typeof n != "object" || n == null)
            return n;
        if (nu in n) {
            const {[nu]: r, "": s} = n;
            if (r === "Ref")
                return e[s];
            const o = Lm.get(r);
            if (!o)
                throw Error(`Unknown pickle key ${r}`);
            if (n = o.unpickle(s),
            typeof n != "object" || n == null)
                return n
        }
        return e.push(n),
        n
    }
}
function oee() {
    D6.length = 0,
    Lm.clear(),
    kc("Map", e => e instanceof Map, e => [...e.entries()], e => new Map(e)),
    kc("Set", e => e instanceof Set, e => [...e.keys()], e => new Set(e)),
    kc("Date", e => e instanceof Date, e => e.toISOString(), e => new Date(e)),
    kc("RegExp", e => e instanceof RegExp, e => [e.source, e.flags], ([e,t]) => new RegExp(e,t)),
    kc("Number", e => typeof e == "number" && (Object.is(e, -0) || !isFinite(e) || isNaN(e)), e => Object.is(e, -0) ? "-0" : String(e), e => Number(e)),
    kc("BigInt", e => typeof e == "bigint", e => String(e), e => BigInt(e))
}
oee();
function iee(e) {
    if (e == null)
        return null;
    const t = un(Ot());
    return t.authStatus !== fr.LoggedIn ? null : {
        workspaceId: e,
        userId: t.user.id
    }
}
function ZD(e, t) {
    const n = iee(e);
    return n == null ? null : `cache/${n.userId}/${n.workspaceId}/${t}`
}
const aee = 1e3 * 60 * 60 * 24;
function lee(e, t, n) {
    const r = ZD(e, t);
    if (r == null)
        return;
    const s = localStorage.getItem(r);
    if (s != null)
        try {
            const {value: o, timestamp: i, version: a, used: l} = JSON.parse(s, see());
            if (a !== n || Date.now() - i > aee) {
                localStorage.removeItem(r);
                return
            }
            return {
                localStorageKey: r,
                value: o,
                version: a,
                used: typeof l == "number" ? l : 0
            }
        } catch {
            return
        }
}
const B0 = {};
function cee(e, t, n) {
    if (e == null)
        return;
    if (t in B0)
        return B0[t];
    const r = lee(e, t, n);
    if (q.addAction(`localStorageCache.${t}`, {
        cacheVersion: n,
        wasPresent: r != null
    }),
    B0[t] = r?.value,
    r != null)
        return r.used + 1 >= 4 ? localStorage.removeItem(r.localStorageKey) : localStorage.setItem(r.localStorageKey, JSON.stringify({
            timestamp: Date.now(),
            value: r.value,
            version: r.version,
            used: r.used + 1
        }, YD())),
        r.value
}
function uee(e, t, n, r) {
    const s = ZD(e, t);
    s != null && localStorage.setItem(s, JSON.stringify({
        value: n,
        timestamp: Date.now(),
        version: r
    }, YD()))
}
function JD() {
    for (const e of Object.keys(localStorage))
        e.startsWith("cache/") && localStorage.removeItem(e)
}
const dee = "session"
  , XD = "refresh";
let a5;
typeof window < "u" && window.BroadcastChannel !== void 0 && (a5 = new window.BroadcastChannel(dee),
a5.onmessage = e => {
    e.data === XD && (document.hidden ? window.addEventListener("visibilitychange", () => {
        document.hidden || (window.location.href = "/")
    }
    ) : setTimeout( () => {
        window.location.href = "/"
    }
    , 300))
}
);
function fee() {
    a5?.postMessage(XD)
}
function hee() {
    fee(),
    JD(),
    tee(),
    ree(),
    ze.deleteCookie(Be.LastUsedModel)
}
function L6(e) {
    hee(),
    window.location.href = e ?? "/?refresh_account=true"
}
const pee = "dgkjq2bp"
  , mee = pee;
function QD() {
    return he( () => import("./egv8htilau9pzui2.js").then(e => e.i), __vite__mapDeps([2, 1]))
}
function gee(e, t, n) {
    if (e.id) {
        const r = {
            app_id: mee,
            user_id: e.id,
            name: e.name,
            email: e.email,
            user_hash: n,
            hide_default_launcher: !0,
            is_chatgpt_user: !0,
            chatgpt_plan_type: t?.planType
        };
        QD().then(s => s?.boot(r))
    }
}
function F6(e, t) {
    QD().then(n => n?.trackEvent(e, t))
}
class Qg extends Error {
    name = "ClientRequestMismatchedAuthError"
}
function eL(e, t="fetch") {
    e.url.includes("/aip");
    const n = e.detail
      , r = n?.conversation_detail_metadata;
    if (r && zD.updateDetails(r),
    e.code === "request_account_access" && zQ.setState({
        accountName: n?.account_name,
        ownerEmail: n?.owner_email,
        userEmail: n?.user_email,
        accountId: n?.account_id,
        hasActiveRequest: n?.has_active_request,
        workspacePlanType: n?.workspace_plan_type
    }),
    e.code === "all_accounts_blocked" && XX(Ot(), n?.user_email),
    WQ(e.code) && KQ.setState({
        accountName: n?.account_name,
        errorCode: e.code
    }),
    e.code === "trigger_account_transfer") {
        HQ.setState({
            destinationWorkspaceId: n?.workspace_id,
            destinationWorkspaceName: n?.workspace_name,
            destinationWorkspaceProfilePictureUrl: n?.workspace_profile_picture_url,
            destinationWorkspacePlanType: n?.workspace_plan_type
        });
        return
    }
    if (e.code === "deactivated_workspace") {
        window.location.href.includes("/workspace/deactivated") || (window.location.href = "/workspace/deactivated");
        return
    }
    if ((e.code === "expired_session_key" || e.code === "token_expired" || e.code === "token_invalidated" || e.jsonError?.error?.code === "token_invalidated") && (q.addAction("Token expired", {
        url: e.url,
        error: n
    }),
    typeof window < "u" && window._oaiHandleSessionExpired?.(t, JSON.stringify(n))),
    e.code === "invalid_account_id_header" && typeof ze.getCookie(Be.Workspace) == "string") {
        ze.deleteCookie(Be.Workspace),
        L6();
        return
    }
}
function tL(e) {
    q.addAction("RequestError", {
        url: e.url,
        message: e.message,
        status: e.status,
        json: e.json,
        requestId: e.requestId,
        deviceId: xi()
    })
}
function vee(e, t) {
    return e.replace(/\{([^}]+)\}/g, (n, r) => t[r].toString())
}
function _ee(e) {
    if (!e)
        return "";
    const t = new URLSearchParams;
    for (const [r,s] of Object.entries(e))
        if (Array.isArray(s))
            for (const o of s)
                t.append(r, o.toString());
        else
            s != null && t.append(r, s.toString());
    const n = t.toString();
    return n.length === 0 ? "" : `?${n}`
}
function yee() {
    return un(Ot()).locale ?? Xg
}
function e1() {
    return {
        [KY]: yee(),
        [Ug]: xi(),
        [jg]: Hu
    }
}
function t1(e={}) {
    const t = e.accessToken ?? bee()
      , n = e1();
    if (t == null) {
        if (e.isAuthOptional === !0)
            return n;
        throw new Qg("No access token when trying to use AuthHeader")
    }
    n.Authorization = `Bearer ${t}`;
    const r = ze.getCookie(Be.Workspace);
    return typeof r == "string" && r !== di && (n["ChatGPT-Account-ID"] = encodeURIComponent(r)),
    n
}
function bee() {
    return Xf(Ot())
}
function nL({method: e, body: t, authOption: n, accessToken: r, additionalHeaders: s}) {
    return {
        method: e?.toUpperCase(),
        body: t,
        credentials: "include",
        headers: {
            ...n === Qt.Anonymous ? e1() : t1({
                isAuthOptional: n === Qt.SendIfAvailable,
                accessToken: r
            }),
            ...t != null && !(t instanceof FormData || t instanceof File) ? {
                "Content-Type": "application/json"
            } : null,
            ...t != null && t instanceof File ? {
                "Content-Type": "application/octet-stream"
            } : null,
            ...s
        }
    }
}
function Cee(e) {
    return (t, n) => {
        const r = (s, o) => {
            if (s >= e.length)
                return n(o);
            const i = e[s];
            return i(o, a => r(s + 1, a))
        }
        ;
        return r(0, t)
    }
}
function rL(e, t) {
    const n = Cee(e);
    return r => n(r, t)
}
async function sL(e, t) {
    let n = await t(e.clone());
    if (n.status === 401) {
        const s = await n.clone().json()
          , o = n.headers.get("X-Request-Id") ?? void 0;
        if (new _t(e.url,n.status,s,o).code === "token_expired") {
            const a = xi();
            await HP(io(Ot()), {
                reason: "token_expired",
                method: e.method ?? "GET",
                path: new URL(e.url,location.origin).pathname
            });
            const l = t1()
              , c = e.clone();
            for (const [u,d] of Object.entries(l))
                c.headers.set(u, d);
            n = await t(c),
            n.status === 200 ? q.addAction("Request succeeded after refresh.", {
                url: e.url,
                deviceId: a
            }) : q.addAction("Request failed after refresh.", {
                url: e.url,
                deviceId: a
            })
        }
    }
    return n
}
async function oL(e, t) {
    let n;
    try {
        n = await t(e)
    } catch (r) {
        throw r instanceof Error ? _t.createWithErrorMessage(e.url, "server", r.message) : r
    }
    if (n.status >= 400) {
        const r = await n.text();
        let s;
        try {
            s = JSON.parse(r)
        } catch {
            s = {
                detail: {
                    code: "not_json_response",
                    text: r?.substring(0, 1e3)
                }
            }
        }
        const o = n.headers.get("X-Request-Id") ?? void 0
          , i = new _t(e.url,n.status,s,o);
        throw eL(i),
        tL(i),
        i
    }
    return n
}
class j6 {
    #e;
    constructor(t) {
        const {baseUrl: n} = t;
        this.#e = typeof n == "string" ? () => n : n
    }
    baseUrl(t) {
        return this.#e(t)
    }
    #t = rL([oL, sL], fetch);
    async fetch(t, n={}) {
        try {
            const r = await this.#t(t);
            return n.skipJsonTransform ? r : r.status === 204 ? {} : r.json()
        } catch (r) {
            throw n.intercomEventOnError && F6(n.intercomEventOnError, {
                url: t.url
            }),
            r
        }
    }
    request(t, n, r) {
        const s = r?.parameters && "query"in r.parameters ? r.parameters.query : void 0
          , o = r?.parameters && "path"in r.parameters && r.parameters.path ? r.parameters.path : {}
          , i = vee(n, o)
          , a = _ee(s)
          , l = nL({
            ...r,
            method: t,
            body: r && "requestBody"in r ? r.requestBody instanceof File ? r.requestBody : JSON.stringify(r.requestBody) : void 0
        })
          , c = `${this.baseUrl(l)}${i}${a}`
          , u = new globalThis.Request(c,l);
        return this.fetch(u, r)
    }
    safeGet(t, ...n) {
        return this.request("get", t, n[0])
    }
    safePost(t, ...n) {
        return this.request("post", t, n[0])
    }
    safeDelete(t, ...n) {
        return this.request("delete", t, n[0])
    }
    safePatch(t, ...n) {
        return this.request("patch", t, n[0])
    }
    async*streamedJsonPost(t, n) {
        n.skipJsonTransform = !0;
        const r = await this.request("post", t, n);
        if (!r.body)
            return;
        const s = r.body.getReader()
          , o = new TextDecoder;
        let i = "";
        for (; ; ) {
            const {value: a, done: l} = await s.read();
            a && (i += o.decode(a, {
                stream: !0
            }));
            let c;
            for (; (c = i.indexOf(`
`)) !== -1; ) {
                const u = i.slice(0, c).trim();
                if (i = i.slice(c + 1),
                u.length !== 0)
                    try {
                        yield JSON.parse(u)
                    } catch {
                        i = u + `
` + i;
                        break
                    }
            }
            if (l) {
                const u = i.trim();
                u && (yield JSON.parse(u));
                return
            }
        }
    }
}
function See(e, t) {
    const n = {
        [lt]: HS
    };
    if (t.headers.Authorization)
        return e;
    for (const [r,s] of Object.entries(n))
        if (e.startsWith(r))
            return e.replace(r, s);
    return e
}
class wee {
    #e = rL([oL, sL], fetch);
    async fetch(t, n={}) {
        n.params && (t += "?" + new URLSearchParams(n.params).toString());
        try {
            const r = nL(n)
              , s = await this.#e(new globalThis.Request(See(t, r),r));
            return n.skipJsonTransform ? s : s.status === 204 ? {} : s.json()
        } catch (r) {
            throw n.intercomEventOnError && F6(n.intercomEventOnError, {
                url: t
            }),
            r
        }
    }
    get(t, n={}) {
        return this.fetch(t, n)
    }
    post(t, n, r={}) {
        return this.fetch(t, {
            ...r,
            method: "post",
            body: n instanceof FormData ? n : JSON.stringify(n)
        })
    }
    async*streamedJsonPost(t, n, r={}) {
        const o = (await this.fetch(t, {
            ...r,
            method: "post",
            body: JSON.stringify(n),
            skipJsonTransform: !0
        })).body;
        if (!o)
            return;
        const i = o.getReader()
          , a = new TextDecoder;
        let l = !1
          , c = "";
        for (; !l; ) {
            const u = await i.read();
            if (l = u.done,
            l && u.value == null)
                break;
            const d = c + a.decode(u.value, {
                stream: !0
            });
            c = "";
            const f = d.split(`
`).filter(p => !!p.trim());
            for (let p = 0; p < f.length; p++)
                try {
                    yield JSON.parse(f[p])
                } catch {
                    c = f[p];
                    break
                }
        }
        c.length > 0 && (yield JSON.parse(c))
    }
}
const ie = new j6({
    baseUrl(e) {
        return !!e.headers.Authorization ? lt : HS
    }
})
  , Eee = new j6({
    baseUrl: Vp
});
new j6({
    baseUrl: tQ
});
const at = new wee
  , iL = ["system-hints"];
function aL() {
    return iL
}
function lxe(e) {
    return e.getQueryData(aL())
}
function lL(e, t) {
    return At({
        queryKey: iL,
        queryFn: async () => {
            const n = await ie.safeGet("/system_hints", {
                authOption: Qt.SendIfAvailable
            });
            return q.addFirstTiming("load.systemHints"),
            n.system_hints.map( ({name: r, description: s, action_label: o, short_label: i, logo: a, system_hint: l, aliases: c=[], required_features: u=[], required_models: d=[], required_conversation_modes: f=[], composer_bar_button_info: p, suggested_prompt: m, allow_in_temporary_chat: v, persist_between_messages: _, regex_matches: y, is_auto: b, category: S, requires_opt_in: C}) => ({
                name: r,
                description: s,
                actionLabel: o ?? void 0,
                shortLabel: i ?? void 0,
                logo: a,
                systemHint: l,
                aliases: c,
                requiredFeatures: u,
                requiredModels: d,
                requiredConversationModes: f,
                composerBarButtonInfo: p ? {
                    announcementKey: p.announcement_key,
                    disabledText: p.disabled_text,
                    nuxTitle: p.nux_title,
                    nuxDescription: p.nux_description,
                    tooltipText: p.tooltip_text,
                    rateLimitReachedText: p.rate_limit_reached_text ?? void 0
                } : void 0,
                suggestedPrompt: m ? {
                    theme: m.theme,
                    title: m.title,
                    subtitle: m.subtitle,
                    sortOrder: m.sort_order,
                    badge: m.badge ?? void 0
                } : void 0,
                allowInTemporaryChat: v,
                persistBetweenMessages: !!_,
                regexMatches: y ?? void 0,
                isAuto: b,
                category: S,
                requiresOptIn: !!C
            }))
        }
        ,
        select: t,
        staleTime: 1 / 0,
        enabled: e ?? !0
    })
}
function Vs() {
    return so({
        queryKey: ["userSettings"],
        queryFn: () => ie.safeGet("/settings/user", {
            authOption: Qt.SendIfAvailable
        })
    })
}
const cL = en(e => Zf(e, Vs));
function uL(e) {
    const {session: t} = Qf()
      , n = t != null;
    return At({
        ...Vs(),
        enabled: n,
        select: e
    })
}
function xee(e) {
    return uL(t => t.settings[e])
}
function Tee(e=!1) {
    const t = Lr();
    return nr({
        mutationFn: ({setting: n, value: r}) => ie.safePatch("/settings/account_user_setting", {
            parameters: {
                query: {
                    feature: n,
                    value: r.toString()
                }
            }
        }),
        onMutate: async ({setting: n, value: r}) => {
            if (e) {
                await t.cancelQueries(Vs());
                const s = t.getQueryData(Vs().queryKey);
                return t.setQueryData(Vs().queryKey, o => o && {
                    ...o,
                    settings: {
                        ...o.settings,
                        [n]: r
                    }
                }),
                {
                    previousValue: s
                }
            }
        }
        ,
        onError: (n, r, s) => {
            e && s !== void 0 && t.setQueryData(Vs().queryKey, s.previousValue)
        }
        ,
        onSuccess: (n, {setting: r}) => {
            t.invalidateQueries(Vs()),
            r === zu.DeveloperMode && t.invalidateQueries({
                queryKey: aL()
            })
        }
    })
}
function n1(e, t) {
    return At({
        queryKey: ["workspace-settings", e],
        queryFn: e ? () => ie.safeGet("/accounts/{account_id}/settings", {
            parameters: {
                path: {
                    account_id: e
                }
            }
        }) : c$,
        select: n => n && t ? t(n) : n
    })
}
const dL = ["AD", "AE", "AF", "AG", "AL", "AM", "AO", "AR", "AT", "AU", "AZ", "BA", "BB", "BD", "BE", "BF", "BG", "BH", "BI", "BJ", "BN", "BO", "BR", "BS", "BT", "BW", "BZ", "CA", "CD", "CF", "CG", "CH", "CI", "CL", "CM", "CO", "CR", "CV", "CY", "CZ", "DE", "DJ", "DK", "DM", "DO", "DZ", "EC", "EE", "EG", "ER", "ES", "ET", "FI", "FJ", "FM", "FR", "GA", "GB", "GD", "GE", "GF", "GH", "GM", "GN", "GP", "GQ", "GR", "GT", "GW", "GY", "HN", "HR", "HT", "HU", "ID", "IE", "IL", "IN", "IQ", "IS", "IT", "JM", "JO", "JP", "KE", "KG", "KH", "KI", "KM", "KN", "KR", "KW", "KZ", "LA", "LB", "LC", "LI", "LK", "LR", "LS", "LT", "LU", "LV", "LY", "MA", "MC", "MD", "ME", "MF", "MG", "MH", "MK", "ML", "MM", "MN", "MQ", "MR", "MT", "MU", "MV", "MW", "MX", "MY", "MZ", "NA", "NE", "NG", "NI", "NL", "NO", "NP", "NR", "NZ", "OM", "PA", "PE", "PG", "PH", "PK", "PL", "PR", "PS", "PT", "PW", "PY", "QA", "RE", "RO", "RS", "RW", "SA", "SB", "SC", "SD", "SE", "SG", "SI", "SK", "SL", "SM", "SN", "SO", "SR", "SS", "ST", "SV", "SZ", "TD", "TG", "TH", "TJ", "TL", "TM", "TN", "TO", "TR", "TT", "TV", "TW", "TZ", "UA", "UG", "US", "UY", "UZ", "VA", "VC", "VN", "VU", "WS", "XK", "YE", "YT", "ZA", "ZM", "ZW"]
  , kee = new Set(["AT", "BE", "BG", "HR", "CY", "CZ", "DK", "EE", "FI", "FR", "DE", "GF", "GP", "GR", "HU", "IS", "IE", "IT", "LV", "LI", "LT", "LU", "MF", "MQ", "MT", "NL", "NO", "PL", "PT", "RE", "RO", "SK", "SI", "ES", "SE", "YT"])
  , Oee = new Set(["GF", "GP", "MF", "MQ", "RE", "YT"])
  , fp = "US"
  , Aee = "GB"
  , Mee = "CH"
  , Iee = "IN"
  , Ree = {
    AL: "Albania",
    DZ: "Algeria",
    AF: "Afghanistan",
    AD: "Andorra",
    AO: "Angola",
    AG: "Antigua & Barbuda",
    AR: "Argentina",
    AM: "Armenia",
    AU: "Australia",
    AT: "Austria",
    AZ: "Azerbaijan",
    BS: "Bahamas",
    BH: "Bahrain",
    BD: "Bangladesh",
    BB: "Barbados",
    BE: "Belgium",
    BZ: "Belize",
    BJ: "Benin",
    BT: "Bhutan",
    BO: "Bolivia",
    BA: "Bosnia & Herzegovina",
    BW: "Botswana",
    BR: "Brazil",
    BN: "Brunei",
    BG: "Bulgaria",
    BF: "Burkina Faso",
    BI: "Burundi",
    CV: "Cape Verde",
    KH: "Cambodia",
    CM: "Cameroon",
    CA: "Canada",
    CF: "Central African Republic",
    TD: "Chad",
    CL: "Chile",
    CO: "Colombia",
    KM: "Comoros",
    CG: "Congo - Brazzaville",
    CD: "Congo - Kinshasa",
    CR: "Costa Rica",
    CI: "CÃ´te dâ€™Ivoire",
    HR: "Croatia",
    CY: "Cyprus",
    CZ: "Czechia",
    DK: "Denmark",
    DJ: "Djibouti",
    DM: "Dominica",
    DO: "Dominican Republic",
    EC: "Ecuador",
    EG: "Egypt",
    SV: "El Salvador",
    GQ: "Equatorial Guinea",
    ER: "Eritrea",
    EE: "Estonia",
    SZ: "Eswatini",
    ET: "Ethiopia",
    FJ: "Fiji",
    FI: "Finland",
    FR: "France",
    GF: "French Guiana",
    GA: "Gabon",
    GM: "Gambia",
    GE: "Georgia",
    DE: "Germany",
    GH: "Ghana",
    GR: "Greece",
    GD: "Grenada",
    GP: "Guadeloupe",
    GT: "Guatemala",
    GN: "Guinea",
    GW: "Guinea-Bissau",
    GY: "Guyana",
    HT: "Haiti",
    VA: "Vatican City",
    HN: "Honduras",
    HU: "Hungary",
    IS: "Iceland",
    IN: "India",
    ID: "Indonesia",
    IQ: "Iraq",
    IE: "Ireland",
    IL: "Israel",
    IT: "Italy",
    JM: "Jamaica",
    JP: "Japan",
    JO: "Jordan",
    KZ: "Kazakhstan",
    KE: "Kenya",
    KI: "Kiribati",
    KW: "Kuwait",
    KG: "Kyrgyzstan",
    LA: "Laos",
    LV: "Latvia",
    LB: "Lebanon",
    LS: "Lesotho",
    LR: "Liberia",
    LY: "Libya",
    LI: "Liechtenstein",
    LT: "Lithuania",
    LU: "Luxembourg",
    MG: "Madagascar",
    MW: "Malawi",
    MY: "Malaysia",
    MV: "Maldives",
    ML: "Mali",
    MT: "Malta",
    MH: "Marshall Islands",
    MQ: "Martinique",
    MR: "Mauritania",
    MU: "Mauritius",
    YT: "Mayotte",
    MX: "Mexico",
    FM: "Micronesia",
    MD: "Moldova",
    MC: "Monaco",
    MN: "Mongolia",
    ME: "Montenegro",
    MA: "Morocco",
    MZ: "Mozambique",
    MM: "Myanmar (Burma)",
    NA: "Namibia",
    NR: "Nauru",
    NP: "Nepal",
    NL: "Netherlands",
    NZ: "New Zealand",
    NI: "Nicaragua",
    NE: "Niger",
    NG: "Nigeria",
    MK: "North Macedonia",
    NO: "Norway",
    OM: "Oman",
    PK: "Pakistan",
    PW: "Palau",
    PS: "Palestine",
    PA: "Panama",
    PG: "Papua New Guinea",
    PY: "Paraguay",
    PE: "Peru",
    PH: "Philippines",
    PL: "Poland",
    PR: "Puerto Rico",
    PT: "Portugal",
    QA: "Qatar",
    RE: "RÃ©union",
    RO: "Romania",
    RW: "Rwanda",
    KN: "St. Kitts & Nevis",
    LC: "St. Lucia",
    VC: "St. Vincent & Grenadines",
    MF: "Saint Martin",
    WS: "Samoa",
    SM: "San Marino",
    ST: "SÃ£o TomÃ© & PrÃ­ncipe",
    SA: "Saudi Arabia",
    SN: "Senegal",
    RS: "Serbia",
    SC: "Seychelles",
    SL: "Sierra Leone",
    SG: "Singapore",
    SK: "Slovakia",
    SI: "Slovenia",
    SB: "Solomon Islands",
    SO: "Somalia",
    ZA: "South Africa",
    KR: "South Korea",
    SS: "South Sudan",
    ES: "Spain",
    LK: "Sri Lanka",
    SR: "Suriname",
    SE: "Sweden",
    CH: "Switzerland",
    SD: "Sudan",
    TW: "Taiwan",
    TJ: "Tajikistan",
    TZ: "Tanzania",
    TH: "Thailand",
    TL: "Timor-Leste",
    TG: "Togo",
    TO: "Tonga",
    TT: "Trinidad & Tobago",
    TN: "Tunisia",
    TR: "TÃ¼rkiye",
    TM: "Turkmenistan",
    TV: "Tuvalu",
    UG: "Uganda",
    UA: "Ukraine",
    AE: "United Arab Emirates",
    GB: "United Kingdom",
    US: "United States",
    UY: "Uruguay",
    UZ: "Uzbekistan",
    VU: "Vanuatu",
    VN: "Vietnam",
    XK: "Kosovo",
    YE: "Yemen",
    ZM: "Zambia",
    ZW: "Zimbabwe"
};
function Nee(e) {
    return dL.includes(e)
}
function cxe({country: e, shouldUseDefaultCountryCode: t}) {
    return t ? (q.addAction(`Force using ${fp}`, {
        user_country: e
    }),
    fp) : e == null || !Nee(e) ? (q.addError(`User country is null or unrecognized - will use ${fp}`, {
        user_country: e
    }),
    fp) : e
}
function Pee(e) {
    try {
        const t = new Intl.DisplayNames([e],{
            type: "region"
        });
        return n => t.of(n) ?? ""
    } catch (t) {
        return q.addError("Failed to create country display name formatter, will fallback to en_US locale display name", {
            cause: t
        }),
        n => Ree[n] ?? ""
    }
}
function Dee() {
    const e = ue()
      , t = un(e);
    return h.useMemo( () => Pee(t.locale), [t.locale])
}
function uxe() {
    const e = Dee();
    return h.useMemo( () => [...dL].sort( (n, r) => {
        const s = e(n)
          , o = e(r);
        return s.localeCompare(o)
    }
    ), [e])
}
function Lee(e) {
    return kee.has(e)
}
function dxe(e) {
    return e == null ? (q.addError(new Error("nullish_country_for_vat_collection_exclusion_check"), {
        country: e
    }),
    !1) : Oee.has(e)
}
const fxe = ["USD", "GBP", "EUR", "INR"]
  , fL = "USD"
  , Fee = "GBP"
  , o9 = "EUR"
  , jee = "INR";
function hxe(e, t=[]) {
    return Lee(e) || e === Mee ? o9 : e === Aee ? Fee : t.includes(e) && e === Iee ? jee : fL
}
const ba = xt({
    dollarSign: {
        id: "currencyCodes.dollarSign",
        defaultMessage: "$"
    },
    dollarCode: {
        id: "currencyCodes.dollarCode",
        defaultMessage: "USD"
    },
    poundSign: {
        id: "currencyCodes.poundSign",
        defaultMessage: "Â£"
    },
    poundCode: {
        id: "currencyCodes.poundCode",
        defaultMessage: "GBP"
    },
    euroSign: {
        id: "currencyCodes.euroSign",
        defaultMessage: "â‚¬"
    },
    euroCode: {
        id: "currencyCodes.euroCode",
        defaultMessage: "EUR"
    },
    inrSign: {
        id: "currencyCodes.inrSign",
        defaultMessage: "â‚¹"
    },
    inrCode: {
        id: "currencyCodes.inrCode",
        defaultMessage: "INR"
    }
})
  , pxe = {
    sign: ba.dollarSign,
    code: ba.dollarCode
}
  , mxe = {
    sign: ba.poundSign,
    code: ba.poundCode
}
  , gxe = {
    sign: ba.euroSign,
    code: ba.euroCode
}
  , vxe = {
    sign: ba.inrSign,
    code: ba.inrCode
};
function sh(e) {
    return e === We.EDUCATION_CBP || e === We.DEPRECATED_EDU
}
function Uee(e) {
    return e === We.QUORUM
}
function r1(e) {
    return e === We.ENTERPRISE_CBP || e === We.DEPRECATED_ENTERPRISE || sh(e) || Uee(e)
}
var q0, i9;
function Bee() {
    if (i9)
        return q0;
    i9 = 1;
    function e() {
        this.__data__ = [],
        this.size = 0
    }
    return q0 = e,
    q0
}
var G0, a9;
function U6() {
    if (a9)
        return G0;
    a9 = 1;
    function e(t, n) {
        return t === n || t !== t && n !== n
    }
    return G0 = e,
    G0
}
var V0, l9;
function s1() {
    if (l9)
        return V0;
    l9 = 1;
    var e = U6();
    function t(n, r) {
        for (var s = n.length; s--; )
            if (e(n[s][0], r))
                return s;
        return -1
    }
    return V0 = t,
    V0
}
var H0, c9;
function qee() {
    if (c9)
        return H0;
    c9 = 1;
    var e = s1()
      , t = Array.prototype
      , n = t.splice;
    function r(s) {
        var o = this.__data__
          , i = e(o, s);
        if (i < 0)
            return !1;
        var a = o.length - 1;
        return i == a ? o.pop() : n.call(o, i, 1),
        --this.size,
        !0
    }
    return H0 = r,
    H0
}
var z0, u9;
function Gee() {
    if (u9)
        return z0;
    u9 = 1;
    var e = s1();
    function t(n) {
        var r = this.__data__
          , s = e(r, n);
        return s < 0 ? void 0 : r[s][1]
    }
    return z0 = t,
    z0
}
var $0, d9;
function Vee() {
    if (d9)
        return $0;
    d9 = 1;
    var e = s1();
    function t(n) {
        return e(this.__data__, n) > -1
    }
    return $0 = t,
    $0
}
var W0, f9;
function Hee() {
    if (f9)
        return W0;
    f9 = 1;
    var e = s1();
    function t(n, r) {
        var s = this.__data__
          , o = e(s, n);
        return o < 0 ? (++this.size,
        s.push([n, r])) : s[o][1] = r,
        this
    }
    return W0 = t,
    W0
}
var K0, h9;
function o1() {
    if (h9)
        return K0;
    h9 = 1;
    var e = Bee()
      , t = qee()
      , n = Gee()
      , r = Vee()
      , s = Hee();
    function o(i) {
        var a = -1
          , l = i == null ? 0 : i.length;
        for (this.clear(); ++a < l; ) {
            var c = i[a];
            this.set(c[0], c[1])
        }
    }
    return o.prototype.clear = e,
    o.prototype.delete = t,
    o.prototype.get = n,
    o.prototype.has = r,
    o.prototype.set = s,
    K0 = o,
    K0
}
var Y0, p9;
function zee() {
    if (p9)
        return Y0;
    p9 = 1;
    var e = o1();
    function t() {
        this.__data__ = new e,
        this.size = 0
    }
    return Y0 = t,
    Y0
}
var Z0, m9;
function $ee() {
    if (m9)
        return Z0;
    m9 = 1;
    function e(t) {
        var n = this.__data__
          , r = n.delete(t);
        return this.size = n.size,
        r
    }
    return Z0 = e,
    Z0
}
var J0, g9;
function Wee() {
    if (g9)
        return J0;
    g9 = 1;
    function e(t) {
        return this.__data__.get(t)
    }
    return J0 = e,
    J0
}
var X0, v9;
function Kee() {
    if (v9)
        return X0;
    v9 = 1;
    function e(t) {
        return this.__data__.has(t)
    }
    return X0 = e,
    X0
}
var Q0, _9;
function hL() {
    if (_9)
        return Q0;
    _9 = 1;
    var e = typeof Xc == "object" && Xc && Xc.Object === Object && Xc;
    return Q0 = e,
    Q0
}
var ev, y9;
function fo() {
    if (y9)
        return ev;
    y9 = 1;
    var e = hL()
      , t = typeof self == "object" && self && self.Object === Object && self
      , n = e || t || Function("return this")();
    return ev = n,
    ev
}
var tv, b9;
function Wu() {
    if (b9)
        return tv;
    b9 = 1;
    var e = fo()
      , t = e.Symbol;
    return tv = t,
    tv
}
var nv, C9;
function Yee() {
    if (C9)
        return nv;
    C9 = 1;
    var e = Wu()
      , t = Object.prototype
      , n = t.hasOwnProperty
      , r = t.toString
      , s = e ? e.toStringTag : void 0;
    function o(i) {
        var a = n.call(i, s)
          , l = i[s];
        try {
            i[s] = void 0;
            var c = !0
        } catch {}
        var u = r.call(i);
        return c && (a ? i[s] = l : delete i[s]),
        u
    }
    return nv = o,
    nv
}
var rv, S9;
function Zee() {
    if (S9)
        return rv;
    S9 = 1;
    var e = Object.prototype
      , t = e.toString;
    function n(r) {
        return t.call(r)
    }
    return rv = n,
    rv
}
var sv, w9;
function Ku() {
    if (w9)
        return sv;
    w9 = 1;
    var e = Wu()
      , t = Yee()
      , n = Zee()
      , r = "[object Null]"
      , s = "[object Undefined]"
      , o = e ? e.toStringTag : void 0;
    function i(a) {
        return a == null ? a === void 0 ? s : r : o && o in Object(a) ? t(a) : n(a)
    }
    return sv = i,
    sv
}
var ov, E9;
function Bo() {
    if (E9)
        return ov;
    E9 = 1;
    function e(t) {
        var n = typeof t;
        return t != null && (n == "object" || n == "function")
    }
    return ov = e,
    ov
}
var iv, x9;
function pL() {
    if (x9)
        return iv;
    x9 = 1;
    var e = Ku()
      , t = Bo()
      , n = "[object AsyncFunction]"
      , r = "[object Function]"
      , s = "[object GeneratorFunction]"
      , o = "[object Proxy]";
    function i(a) {
        if (!t(a))
            return !1;
        var l = e(a);
        return l == r || l == s || l == n || l == o
    }
    return iv = i,
    iv
}
var av, T9;
function Jee() {
    if (T9)
        return av;
    T9 = 1;
    var e = fo()
      , t = e["__core-js_shared__"];
    return av = t,
    av
}
var lv, k9;
function Xee() {
    if (k9)
        return lv;
    k9 = 1;
    var e = Jee()
      , t = function() {
        var r = /[^.]+$/.exec(e && e.keys && e.keys.IE_PROTO || "");
        return r ? "Symbol(src)_1." + r : ""
    }();
    function n(r) {
        return !!t && t in r
    }
    return lv = n,
    lv
}
var cv, O9;
function mL() {
    if (O9)
        return cv;
    O9 = 1;
    var e = Function.prototype
      , t = e.toString;
    function n(r) {
        if (r != null) {
            try {
                return t.call(r)
            } catch {}
            try {
                return r + ""
            } catch {}
        }
        return ""
    }
    return cv = n,
    cv
}
var uv, A9;
function Qee() {
    if (A9)
        return uv;
    A9 = 1;
    var e = pL()
      , t = Xee()
      , n = Bo()
      , r = mL()
      , s = /[\\^$.*+?()[\]{}|]/g
      , o = /^\[object .+?Constructor\]$/
      , i = Function.prototype
      , a = Object.prototype
      , l = i.toString
      , c = a.hasOwnProperty
      , u = RegExp("^" + l.call(c).replace(s, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
    function d(f) {
        if (!n(f) || t(f))
            return !1;
        var p = e(f) ? u : o;
        return p.test(r(f))
    }
    return uv = d,
    uv
}
var dv, M9;
function ete() {
    if (M9)
        return dv;
    M9 = 1;
    function e(t, n) {
        return t?.[n]
    }
    return dv = e,
    dv
}
var fv, I9;
function ec() {
    if (I9)
        return fv;
    I9 = 1;
    var e = Qee()
      , t = ete();
    function n(r, s) {
        var o = t(r, s);
        return e(o) ? o : void 0
    }
    return fv = n,
    fv
}
var hv, R9;
function B6() {
    if (R9)
        return hv;
    R9 = 1;
    var e = ec()
      , t = fo()
      , n = e(t, "Map");
    return hv = n,
    hv
}
var pv, N9;
function i1() {
    if (N9)
        return pv;
    N9 = 1;
    var e = ec()
      , t = e(Object, "create");
    return pv = t,
    pv
}
var mv, P9;
function tte() {
    if (P9)
        return mv;
    P9 = 1;
    var e = i1();
    function t() {
        this.__data__ = e ? e(null) : {},
        this.size = 0
    }
    return mv = t,
    mv
}
var gv, D9;
function nte() {
    if (D9)
        return gv;
    D9 = 1;
    function e(t) {
        var n = this.has(t) && delete this.__data__[t];
        return this.size -= n ? 1 : 0,
        n
    }
    return gv = e,
    gv
}
var vv, L9;
function rte() {
    if (L9)
        return vv;
    L9 = 1;
    var e = i1()
      , t = "__lodash_hash_undefined__"
      , n = Object.prototype
      , r = n.hasOwnProperty;
    function s(o) {
        var i = this.__data__;
        if (e) {
            var a = i[o];
            return a === t ? void 0 : a
        }
        return r.call(i, o) ? i[o] : void 0
    }
    return vv = s,
    vv
}
var _v, F9;
function ste() {
    if (F9)
        return _v;
    F9 = 1;
    var e = i1()
      , t = Object.prototype
      , n = t.hasOwnProperty;
    function r(s) {
        var o = this.__data__;
        return e ? o[s] !== void 0 : n.call(o, s)
    }
    return _v = r,
    _v
}
var yv, j9;
function ote() {
    if (j9)
        return yv;
    j9 = 1;
    var e = i1()
      , t = "__lodash_hash_undefined__";
    function n(r, s) {
        var o = this.__data__;
        return this.size += this.has(r) ? 0 : 1,
        o[r] = e && s === void 0 ? t : s,
        this
    }
    return yv = n,
    yv
}
var bv, U9;
function ite() {
    if (U9)
        return bv;
    U9 = 1;
    var e = tte()
      , t = nte()
      , n = rte()
      , r = ste()
      , s = ote();
    function o(i) {
        var a = -1
          , l = i == null ? 0 : i.length;
        for (this.clear(); ++a < l; ) {
            var c = i[a];
            this.set(c[0], c[1])
        }
    }
    return o.prototype.clear = e,
    o.prototype.delete = t,
    o.prototype.get = n,
    o.prototype.has = r,
    o.prototype.set = s,
    bv = o,
    bv
}
var Cv, B9;
function ate() {
    if (B9)
        return Cv;
    B9 = 1;
    var e = ite()
      , t = o1()
      , n = B6();
    function r() {
        this.size = 0,
        this.__data__ = {
            hash: new e,
            map: new (n || t),
            string: new e
        }
    }
    return Cv = r,
    Cv
}
var Sv, q9;
function lte() {
    if (q9)
        return Sv;
    q9 = 1;
    function e(t) {
        var n = typeof t;
        return n == "string" || n == "number" || n == "symbol" || n == "boolean" ? t !== "__proto__" : t === null
    }
    return Sv = e,
    Sv
}
var wv, G9;
function a1() {
    if (G9)
        return wv;
    G9 = 1;
    var e = lte();
    function t(n, r) {
        var s = n.__data__;
        return e(r) ? s[typeof r == "string" ? "string" : "hash"] : s.map
    }
    return wv = t,
    wv
}
var Ev, V9;
function cte() {
    if (V9)
        return Ev;
    V9 = 1;
    var e = a1();
    function t(n) {
        var r = e(this, n).delete(n);
        return this.size -= r ? 1 : 0,
        r
    }
    return Ev = t,
    Ev
}
var xv, H9;
function ute() {
    if (H9)
        return xv;
    H9 = 1;
    var e = a1();
    function t(n) {
        return e(this, n).get(n)
    }
    return xv = t,
    xv
}
var Tv, z9;
function dte() {
    if (z9)
        return Tv;
    z9 = 1;
    var e = a1();
    function t(n) {
        return e(this, n).has(n)
    }
    return Tv = t,
    Tv
}
var kv, $9;
function fte() {
    if ($9)
        return kv;
    $9 = 1;
    var e = a1();
    function t(n, r) {
        var s = e(this, n)
          , o = s.size;
        return s.set(n, r),
        this.size += s.size == o ? 0 : 1,
        this
    }
    return kv = t,
    kv
}
var Ov, W9;
function q6() {
    if (W9)
        return Ov;
    W9 = 1;
    var e = ate()
      , t = cte()
      , n = ute()
      , r = dte()
      , s = fte();
    function o(i) {
        var a = -1
          , l = i == null ? 0 : i.length;
        for (this.clear(); ++a < l; ) {
            var c = i[a];
            this.set(c[0], c[1])
        }
    }
    return o.prototype.clear = e,
    o.prototype.delete = t,
    o.prototype.get = n,
    o.prototype.has = r,
    o.prototype.set = s,
    Ov = o,
    Ov
}
var Av, K9;
function hte() {
    if (K9)
        return Av;
    K9 = 1;
    var e = o1()
      , t = B6()
      , n = q6()
      , r = 200;
    function s(o, i) {
        var a = this.__data__;
        if (a instanceof e) {
            var l = a.__data__;
            if (!t || l.length < r - 1)
                return l.push([o, i]),
                this.size = ++a.size,
                this;
            a = this.__data__ = new n(l)
        }
        return a.set(o, i),
        this.size = a.size,
        this
    }
    return Av = s,
    Av
}
var Mv, Y9;
function G6() {
    if (Y9)
        return Mv;
    Y9 = 1;
    var e = o1()
      , t = zee()
      , n = $ee()
      , r = Wee()
      , s = Kee()
      , o = hte();
    function i(a) {
        var l = this.__data__ = new e(a);
        this.size = l.size
    }
    return i.prototype.clear = t,
    i.prototype.delete = n,
    i.prototype.get = r,
    i.prototype.has = s,
    i.prototype.set = o,
    Mv = i,
    Mv
}
var Iv, Z9;
function pte() {
    if (Z9)
        return Iv;
    Z9 = 1;
    var e = "__lodash_hash_undefined__";
    function t(n) {
        return this.__data__.set(n, e),
        this
    }
    return Iv = t,
    Iv
}
var Rv, J9;
function mte() {
    if (J9)
        return Rv;
    J9 = 1;
    function e(t) {
        return this.__data__.has(t)
    }
    return Rv = e,
    Rv
}
var Nv, X9;
function gL() {
    if (X9)
        return Nv;
    X9 = 1;
    var e = q6()
      , t = pte()
      , n = mte();
    function r(s) {
        var o = -1
          , i = s == null ? 0 : s.length;
        for (this.__data__ = new e; ++o < i; )
            this.add(s[o])
    }
    return r.prototype.add = r.prototype.push = t,
    r.prototype.has = n,
    Nv = r,
    Nv
}
var Pv, Q9;
function gte() {
    if (Q9)
        return Pv;
    Q9 = 1;
    function e(t, n) {
        for (var r = -1, s = t == null ? 0 : t.length; ++r < s; )
            if (n(t[r], r, t))
                return !0;
        return !1
    }
    return Pv = e,
    Pv
}
var Dv, e8;
function vL() {
    if (e8)
        return Dv;
    e8 = 1;
    function e(t, n) {
        return t.has(n)
    }
    return Dv = e,
    Dv
}
var Lv, t8;
function _L() {
    if (t8)
        return Lv;
    t8 = 1;
    var e = gL()
      , t = gte()
      , n = vL()
      , r = 1
      , s = 2;
    function o(i, a, l, c, u, d) {
        var f = l & r
          , p = i.length
          , m = a.length;
        if (p != m && !(f && m > p))
            return !1;
        var v = d.get(i)
          , _ = d.get(a);
        if (v && _)
            return v == a && _ == i;
        var y = -1
          , b = !0
          , S = l & s ? new e : void 0;
        for (d.set(i, a),
        d.set(a, i); ++y < p; ) {
            var C = i[y]
              , w = a[y];
            if (c)
                var x = f ? c(w, C, y, a, i, d) : c(C, w, y, i, a, d);
            if (x !== void 0) {
                if (x)
                    continue;
                b = !1;
                break
            }
            if (S) {
                if (!t(a, function(E, T) {
                    if (!n(S, T) && (C === E || u(C, E, l, c, d)))
                        return S.push(T)
                })) {
                    b = !1;
                    break
                }
            } else if (!(C === w || u(C, w, l, c, d))) {
                b = !1;
                break
            }
        }
        return d.delete(i),
        d.delete(a),
        b
    }
    return Lv = o,
    Lv
}
var Fv, n8;
function yL() {
    if (n8)
        return Fv;
    n8 = 1;
    var e = fo()
      , t = e.Uint8Array;
    return Fv = t,
    Fv
}
var jv, r8;
function vte() {
    if (r8)
        return jv;
    r8 = 1;
    function e(t) {
        var n = -1
          , r = Array(t.size);
        return t.forEach(function(s, o) {
            r[++n] = [o, s]
        }),
        r
    }
    return jv = e,
    jv
}
var Uv, s8;
function V6() {
    if (s8)
        return Uv;
    s8 = 1;
    function e(t) {
        var n = -1
          , r = Array(t.size);
        return t.forEach(function(s) {
            r[++n] = s
        }),
        r
    }
    return Uv = e,
    Uv
}
var Bv, o8;
function _te() {
    if (o8)
        return Bv;
    o8 = 1;
    var e = Wu()
      , t = yL()
      , n = U6()
      , r = _L()
      , s = vte()
      , o = V6()
      , i = 1
      , a = 2
      , l = "[object Boolean]"
      , c = "[object Date]"
      , u = "[object Error]"
      , d = "[object Map]"
      , f = "[object Number]"
      , p = "[object RegExp]"
      , m = "[object Set]"
      , v = "[object String]"
      , _ = "[object Symbol]"
      , y = "[object ArrayBuffer]"
      , b = "[object DataView]"
      , S = e ? e.prototype : void 0
      , C = S ? S.valueOf : void 0;
    function w(x, E, T, k, A, O, M) {
        switch (T) {
        case b:
            if (x.byteLength != E.byteLength || x.byteOffset != E.byteOffset)
                return !1;
            x = x.buffer,
            E = E.buffer;
        case y:
            return !(x.byteLength != E.byteLength || !O(new t(x), new t(E)));
        case l:
        case c:
        case f:
            return n(+x, +E);
        case u:
            return x.name == E.name && x.message == E.message;
        case p:
        case v:
            return x == E + "";
        case d:
            var I = s;
        case m:
            var R = k & i;
            if (I || (I = o),
            x.size != E.size && !R)
                return !1;
            var D = M.get(x);
            if (D)
                return D == E;
            k |= a,
            M.set(x, E);
            var P = r(I(x), I(E), k, A, O, M);
            return M.delete(x),
            P;
        case _:
            if (C)
                return C.call(x) == C.call(E)
        }
        return !1
    }
    return Bv = w,
    Bv
}
var qv, i8;
function H6() {
    if (i8)
        return qv;
    i8 = 1;
    function e(t, n) {
        for (var r = -1, s = n.length, o = t.length; ++r < s; )
            t[o + r] = n[r];
        return t
    }
    return qv = e,
    qv
}
var Gv, a8;
function ks() {
    if (a8)
        return Gv;
    a8 = 1;
    var e = Array.isArray;
    return Gv = e,
    Gv
}
var Vv, l8;
function bL() {
    if (l8)
        return Vv;
    l8 = 1;
    var e = H6()
      , t = ks();
    function n(r, s, o) {
        var i = s(r);
        return t(r) ? i : e(i, o(r))
    }
    return Vv = n,
    Vv
}
var Hv, c8;
function yte() {
    if (c8)
        return Hv;
    c8 = 1;
    function e(t, n) {
        for (var r = -1, s = t == null ? 0 : t.length, o = 0, i = []; ++r < s; ) {
            var a = t[r];
            n(a, r, t) && (i[o++] = a)
        }
        return i
    }
    return Hv = e,
    Hv
}
var zv, u8;
function CL() {
    if (u8)
        return zv;
    u8 = 1;
    function e() {
        return []
    }
    return zv = e,
    zv
}
var $v, d8;
function z6() {
    if (d8)
        return $v;
    d8 = 1;
    var e = yte()
      , t = CL()
      , n = Object.prototype
      , r = n.propertyIsEnumerable
      , s = Object.getOwnPropertySymbols
      , o = s ? function(i) {
        return i == null ? [] : (i = Object(i),
        e(s(i), function(a) {
            return r.call(i, a)
        }))
    }
    : t;
    return $v = o,
    $v
}
var Wv, f8;
function bte() {
    if (f8)
        return Wv;
    f8 = 1;
    function e(t, n) {
        for (var r = -1, s = Array(t); ++r < t; )
            s[r] = n(r);
        return s
    }
    return Wv = e,
    Wv
}
var Kv, h8;
function La() {
    if (h8)
        return Kv;
    h8 = 1;
    function e(t) {
        return t != null && typeof t == "object"
    }
    return Kv = e,
    Kv
}
var Yv, p8;
function Cte() {
    if (p8)
        return Yv;
    p8 = 1;
    var e = Ku()
      , t = La()
      , n = "[object Arguments]";
    function r(s) {
        return t(s) && e(s) == n
    }
    return Yv = r,
    Yv
}
var Zv, m8;
function $6() {
    if (m8)
        return Zv;
    m8 = 1;
    var e = Cte()
      , t = La()
      , n = Object.prototype
      , r = n.hasOwnProperty
      , s = n.propertyIsEnumerable
      , o = e(function() {
        return arguments
    }()) ? e : function(i) {
        return t(i) && r.call(i, "callee") && !s.call(i, "callee")
    }
    ;
    return Zv = o,
    Zv
}
var Ld = {
    exports: {}
}, Jv, g8;
function Ste() {
    if (g8)
        return Jv;
    g8 = 1;
    function e() {
        return !1
    }
    return Jv = e,
    Jv
}
Ld.exports;
var v8;
function W6() {
    return v8 || (v8 = 1,
    function(e, t) {
        var n = fo()
          , r = Ste()
          , s = t && !t.nodeType && t
          , o = s && !0 && e && !e.nodeType && e
          , i = o && o.exports === s
          , a = i ? n.Buffer : void 0
          , l = a ? a.isBuffer : void 0
          , c = l || r;
        e.exports = c
    }(Ld, Ld.exports)),
    Ld.exports
}
var Xv, _8;
function K6() {
    if (_8)
        return Xv;
    _8 = 1;
    var e = 9007199254740991
      , t = /^(?:0|[1-9]\d*)$/;
    function n(r, s) {
        var o = typeof r;
        return s = s ?? e,
        !!s && (o == "number" || o != "symbol" && t.test(r)) && r > -1 && r % 1 == 0 && r < s
    }
    return Xv = n,
    Xv
}
var Qv, y8;
function Y6() {
    if (y8)
        return Qv;
    y8 = 1;
    var e = 9007199254740991;
    function t(n) {
        return typeof n == "number" && n > -1 && n % 1 == 0 && n <= e
    }
    return Qv = t,
    Qv
}
var e_, b8;
function wte() {
    if (b8)
        return e_;
    b8 = 1;
    var e = Ku()
      , t = Y6()
      , n = La()
      , r = "[object Arguments]"
      , s = "[object Array]"
      , o = "[object Boolean]"
      , i = "[object Date]"
      , a = "[object Error]"
      , l = "[object Function]"
      , c = "[object Map]"
      , u = "[object Number]"
      , d = "[object Object]"
      , f = "[object RegExp]"
      , p = "[object Set]"
      , m = "[object String]"
      , v = "[object WeakMap]"
      , _ = "[object ArrayBuffer]"
      , y = "[object DataView]"
      , b = "[object Float32Array]"
      , S = "[object Float64Array]"
      , C = "[object Int8Array]"
      , w = "[object Int16Array]"
      , x = "[object Int32Array]"
      , E = "[object Uint8Array]"
      , T = "[object Uint8ClampedArray]"
      , k = "[object Uint16Array]"
      , A = "[object Uint32Array]"
      , O = {};
    O[b] = O[S] = O[C] = O[w] = O[x] = O[E] = O[T] = O[k] = O[A] = !0,
    O[r] = O[s] = O[_] = O[o] = O[y] = O[i] = O[a] = O[l] = O[c] = O[u] = O[d] = O[f] = O[p] = O[m] = O[v] = !1;
    function M(I) {
        return n(I) && t(I.length) && !!O[e(I)]
    }
    return e_ = M,
    e_
}
var t_, C8;
function Z6() {
    if (C8)
        return t_;
    C8 = 1;
    function e(t) {
        return function(n) {
            return t(n)
        }
    }
    return t_ = e,
    t_
}
var Fd = {
    exports: {}
};
Fd.exports;
var S8;
function J6() {
    return S8 || (S8 = 1,
    function(e, t) {
        var n = hL()
          , r = t && !t.nodeType && t
          , s = r && !0 && e && !e.nodeType && e
          , o = s && s.exports === r
          , i = o && n.process
          , a = function() {
            try {
                var l = s && s.require && s.require("util").types;
                return l || i && i.binding && i.binding("util")
            } catch {}
        }();
        e.exports = a
    }(Fd, Fd.exports)),
    Fd.exports
}
var n_, w8;
function SL() {
    if (w8)
        return n_;
    w8 = 1;
    var e = wte()
      , t = Z6()
      , n = J6()
      , r = n && n.isTypedArray
      , s = r ? t(r) : e;
    return n_ = s,
    n_
}
var r_, E8;
function wL() {
    if (E8)
        return r_;
    E8 = 1;
    var e = bte()
      , t = $6()
      , n = ks()
      , r = W6()
      , s = K6()
      , o = SL()
      , i = Object.prototype
      , a = i.hasOwnProperty;
    function l(c, u) {
        var d = n(c)
          , f = !d && t(c)
          , p = !d && !f && r(c)
          , m = !d && !f && !p && o(c)
          , v = d || f || p || m
          , _ = v ? e(c.length, String) : []
          , y = _.length;
        for (var b in c)
            (u || a.call(c, b)) && !(v && (b == "length" || p && (b == "offset" || b == "parent") || m && (b == "buffer" || b == "byteLength" || b == "byteOffset") || s(b, y))) && _.push(b);
        return _
    }
    return r_ = l,
    r_
}
var s_, x8;
function X6() {
    if (x8)
        return s_;
    x8 = 1;
    var e = Object.prototype;
    function t(n) {
        var r = n && n.constructor
          , s = typeof r == "function" && r.prototype || e;
        return n === s
    }
    return s_ = t,
    s_
}
var o_, T8;
function EL() {
    if (T8)
        return o_;
    T8 = 1;
    function e(t, n) {
        return function(r) {
            return t(n(r))
        }
    }
    return o_ = e,
    o_
}
var i_, k8;
function Ete() {
    if (k8)
        return i_;
    k8 = 1;
    var e = EL()
      , t = e(Object.keys, Object);
    return i_ = t,
    i_
}
var a_, O8;
function xte() {
    if (O8)
        return a_;
    O8 = 1;
    var e = X6()
      , t = Ete()
      , n = Object.prototype
      , r = n.hasOwnProperty;
    function s(o) {
        if (!e(o))
            return t(o);
        var i = [];
        for (var a in Object(o))
            r.call(o, a) && a != "constructor" && i.push(a);
        return i
    }
    return a_ = s,
    a_
}
var l_, A8;
function l1() {
    if (A8)
        return l_;
    A8 = 1;
    var e = pL()
      , t = Y6();
    function n(r) {
        return r != null && t(r.length) && !e(r)
    }
    return l_ = n,
    l_
}
var c_, M8;
function Yu() {
    if (M8)
        return c_;
    M8 = 1;
    var e = wL()
      , t = xte()
      , n = l1();
    function r(s) {
        return n(s) ? e(s) : t(s)
    }
    return c_ = r,
    c_
}
var u_, I8;
function xL() {
    if (I8)
        return u_;
    I8 = 1;
    var e = bL()
      , t = z6()
      , n = Yu();
    function r(s) {
        return e(s, n, t)
    }
    return u_ = r,
    u_
}
var d_, R8;
function Tte() {
    if (R8)
        return d_;
    R8 = 1;
    var e = xL()
      , t = 1
      , n = Object.prototype
      , r = n.hasOwnProperty;
    function s(o, i, a, l, c, u) {
        var d = a & t
          , f = e(o)
          , p = f.length
          , m = e(i)
          , v = m.length;
        if (p != v && !d)
            return !1;
        for (var _ = p; _--; ) {
            var y = f[_];
            if (!(d ? y in i : r.call(i, y)))
                return !1
        }
        var b = u.get(o)
          , S = u.get(i);
        if (b && S)
            return b == i && S == o;
        var C = !0;
        u.set(o, i),
        u.set(i, o);
        for (var w = d; ++_ < p; ) {
            y = f[_];
            var x = o[y]
              , E = i[y];
            if (l)
                var T = d ? l(E, x, y, i, o, u) : l(x, E, y, o, i, u);
            if (!(T === void 0 ? x === E || c(x, E, a, l, u) : T)) {
                C = !1;
                break
            }
            w || (w = y == "constructor")
        }
        if (C && !w) {
            var k = o.constructor
              , A = i.constructor;
            k != A && "constructor"in o && "constructor"in i && !(typeof k == "function" && k instanceof k && typeof A == "function" && A instanceof A) && (C = !1)
        }
        return u.delete(o),
        u.delete(i),
        C
    }
    return d_ = s,
    d_
}
var f_, N8;
function kte() {
    if (N8)
        return f_;
    N8 = 1;
    var e = ec()
      , t = fo()
      , n = e(t, "DataView");
    return f_ = n,
    f_
}
var h_, P8;
function Ote() {
    if (P8)
        return h_;
    P8 = 1;
    var e = ec()
      , t = fo()
      , n = e(t, "Promise");
    return h_ = n,
    h_
}
var p_, D8;
function TL() {
    if (D8)
        return p_;
    D8 = 1;
    var e = ec()
      , t = fo()
      , n = e(t, "Set");
    return p_ = n,
    p_
}
var m_, L8;
function Ate() {
    if (L8)
        return m_;
    L8 = 1;
    var e = ec()
      , t = fo()
      , n = e(t, "WeakMap");
    return m_ = n,
    m_
}
var g_, F8;
function c1() {
    if (F8)
        return g_;
    F8 = 1;
    var e = kte()
      , t = B6()
      , n = Ote()
      , r = TL()
      , s = Ate()
      , o = Ku()
      , i = mL()
      , a = "[object Map]"
      , l = "[object Object]"
      , c = "[object Promise]"
      , u = "[object Set]"
      , d = "[object WeakMap]"
      , f = "[object DataView]"
      , p = i(e)
      , m = i(t)
      , v = i(n)
      , _ = i(r)
      , y = i(s)
      , b = o;
    return (e && b(new e(new ArrayBuffer(1))) != f || t && b(new t) != a || n && b(n.resolve()) != c || r && b(new r) != u || s && b(new s) != d) && (b = function(S) {
        var C = o(S)
          , w = C == l ? S.constructor : void 0
          , x = w ? i(w) : "";
        if (x)
            switch (x) {
            case p:
                return f;
            case m:
                return a;
            case v:
                return c;
            case _:
                return u;
            case y:
                return d
            }
        return C
    }
    ),
    g_ = b,
    g_
}
var v_, j8;
function Mte() {
    if (j8)
        return v_;
    j8 = 1;
    var e = G6()
      , t = _L()
      , n = _te()
      , r = Tte()
      , s = c1()
      , o = ks()
      , i = W6()
      , a = SL()
      , l = 1
      , c = "[object Arguments]"
      , u = "[object Array]"
      , d = "[object Object]"
      , f = Object.prototype
      , p = f.hasOwnProperty;
    function m(v, _, y, b, S, C) {
        var w = o(v)
          , x = o(_)
          , E = w ? u : s(v)
          , T = x ? u : s(_);
        E = E == c ? d : E,
        T = T == c ? d : T;
        var k = E == d
          , A = T == d
          , O = E == T;
        if (O && i(v)) {
            if (!i(_))
                return !1;
            w = !0,
            k = !1
        }
        if (O && !k)
            return C || (C = new e),
            w || a(v) ? t(v, _, y, b, S, C) : n(v, _, E, y, b, S, C);
        if (!(y & l)) {
            var M = k && p.call(v, "__wrapped__")
              , I = A && p.call(_, "__wrapped__");
            if (M || I) {
                var R = M ? v.value() : v
                  , D = I ? _.value() : _;
                return C || (C = new e),
                S(R, D, y, b, C)
            }
        }
        return O ? (C || (C = new e),
        r(v, _, y, b, S, C)) : !1
    }
    return v_ = m,
    v_
}
var __, U8;
function Q6() {
    if (U8)
        return __;
    U8 = 1;
    var e = Mte()
      , t = La();
    function n(r, s, o, i, a) {
        return r === s ? !0 : r == null || s == null || !t(r) && !t(s) ? r !== r && s !== s : e(r, s, o, i, n, a)
    }
    return __ = n,
    __
}
var y_, B8;
function Ite() {
    if (B8)
        return y_;
    B8 = 1;
    var e = Q6();
    function t(n, r) {
        return e(n, r)
    }
    return y_ = t,
    y_
}
var Rte = Ite();
const Nte = mn(Rte);
function kL(e) {
    return e !== We.FREE
}
const Pte = "ext-oai-did"
  , _xe = "ext-login-allow-phone"
  , yxe = "ext-whatsapp-al-flow";
function Dte(e) {
    return {
        [Pte]: e
    }
}
const Lte = o6.OpenAISidetron;
function Fte(e) {
    if (un(e).isElectron)
        return Lte
}
function jte(e, t) {
    const n = Fte(e);
    return n ?? o6.OpenAI
}
function Au(e, {fallbackScreenHint: t="login_or_signup", useFallbackScreenHint: n=!1, callbackUrl: r="/", additionalAuthParams: s={}, callback: o, shouldOpenPaymentModalOnAuth: i=!1}={}) {
    const a = jte(e, new URL(window.location.href).searchParams);
    let l = t;
    !n && t !== "login_or_signup" && $t(e, "1803944755").get("enable_unified_login_or_signup_start_page_at_chatgpt_web", !1) && (l = "login_or_signup"),
    i && ze.setBooleanCookie(Be.ShowPaymentModal, !0, {
        maxAge: 6 * 60 * 60
    });
    const c = Ts();
    ze.setCookie(Be.AuthSessionLoggingId, c),
    o?.(a),
    NS.signIn(a, {
        callbackUrl: r
    }, {
        prompt: "login",
        screen_hint: l,
        ...Dte(xi()),
        [bZ]: c,
        ...s
    })
}
const Ute = We.FREE
  , Bte = Jd.OWNER
  , qte = "AccountState";
uW(qte, e => ({
    ...e,
    accountItems: e.accountItems.map(t => new Fm(t.data))
}));
function OL(e) {
    return Date.parse(e) / 1e3
}
function Gc(e) {
    if (e == null)
        return;
    const t = OL(e);
    if (!isNaN(t))
        return t
}
class Fm {
    constructor(t) {
        this.data = t
    }
    get id() {
        return this.data.id
    }
    get residencyRegion() {
        return this.data.residencyRegion
    }
    get computeResidency() {
        return this.data.computeResidency
    }
    get computeResidencyDisplayName() {
        return this.data.computeResidencyDisplayName
    }
    get computeResidencyDescription() {
        return this.data.computeResidencyDescription
    }
    get isHipaaCompliantWorkspace() {
        return this.data.isHipaaCompliantWorkspace ?? !1
    }
    get structure() {
        return this.data.structure
    }
    get workspaceType() {
        return this.data.workspaceType
    }
    get eligibleForReactivation() {
        return this.data.eligibleForReactivation
    }
    get organizationId() {
        return this.data.organizationId
    }
    get name() {
        return this.data.name
    }
    get features() {
        return this.data.features
    }
    isEqual(t) {
        return Nte(this.data, t.data)
    }
    get planType() {
        return this.data.subscriptionStatus.planType
    }
    get canAccessWithCurrentSession() {
        return this.data.canAccessWithCurrentSession
    }
    get ssoConnectionName() {
        return this.data.ssoConnectionName
    }
    get isDelinquent() {
        return this.data.subscriptionStatus.isDelinquent
    }
    get gracePeriodId() {
        return this.data.subscriptionStatus.gracePeriodId
    }
    get accountUserId() {
        return this.data.accountUserId
    }
    get normalizedAccountUserId() {
        return this.isPersonalAccount() ? this.authUserId : this.data.accountUserId
    }
    get authUserId() {
        return this.data.accountUserId?.split("__")[0]
    }
    get subscriptionAnalyticsParams() {
        const {subscriptionStatus: t} = this.data;
        return {
            currentPlanType: t.planType,
            subscriptionStatus: {
                billingPeriod: t.billingPeriod,
                hasPaidSubscription: t.hasPaidSubscription,
                subscriptionPlan: t.subscriptionPlan,
                subscriptionExpiresAt: t.subscriptionExpiresAt,
                wasPaidCustomer: t.wasPaidCustomer
            }
        }
    }
    isResellerHosted() {
        return this.data.subscriptionStatus.isResellerHosted
    }
    isEnterprisey() {
        return r1(this.data.subscriptionStatus.planType)
    }
    isRBACEnabled() {
        return this.isEnterprisey()
    }
    isWorkspacePlan() {
        return this.isEnterprisey() || this.isTeam()
    }
    isPro() {
        return this.data.subscriptionStatus.planType === We.PRO
    }
    isEdu() {
        return sh(this.data.subscriptionStatus.planType)
    }
    isTeam() {
        return this.data.subscriptionStatus.planType === We.SELF_SERVE_BUSINESS
    }
    isGo() {
        return this.data.subscriptionStatus.planType === We.GO
    }
    isPlus() {
        return this.data.subscriptionStatus.planType === We.PLUS
    }
    isFree() {
        return this.data.subscriptionStatus.planType === We.FREE
    }
    isCBP() {
        return this.data.subscriptionStatus.planType === We.ENTERPRISE_CBP || this.data.subscriptionStatus.planType === We.EDUCATION_CBP
    }
    isWorkspaceAccount() {
        return this.data.structure === Dr.WORKSPACE
    }
    getWorkspaceId() {
        if (this.isWorkspaceAccount())
            return this.id
    }
    getDaysUntilPlanRenews() {
        const t = this.data.subscriptionStatus.subscriptionRenewsAt;
        if (t == null)
            return null;
        const n = Math.floor(Date.now() / 1e3);
        return Math.ceil((t - n) / (60 * 60 * 24))
    }
    getDaysUntilSubscriptionCancelAt() {
        const t = this.data.subscriptionStatus.subscriptionCancelsAt;
        if (t == null)
            return null;
        const n = Math.floor(Date.now() / 1e3);
        return Math.ceil((t - n) / (60 * 60 * 24))
    }
    getDaysUntilPlanDiscountExpires() {
        const t = Gc(this.data.subscriptionStatus.discount?.discount_expires_at);
        if (t == null)
            return null;
        const n = Math.floor(Date.now() / 1e3);
        return Math.ceil((t - n) / (60 * 60 * 24))
    }
    isPersonalAccount() {
        return this.data.structure === Dr.PERSONAL
    }
    hasPaidSubscription() {
        return this.data.subscriptionStatus.hasPaidSubscription
    }
    isActiveSubscriptionGratis() {
        return this.data.subscriptionStatus.isActiveSubscriptionGratis
    }
    getSubscriptionBillingCurrency() {
        return this.data.subscriptionStatus.billingCurrency
    }
    mustGetSubscriptionBillingCurrency(t) {
        const n = this.getSubscriptionBillingCurrency();
        return n !== void 0 ? (q.addAction("chatgpt_present_subscription_billing_currency", {
            subscriptionBillingCurrency: n,
            callLocation: t
        }),
        bm(Ot(), "chatgpt_present_subscription_billing_currency", void 0, {
            subscriptionBillingCurrency: n,
            callLocation: t
        }),
        n) : (q.addError(new Error("chatgpt_missing_subscription_billing_currency"), {
            callLocation: t
        }),
        bm(Ot(), "chatgpt_missing_subscription_billing_currency", void 0, {
            callLocation: t
        }),
        fL)
    }
    willRenewSubscription() {
        return this.data.subscriptionStatus.lastActiveSubscription.will_renew
    }
    willPlanChange() {
        return !!this.data.subscriptionStatus.scheduledPlanChange
    }
    getDaysUntilPlanChanges() {
        const t = this.data.subscriptionStatus.scheduledPlanChange?.changesAt;
        if (t == null)
            return null;
        const n = Math.floor(Date.now() / 1e3);
        return Math.ceil((t - n) / (60 * 60 * 24))
    }
    getNextPlanType() {
        return this.data.subscriptionStatus.scheduledPlanChange?.planType ?? null
    }
    getLastActiveSubscription() {
        return this.data.subscriptionStatus.lastActiveSubscription
    }
    isDeactivated() {
        return this.data.deactivated
    }
    canInviteMembers() {
        return this.isTeam() || this.isEnterprisey() && (this.isOwnerOfAccount() || this.isAdminOfAccount())
    }
    isOwnerOfAccount() {
        return this.data.role === Jd.OWNER
    }
    isAdminOfAccount() {
        return this.data.role === Jd.ADMIN
    }
    isStandardUserOfAccount() {
        return this.data.role === Jd.STANDARD
    }
    hasPaidFeatures() {
        return this.hasPaidSubscription() || this.isEnterprisey()
    }
    hasCustomerObject() {
        return this.data.subscriptionStatus.hasCustomerObject
    }
    getProcessorEntity() {
        return this.data.subscriptionStatus.processorEntity
    }
    wasPaidCustomer() {
        return !this.data.subscriptionStatus.hasPaidSubscription && this.data.subscriptionStatus.wasPaidCustomer
    }
    isOrWasPaidCustomer() {
        return this.data.subscriptionStatus.hasPaidSubscription || this.data.subscriptionStatus.wasPaidCustomer
    }
    isEligibleForCancellationPromotion() {
        return this.data.subscriptionStatus.isEligibleForCancellationPromotion
    }
}
class ew {
    constructor(t) {
        this.data = t
    }
    static fromLightAccount(t, n) {
        return new ew({
            lightAccount: t,
            authUserId: n
        })
    }
    get id() {
        return this.data.lightAccount.id
    }
    get authUserId() {
        return this.data.authUserId
    }
    get structure() {
        return this.data.lightAccount.structure
    }
    get planType() {
        return this.data.lightAccount.planType
    }
    get isDelinquent() {
        return this.data.lightAccount.isDelinquent
    }
    get gracePeriodId() {
        return this.data.lightAccount.gracePeriodId
    }
    get accountUserId() {
        return this.data.authUserId ? this.data.authUserId + "__" + this.data.lightAccount.id : void 0
    }
    get normalizedAccountUserId() {
        return this.isPersonalAccount() ? this.data.authUserId : this.accountUserId
    }
    isEnterprisey() {
        return r1(this.planType)
    }
    isRBACEnabled() {
        return this.isEnterprisey()
    }
    isWorkspacePlan() {
        return this.isEnterprisey() || this.isTeam()
    }
    isGo() {
        return this.planType === We.GO
    }
    isPro() {
        return this.planType === We.PRO
    }
    isEdu() {
        return sh(this.planType)
    }
    isTeam() {
        return this.planType === We.SELF_SERVE_BUSINESS
    }
    isBusiness() {
        return this.planType === We.ENTERPRISE_CBP
    }
    isPlus() {
        return this.planType === We.PLUS
    }
    isFree() {
        return this.planType === We.FREE
    }
    isCBP() {
        return this.planType === We.ENTERPRISE_CBP || this.planType === We.EDUCATION_CBP
    }
    hasPaidSubscription() {
        return kL(this.planType)
    }
    hasPaidFeatures() {
        return this.hasPaidSubscription() || this.isEnterprisey()
    }
    isWorkspaceAccount() {
        return this.structure === Dr.WORKSPACE
    }
    getWorkspaceId() {
        if (this.isWorkspaceAccount())
            return this.id
    }
    isPersonalAccount() {
        return this.structure === Dr.PERSONAL
    }
    hasPlusFeatures() {
        return this.planType !== We.FREE
    }
}
function Gte(e) {
    return e.account_ordering.map(t => {
        const n = e.accounts[t];
        return new Fm({
            id: n.account.account_id,
            residencyRegion: n.account.account_residency_region,
            computeResidency: n.account.account_compute_residency,
            computeResidencyDisplayName: n.account.account_compute_residency_display_name,
            computeResidencyDescription: n.account.account_compute_residency_description,
            accountUserId: n.account.account_user_id,
            name: n.account.name ?? null,
            profilePictureId: n.account.profile_picture_id,
            profilePictureUrl: n.account.profile_picture_url,
            structure: n.account.structure,
            workspaceType: n.account.workspace_type,
            role: n.account.account_user_role ?? Bte,
            organizationId: n.account.organization_id,
            deactivated: n.account.is_deactivated,
            eligibleForReactivation: n.account.eligible_for_reactivation,
            ekmConfig: n.account.ekm_config,
            isHipaaCompliantWorkspace: n.account.is_hipaa_compliant_workspace,
            subscriptionStatus: {
                billingPeriod: n.entitlement.billing_period,
                hasPaidSubscription: n.entitlement.has_active_subscription || !1,
                isActiveSubscriptionGratis: n.entitlement.is_active_subscription_gratis || !1,
                billingCurrency: n.entitlement.billing_currency,
                subscriptionPlan: n.entitlement.subscription_plan,
                planType: n.account.plan_type ?? Ute,
                subscriptionRenewsAt: Gc(n.entitlement.renews_at),
                subscriptionCancelsAt: Gc(n.entitlement.cancels_at),
                subscriptionExpiresAt: Gc(n.entitlement.expires_at),
                scheduledPlanChange: n.entitlement.scheduled_plan_change ? {
                    changesAt: OL(n.entitlement.scheduled_plan_change.changes_at),
                    planType: n.entitlement.scheduled_plan_change.plan_type
                } : void 0,
                wasPaidCustomer: n.account.has_previously_paid_subscription ?? !1,
                hasCustomerObject: n.account.processor?.a001.has_customer_object ?? !1,
                processorEntity: n.account.processor?.a001.processor_entity,
                lastActiveSubscription: n.last_active_subscription,
                isResellerHosted: n.account.reseller_hosted_account ?? !1,
                discount: n.entitlement.discount,
                isEligibleForCancellationPromotion: n.entitlement.is_eligible_for_cp ?? !1,
                isDelinquent: n.entitlement.is_delinquent,
                becameDelinquentAt: Gc(n.entitlement.became_delinquent_timestamp),
                gracePeriodEndAt: Gc(n.entitlement.grace_period_end_timestamp),
                gracePeriodId: n.entitlement.grace_period_id
            },
            features: [...n.features].sort(),
            canAccessWithCurrentSession: n.can_access_with_session !== !1,
            ssoConnectionName: n.sso_connection_name ?? null
        })
    }
    )
}
function Vte(e, t) {
    const n = e.filter(s => s.canAccessWithCurrentSession);
    if (typeof t == "string") {
        const s = n.find(o => o.id === t);
        if (s !== void 0)
            return s;
        if (t === di) {
            const o = n.find(i => i.structure === Dr.PERSONAL);
            if (o !== void 0)
                return o
        }
    }
    if (n.length === 1 || !n.some(s => s.structure === Dr.WORKSPACE))
        return n[0]
}
function Hte(e, t) {
    if (e) {
        if (e.structure === Dr.WORKSPACE)
            return e.id;
        if (t.some(r => r.structure === Dr.WORKSPACE))
            return di
    }
}
async function zte() {
    const e = await ie.safeGet("/accounts/check/{version}", {
        parameters: {
            path: {
                version: iW
            },
            query: {
                timezone_offset_min: new Date().getTimezoneOffset().toString()
            }
        },
        intercomEventOnError: "fetch-error:accounts:get",
        authOption: Qt.SendIfAvailable
    })
      , t = ze.getCookie(Be.Workspace) ?? void 0
      , n = Gte(e)
      , r = Vte(n, t);
    return {
        accountItems: n,
        currentAccountId: r?.id
    }
}
function $te(e, t) {
    return e instanceof Fm && t instanceof Fm && e.isEqual(t) ? e : u$(e, t)
}
const Wte = so({
    queryKey: ["account-status"],
    queryFn: zte,
    structuralSharing: $te,
    staleTime: 1 / 0
});
function Ci() {
    return Wte
}
function u1(e) {
    return e?.accountItems.find(t => t.id === e.currentAccountId) ?? null
}
function Kte(e) {
    const t = e.getQueryData(Ci().queryKey);
    return u1(t)
}
function l5(e) {
    e != null ? ze.setCookie(Be.Workspace, e, {
        maxAge: PD
    }) : ze.deleteCookie(Be.Workspace)
}
function Yte(e) {
    ze.setCookie(Be.WorkspaceResidencyRegion, e, {
        maxAge: PD
    })
}
function AL(e, t) {
    const n = ze.getCookie(Be.Workspace);
    return e.structure === Dr.WORKSPACE ? (l5(e.id),
    Yte(e.residencyRegion)) : e.structure === Dr.PERSONAL && t && l5(di),
    ze.deleteCookie(Be.DowngradeAccountEnabled),
    ze.deleteCookie(Be.DogfoodingAccountType),
    {
        accountCookieChanged: (n ?? di) !== (ze.getCookie(Be.Workspace) ?? di)
    }
}
function bxe(e, t, n=!0) {
    const r = e.getQueryData(Ci().queryKey);
    if (r == null)
        return {
            updatedAccount: !1
        };
    const s = r.accountItems.find(o => o.id === t);
    return s == null ? {
        updatedAccount: !1
    } : (AL(s, n),
    e.setQueryData(Ci().queryKey, {
        ...r,
        currentAccountId: t
    }),
    {
        updatedAccount: !0
    })
}
function Cxe(e, t, n, r, s, o=!0) {
    const i = e.getQueryData(Ci().queryKey);
    if (i == null)
        return {
            willRedirect: !1,
            updatedAccount: !1
        };
    const a = i.accountItems.find(c => c.id === t);
    if (a == null)
        return {
            willRedirect: !1,
            updatedAccount: !1
        };
    const {accountCookieChanged: l} = AL(a, o);
    if (!a.canAccessWithCurrentSession) {
        const c = a.ssoConnectionName ? {
            connection: a.ssoConnectionName
        } : void 0
          , u = r.formatMessage(q8.workspacePlaceholder)
          , d = a.data.name || u;
        return s.info(r.formatMessage(q8.authenticateNotice, {
            workspaceName: d
        })),
        Au(n, {
            fallbackScreenHint: "login",
            additionalAuthParams: c
        }),
        {
            willRedirect: !0,
            updatedAccount: !0
        }
    }
    return l ? L6() : e.setQueryData(Ci().queryKey, {
        ...i,
        currentAccountId: t
    }),
    {
        willRedirect: !1,
        updatedAccount: !0
    }
}
function ML() {
    return At(Ci())
}
function ir() {
    return At({
        ...Ci(),
        select: u1
    }).data ?? null
}
const bn = en(e => {
    const t = Jf(e)
      , n = t?.user?.id
      , r = t?.account ?? null;
    return r ? ew.fromLightAccount(r, n) : null
}
);
function Sxe() {
    return ir()?.isHipaaCompliantWorkspace ?? !1
}
function IL() {
    return ir()?.features
}
function wxe(e) {
    return IL()?.includes(e) ?? !1
}
function Exe() {
    const e = ir()
      , t = n1(e?.getWorkspaceId())
      , n = t.isLoading ? null : t.data?.allow_third_party_gpts === "allow_specific";
    return e?.isOwnerOfAccount() && n
}
function RL(e) {
    return e.accountItems.some(t => t.hasPaidFeatures())
}
function xxe(e) {
    return !e?.accountItems.every(n => n.isPlus() || n.isFree() || n.isGo())
}
function Txe(e) {
    "use forget";
    const t = De.c(5)
      , n = ir();
    let r;
    t[0] !== n ? (r = n?.isRBACEnabled(),
    t[0] = n,
    t[1] = r) : r = t[1];
    const s = r
      , o = lL(s);
    if (!s)
        return !0;
    let i;
    return t[2] !== e || t[3] !== o.data ? (i = o.data != null && o.data.some(a => a.systemHint === e),
    t[2] = e,
    t[3] = o.data,
    t[4] = i) : i = t[4],
    i
}
const q8 = xt({
    authenticateNotice: {
        id: "zALe8U",
        defaultMessage: "You need to authenticate to access {workspaceName}. Redirecting..."
    },
    workspacePlaceholder: {
        id: "IIY4N4",
        defaultMessage: "this workspace"
    }
})
  , Zte = ["default", "blue", "green", "yellow", "pink", "orange"]
  , Jte = ["purple"]
  , Xte = ["black"]
  , Qte = e => {
    const t = bn(e)?.planType
      , n = t === We.PLUS
      , r = t === We.PRO
      , s = t === We.SELF_SERVE_BUSINESS || r1(t)
      , i = !sh(t) && (n || r || s);
    return [...Zte, ...i ? Jte : [], ...r ? Xte : []]
}
;
function NL(e) {
    return $t(e, "1187049270").get("themes_enabled", !1)
}
const PL = en(e => dn( () => Wt.getItem(Ft.ChatTheme, {
    userId: bn(e)?.normalizedAccountUserId
}) ?? "default"))
  , DL = (e, t) => {
    PL(e).setState(t),
    Wt.setItem(Ft.ChatTheme, t, {
        userId: bn(e)?.normalizedAccountUserId
    })
}
;
function ene() {
    const e = ue();
    return PL(e)()
}
function kxe() {
    const e = ue()
      , t = NL(e)
      , n = ene()
      , r = Tee();
    return t ? {
        isLoading: !1,
        value: n,
        setValue: s => {
            r.mutate({
                setting: zu.ChatTheme,
                value: s
            }),
            DL(e, s)
        }
    } : {
        isLoading: !1,
        value: "default",
        setValue: () => {}
    }
}
const tne = ({cspScriptNonce: e}) => {
    const t = ue();
    if (!NL(t))
        return null;
    const n = Kp(Ft.ChatTheme, {
        userId: bn(t)?.normalizedAccountUserId
    });
    return g.jsx("script", {
        nonce: e,
        suppressHydrationWarning: !0,
        children: `!function(){try{const t=localStorage.getItem(${JSON.stringify(n)});document.documentElement.dataset.chatTheme="string"==typeof t?JSON.parse(t):void 0}catch(e){}}();`
    })
}
;
function nne(e) {
    const t = Qte(e)
      , n = Na( () => {
        const s = cL(e)().data?.settings[zu.ChatTheme] ?? Wt.getItem(Ft.ChatTheme, {
            userId: bn(e)?.normalizedAccountUserId
        });
        return XP(s, t, "default")
    }
    );
    return qY( () => {
        const r = n();
        document.documentElement.dataset.chatTheme = r,
        DL(e, r)
    }
    )
}
var rne = (e => (e.Small = "small",
e.Medium = "medium",
e.Large = "large",
e.XLarge = "xlarge",
e))(rne || {});
const d1 = {
    small: 640,
    medium: 768,
    large: 1024,
    xlarge: 1280
};
function sne(e, t) {
    const n = rD()
      , r = h.useRef(null)
      , s = h.useCallback(o => {
        if (n == null)
            return () => {}
            ;
        const i = n.matchMedia(e)
          , a = new AbortController;
        return i.addEventListener("change", l => {
            const c = l.matches
              , u = c !== r.current?.result;
            r.current = {
                win: n,
                query: e,
                result: c
            },
            u && o()
        }
        , {
            signal: a.signal
        }),
        () => {
            a.abort()
        }
    }
    , [e, n]);
    return h.useSyncExternalStore(s, () => {
        const o = io(n);
        if (r.current?.win !== o || r.current?.query !== e) {
            const i = o.matchMedia(e).matches;
            r.current = {
                win: o,
                query: e,
                result: i
            }
        }
        return r.current.result
    }
    , t)
}
function one(e, t) {
    return window.matchMedia(e).matches
}
function tc(e, t) {
    return [ () => sne(e, t), () => one(e)]
}
const [ine] = tc("(prefers-reduced-motion: reduce)", () => !1)
  , [f1,Oxe] = tc(`(min-width: ${d1.small}px)`, () => !J$())
  , [LL,ane] = tc(`(min-width: ${d1.medium}px)`, () => US() || BS())
  , [Axe,Mxe] = tc(`(min-width: ${d1.large}px)`, BS)
  , [Ixe] = tc(`(min-width: ${d1.xlarge}px)`, () => !1)
  , [Rxe,FL] = tc("(pointer: coarse)", wN)
  , [lne,Nxe] = tc("(hover: hover)", BS);
function Pxe() {
    return !LL()
}
function cne() {
    const e = {
        composer: {
            autofocusDisabled$: Ct(xg() || t7()),
            reset: () => {
                e.composer.autofocusDisabled$.set(FL() || t7())
            }
        },
        projects: {
            createOrUpdateProject$: Ct(void 0),
            moveConversationToProject$: Ct(void 0),
            renamingProjectId$: Ct(void 0),
            reset: () => {
                e.projects.renamingProjectId$.set(void 0)
            }
        }
    };
    return e
}
const une = en(cne)
  , dne = "https://cdn.oaistatic.com/assets/chatgpt-share-og-u7j5uyao.webp"
  , fne = {
    src: dne
}
  , hne = "https://cdn.oaistatic.com/assets/favicon-180x180-od45eci6.webp"
  , pne = {
    src: hne
}
  , mne = "data:image/x-icon;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAVfSURBVHgB5VuLUeMwEJWZKyBUgK8Cch2khHRwpgJCBQkVJFSQpAKggtBBuAocKiBUsKcX24wtZHlXlpIwvJkdYyLJ2q/WKzlRkUFEqb6MNF1rSksalNc6dpr25fWfpldQkiQ79d2gmR5pmmvKqT+2mpYYU50z9AQHmqaBmG5DrimjwqrOAzXG3+l4yMtnpuqU0BO4PTLjNkFk6tiA5DVt6HyQ07GsgU6v9TZgThMVE1RE9nPHVMUAFUvRd8GSy1fCaaQH3OrLUH0vIIn609WoUwClNDMVCPv9Xu12u88rkKbp4TocDtVgMFABsdJCuFG+oGKt7Y3NZkOTyYQ0o4RhXYQ24/GYVqsVvb8HibVz5QMqor03MPnZbEZao51MuyjLMsrznHpCtjpQsc57iT8U44EFAV5SxQV55vMwda6Zj0ajA1Mg/K39n9UPruGJDZf5jDywWCxaJw5rQAyAgLr8mhMvYGGemHQxD9PPSQhMqE1jy+WSfIG+bYJAoPQIkugwcAlgSkK0MT+dTkNFcZrP59aYAtfxwCyY9m3MQ2Pb7ZZCAwHQZg1wFyHsVkBC34ev2pgPsGS1AhZlC5aIP0LMbALIub1t2ojNfAWbEOAewmfnJvMiZ8LSZWohhtm3AcyaMcEjHozqAlhye+HhtoB3bDw+Pn6ZB9xSgEVdAGz1mdqH6Z8K0HoPK8jr0Z/Xw6J91zqP37BSxIoNtkAstIIUAhhzW4MhrvbrSyTahcoJTJhWIMwSswslKHQ8Pz837nU21tr25eXl82+89z88PKgY0PGnca/fFZQAQ1jAI1dcZuR1RX5kb6rfUsUCLMucl8DantgBEMyaDHXBXK8RQGPAdAOsEExs4QKsGhRKWA3bGXZ7jraCxj3Ms+4aoVCV1Cq8vb0pJgYQQMppWdXvPnsyandaM1/ixP39vQoNUwCmslxdL5QnuMVLWEG9LSwgtBVcXV017k1lueAtAAlMYQk0FB3RBQCTr2sE5upaPn3w8fHRuJeU1iGAHafh5eVl456jRTBursvmuh0CPvGp6vpLFcdSOnF9fd24f3197exzc9Pck9DL4IEaM9CTv7u76xwPAdWMJ/UxXHN1YN8rEXIlHGbaDLIlQrZXayUshkoSNANPcAH2ommu/WZqXMd6vW7c397eflmuDioQBERbW1hO/f+wEE6OUnUXlcLMGqDr9RO1OsWoFkFb3L0EjgUJs82x6HXYTIeVw9zgHhACytcckwRzLmqDKTxBGnzofrADEtQDzbw7Vn7PgWmRwuLM9tMR9A27rBqgCBEEtrqgcBNmWReAqJZkWkHMgodkDtIhGuGQBG5gswL4+rFg25ARaj9XJjCuZIR6lK/IY5dGDBvzHnEoswkAFQ6RHZtm6DkZNtq24qSbItR2VoCEVgC/t63hoXeJMJZN2J7Pmak2kIcVtG1aqjJ17SMI12kT/M9jNyqnrpMiuoHYkcFk2wkPCAduIZksxnMds+lhYZnJb9IihI0qPnIQAW91eqe29Xe8CyBPB6GKU73ZIZfHOz3yelSLXBUdvBXqbM/nON0uSZLfrJbU45CU61RHH4I1oNTuCdkhqVIIvda0UIIA4wFOm/gdoiZBiuwSBJIkybE5tEXUh8YDZJgzF4+co7IrffmrAgD+DT9H3R5+D6p8GVfEhSpGBDoyu9Z+n7ka/PjD0qyqcDnQWn0frDnMi0HCTPFEWKiYoGJ1+JmfzNSE4HWiNCI2dIpP6KgoqOZ0OhxP6w4hwBpmRxbEe/nMoJ+X9EIpiNgWkZ8d4zZQUWNckeD4XQfTyEhHKgJYiVAfUBGchiVVn9B3fT6P3SpsFr7E/nz+P3T08cw43Z8wAAAAAElFTkSuQmCC"
  , gne = "data:image/svg+xml,%3csvg%20width='64'%20height='64'%20viewBox='0%200%2064%2064'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%20%3e%3crect%20width='64'%20height='64'%20rx='32'%20fill='white'%20/%3e%3cpath%20d='M34.2043%2037.0916H41.6359'%20stroke='black'%20stroke-width='3.42172'%20stroke-linecap='round'%20/%3e%3cpath%20d='M32.089%2053.6889C28.2099%2053.6889%2024.6248%2052.7289%2021.3334%2050.809C18.0421%2048.8499%2015.4169%2046.2247%2013.4578%2042.9334C11.5378%2039.642%2010.5779%2036.0569%2010.5779%2032.1778C10.5779%2028.2987%2011.5378%2024.7136%2013.4578%2021.4222C15.4169%2018.1309%2018.0421%2015.5253%2021.3334%2013.6054C24.6248%2011.6462%2028.2099%2010.6667%2032.089%2010.6667C35.968%2010.6667%2039.5532%2011.6462%2042.8445%2013.6054C46.1359%2015.5253%2048.7415%2018.1309%2050.6614%2021.4222C52.6205%2024.7136%2053.6001%2028.2987%2053.6001%2032.1778C53.6001%2036.0569%2052.6205%2039.642%2050.6614%2042.9334C48.7415%2046.2247%2046.1359%2048.8499%2042.8445%2050.809C39.5532%2052.7289%2035.968%2053.6889%2032.089%2053.6889ZM32.089%2049.6923C35.2628%2049.6923%2038.1818%2048.9087%2040.8462%2047.3414C43.5498%2045.7741%2045.6853%2043.6582%2047.2526%2040.9938C48.8199%2038.2902%2049.6035%2035.3516%2049.6035%2032.1778C49.6035%2029.004%2048.8199%2026.0849%2047.2526%2023.4205C45.6853%2020.717%2043.5498%2018.5815%2040.8462%2017.0142C38.1818%2015.4469%2035.2628%2014.6633%2032.089%2014.6633C28.9152%2014.6633%2025.9765%2015.4469%2023.273%2017.0142C20.6086%2018.5815%2018.4927%2020.717%2016.9254%2023.4205C15.3581%2026.0849%2014.5745%2029.004%2014.5745%2032.1778C14.5745%2035.3516%2015.3581%2038.2902%2016.9254%2040.9938C18.4927%2043.6582%2020.6086%2045.7741%2023.273%2047.3414C25.9765%2048.9087%2028.9152%2049.6923%2032.089%2049.6923ZM24.2133%2039.7008C23.6648%2039.7008%2023.1946%2039.5049%2022.8028%2039.1131C22.411%2038.7212%2022.215%2038.2511%2022.215%2037.7025C22.215%2037.3499%2022.313%2037.0364%2022.5089%2036.7621L25.2713%2032.0602L22.6265%2027.5935C22.3522%2027.1625%2022.215%2026.7706%2022.215%2026.418C22.215%2025.9086%2022.411%2025.458%2022.8028%2025.0662C23.1946%2024.6744%2023.6648%2024.4785%2024.2133%2024.4785C24.9186%2024.4785%2025.4672%2024.7919%2025.859%2025.4188L29.0328%2030.8848C29.2679%2031.2766%2029.3854%2031.6684%2029.3854%2032.0602C29.3854%2032.4521%2029.2679%2032.8439%2029.0328%2033.2357L25.859%2038.7017C25.4672%2039.3678%2024.9186%2039.7008%2024.2133%2039.7008ZM34.2048%2039.1131C33.6563%2039.1131%2033.1861%2038.9172%2032.7943%2038.5253C32.4025%2038.1335%2032.2065%2037.6633%2032.2065%2037.1148C32.2065%2036.6054%2032.4025%2036.1548%2032.7943%2035.763C33.1861%2035.3712%2033.6563%2035.1752%2034.2048%2035.1752H41.7279C42.2372%2035.1752%2042.6878%2035.3712%2043.0796%2035.763C43.4715%2036.1548%2043.6674%2036.6054%2043.6674%2037.1148C43.6674%2037.6633%2043.4715%2038.1335%2043.0796%2038.5253C42.6878%2038.9172%2042.2372%2039.1131%2041.7279%2039.1131H34.2048Z'%20fill='black'%20/%3e%3c/svg%3e"
  , vne = "https://cdn.oaistatic.com/assets/favicon-eex17e9e.ico"
  , _ne = "https://cdn.oaistatic.com/assets/favicon-l4nq08hd.svg"
  , yne = Object.prototype.toString;
function bne(e, t) {
    try {
        return e instanceof t
    } catch {
        return !1
    }
}
function Cne(e) {
    switch (yne.call(e)) {
    case "[object Error]":
    case "[object Exception]":
    case "[object DOMException]":
        return !0;
    default:
        return bne(e, Error)
    }
}
const G8 = {
    componentStack: null,
    error: null
};
function Sne(e, t) {
    const n = new WeakMap;
    function r(s, o) {
        if (!n.has(s)) {
            if (s.cause)
                return n.set(s, !0),
                r(s.cause, o);
            s.cause = o
        }
    }
    r(e, t)
}
const wne = ["The node to be removed is not a child of this node", "The object can not be found here."];
function Ene(e) {
    return wne.some(t => e.message?.includes(t))
}
let tw = class extends h.Component {
    state;
    constructor(t) {
        super(t),
        this.state = G8
    }
    componentDidCatch(t, {componentStack: n}) {
        if (Cne(t)) {
            const r = new Error(t.message);
            r.name = `React ErrorBoundary ${r.name}`,
            r.stack = n ?? "",
            Sne(t, r)
        }
        if (!Ene(t) && (this.props.logRequestErrors === !0 || !(t instanceof _t))) {
            const r = new Error(t.message);
            r.name = "ReactRenderingError",
            r.stack = n ?? "",
            r.cause = t,
            q.addError(r, {
                error_boundary: this.props.name
            })
        }
        JD(),
        this.props.onError && this.props.onError(t, n ?? ""),
        this.setState({
            error: t,
            componentStack: n
        })
    }
    resetErrorBoundary = () => {
        const {onReset: t} = this.props
          , {error: n, componentStack: r} = this.state;
        t && t(n, r ?? ""),
        this.setState(G8)
    }
    ;
    render() {
        const {fallback: t, children: n} = this.props
          , r = this.state;
        if (r.error) {
            let s;
            return typeof t == "function" ? s = t({
                error: r.error,
                componentStack: r.componentStack ?? "",
                resetError: this.resetErrorBoundary
            }) : s = t,
            h.isValidElement(s) ? s : null
        }
        return typeof n == "function" ? n() : n
    }
}
;
function xne(e) {
    if (typeof document > "u")
        throw new Error("not supported in SSR");
    const t = document.createElement("template");
    return t.innerHTML = e,
    t.innerHTML
}
function Tne(e) {
    return `data:image/svg+xml;utf8,${encodeURIComponent(e)}`
}
const Lxe = ({svgString: e, ...t}) => {
    const n = h.useMemo( () => xne(e), [e]);
    return n ? g.jsx("img", {
        src: Tne(n),
        ...t
    }) : null
}
  , Fxe = ({svgString: e, className: t, color: n}) => g.jsx(tw, {
    name: "StringToSVG",
    fallback: g.jsx("div", {
        className: t
    }),
    children: g.jsx("div", {
        className: we("[&_svg]:h-full [&_svg]:w-full", t),
        dangerouslySetInnerHTML: {
            __html: e
        },
        style: {
            color: n
        }
    })
})
  , Oc = xt({
    description: {
        id: "meta.description",
        defaultMessage: "ChatGPT helps you get answers, find inspiration and be more productive. It is free to use and easy to try. Just ask and ChatGPT can help with writing, learning, brainstorming and more."
    },
    keywords: {
        id: "meta.keywords",
        defaultMessage: "ai chat,ai,chap gpt,chat gbt,chat gpt 3,chat gpt login,chat gpt website,chat gpt,chat gtp,chat openai,chat,chatai,chatbot gpt,chatg,chatgpt login,chatgpt,gpt chat,open ai,openai chat,openai chatgpt,openai"
    },
    ogDescription: {
        id: "meta.ogDescription",
        defaultMessage: "A conversational AI system that listens, learns, and challenges"
    }
})
  , kne = [{
    property: "og:title",
    content: "ChatGPT"
}, {
    property: "og:image",
    content: fne.src
}];
function Ac(e, t) {
    const n = new URL(e,"https://chatgpt.com");
    return t && n.searchParams.set("locale", t),
    n.toString()
}
function One() {
    const e = gt()
      , t = ue()
      , n = us(t).checkGate("3125419433")
      , r = cs();
    return wg().some(i => i.handle?.hasRouteMeta) ? null : n ? g.jsxs(g.Fragment, {
        children: [g.jsx("meta", {
            name: "description",
            content: e.formatMessage(Oc.description)
        }), g.jsx("meta", {
            name: "keyword",
            content: e.formatMessage(Oc.keywords)
        }), g.jsx("meta", {
            property: "og:description",
            content: e.formatMessage(Oc.ogDescription)
        }), g.jsx("meta", {
            property: "og:url",
            content: Ac("/", un(t).locale)
        }), g.jsx("meta", {
            property: "og:site_name",
            content: "ChatGPT"
        }), ZQ().map(i => g.jsx("link", {
            rel: "alternate",
            hrefLang: i,
            href: Ac(r.pathname, i)
        }, i)), g.jsx("link", {
            rel: "alternate",
            hrefLang: "x-default",
            href: Ac(r.pathname)
        }), g.jsx("link", {
            rel: "canonical",
            href: Ac(r.pathname)
        })]
    }) : g.jsxs(g.Fragment, {
        children: [g.jsx("meta", {
            name: "description",
            content: Oc.description.defaultMessage
        }), g.jsx("meta", {
            name: "keyword",
            content: Oc.keywords.defaultMessage
        }), g.jsx("meta", {
            property: "og:description",
            content: Oc.ogDescription.defaultMessage
        }), g.jsx("meta", {
            property: "og:url",
            content: Ac("/")
        }), g.jsx("meta", {
            property: "og:site_name",
            content: "ChatGPT"
        }), g.jsx("link", {
            rel: "canonical",
            href: Ac("/")
        })]
    })
}
function Ane() {
    "use forget";
    const e = De.c(6)
      , t = ue();
    let n;
    e[0] !== t ? (n = $t(t, "3927927759").get("enable_mobile_app_upsell_banner", !1),
    e[0] = t,
    e[1] = n) : n = e[1];
    const r = n;
    let s;
    e[2] !== r ? (s = r && g.jsx("link", {
        rel: "manifest",
        href: "/manifest.json"
    }),
    e[2] = r,
    e[3] = s) : s = e[3];
    let o;
    return e[4] !== s ? (o = g.jsx(g.Fragment, {
        children: s
    }),
    e[4] = s,
    e[5] = o) : o = e[5],
    o
}
function Mne({pathname: e}) {
    if (e !== "/")
        return null;
    const t = {
        "@context": "https://schema.org",
        "@type": "WebSite",
        url: "https://chatgpt.com/",
        name: "ChatGPT"
    };
    return g.jsx("script", {
        id: "website-ld",
        type: "application/ld+json",
        children: JSON.stringify(t)
    })
}
function Ine() {
    "use forget";
    const e = De.c(12)
      , t = ue()
      , {pathname: n} = cs()
      , r = !n.startsWith("/share") && !n.startsWith("/s") && !n.startsWith("/canvas/shared");
    let s;
    e[0] !== t ? (s = $t(t, "3927927759").get("enable_mobile_app_upsell_banner", !1),
    e[0] = t,
    e[1] = s) : s = e[1];
    const o = s;
    let i, a;
    e[2] === Symbol.for("react.memo_cache_sentinel") ? (i = g.jsx("link", {
        rel: "preconnect",
        href: "https://cdn.oaistatic.com"
    }),
    a = g.jsx("link", {
        rel: "preconnect",
        href: "https://ab.chatgpt.com"
    }),
    e[2] = i,
    e[3] = a) : (i = e[2],
    a = e[3]);
    let l;
    e[4] !== r ? (l = r && g.jsx("meta", {
        name: "robots",
        content: "index, follow"
    }),
    e[4] = r,
    e[5] = l) : l = e[5];
    let c;
    e[6] === Symbol.for("react.memo_cache_sentinel") ? (c = g.jsx("meta", {
        httpEquiv: "Content-Type",
        content: "text/html; charset=utf-8"
    }),
    e[6] = c) : c = e[6];
    let u;
    e[7] !== o ? (u = o && g.jsx("meta", {
        name: "apple-itunes-app",
        content: "app-id=6448311069"
    }),
    e[7] = o,
    e[8] = u) : u = e[8];
    let d;
    return e[9] !== l || e[10] !== u ? (d = g.jsxs(g.Fragment, {
        children: [i, a, l, c, u]
    }),
    e[9] = l,
    e[10] = u,
    e[11] = d) : d = e[11],
    d
}
function V8({href: e}) {
    return g.jsxs(g.Fragment, {
        children: [g.jsx("link", {
            rel: "icon",
            href: e,
            type: "image/svg+xml"
        }), g.jsx("link", {
            rel: "icon",
            href: e,
            type: "image/svg+xml",
            media: "(prefers-color-scheme: dark)"
        })]
    })
}
function Rne() {
    "use forget";
    const e = De.c(5)
      , {pathname: t} = cs();
    let n;
    e[0] !== t ? (n = t.startsWith("/codex") ? g.jsxs(g.Fragment, {
        children: [g.jsx("link", {
            rel: "icon",
            href: mne,
            sizes: "32x32"
        }), g.jsx(V8, {
            href: gne
        })]
    }) : g.jsxs(g.Fragment, {
        children: [g.jsx("link", {
            rel: "icon",
            href: vne,
            sizes: "32x32"
        }), g.jsx(V8, {
            href: _ne
        })]
    }),
    e[0] = t,
    e[1] = n) : n = e[1];
    let r;
    e[2] === Symbol.for("react.memo_cache_sentinel") ? (r = g.jsx("link", {
        rel: "apple-touch-icon",
        sizes: "180x180",
        href: pne.src
    }),
    e[2] = r) : r = e[2];
    let s;
    return e[3] !== n ? (s = g.jsxs(g.Fragment, {
        children: [n, r]
    }),
    e[3] = n,
    e[4] = s) : s = e[4],
    s
}
const c5 = e => e;
var Mu = (e => (e.ContentOrTos = "content_or_tos",
e.ContentPolicy = "content_policy",
e.BioSafetyContentPolicy = "bio_safety_content_policy",
e.ModelIncompatibility = "model_incompatibility",
e.ContentRegurgitation = "content_regurgitation",
e))(Mu || {});
const jL = {
    errType: "warning",
    errCode: "content_policy"
}
  , Nne = {
    errType: "danger",
    errCode: "model_incompatibility"
}
  , Pne = {
    err: "Contents may violate our content policy",
    errType: "danger",
    errCode: "content_policy"
}
  , UL = {
    err: "Contents may violate our content policy",
    errType: "danger",
    errCode: "content_policy",
    shouldDisableConversation: !0
}
  , Dne = {
    errType: "danger",
    errCode: "bio_safety_content_policy",
    canRetry: !1
}
  , Lne = {
    errType: "danger",
    errCode: "bio_safety_content_policy",
    canRetry: !1,
    shouldDisableConversation: !0
}
  , BL = (e, t) => !e.length || t ? null : {
    disclaimers: e
}
  , qL = ({isSafetyLimited: e, shouldDisableConversation: t, isModelIncompatibility: n}) => e ? t ? Lne : Dne : t ? UL : n ? Nne : Pne;
class Fne {
    isMultimodalTextMessage(t) {
        return t.content.content_type === rt.MultimodalText
    }
    isPartAssetPointer(t) {
        return typeof t != "string" && (t.content_type === Jn.ImageAssetPointer || t.content_type === Jn.AudioAssetPointer)
    }
    isBase64ImagePart(t) {
        return typeof t != "string" && t.content_type === Jn.Image
    }
    isPartRealTimeUserAudioVideoAssetPointer(t) {
        return typeof t != "string" && t.content_type === Jn.RealTimeUserAudioVideoAssetPointer
    }
    isPartAudioTranscription(t) {
        return typeof t != "string" && t.content_type === Jn.AudioTranscription
    }
    getAudio(t) {
        return this.isMultimodalTextMessage(t) ? t.content.parts.filter(n => typeof n != "string" && n.content_type === Jn.Audio) : []
    }
    getAssetPointers(t) {
        return this.isMultimodalTextMessage(t) ? t.content.parts.filter(n => this.isPartAssetPointer(n)) : []
    }
    getImageAssetPointers(t) {
        return this.isMultimodalTextMessage(t) ? this.getImageAssetPointersFromParts(t.content.parts) : []
    }
    getImageAssetPointersFromParts(t) {
        return t.filter(n => this.isPartAssetPointer(n) && n.content_type === Jn.ImageAssetPointer)
    }
    getFrameAssetPointers(t) {
        return this.isMultimodalTextMessage(t) ? t.content.parts.flatMap(n => {
            if (typeof n != "string" && n.content_type === Jn.RealTimeUserAudioVideoAssetPointer)
                return n.frames_asset_pointers
        }
        ).filter(n => !!n) : []
    }
    getAudioAssetPointers(t) {
        return this.isMultimodalTextMessage(t) ? t.content.parts.map(n => {
            if (typeof n != "string")
                switch (n.content_type) {
                case Jn.AudioAssetPointer:
                    return n;
                case Jn.RealTimeUserAudioVideoAssetPointer:
                    return n.audio_asset_pointer;
                default:
                    return
                }
        }
        ).filter(n => !!n) : []
    }
    getVideoContainerAssetPointers(t) {
        return this.isMultimodalTextMessage(t) ? t.content.parts.flatMap(n => typeof n != "string" && n.content_type === Jn.RealTimeUserAudioVideoAssetPointer ? n.video_container_asset_pointer : null).filter(n => !!n) : []
    }
    getImageOperationFileIds(t) {
        const n = t.metadata?.dalle?.from_client?.operation ?? t.metadata?.generation?.from_client?.operation;
        return n?.type === "inpainting" ? {
            operation: "inpainting",
            originalFileId: n.original_file_id,
            maskFileId: n.mask_file_id
        } : n?.type === "transformation" ? {
            operation: "transformation",
            originalFileId: n.original_file_id
        } : void 0
    }
    getPartsAsString(t, n=!0) {
        return this.isMultimodalTextMessage(t) ? t.content.parts.map(r => {
            if (typeof r == "string")
                return r;
            if (this.isPartAudioTranscription(r))
                return r.text;
            if (n) {
                if (this.isPartAssetPointer(r))
                    return `[media pointer="${r.asset_pointer}"]`;
                if (this.isPartRealTimeUserAudioVideoAssetPointer(r)) {
                    const s = r.audio_asset_pointer?.asset_pointer;
                    return s && `[media pointer="${s}"]`
                } else if (this.isBase64ImagePart(r))
                    return r.payload
            } else
                return !1
        }
        ).filter(Boolean).join(`
`) : ""
    }
}
const nw = new Fne
  , jne = ["image_gen"];
var Re = (e => (e[e.no_render = 0] = "no_render",
e[e.BrowseTool = 1] = "BrowseTool",
e[e.Browsing = 2] = "Browsing",
e[e.CanmoreTool = 3] = "CanmoreTool",
e[e.Container = 4] = "Container",
e[e.CodeInterpreter = 5] = "CodeInterpreter",
e[e.CodeInterpreterTool = 6] = "CodeInterpreterTool",
e[e.Dalle = 7] = "Dalle",
e[e.DalleTool = 8] = "DalleTool",
e[e.GizmoEditor = 9] = "GizmoEditor",
e[e.JITPlugin = 10] = "JITPlugin",
e[e.JITPluginTool = 11] = "JITPluginTool",
e[e.JITPluginGoogleTool = 12] = "JITPluginGoogleTool",
e[e.ImagePreloadTool = 13] = "ImagePreloadTool",
e[e.ModelEditableContext = 14] = "ModelEditableContext",
e[e.MultimodalText = 15] = "MultimodalText",
e[e.ParallelBrowsing = 16] = "ParallelBrowsing",
e[e.ParallelBrowsingTool = 17] = "ParallelBrowsingTool",
e[e.RetrievalBrowsing = 18] = "RetrievalBrowsing",
e[e.RetrievalBrowsingTool = 19] = "RetrievalBrowsingTool",
e[e.SearchResultTool = 20] = "SearchResultTool",
e[e.SearchGPTQuery = 21] = "SearchGPTQuery",
e[e.System = 22] = "System",
e[e.SystemContent = 23] = "SystemContent",
e[e.DeveloperContent = 24] = "DeveloperContent",
e[e.Text = 25] = "Text",
e[e.StructuredThoughts = 26] = "StructuredThoughts",
e[e.ReasoningRecap = 27] = "ReasoningRecap",
e[e.UserEditableContext = 28] = "UserEditableContext",
e[e.UserModelBio = 29] = "UserModelBio",
e[e.UserModelBioTool = 30] = "UserModelBioTool",
e[e.Unknown = 31] = "Unknown",
e[e.de1d73e = 32] = "de1d73e",
e[e.a8km123 = 33] = "a8km123",
e[e.f959b8c = 34] = "f959b8c",
e[e.b1de6e2_c = 35] = "b1de6e2_c",
e[e.b1de6e2_s = 36] = "b1de6e2_s",
e[e.b1de6e2_d = 37] = "b1de6e2_d",
e[e.b1de6e2_rm = 38] = "b1de6e2_rm",
e[e.l1p9k3u = 39] = "l1p9k3u",
e[e.l1239dk1 = 40] = "l1239dk1",
e[e.l1239dk2 = 41] = "l1239dk2",
e[e.is_loading_message = 42] = "is_loading_message",
e[e.b47u8ra0_t = 43] = "b47u8ra0_t",
e[e.oiw209h = 44] = "oiw209h",
e[e.oiw209h_c = 45] = "oiw209h_c",
e[e.t2uay3k = 46] = "t2uay3k",
e[e.t2uay3k_c = 47] = "t2uay3k_c",
e[e.c12k321 = 48] = "c12k321",
e[e.Oboe = 49] = "Oboe",
e[e.CoTSearchToolCall = 50] = "CoTSearchToolCall",
e[e.CoTSearchToolResult = 51] = "CoTSearchToolResult",
e[e.n7jupd_c = 52] = "n7jupd_c",
e[e.n7jupd_r = 53] = "n7jupd_r",
e[e.n7jupd_t = 54] = "n7jupd_t",
e[e.n7jupd_m = 55] = "n7jupd_m",
e[e.n7jupd_x = 56] = "n7jupd_x",
e[e.n7jupd_i = 57] = "n7jupd_i",
e[e.n7jupd_a = 58] = "n7jupd_a",
e[e.n7jupd_n = 59] = "n7jupd_n",
e[e.n7jupd_p = 60] = "n7jupd_p",
e[e.n7jupd_image_gen = 61] = "n7jupd_image_gen",
e[e.n7jupd_native_api_tool = 62] = "n7jupd_native_api_tool",
e[e.PIMBlock = 63] = "PIMBlock",
e[e.Mochi = 64] = "Mochi",
e[e.SuperWidget = 65] = "SuperWidget",
e[e.Croquette = 66] = "Croquette",
e[e.kaur1br5 = 67] = "kaur1br5",
e))(Re || {})
  , bl = (e => (e.BROWSER = "browser",
e.CANMORE = "canmore",
e.MTBROWSER = "mtbrowser",
e.WIKI_BROWSER = "wiki_browser",
e.MYFILES_BROWSER = "myfiles_browser",
e.FILE_SEARCH = "file_search",
e.GDRIVE_BROWSER = "gdrive_browser",
e.BROWSING_TEAM = "browsing_team",
e.BIO = "bio",
e.PYTHON = "python",
e.DALLE = "dalle",
e.GIZMO_EDITOR = "gizmo_editor",
e.JIT_PLUGIN = "jit_plugin",
e.SEARCH_RESULT = "search_result",
e.SEARCH_RESULTS = "search_results",
e.A8KM123 = "a8km123",
e.SEARCHGPT = "web",
e.SEARCH_COT = "web.run",
e.DE1D73E = "de1d73e",
e.L1P9K3U = "l1p9k3u",
e.L1239DK1 = "l1239dk1",
e.CONTAINER = "container",
e.COMPUTER = "computer",
e.OIW209H = "oiw209h",
e.T2UAY3K = "t2uay3k",
e.START_RESEARCH_TASK = "research_kickoff_tool.start_research_task",
e.CLARIFY_WITH_TEXT = "research_kickoff_tool.clarify_with_text",
e.ADVANCED_VOICE = "advanced_voice",
e.OBOE = "oboe",
e.IMAGE_GEN_HALLUCINATED = "image_gen",
e.n7jupd_m = "n7jupd.metadata",
e.IMAGEGEN_MAKE_IMAGE = "imagegen.make_image",
e.SUPER_WIDGET = "super_widget",
e))(bl || {});
function H8(e) {
    return e && [4202148095, 653746659, 45870204, 111655449].some(t => Rr(t, e))
}
function Une(e) {
    const n = u5(e.author.name)?.namespace
      , r = ["browser", "container", "computer"];
    return e.metadata?.n7jupd_message && r.includes(n) && e.content.content_type === rt.Text
}
function Bne(e, t) {
    return e && Rr(t, e.split(".")[0])
}
function Do(e) {
    if (e.metadata?.n7jupd_subtool && (e.metadata.n7jupd_subtool.subtool?.includes("api_tool") || e.metadata.n7jupd_subtool.result_of_subtool?.includes("api_tool")))
        return 58;
    if (e.metadata?.n7jupd_message && (e.recipient?.includes("api_tool") || e.author?.name?.includes("api_tool")))
        return 62;
    if (e.metadata?.is_pim_warning)
        return 63;
    if (e.metadata?.n7jupd_message && e.content.content_type === rt.StructuredThoughts)
        return 54;
    if (e.metadata?.is_auto_proceed_message)
        return 60;
    if (e.metadata?.is_takeover_ended_message)
        return 59;
    if (e.content.content_type === rt.StructuredThoughts)
        return 26;
    if (e.content.content_type === rt.ReasoningRecap)
        return 27;
    if (e.metadata?.b1de6e2_c)
        return 35;
    if (e.recipient === "l1p9k3u" || e.author.name === "l1p9k3u")
        return 39;
    if (e.author.name === "l1239dk1" || e.recipient === "l1239dk1")
        return 40;
    if (e.author.name?.startsWith("container"))
        return Rr(3061204740, e.author.name) && e?.metadata?.n7jupd_message ? 6 : 4;
    if (e.author.role === Ke.Assistant && e.metadata?.async_task_id != null && e.metadata?.async_task_turn_id != null)
        return 41;
    if (e.metadata?.b1de6e2_s || e.recipient === "research_kickoff_tool.start_research_task")
        return 36;
    if (e.metadata?.b1de6e2_d)
        return 37;
    if (e.metadata?.b1de6e2_rm)
        return 38;
    if (e.metadata?.is_loading_message)
        return 42;
    if (e.metadata?.b47u8ra0_t)
        return 43;
    if (e.metadata?.f959b8c)
        return 34;
    if (H8(e.author.name) || H8(e.recipient) || Une(e))
        return 0;
    const t = "kaur1br5";
    if (e.recipient?.startsWith(t) || e.author.name?.startsWith(t))
        return 67;
    if (e.author.role === Ke.Assistant && Bne(e.recipient, 724319625))
        return 52;
    if (e.content.content_type === rt.ComputerOutput)
        return 53;
    if (e.author.role === Ke.Assistant) {
        if (jne.some(r => e.recipient?.startsWith(r)))
            return 31;
        const n = u5(e.recipient);
        if (e.recipient === "browser" || e.recipient === "wiki_browser" || n?.namespace === "mtbrowser")
            return 2;
        if (e.recipient === "web" || e.recipient?.startsWith("web."))
            return 21;
        if (e.recipient === "web.run" && (e?.metadata?.search_queries?.length ?? 0) > 0)
            return 50;
        if (e.recipient === "myfiles_browser" || e.recipient === "gdrive_browser" || n?.namespace === "file_search" || n?.namespace === "myfiles_browser")
            return 18;
        if (e.recipient === "browsing_team")
            return 16;
        if (e.recipient === "bio")
            return 29;
        if (e.recipient === "python")
            return 5;
        if (e?.metadata?.n7jupd_message && (Rr(3179801956, e.recipient) || Rr(3061204740, e.recipient)))
            return 5;
        if (n?.namespace === "dalle" || e.recipient === "dalle")
            return 7;
        if (n?.namespace === "t2uay3k" || e.recipient === "t2uay3k")
            return 46;
        if (n?.namespace === "oiw209h" || e.recipient === "oiw209h")
            return 44;
        if (n?.namespace === "gizmo_editor")
            return 9;
        if (n?.namespace === "container")
            return 4;
        if (n?.namespace === "canmore")
            return 3;
        if (n?.namespace === "de1d73e")
            return 32;
        if (W8(n?.namespace) || $8(n?.namespace) || K8(n?.namespace))
            return 10;
        if (n != null)
            return 31;
        if (e.content.content_type === rt.ModelEditableContext)
            return 14
    } else if (e.author.role === Ke.Tool) {
        const n = u5(e.author.name);
        if (e.author.name === "browser" || e.author.name === "wiki_browser" || n?.namespace === "mtbrowser")
            return 1;
        if (e.author.name === "myfiles_browser" || e.author.name === "gdrive_browser" || e.author.name === "file_search" || n?.namespace === "file_search" || n?.namespace === "myfiles_browser")
            return 19;
        if (e.author.name === "browsing_team")
            return 17;
        if (e.author.name === "web.run" && (e?.metadata?.search_result_groups?.length ?? 0) > 0)
            return 51;
        if (e.author.name === "search_result" && e.content.content_type === rt.TetherQuote)
            return 20;
        if (e.author.name === "search_results" && e.content.content_type === rt.TetherBrowsingDisplay)
            return 13;
        if (e.author.name === "bio")
            return 30;
        if (e.author.name === "a8km123")
            return 33;
        if (e.author.name === "python")
            return 6;
        if (Rr(3179801956, e.author.name))
            return 6;
        if (n?.namespace === "dalle" || e.author.name === "dalle")
            return 8;
        if (n?.namespace === "t2uay3k" || e.author.name === "image_gen")
            return 47;
        if (e.metadata?.image_gen_async)
            return 46;
        if (n?.namespace === "gizmo_editor")
            return 9;
        if (n?.namespace === "canmore")
            return 3;
        if (W8(n?.namespace) || $8(n?.namespace))
            return 11;
        if (K8(n?.namespace))
            return 12;
        if (n?.namespace === "de1d73e")
            return 32;
        if (n?.namespace === "oiw209h")
            return 45;
        if (e.author.name?.startsWith("web."))
            return 22;
        if (e.author.name === "research_kickoff_tool.start_research_task")
            return 36;
        if (e.author.name === "research_kickoff_tool.clarify_with_text")
            return 0;
        if (e.author.name === "n7jupd.metadata")
            return 55;
        if (e.author.name === "imagegen.make_image")
            return 61;
        if (n?.namespace === "browser")
            return 56;
        if (e.author.name === "super_widget")
            return 65;
        if (n != null || e.author.name === "plugin_service")
            return qne(e)
    } else {
        if (e.author.role === Ke.System || e.author.role === Ke.Developer)
            return e.metadata?.n7jupd_message ? 22 : e.metadata?.rebase_system_message || e.content.content_type === rt.SystemMessage || e.content.content_type === rt.SystemContent ? 23 : e.metadata?.rebase_developer_message || e.content.content_type === rt.DeveloperContent ? 24 : 22;
        if (e.author.role === Ke.User && (e.content.content_type === rt.UserEditableContext || e.metadata?.is_user_system_message))
            return 28
    }
    return e.content.content_type === rt.Text || e.content.content_type === rt.MultimodalText ? 25 : 31
}
function qne(e) {
    return e.create_time && e.create_time > 17172e5 ? q.addError("[Unknown tool] Encountered a message with an unknown tool. Rendering as Unknown message type, which is not visible.", {
        message: e
    }) : q.addError("[Unknown tool] Encountered a message with an unknown tool, which is most likely an old plugin. Rendering as Unknown message type, which may not appear as expected.", {
        message: e
    }),
    31
}
function Gne(e) {
    return e.metadata?.finish_details != null
}
function rw(e) {
    return e.content.content_type === rt.Text ? e.content.parts.some(t => t.length > 0) : e.content.content_type === rt.MultimodalText ? nw.getPartsAsString(e).length > 0 : !1
}
function Vne(e) {
    return rw(e) ? !0 : "text"in e.content ? e.content.text.length > 0 : "result"in e.content ? e.content.result.length > 0 : !1
}
function Hne(e) {
    return e.metadata?.finish_details?.type === "stop"
}
function zne(e) {
    return e?.metadata?.finish_details?.type === "max_tokens"
}
function jxe(e) {
    return e.metadata?.finish_details?.type === "interrupted"
}
function $ne(e) {
    return e.metadata?.message_type === "continue"
}
function u5(e) {
    if (e == null || !e.includes("."))
        return null;
    const [t,n] = e.split(".");
    return {
        namespace: t,
        functionName: n
    }
}
function Wne(e, t) {
    return {
        id: Ts(),
        author: {
            role: Ke.System
        },
        content: {
            content_type: rt.Text,
            parts: Array.isArray(e) ? e : [e]
        },
        metadata: t
    }
}
function z8(e, t, n, r=Ts()) {
    return {
        id: r,
        author: {
            role: Ke.Assistant
        },
        content: {
            content_type: rt.Text,
            parts: Array.isArray(e) ? e : [e]
        },
        metadata: t,
        clientMetadata: n
    }
}
function h1(e, t, n) {
    const r = {
        role: Ke.User
    };
    return n && (r.metadata = n),
    {
        id: Ts(),
        author: r,
        create_time: Date.now() / 1e3,
        content: typeof e == "string" ? {
            content_type: rt.Text,
            parts: [e]
        } : e,
        metadata: t
    }
}
function Uxe(e) {
    return Wne([`The user is referring to this in particular:
${e}`], {
        exclude_after_next_user_message: !0
    })
}
function Bxe(e) {
    return h1(e, {
        is_visually_hidden_from_conversation: !0
    })
}
function qxe(e) {
    return {
        id: Ts(),
        author: {
            role: Ke.System
        },
        content: e,
        metadata: {
            rebase_system_message: !0
        },
        recipient: "all"
    }
}
function $8(e) {
    return e === "api_tool" || e === "ecosystem_demo" || e === "genui" || e === "kanzi_app"
}
function W8(e) {
    if (!e)
        return !1;
    const t = e.split("__");
    return t.findIndex(n => n === "jit_plugin") === t.length - 1
}
function K8(e) {
    return e === "gmail" || e === "gcal" || e === "gcontacts"
}
function Y8(e) {
    return e.author.role === Ke.Assistant ? e.metadata?.gizmo_id : void 0
}
function Vc(e) {
    return e.author.role === Ke.User && !e.metadata?.is_user_system_message
}
function Kne(e) {
    return e.metadata?.is_contextual_retry_user_message
}
function GL(e) {
    return Vc(e) && !Kne(e) || e.author.metadata?.is_system_initiated_conversation === !0
}
function VL(e) {
    return e.metadata?.reasoning_status != null
}
function Ca(e) {
    const t = Do(e);
    return t === 22 || t === 23 || t === 24 || t === 29 || t === 30 || t === 14 || t === 28 || t === 31 || !(t === 46 || t === 47) && !(t === 59) && e.metadata?.is_visually_hidden_from_conversation === !0
}
function HL(e) {
    switch (Do(e)) {
    case 23:
    case 24:
    case 28:
    case 14:
        return !0;
    default:
        return !1
    }
}
function jm(e) {
    if (Ca(e))
        return !1;
    if ((e.metadata?.attachments?.length ?? 0) > 0)
        return !0;
    if (e.metadata?.reasoning_status)
        return !1;
    if (e.clientMetadata?.errCode && Object.values(Mu).some(t => t === e.clientMetadata?.errCode))
        return !0;
    switch (Do(e)) {
    case 25:
    case 63:
        return rw(e);
    case 3:
        return Vne(e);
    case 46:
    case 60:
    case 59:
    case 5:
    case 6:
        return !0;
    default:
        return !1
    }
}
function zL(e) {
    return Ca(e) ? !1 : Do(e) === 25 && rw(e)
}
function Gxe(e) {
    return Ca(e) ? !1 : Do(e) === 47 && e.status === "finished_successfully" && e.recipient === "all"
}
function Yne(e) {
    const t = e.recipient;
    return !!t && (t.includes("image_gen") || t.includes("image_gen") || t.includes("t2uay3k"))
}
class Zne {
    cacheK1 = new WeakMap;
    get(t, n) {
        return this.cacheK1.get(t)?.get(n)
    }
    set(t, n, r) {
        let s = this.cacheK1.get(t);
        s || (s = new WeakMap,
        this.cacheK1.set(t, s)),
        s.set(n, r)
    }
}
var b_, Z8;
function Jne() {
    if (Z8)
        return b_;
    Z8 = 1;
    function e(t) {
        var n = t == null ? 0 : t.length;
        return n ? t[n - 1] : void 0
    }
    return b_ = e,
    b_
}
var Xne = Jne();
const Iu = mn(Xne)
  , Qne = "contentReference"
  , ere = "writing"
  , Vxe = [ere];
function Hxe(e) {
    try {
        const n = new Intl.Segmenter("en-US",{
            granularity: "grapheme"
        }).segment(e)
          , r = [];
        for (const s of n)
            r.push(s.segment);
        return r
    } catch {
        return e.split("")
    }
}
function tre(e) {
    const t = [];
    for (let n = 0; n < e.length; n++) {
        const r = e.codePointAt(n);
        r !== void 0 && (t.push(r),
        r > 65535 && n++)
    }
    return t
}
function J8(e) {
    return String.fromCodePoint(...e)
}
function zxe(e) {
    return e.replaceAll(/[\s_]+/g, "-").replaceAll(/([a-z0-9])([A-Z])/g, "$1-$2").replaceAll(/([A-Z]+)([A-Z][a-z0-9]+)/g, "$1-$2").replaceAll(/-+/g, "-").toLowerCase()
}
function nre(e, t=[]) {
    const n = p1(t);
    return sw(n, e, {
        includeDirectives: !1
    })
}
function $xe(e, t=[]) {
    const n = p1(t);
    return sw(n, e, {
        includeDirectives: !0
    })
}
function Wxe(e, t=[], n, r, s=!0, o) {
    const i = p1(t, r);
    let a = 0
      , l = i.filter( ({index: u, displayType: d}) => u != null && d).reduce( (u, {index: d, newContentReference: f}) => ((f.type === "grouped_webpages" || f.type === "grouped_webpages_v2" || f.type === "grouped_webpages_model_predicted_fallback") && (f.items = f.items.map(p => ({
        ...p,
        section_index: a++
    }))),
    u[d] = f,
    u), [])
      , c = sw(i, e);
    return s && (c = rre(c)),
    l = sre(o, l),
    n && (o?.length ?? 0) === 0 && ({updatedText: c, updatedReferences: l} = ore(n, l, c)),
    {
        processedText: c,
        displayedContentReferences: l
    }
}
function p1(e=[], t) {
    return [...e.entries()].sort( ([,s], [,o]) => s.start_idx - o.start_idx || s.end_idx - o.end_idx).reduce( (s, [o,i]) => {
        let a, l;
        switch (i.type) {
        case "invalid":
        case "hidden":
            a = {
                ...i,
                type: "hidden",
                invalid: i.type === "invalid"
            };
            break;
        case "image_v2":
        case "nav_list":
        case "tldr":
        case "optimistic_image_citation":
        case "sources_footnote":
        case "sports_standings":
        case "sports_schedule":
        case "navigation":
        case "checkout_confirmation":
        case "video":
        case "file_navlist":
            i.type === "tldr" && i.used_as_navigation || i.type === "navigation" ? a = {
                ...i,
                type: "hidden",
                invalid: !0
            } : (l = "block",
            a = {
                ...i
            });
            break;
        case "file":
        case "python":
        case "container":
        case "title_citation":
        case "location_search":
        case "time":
        case "entity":
        case "product_entity":
        case "grouped_webpages":
        case "grouped_webpages_v2":
        case "grouped_webpages_model_predicted_fallback":
        case "attribution":
        case "image_inline":
            l = "inline",
            a = {
                ...i
            };
            break;
        case "webpage":
        case "webpage_extended":
            l = "inline",
            a = {
                type: "grouped_webpages",
                matched_text: i.matched_text,
                start_idx: i.start_idx,
                end_idx: i.end_idx,
                alt: i.alt,
                refs: i.refs,
                prompt_text: i.prompt_text,
                items: [{
                    ...i
                }],
                safe_urls: i.safe_urls
            };
            break;
        case "calculator":
        case "stock":
        case "forecast":
        case "businesses_map":
        case "products":
        case "product_reviews":
        case "product_rationale":
        case "image_group":
            l = "block",
            a = {
                ...i
            };
            break;
        default:
            a = {
                ...i,
                type: "hidden",
                invalid: !0
            },
            l = "alt";
            break
        }
        return s.push({
            originalContentReference: i,
            newContentReference: a,
            index: o,
            displayType: l
        }),
        t && s.push({
            originalContentReference: i,
            newContentReference: {
                type: "debug",
                matched_text: i.matched_text.replace(/(^ã€|ã€‘$)/g, ""),
                ...i.type === "webpage_extended" && i.pub_date && {
                    pub_date: new Date(i.pub_date * 1e3).toLocaleString()
                }
            },
            index: o
        }),
        s
    }
    , [])
}
const d5 = "â€‹"
  , Kxe = "îˆ€";
function sw(e, t, n={
    includeDirectives: !0
}) {
    let r = ""
      , s = 0;
    const o = tre(t);
    for (const i of e) {
        const {originalContentReference: a, displayType: l, index: c} = i
          , {start_idx: u, end_idx: d} = a
          , f = o.slice(s, u);
        if (r += J8(f),
        s = d,
        l)
            if (n.includeDirectives)
                switch (l) {
                case "block":
                    r += `
` + f5(c, "leaf") + `
`;
                    break;
                case "inline":
                    {
                        r.endsWith("```") && (r += `
`),
                        r.length !== 0 && r[r.length - 1].match(/[:\\]/) && (r += d5),
                        /https?:\/\/[^\s]*$/.test(r) && (r += " "),
                        r += f5(c, "inline");
                        break
                    }
                case "alt":
                    r += a.alt ?? "";
                    break
                }
            else
                r += a.alt ?? ""
    }
    return r += J8(o.slice(s)),
    r
}
function f5(e, t) {
    return `${t === "leaf" ? "::" : ":"}${Qne}[oaicite:${e}]{index=${e}}`
}
function rre(e) {
    let t = e;
    t = t.replace(/ã€[^ã€‘]*$/g, "");
    const n = t.match(/(\n|^):::/g);
    return n && n.length % 2 === 1 && (t += `
:::`),
    t = t.replace(/^\d+$/, ""),
    t
}
function sre(e, t) {
    return t.map(r => {
        if (r.type === "python") {
            const s = e?.find(o => o.metadata?.python_citation?.citation_id === r.citation_id);
            return {
                ...r,
                cited_message: s,
                highlighted_text: X8(s?.metadata?.python_citation?.annotated_text ?? "", r.starting_line, r.ending_line)
            }
        } else if (r.type === "container") {
            const s = e?.find(o => o.metadata?.container_citation?.citation_id === r.citation_id);
            return {
                ...r,
                cited_message: s,
                highlighted_text: X8(s?.metadata?.container_citation?.annotated_parts?.join(`
`) ?? "", r.starting_line, r.ending_line)
            }
        }
        return r
    }
    )
}
function ore(e, t, n) {
    const r = e.find(o => Do(o) === Re.CodeInterpreter)
      , s = e.find(o => Do(o) === Re.CodeInterpreterTool);
    if (r != null && s != null) {
        const o = t.length;
        n.endsWith("```") && (n += `
`),
        n += " " + d5 + f5(o, "inline") + d5,
        t.push({
            type: "code_execution",
            codeMessage: r,
            codeExecutionOutputMessage: s
        })
    }
    return {
        updatedText: n,
        updatedReferences: t
    }
}
function X8(e, t, n) {
    const r = e.split(`
`)
      , s = r.findIndex(l => l.startsWith(`${t}:`))
      , o = r.findIndex(l => l.startsWith(`${n}:`));
    return s === -1 || o === -1 || o < s ? null : r.slice(s, o + 1).map(l => l.replace(/^L\d+:\s*/, "").trim()).join(`
`)
}
function m1(e, t={
    shouldGetTextFromContentReferences: !1,
    shouldGetVisibleText: !1
}) {
    if (t.shouldGetVisibleText && !zL(e))
        return "";
    switch (e.content.content_type) {
    case rt.Text:
        {
            const n = e.content.parts.join("");
            return t.shouldGetTextFromContentReferences && e.metadata?.content_references ? nre(n, e.metadata.content_references) : n
        }
    case rt.MultimodalText:
        return nw.getPartsAsString(e, !t.shouldGetVisibleText);
    case rt.TetherBrowsingDisplay:
        return e.content.result;
    case rt.TetherQuote:
    case rt.TetherBrowsingCode:
    case rt.Code:
    case rt.ExecutionOutput:
    case rt.SystemError:
        return e.content.text;
    case rt.SystemMessage:
    case rt.SystemContent:
        return e?.metadata?.__internal?.rendered_harmony_string ?? JSON.stringify(e.content, null, 2);
    case rt.UserEditableContext:
        return `${e.content.user_profile}
${e.content.user_instructions}`;
    case rt.SonicWebpage:
        return `[${e.content.ref_id}] ${e.content.title} (${e.content.url})`;
    case rt.StructuredThoughts:
        return e.content.thoughts.map(n => `**${n.summary}**

${n.content}`).join(`

`);
    case rt.ReasoningRecap:
        return e.content.content;
    default:
        return ""
    }
}
var C_, Q8;
function ire() {
    if (Q8)
        return C_;
    Q8 = 1;
    var e = G6()
      , t = Q6()
      , n = 1
      , r = 2;
    function s(o, i, a, l) {
        var c = a.length
          , u = c
          , d = !l;
        if (o == null)
            return !u;
        for (o = Object(o); c--; ) {
            var f = a[c];
            if (d && f[2] ? f[1] !== o[f[0]] : !(f[0]in o))
                return !1
        }
        for (; ++c < u; ) {
            f = a[c];
            var p = f[0]
              , m = o[p]
              , v = f[1];
            if (d && f[2]) {
                if (m === void 0 && !(p in o))
                    return !1
            } else {
                var _ = new e;
                if (l)
                    var y = l(m, v, p, o, i, _);
                if (!(y === void 0 ? t(v, m, n | r, l, _) : y))
                    return !1
            }
        }
        return !0
    }
    return C_ = s,
    C_
}
var S_, ex;
function $L() {
    if (ex)
        return S_;
    ex = 1;
    var e = Bo();
    function t(n) {
        return n === n && !e(n)
    }
    return S_ = t,
    S_
}
var w_, tx;
function are() {
    if (tx)
        return w_;
    tx = 1;
    var e = $L()
      , t = Yu();
    function n(r) {
        for (var s = t(r), o = s.length; o--; ) {
            var i = s[o]
              , a = r[i];
            s[o] = [i, a, e(a)]
        }
        return s
    }
    return w_ = n,
    w_
}
var E_, nx;
function WL() {
    if (nx)
        return E_;
    nx = 1;
    function e(t, n) {
        return function(r) {
            return r == null ? !1 : r[t] === n && (n !== void 0 || t in Object(r))
        }
    }
    return E_ = e,
    E_
}
var x_, rx;
function lre() {
    if (rx)
        return x_;
    rx = 1;
    var e = ire()
      , t = are()
      , n = WL();
    function r(s) {
        var o = t(s);
        return o.length == 1 && o[0][2] ? n(o[0][0], o[0][1]) : function(i) {
            return i === s || e(i, s, o)
        }
    }
    return x_ = r,
    x_
}
var T_, sx;
function g1() {
    if (sx)
        return T_;
    sx = 1;
    var e = Ku()
      , t = La()
      , n = "[object Symbol]";
    function r(s) {
        return typeof s == "symbol" || t(s) && e(s) == n
    }
    return T_ = r,
    T_
}
var k_, ox;
function ow() {
    if (ox)
        return k_;
    ox = 1;
    var e = ks()
      , t = g1()
      , n = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/
      , r = /^\w*$/;
    function s(o, i) {
        if (e(o))
            return !1;
        var a = typeof o;
        return a == "number" || a == "symbol" || a == "boolean" || o == null || t(o) ? !0 : r.test(o) || !n.test(o) || i != null && o in Object(i)
    }
    return k_ = s,
    k_
}
var O_, ix;
function cre() {
    if (ix)
        return O_;
    ix = 1;
    var e = q6()
      , t = "Expected a function";
    function n(r, s) {
        if (typeof r != "function" || s != null && typeof s != "function")
            throw new TypeError(t);
        var o = function() {
            var i = arguments
              , a = s ? s.apply(this, i) : i[0]
              , l = o.cache;
            if (l.has(a))
                return l.get(a);
            var c = r.apply(this, i);
            return o.cache = l.set(a, c) || l,
            c
        };
        return o.cache = new (n.Cache || e),
        o
    }
    return n.Cache = e,
    O_ = n,
    O_
}
var A_, ax;
function ure() {
    if (ax)
        return A_;
    ax = 1;
    var e = cre()
      , t = 500;
    function n(r) {
        var s = e(r, function(i) {
            return o.size === t && o.clear(),
            i
        })
          , o = s.cache;
        return s
    }
    return A_ = n,
    A_
}
var M_, lx;
function dre() {
    if (lx)
        return M_;
    lx = 1;
    var e = ure()
      , t = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g
      , n = /\\(\\)?/g
      , r = e(function(s) {
        var o = [];
        return s.charCodeAt(0) === 46 && o.push(""),
        s.replace(t, function(i, a, l, c) {
            o.push(l ? c.replace(n, "$1") : a || i)
        }),
        o
    });
    return M_ = r,
    M_
}
var I_, cx;
function KL() {
    if (cx)
        return I_;
    cx = 1;
    function e(t, n) {
        for (var r = -1, s = t == null ? 0 : t.length, o = Array(s); ++r < s; )
            o[r] = n(t[r], r, t);
        return o
    }
    return I_ = e,
    I_
}
var R_, ux;
function fre() {
    if (ux)
        return R_;
    ux = 1;
    var e = Wu()
      , t = KL()
      , n = ks()
      , r = g1()
      , s = e ? e.prototype : void 0
      , o = s ? s.toString : void 0;
    function i(a) {
        if (typeof a == "string")
            return a;
        if (n(a))
            return t(a, i) + "";
        if (r(a))
            return o ? o.call(a) : "";
        var l = a + "";
        return l == "0" && 1 / a == -1 / 0 ? "-0" : l
    }
    return R_ = i,
    R_
}
var N_, dx;
function hre() {
    if (dx)
        return N_;
    dx = 1;
    var e = fre();
    function t(n) {
        return n == null ? "" : e(n)
    }
    return N_ = t,
    N_
}
var P_, fx;
function v1() {
    if (fx)
        return P_;
    fx = 1;
    var e = ks()
      , t = ow()
      , n = dre()
      , r = hre();
    function s(o, i) {
        return e(o) ? o : t(o, i) ? [o] : n(r(o))
    }
    return P_ = s,
    P_
}
var D_, hx;
function oh() {
    if (hx)
        return D_;
    hx = 1;
    var e = g1();
    function t(n) {
        if (typeof n == "string" || e(n))
            return n;
        var r = n + "";
        return r == "0" && 1 / n == -1 / 0 ? "-0" : r
    }
    return D_ = t,
    D_
}
var L_, px;
function iw() {
    if (px)
        return L_;
    px = 1;
    var e = v1()
      , t = oh();
    function n(r, s) {
        s = e(s, r);
        for (var o = 0, i = s.length; r != null && o < i; )
            r = r[t(s[o++])];
        return o && o == i ? r : void 0
    }
    return L_ = n,
    L_
}
var F_, mx;
function pre() {
    if (mx)
        return F_;
    mx = 1;
    var e = iw();
    function t(n, r, s) {
        var o = n == null ? void 0 : e(n, r);
        return o === void 0 ? s : o
    }
    return F_ = t,
    F_
}
var j_, gx;
function mre() {
    if (gx)
        return j_;
    gx = 1;
    function e(t, n) {
        return t != null && n in Object(t)
    }
    return j_ = e,
    j_
}
var U_, vx;
function gre() {
    if (vx)
        return U_;
    vx = 1;
    var e = v1()
      , t = $6()
      , n = ks()
      , r = K6()
      , s = Y6()
      , o = oh();
    function i(a, l, c) {
        l = e(l, a);
        for (var u = -1, d = l.length, f = !1; ++u < d; ) {
            var p = o(l[u]);
            if (!(f = a != null && c(a, p)))
                break;
            a = a[p]
        }
        return f || ++u != d ? f : (d = a == null ? 0 : a.length,
        !!d && s(d) && r(p, d) && (n(a) || t(a)))
    }
    return U_ = i,
    U_
}
var B_, _x;
function YL() {
    if (_x)
        return B_;
    _x = 1;
    var e = mre()
      , t = gre();
    function n(r, s) {
        return r != null && t(r, s, e)
    }
    return B_ = n,
    B_
}
var q_, yx;
function vre() {
    if (yx)
        return q_;
    yx = 1;
    var e = Q6()
      , t = pre()
      , n = YL()
      , r = ow()
      , s = $L()
      , o = WL()
      , i = oh()
      , a = 1
      , l = 2;
    function c(u, d) {
        return r(u) && s(d) ? o(i(u), d) : function(f) {
            var p = t(f, u);
            return p === void 0 && p === d ? n(f, u) : e(d, p, a | l)
        }
    }
    return q_ = c,
    q_
}
var G_, bx;
function aw() {
    if (bx)
        return G_;
    bx = 1;
    function e(t) {
        return t
    }
    return G_ = e,
    G_
}
var V_, Cx;
function _re() {
    if (Cx)
        return V_;
    Cx = 1;
    function e(t) {
        return function(n) {
            return n?.[t]
        }
    }
    return V_ = e,
    V_
}
var H_, Sx;
function yre() {
    if (Sx)
        return H_;
    Sx = 1;
    var e = iw();
    function t(n) {
        return function(r) {
            return e(r, n)
        }
    }
    return H_ = t,
    H_
}
var z_, wx;
function bre() {
    if (wx)
        return z_;
    wx = 1;
    var e = _re()
      , t = yre()
      , n = ow()
      , r = oh();
    function s(o) {
        return n(o) ? e(r(o)) : t(o)
    }
    return z_ = s,
    z_
}
var $_, Ex;
function ih() {
    if (Ex)
        return $_;
    Ex = 1;
    var e = lre()
      , t = vre()
      , n = aw()
      , r = ks()
      , s = bre();
    function o(i) {
        return typeof i == "function" ? i : i == null ? n : typeof i == "object" ? r(i) ? t(i[0], i[1]) : e(i) : s(i)
    }
    return $_ = o,
    $_
}
var W_, xx;
function Cre() {
    if (xx)
        return W_;
    xx = 1;
    var e = ih()
      , t = l1()
      , n = Yu();
    function r(s) {
        return function(o, i, a) {
            var l = Object(o);
            if (!t(o)) {
                var c = e(i, 3);
                o = n(o),
                i = function(d) {
                    return c(l[d], d, l)
                }
            }
            var u = s(o, i, a);
            return u > -1 ? l[c ? o[u] : u] : void 0
        }
    }
    return W_ = r,
    W_
}
var K_, Tx;
function ZL() {
    if (Tx)
        return K_;
    Tx = 1;
    function e(t, n, r, s) {
        for (var o = t.length, i = r + (s ? 1 : -1); s ? i-- : ++i < o; )
            if (n(t[i], i, t))
                return i;
        return -1
    }
    return K_ = e,
    K_
}
var Y_, kx;
function Sre() {
    if (kx)
        return Y_;
    kx = 1;
    var e = /\s/;
    function t(n) {
        for (var r = n.length; r-- && e.test(n.charAt(r)); )
            ;
        return r
    }
    return Y_ = t,
    Y_
}
var Z_, Ox;
function wre() {
    if (Ox)
        return Z_;
    Ox = 1;
    var e = Sre()
      , t = /^\s+/;
    function n(r) {
        return r && r.slice(0, e(r) + 1).replace(t, "")
    }
    return Z_ = n,
    Z_
}
var J_, Ax;
function JL() {
    if (Ax)
        return J_;
    Ax = 1;
    var e = wre()
      , t = Bo()
      , n = g1()
      , r = NaN
      , s = /^[-+]0x[0-9a-f]+$/i
      , o = /^0b[01]+$/i
      , i = /^0o[0-7]+$/i
      , a = parseInt;
    function l(c) {
        if (typeof c == "number")
            return c;
        if (n(c))
            return r;
        if (t(c)) {
            var u = typeof c.valueOf == "function" ? c.valueOf() : c;
            c = t(u) ? u + "" : u
        }
        if (typeof c != "string")
            return c === 0 ? c : +c;
        c = e(c);
        var d = o.test(c);
        return d || i.test(c) ? a(c.slice(2), d ? 2 : 8) : s.test(c) ? r : +c
    }
    return J_ = l,
    J_
}
var X_, Mx;
function Ere() {
    if (Mx)
        return X_;
    Mx = 1;
    var e = JL()
      , t = 1 / 0
      , n = 17976931348623157e292;
    function r(s) {
        if (!s)
            return s === 0 ? s : 0;
        if (s = e(s),
        s === t || s === -1 / 0) {
            var o = s < 0 ? -1 : 1;
            return o * n
        }
        return s === s ? s : 0
    }
    return X_ = r,
    X_
}
var Q_, Ix;
function xre() {
    if (Ix)
        return Q_;
    Ix = 1;
    var e = Ere();
    function t(n) {
        var r = e(n)
          , s = r % 1;
        return r === r ? s ? r - s : r : 0
    }
    return Q_ = t,
    Q_
}
var ey, Rx;
function Tre() {
    if (Rx)
        return ey;
    Rx = 1;
    var e = ZL()
      , t = ih()
      , n = xre()
      , r = Math.max
      , s = Math.min;
    function o(i, a, l) {
        var c = i == null ? 0 : i.length;
        if (!c)
            return -1;
        var u = c - 1;
        return l !== void 0 && (u = n(l),
        u = l < 0 ? r(c + u, 0) : s(u, c - 1)),
        e(i, t(a, 3), u, !0)
    }
    return ey = o,
    ey
}
var ty, Nx;
function kre() {
    if (Nx)
        return ty;
    Nx = 1;
    var e = Cre()
      , t = Tre()
      , n = e(t);
    return ty = n,
    ty
}
var Ore = kre();
const Yp = mn(Ore)
  , ny = -1;
var Are = (e => (e[e.Text = 0] = "Text",
e[e.MultiText = 1] = "MultiText",
e[e.StructuredThoughts = 2] = "StructuredThoughts",
e[e.ReasoningRecap = 3] = "ReasoningRecap",
e[e.Browsing = 4] = "Browsing",
e[e.CodeInterpreter = 5] = "CodeInterpreter",
e[e.JITPlugin = 6] = "JITPlugin",
e[e.RetrievalBrowsing = 7] = "RetrievalBrowsing",
e[e.ParallelBrowsing = 8] = "ParallelBrowsing",
e[e.Dalle = 9] = "Dalle",
e[e.Canmore = 10] = "Canmore",
e[e.Container = 11] = "Container",
e[e.GizmoEditor = 12] = "GizmoEditor",
e[e.SearchResult = 13] = "SearchResult",
e[e.Debug = 14] = "Debug",
e[e.SearchGPTQuery = 15] = "SearchGPTQuery",
e[e.l1p9k3u = 16] = "l1p9k3u",
e[e.a8km123 = 17] = "a8km123",
e[e.f959b8c = 18] = "f959b8c",
e[e.b1de6e2_c = 19] = "b1de6e2_c",
e[e.b1de6e2_s = 20] = "b1de6e2_s",
e[e.b1de6e2_d = 21] = "b1de6e2_d",
e[e.b1de6e2_rm = 22] = "b1de6e2_rm",
e[e.is_loading_message = 23] = "is_loading_message",
e[e.b47u8ra0_t = 24] = "b47u8ra0_t",
e[e.de1d73e = 25] = "de1d73e",
e[e.oiw209h = 26] = "oiw209h",
e[e.c12k321 = 27] = "c12k321",
e[e.t2uay3k = 28] = "t2uay3k",
e[e.Oboe = 29] = "Oboe",
e[e.CoTSearchTool = 30] = "CoTSearchTool",
e[e.n7jupd = 31] = "n7jupd",
e[e.n7jupd_x = 32] = "n7jupd_x",
e[e.n7jupd_i = 33] = "n7jupd_i",
e[e.n7jupd_a = 34] = "n7jupd_a",
e[e.n7jupd_n = 35] = "n7jupd_n",
e[e.n7jupd_p = 36] = "n7jupd_p",
e[e.n7jupd_image_gen = 37] = "n7jupd_image_gen",
e[e.n7jupd_native_api_tool = 38] = "n7jupd_native_api_tool",
e[e.PIMBlock = 39] = "PIMBlock",
e[e.Mochi = 40] = "Mochi",
e[e.SuperWidget = 41] = "SuperWidget",
e[e.Croquette = 42] = "Croquette",
e[e.kaur1br5 = 43] = "kaur1br5",
e))(Are || {});
const Mre = {
    [Re.StructuredThoughts]: 2,
    [Re.ReasoningRecap]: 3,
    [Re.Browsing]: 4,
    [Re.BrowseTool]: 4,
    [Re.SearchGPTQuery]: 15,
    [Re.RetrievalBrowsing]: 7,
    [Re.RetrievalBrowsingTool]: 7,
    [Re.ParallelBrowsing]: 8,
    [Re.ParallelBrowsingTool]: 8,
    [Re.JITPlugin]: 6,
    [Re.JITPluginTool]: 6,
    [Re.JITPluginGoogleTool]: 6,
    [Re.Dalle]: 9,
    [Re.DalleTool]: 9,
    [Re.t2uay3k]: 28,
    [Re.t2uay3k_c]: 28,
    [Re.oiw209h]: 26,
    [Re.oiw209h_c]: 26,
    [Re.Container]: 11,
    [Re.CodeInterpreter]: 5,
    [Re.CodeInterpreterTool]: 5,
    [Re.a8km123]: 17,
    [Re.f959b8c]: 18,
    [Re.b1de6e2_c]: 19,
    [Re.b1de6e2_s]: 20,
    [Re.b1de6e2_d]: 21,
    [Re.b1de6e2_rm]: 22,
    [Re.l1p9k3u]: 16,
    [Re.is_loading_message]: 23,
    [Re.b47u8ra0_t]: 24,
    [Re.de1d73e]: 25,
    [Re.GizmoEditor]: 12,
    [Re.SearchResultTool]: 13,
    [Re.ImagePreloadTool]: 13,
    [Re.CanmoreTool]: 10,
    [Re.c12k321]: 27,
    [Re.CoTSearchToolCall]: 30,
    [Re.CoTSearchToolResult]: 30,
    [Re.n7jupd_c]: 31,
    [Re.n7jupd_r]: 31,
    [Re.n7jupd_t]: 31,
    [Re.n7jupd_m]: 31,
    [Re.n7jupd_x]: 32,
    [Re.n7jupd_i]: 31,
    [Re.n7jupd_a]: 34,
    [Re.n7jupd_native_api_tool]: 38,
    [Re.n7jupd_n]: 35,
    [Re.n7jupd_p]: 36,
    [Re.kaur1br5]: 43,
    [Re.PIMBlock]: 39,
    [Re.Mochi]: 40,
    [Re.SuperWidget]: 41,
    [Re.Croquette]: 42,
    [Re.n7jupd_image_gen]: 37
};
function Ire(e) {
    switch (e) {
    case Re.JITPlugin:
    case Re.Dalle:
    case Re.t2uay3k:
    case Re.oiw209h:
    case Re.CoTSearchToolCall:
    case Re.CodeInterpreter:
    case Re.PIMBlock:
        return !0;
    default:
        return !1
    }
}
function Rre(e, t, n) {
    return !e || e.type !== t || Ire(Do(n)) || e.type === 11 && !n.author.name?.startsWith(bl.CONTAINER) ? !1 : e.type === t
}
function Px(e, t) {
    return Bs(e, n => {
        if (VL(t)) {
            let a;
            const l = t.metadata?.reasoning_group_id;
            l ? a = Yp(n, u => u.type === ny && u.reasoningGroupId === l) : a = Iu(n);
            let c;
            a?.type === ny ? c = a : (c = {
                type: ny,
                groups: [],
                reasoningGroupId: l
            },
            n.push(c)),
            n = c.groups
        }
        const r = Do(t)
          , s = Mre[r]
          , o = Iu(n)
          , i = o?.type !== 14 ? o : Yp(n, a => a.type !== 14);
        r === Re.Text && (i?.type === 1 || i?.type === 0) && m1(t) != null && ($ne(t) || zne(i.messages[i.messages.length - 1])) ? (i.type = 1,
        i.messages.push(t)) : s === 17 && n.some(a => a.type === 17) ? Yp(n, l => l.type === 17).messages.push(t) : Rre(i, s, t) ? i.messages.push(t) : n.push({
            type: s ?? (Ca(t) ? 14 : 0),
            messages: [t]
        })
    }
    )
}
const Dx = new Zne
  , Nre = Object.freeze([]);
function XL(e, t, n=!1) {
    const r = e.getNodeByIdOrMessageId(t)
      , s = r.id !== e.rootId ? XL(e, r.parentId, n) : Nre
      , o = r.message
      , i = Dx.get(s, o);
    if (i)
        return i;
    const a = Pre(s, o, n);
    return Dx.set(s, o, a),
    a
}
function Pre(e, t, n=!1) {
    const r = [...e]
      , s = Iu(r)
      , o = GL(t);
    if (s && Dre(s, t)) {
        const i = [...s.messages, t]
          , a = Px(s.messageGroups, t)
          , l = s.role === Ke.System ? Lx(t, n) : s.role
          , c = Y8(t) ?? s.gizmoId;
        let u = s.authorId
          , d = s.modelSlug;
        r[r.length - 1] = {
            ...s,
            messages: i,
            messageGroups: a,
            role: l,
            isPrompt: s.isPrompt || o,
            gizmoId: c,
            authorId: u,
            modelSlug: d
        }
    } else {
        const i = t.clientMetadata?.requestId
          , a = Lx(t, n)
          , l = a === Ke.Assistant && i && i !== s?.id ? i : t.id;
        r.push({
            id: l,
            role: a,
            messages: [t],
            messageGroups: Px([], t),
            isPrompt: o,
            gizmoId: Y8(t)
        })
    }
    return r
}
function Lx(e, t) {
    return HL(e) ? Ke.System : e.author.role === Ke.Tool ? Ke.Assistant : e.author.role === Ke.Developer && !t ? Ke.System : e.author.role
}
function Dre(e, t, n) {
    return t.metadata?.is_indepth_feedback ? !1 : Iu(e.messages)?.metadata?.reasoning_status && t.metadata?.reasoning_status || e.role === t.author.role ? !0 : e.role === Ke.User && t.recipient === "bio" ? !1 : HL(t) ? e.role === Ke.Root || e.role === Ke.System : Ca(t) || (e.role === Ke.System || e.role === Ke.Developer) && !e.isPrompt ? !0 : t.author.role === Ke.Tool ? e.role === Ke.Assistant : !1
}
function lw() {
    const e = cs();
    return jre(e.pathname)
}
function Lre(e) {
    const n = new URL(`http://example.com${e}`).pathname.match(/(?:\/gizmo)?\/g\/([^/]+)/);
    if (n)
        return n[1]
}
function Fre(e) {
    const t = e.split("-");
    return t.length > 1 && t[0] === "g" ? t?.[1] === "p" ? `g-p-${t[2]}` : `g-${t[1]}` : t[0]
}
function jre(e) {
    const t = Lre(e);
    if (t)
        return Fre(t)
}
function ah() {
    "use forget";
    const e = De.c(2)
      , t = ue()
      , n = !yn(t);
    let r;
    return e[0] !== n ? (r = {
        isUnauthenticated: n,
        isLoading: !1
    },
    e[0] = n,
    e[1] = r) : r = e[1],
    r
}
function Ure() {
    ze.deleteCookie(Be.SegmentUserId),
    ze.deleteCookie(Be.SegmentUserTraits),
    Wt.removeItem(Ft.SegmentUserId),
    Wt.removeItem(Ft.SegmentUserTraits)
}
const h5 = () => ({
    hash: window.location.hash,
    path: window.location.pathname,
    search: window.location.search,
    url: window.location.href
});
var cw = (e => (e.WINDOW_VISIBILITY_STATE_CHANGED = "WINDOW_VISIBILITY_STATE_CHANGED",
e.WINDOW_FOCUS_CHANGED = "WINDOW_FOCUS_CHANGED",
e))(cw || {})
  , Sa = (e => (e.LOGIN_CHANGED = "LOGIN_CHANGED",
e.LOGOUT = "LOGOUT",
e.QUIT = "QUIT",
e.SET_COMPANION_WINDOW_VISIBILITY = "SET_COMPANION_WINDOW_VISIBILITY",
e.SET_WEB_RELEASE_PROPERTIES = "WEB_RELEASE_PROPERTIES",
e.ERROR_THROWN = "ERROR_THROWN",
e.ZOOM = "ZOOM",
e.DESKTOP_SETTING_CHANGED = "DESKTOP_SETTING_CHANGED",
e.HOTKEY_RECORDING_STATE = "HOTKEY_RECORDING_STATE",
e.ADD_BREADCRUMB = "ADD_BREADCRUMB",
e))(Sa || {})
  , _1 = (e => (e.ZOOM_IN = "ZOOM_IN",
e.ZOOM_OUT = "ZOOM_OUT",
e.ZOOM_RESET = "ZOOM_RESET",
e))(_1 || {})
  , QL = (e => (e.MICROPHONE = "MICROPHONE",
e))(QL || {});
function Yxe() {
    qn?.publish(Sa.ZOOM, {
        command: _1.ZOOM_IN
    })
}
function Zxe() {
    qn?.publish(Sa.ZOOM, {
        command: _1.ZOOM_OUT
    })
}
function Jxe() {
    qn?.publish(Sa.ZOOM, {
        command: _1.ZOOM_RESET
    })
}
function Fx(e) {
    if (Tg) {
        const t = Date.now();
        qn?.publish(Sa.ADD_BREADCRUMB, {
            message: e,
            epochTimestamp: t
        })
    }
}
function eF() {
    return ze.getCookie(Be.PunchOutInfoToken)
}
function Xxe() {
    return eF() != null
}
class Bre {
    analytics;
    appName;
    appVersion;
    deviceId;
    browserLocale;
    options;
    settings;
    user;
    constructor({appName: t, appVersion: n, deviceId: r, browserLocale: s, options: o, settings: i}) {
        this.analytics = new Promise(a => {
            he( () => import("./cphgm26927zo9d84.js").then(l => l.v), __vite__mapDeps([3, 1])).then(l => {
                if (!l) {
                    q.addAction("ClientEventsServiceLogger.segmentImport.failed", {
                        appName: t,
                        appVersion: n
                    });
                    return
                }
                const c = new l.AnalyticsBrowser;
                c.addSourceMiddleware(qre(this)),
                a([c])
            }
            )
        }
        ),
        this.appName = t,
        this.appVersion = n,
        this.deviceId = r,
        this.browserLocale = s,
        this.options = o,
        this.settings = i
    }
    async initialize({user: t}) {
        const n = {
            appName: this.appName,
            appVersion: this.appVersion
        };
        q.addAction("ClientEventsServiceLogger.initialize.start", n),
        t && this.identify(t);
        const [r] = await this.analytics;
        r.load(this.settings, this.options).catch( () => {
            q.addAction("ClientEventsServiceLogger.initialize.failed", n)
        }
        ),
        r.ready( () => {
            q.addAction("ClientEventsServiceLogger.initialize.success", n)
        }
        )
    }
    async track(t, n) {
        const [r] = await this.analytics;
        r.track(t, n, {
            page: h5()
        }),
        Fx(`Web Client Event: ${t} with data: ${JSON.stringify(n)}`)
    }
    async trackPageView() {
        const t = h5()
          , [n] = await this.analytics;
        n.page(void 0, t, {
            page: t
        }),
        Fx(`Web Client Page View: ${t.path}`)
    }
    async identify(t) {
        this.user = t;
        const [n] = await this.analytics;
        n.identify(t.userId, t.traits)
    }
    buildEnvelope(t, n) {
        const r = this.getExtraContext()
          , s = t.$type;
        return {
            eventName: (s.split(".").pop() ?? "structured_event").replace(/([a-z0-9])([A-Z])/g, "$1_$2").replace(/([A-Z])([A-Z][a-z])/g, "$1_$2").toLowerCase(),
            eventClass: "chatgpt_web",
            eventId: Ts(),
            eventCreatedAt: new Date().toISOString(),
            eventType: "client",
            userParams: {
                userId: this.user?.userId ?? "",
                authStatus: String(r.auth_status ?? ""),
                planType: String(r.user_traits?.plan_type ?? ""),
                workspaceId: String(r.user_traits?.workspace_id ?? "")
            },
            deviceParams: {
                deviceId: this.deviceId,
                locale: this.browserLocale,
                appEnvironment: String(r.app_name ?? ""),
                appVersion: this.appVersion
            },
            eventParams: {
                "@type": `openai.buf.dev/openai/protobuf-analytics-events/${s}`,
                ...n
            }
        }
    }
    trackStructuredEvent(t, n) {
        const r = this.buildEnvelope(t, n);
        this.track("__protobuf_structured_event__", r)
    }
    getExtraContext() {
        return {
            app_name: this.appName,
            app_version: this.appVersion,
            browser_locale: this.browserLocale,
            device_id: this.deviceId,
            auth_status: this.user ? fr.LoggedIn : fr.LoggedOut,
            user_traits: this.user?.traits,
            punch_out_info_token: eF()
        }
    }
}
function qre(e) {
    return ({payload: t, next: n}) => {
        t.obj.context = {
            ...t.obj.context,
            ...e.getExtraContext()
        },
        n(t)
    }
}
const Gre = xi()
  , Vre = navigator.language
  , p5 = "9d358314d30a26d59ec2f2390d079c86e2c0018f"
  , bd = new Bre({
    appName: "chatgpt",
    appVersion: p5,
    deviceId: Gre,
    browserLocale: Vre,
    options: sW,
    settings: oW
});
function Hre(e) {
    const t = {};
    return Object.entries(e).forEach( ([n,r]) => {
        (typeof r == "number" || typeof r == "string" || typeof r == "boolean") && (t[n] = String(r))
    }
    ),
    t
}
const V = {
    initialize({userInfo: e}={}) {
        const t = e?.currentAccount?.structure === Dr.WORKSPACE ? e.currentAccount.id : null
          , n = e ? {
            userId: e.sessionUser.id,
            traits: {
                plan_type: e.currentAccount?.planType ?? null,
                workspace_id: t,
                workspace_type: e.currentAccount?.workspaceType ?? null
            }
        } : null;
        bd.initialize({
            user: n
        })
    },
    logEvent(e, t) {
        bd.track(e, {
            ...t,
            origin: "chat",
            app_version: p5
        })
    },
    logEventWithStatsig(e, t, n) {
        this.logValueEventWithStatsig({
            segmentEventName: e,
            statsigEventName: t,
            data: n
        })
    },
    logValueEventWithStatsig({segmentEventName: e, value: t, statsigEventName: n, data: r}) {
        const s = {
            ...t != null ? {
                value: t
            } : {},
            ...r,
            origin: "chat",
            app_version: p5
        };
        bd.track(e, s);
        const o = Hre(s);
        ft.logEvent(n, t ?? null, o)
    },
    logPageView() {
        bd.trackPageView()
    },
    logStructuredEvent(e, t) {
        bd.trackStructuredEvent(e, t)
    },
    logNewChatButtonClicked({location: e, gizmo_id: t}) {
        this.logEvent("New Chat Button Clicked", {
            location: e,
            gizmo_id: t
        }),
        ft.logEvent("chatgpt_new_chat_button_clicked", null, {
            location: e
        })
    },
    logAuthErrorResponse(e) {
        this.logEvent("Auth: Error", {
            error_code: e
        }),
        ft.logEvent("chatgpt_auth_error", e)
    },
    logNoAuthAttachButtonClicked(e) {
        this.logEvent("No Auth Attach Button Clicked", e),
        ft.logEvent("chatgpt_web_no_auth_attach_button_clicked", null, e)
    },
    logNoAuthVoiceButtonClicked(e) {
        this.logEvent("No Auth Voice Button Clicked", e),
        ft.logEvent("chatgpt_web_no_auth_voice_button_clicked", null, e)
    },
    logLogInButtonClicked(e) {
        this.logEvent("Auth: Login", e),
        ft.logEvent("chatgpt_auth_log_in", null, e)
    },
    logSignUpButtonClicked(e) {
        this.logEvent("Auth: Signup", e),
        ft.logEvent("chatgpt_auth_sign_up", null, e)
    },
    logLoginOrSignUpButtonClicked(e) {
        this.logEvent("Auth: Login or Signup", e),
        ft.logEvent("chatgpt_auth_log_in_or_sign_up", null, e)
    },
    logLogOutButtonClicked(e) {
        this.logEvent("Auth: Logout", e),
        ft.logEvent("chatgpt_auth_log_out", null, e)
    },
    logRateLimitBannerShown(e) {
        let t, n;
        switch (e.type) {
        case "account_sharing_degrade":
            t = "Account Sharing Degrade: Show Info",
            n = "chatgpt_account_sharing_degrade_banner_shown";
            break;
        case "tatertot-in-context-upsell":
        case "o3-mini-high-in-context-upsell-free":
        case "o3-mini-high-in-context-upsell-plus":
        case "deep-research-in-context-upsell":
        case "deep-research-in-context-upsell-free":
        case "codex-in-context-upsell":
        case "codex-in-context-upsell-plus":
            t = "In-Context Upsell Banner: Show Info",
            n = "chatgpt_in_context_upsell_banner_shown";
            break;
        default:
            t = "Rate Limit: Show Info",
            n = "chatgpt_rate_limit_banner_shown";
            break
        }
        this.logEvent(t, e);
        const {call_to_action: r, ...s} = e
          , o = s;
        r?.forEach( (i, a) => {
            o[`call_to_action.${a}`] = i
        }
        ),
        ft.logEvent(n, null, {
            ...o,
            is_new_conversation: e.is_new_conversation.toString(),
            is_hard_block: e.is_hard_block.toString()
        })
    },
    logRateLimitGetPlusButtonClicked(e) {
        this.logEvent("Rate Limit: Click Upsell", e),
        ft.logEvent("chatgpt_rate_limit_get_plus_button_clicked", null, {
            ...e,
            is_new_conversation: e.is_new_conversation ? e.is_new_conversation.toString() : "",
            is_hard_block: e.is_hard_block.toString()
        })
    },
    logRateLimitUpgradePlanButtonClicked(e) {
        this.logEvent("Rate Limit: Click Upsell", e),
        ft.logEvent("chatgpt_rate_limit_upgrade_plan_button_clicked", null, {
            ...e,
            is_new_conversation: e.is_new_conversation.toString(),
            is_hard_block: e.is_hard_block.toString()
        })
    },
    logPopoverHover(e) {
        this.logEvent("Popover Hover", e),
        ft.logEvent("chatgpt_popover_hover", null, e)
    },
    logUpsellGetPlusButtonClicked(e) {
        this.logEventWithStatsig("Upsell: Get Plus Clicked", "chatgpt_upsell_get_plus_button_clicked", e)
    },
    logToggleShowRecents({isOnlyShowingRecents: e}) {
        this.logEvent("Toggle Show Recents", {
            isOnlyShowingRecents: e
        }),
        ft.logEvent("chatgpt_toggle_show_recents", null, {
            isOnlyShowingRecents: String(e)
        })
    },
    logToggleShowGptList({isCollapsed: e}) {
        this.logEvent("Toggle Show GPT List", {
            isCollapsed: e
        })
    },
    logToggleDesktopNavCollapsed({isDesktopNavCollapsed: e, action: t}) {
        this.logEvent("Toggle Desktop Nav Collapsed", {
            isDesktopNavCollapsed: e
        }),
        ft.logEvent("chatgpt_toggle_desktop_nav_collapsed", null, {
            isDesktopNavCollapsed: String(e),
            action: t
        })
    },
    logTogglePlanManagementModal({isOpen: e}) {
        const t = "chatgpt_toggle_plan_management_modal";
        this.logEvent("Toggle Plan Management Modal", {
            isOpen: e
        }),
        ft.logEvent(t, null, {
            isOpen: String(e)
        })
    },
    logPaymentSuccess(e) {
        this.logEvent("Subscription: Payment Success Page", e),
        ft.logEvent("chatgpt_plan_payment_success_page", null, e)
    },
    logNetworkError(e) {
        this.logEvent("chatgpt_web_network_error", e),
        ft.logEvent("chatgpt_web_network_error", null, e)
    },
    logFailedToFetchError(e) {
        this.logEvent("chatgpt_web_failed_to_fetch", e),
        ft.logEvent("chatgpt_web_failed_to_fetch", null, e)
    }
}
  , tF = Ft.IsNoAuthChatTrainingEnabled
  , ra = Ei( () => {
    let e = null;
    return typeof window < "u" && (e = Zre() ?? null),
    {
        isNoAuthChatTrainingEnabled: e,
        isTemporaryChatEnabled: !1,
        isAnonModeEnabled: !1
    }
}
)
  , uw = e => Xl(ra, e);
function zre() {
    const e = $re()
      , t = Wre()
      , {isUnauthenticated: n} = ah();
    return !!(e || n && !t)
}
function dw(e) {
    return fw() || !yn(e) && !Kre(e)
}
function $re() {
    return uw(e => e.isTemporaryChatEnabled)
}
function fw() {
    return ra.getState().isTemporaryChatEnabled
}
function nF(e) {
    return Xe(e, "1656345175")
}
function Wre() {
    const e = ue()
      , t = uw(n => n.isNoAuthChatTrainingEnabled);
    return t ?? nF(e)
}
function Kre(e) {
    const t = ra.getState().isNoAuthChatTrainingEnabled;
    return t ?? nF(e)
}
function Qxe() {
    return uw(e => e.isAnonModeEnabled)
}
function Yre() {
    return ra.getState().isAnonModeEnabled
}
const jx = {
    setIsTemporaryChatEnabled(e) {
        ra.setState({
            isTemporaryChatEnabled: e
        }),
        e && V.logEvent("Enable Temporary Chat")
    },
    setIsAnonModeEnabled(e) {
        ra.setState({
            isAnonModeEnabled: e
        })
    },
    toggleIsTemporaryChatEnabled() {
        jx.setIsTemporaryChatEnabled(!ra.getState().isTemporaryChatEnabled)
    },
    disableTemporaryChat() {
        jx.setIsTemporaryChatEnabled(!1)
    },
    setIsNoAuthChatTrainingEnabled(e) {
        ra.setState({
            isNoAuthChatTrainingEnabled: e
        }),
        Wt.setItem(tF, e)
    }
};
function Zre() {
    const e = Wt.getItem(tF);
    return e === "true" || e === !0 ? !0 : e === "false" || e === !1 ? !1 : void 0
}
function jl(e, t) {
    for (const [n,r] of Object.entries(t))
        e.addEventListener(n, r);
    return () => {
        for (const [n,r] of Object.entries(t))
            e.removeEventListener(n, r)
    }
}
function eTe(e, t) {
    for (const [n,r] of Object.entries(t))
        e.on(n, r);
    return () => {
        for (const [n,r] of Object.entries(t))
            e.off(n, r)
    }
}
function Jre(e, t) {
    let n;
    const r = () => Wt.getItem(e) ?? t()
      , s = Pa(o => (n = o,
    jl(window, {
        storage: ({key: i}) => {
            i === e && o()
        }
    })), r, {
        name: `localStorage:${e}`,
        getServerFallback: t
    });
    return s.set = o => {
        Wt.setItem(e, DP(o) ? o(r()) : o),
        n?.()
    }
    ,
    s
}
const m5 = {}
  , Xre = ["added", "updated", "removed"];
let Ux = !1;
function Qre(e) {
    Ux || (Ux = !0,
    e.getQueryCache().subscribe(t => {
        const n = t.query.queryHash;
        if (t.query.state.status === "success" && n in m5 && Xre.includes(t.type)) {
            const {cacheKey: r, cacheVersion: s} = m5[n];
            uee(Kte(e)?.id ?? null, r, t.query.state.data, s)
        }
    }
    ))
}
function ese(e, t, n, r) {
    Qre(e),
    m5[MN(t)] = {
        cacheKey: n,
        cacheVersion: r
    }
}
function y1(e, t, n) {
    const r = Vg()
      , s = ue();
    if (r)
        return rF(s, e, t, n)
}
function rF(e, t, n, r) {
    const s = bn(e)
      , o = Aa(e);
    return ese(o, r, t, n),
    () => {
        const i = cee(s?.id ?? null, t, n);
        if (i != null)
            return i
    }
}
const lh = e => ["models", {
    IIM: e?.IIM ?? !1,
    isGizmo: e?.isGizmo ?? !1
}]
  , tse = () => ["gizmo-models"]
  , sF = "models"
  , oF = 1;
function iF(e) {
    const t = At(Um(e));
    return zre() && t.data ? {
        ...t,
        data: cse(t.data)
    } : t
}
function aF({isGizmo: e}) {
    const t = y1(sF, oF, lh());
    return iF({
        isGizmo: e,
        placeholderData: e ? void 0 : t
    })
}
function nse({isGizmo: e}) {
    return iF({
        IIM: !0,
        isGizmo: e,
        enabled: !1
    })
}
const Um = e => so({
    retry: 5,
    enabled: e?.enabled ?? !0,
    queryKey: lh(e),
    queryFn: async () => {
        const t = io(await ie.safeGet("/models", {
            authOption: Qt.SendIfAvailable,
            parameters: {
                query: {
                    iim: e?.IIM,
                    is_gizmo: e?.isGizmo
                }
            }
        }));
        return ose(t)
    }
    ,
    placeholderData: e?.placeholderData
});
function hw({isGizmo: e=!1}={}) {
    const {data: t, isLoading: n} = aF({
        isGizmo: e
    })
      , {data: r, isLoading: s} = nse({
        isGizmo: e
    });
    return {
        modelsData: r ?? t,
        externalModelsLoading: n,
        fullModelsLoading: s || n
    }
}
function rse({enabled: e=!0}={}) {
    const {data: t, isLoading: n} = At(so({
        retry: 5,
        enabled: e,
        queryKey: tse(),
        queryFn: async () => {
            const r = io(await ie.safeGet("/models/gpts", {
                authOption: Qt.SendIfAvailable
            }));
            return ise(r)
        }
    }));
    return {
        gizmoModelsData: t,
        gizmoModelsLoading: n
    }
}
const tTe = en(e => Zf(e, () => Um({
    IIM: !1,
    placeholderData: rF(e, sF, oF, lh())
}), {
    forcePendingOnServer: !0
}));
function sse({isGizmo: e=!1}={}) {
    return aF({
        isGizmo: e
    })
}
function lF(e) {
    return e.getQueryData(lh())
}
function ose(e) {
    return {
        categories: e.categories.concat().reverse().map(ase),
        groups: e.internal_groups?.map(lse) ?? [],
        defaultModelSlug: e.default_model_slug ?? null,
        modelPickerVersion: e.model_picker_version,
        models: new Map(e.models.map(t => [t.slug, cF(t)])),
        title: e.title
    }
}
function ise(e) {
    return {
        editor: e.editor,
        model_override: e.model_override
    }
}
function cF(e) {
    return {
        id: e.slug,
        maxTokens: e.max_tokens,
        title: e.title,
        description: e.description,
        tags: e.tags,
        enabledTools: e.enabled_tools,
        product_features: e.product_features,
        enableInfer: e.enable_infer,
        enableInferOptOut: e.enable_infer_opt_out,
        reasoningType: e.reasoning_type
    }
}
function ase({default_model: e, tagline: t, color: n, human_category_name: r, category: s, human_category_short_name: o, human_category_shorter_name: i, subscription_level: a, short_explainer: l, subcategory: c, render_header_type: u, title: d, is_beta: f, is_alpha: p, model_badge: m, supported_features: v, supported_models: _, disabled_by_admin: y, date_updated: b, action_pill_short_name: S, slash_command_enabled: C, ...w}) {
    return {
        color: n,
        tagline: t,
        defaultModel: e,
        label: r,
        shortLabel: o,
        description: l,
        shorterLabel: i ?? o,
        subscriptionLevel: a,
        categoryId: s,
        subcategory: c,
        renderHeaderType: u,
        isBeta: f,
        isAlpha: p,
        modelBadge: m,
        title: d,
        supportedFeatures: v,
        supportedModels: _ ?? [],
        dateUpdated: b,
        actionPillShortName: S,
        slashCommandEnabled: C,
        disabledByAdmin: y ?? !1,
        ...w
    }
}
function lse({group: e, human_group_name: t, human_group_short_name: n, model_ids: r}) {
    return {
        group: e,
        label: t,
        shortLabel: n,
        modelIds: r
    }
}
const Bx = new WeakMap;
function cse(e) {
    let t = Bx.get(e);
    if (!t) {
        const n = new Map([...e.models.entries()].filter( ([,r]) => r.tags.includes("history_off_approved")));
        t = {
            models: n,
            defaultModelSlug: e.defaultModelSlug,
            categories: e.categories.filter(r => n.has(r.defaultModel)),
            groups: e.groups.map(r => ({
                ...r,
                modelIds: r.modelIds.filter(s => n.has(s))
            })).filter(r => r.modelIds.length > 0)
        },
        Bx.set(e, t)
    }
    return t
}
const uF = e => h.createElement("svg", {
    width: 16,
    height: 16,
    viewBox: "0 0 16 16",
    fill: "currentColor",
    xmlns: "http://www.w3.org/2000/svg",
    "data-rtl-flip": "",
    ...e
}, h.createElement("path", {
    d: "M6.02925 3.02929C6.25652 2.80202 6.60803 2.77382 6.86616 2.94433L6.97065 3.02929L11.4707 7.52929C11.7304 7.78899 11.7304 8.211 11.4707 8.4707L6.97065 12.9707C6.71095 13.2304 6.28895 13.2304 6.02925 12.9707C5.76955 12.711 5.76955 12.289 6.02925 12.0293L10.0585 7.99999L6.02925 3.9707L5.94429 3.8662C5.77378 3.60807 5.80198 3.25656 6.02925 3.02929Z"
}))
  , use = e => h.createElement("svg", {
    width: 16,
    height: 16,
    viewBox: "0 0 16 16",
    fill: "currentColor",
    xmlns: "http://www.w3.org/2000/svg",
    ...e
}, h.createElement("path", {
    d: "M8 9.93359C8.40501 9.93359 8.7334 10.262 8.7334 10.667C8.73322 11.0718 8.4049 11.4004 8 11.4004C7.59524 11.4002 7.26678 11.0718 7.2666 10.667C7.2666 10.2621 7.59512 9.93375 8 9.93359Z"
}), h.createElement("path", {
    d: "M8 4.66699C9.00983 4.66699 9.71143 5.3376 9.91113 6.12598C10.1119 6.91849 9.80668 7.84168 8.89453 8.29785C8.75494 8.36765 8.66699 8.51093 8.66699 8.66699C8.66681 9.03503 8.36808 9.33301 8 9.33301C7.63194 9.33299 7.33319 9.03502 7.33301 8.66699C7.33301 8.00598 7.70668 7.40116 8.29785 7.10547C8.60101 6.95389 8.6789 6.69288 8.61816 6.45312C8.55627 6.20931 8.35206 6 8 6C7.74846 6.00001 7.52816 6.13905 7.41406 6.34766C7.23735 6.67059 6.83275 6.78894 6.50977 6.6123C6.18684 6.43568 6.0677 6.03099 6.24414 5.70801C6.58269 5.08904 7.24177 4.667 8 4.66699Z"
}), h.createElement("path", {
    fillRule: "evenodd",
    clipRule: "evenodd",
    d: "M8 1.33301C11.6819 1.33301 14.667 4.3181 14.667 8C14.667 11.6819 11.6819 14.667 8 14.667C4.3181 14.667 1.33301 11.6819 1.33301 8C1.33301 4.3181 4.3181 1.33301 8 1.33301ZM8 2.66699C5.05448 2.66699 2.66699 5.05448 2.66699 8C2.66699 10.9455 5.05448 13.333 8 13.333C10.9455 13.333 13.333 10.9455 13.333 8C13.333 5.05448 10.9455 2.66699 8 2.66699Z"
}))
  , dse = e => h.createElement("svg", {
    width: 16,
    height: 16,
    viewBox: "0 0 16 16",
    fill: "currentColor",
    xmlns: "http://www.w3.org/2000/svg",
    "data-rtl-flip": "",
    ...e
}, h.createElement("path", {
    d: "M11.3349 10.3301V5.60547L4.47065 12.4707C4.21095 12.7304 3.78895 12.7304 3.52925 12.4707C3.26955 12.211 3.26955 11.789 3.52925 11.5293L10.3945 4.66504H5.66011C5.29284 4.66504 4.99507 4.36727 4.99507 4C4.99507 3.63273 5.29284 3.33496 5.66011 3.33496H11.9999L12.1337 3.34863C12.4369 3.41057 12.665 3.67857 12.665 4V10.3301C12.6649 10.6973 12.3672 10.9951 11.9999 10.9951C11.6327 10.9951 11.335 10.6973 11.3349 10.3301ZM11.333 4.66699L11.3349 4.66797L11.332 4.66504H11.331L11.333 4.66699Z"
}));
function Wr(e) {
    return e ? "" : void 0
}
function fse(e, t) {
    return e.getAttribute(t) != null
}
function nTe(e, t, n) {
    dF(e, t, Wr(n))
}
function dF(e, t, n) {
    e && (n != null ? e.setAttribute(t, n) : e.removeAttribute(t))
}
function hse() {
    return SN() ? 8 : 1
}
function fF(e) {
    return (e.ctrlKey ? 1 : 0) | (e.altKey ? 2 : 0) | (e.shiftKey ? 4 : 0) | (e.metaKey ? 8 : 0)
}
function pse(e) {
    return !b1(e) && !fF(e)
}
function b1(e) {
    const t = "nativeEvent"in e ? e.nativeEvent : e;
    return t.isComposing || t.keyCode === 229
}
function mse(e) {
    const {key: t, currentTarget: n} = e
      , r = n instanceof HTMLInputElement;
    return pse(e) && (t === "Tab" || t === "ArrowDown" || t === "ArrowUp" || t === "ArrowLeft" && (!r || n.selectionStart === 0 || n.selectionEnd === 0) || t === "ArrowRight" && (!r || n.selectionEnd === n.selectionStart && n.selectionStart === n.value.length))
}
const ki = e => {
    "use forget";
    const t = De.c(113);
    let n, r, s, o, i, a, l, c, u, d, f, p, m, v, _, y, b, S, C, w, x;
    t[0] !== e ? ({as: o, icon: r, trailing: s, highlightTrailing: n, showHighlightTrailing: m, trailingColor: v, label: d, badge: i, secondary: p, className: l, color: c, size: _, active: y, highlighted: b, hasManagedFocus: S, subMenu: C, fillContainer: w, children: a, iconOnly: x, iconAriaLabel: u, ...f} = e,
    t[0] = e,
    t[1] = n,
    t[2] = r,
    t[3] = s,
    t[4] = o,
    t[5] = i,
    t[6] = a,
    t[7] = l,
    t[8] = c,
    t[9] = u,
    t[10] = d,
    t[11] = f,
    t[12] = p,
    t[13] = m,
    t[14] = v,
    t[15] = _,
    t[16] = y,
    t[17] = b,
    t[18] = S,
    t[19] = C,
    t[20] = w,
    t[21] = x) : (n = t[1],
    r = t[2],
    s = t[3],
    o = t[4],
    i = t[5],
    a = t[6],
    l = t[7],
    c = t[8],
    u = t[9],
    d = t[10],
    f = t[11],
    p = t[12],
    m = t[13],
    v = t[14],
    _ = t[15],
    y = t[16],
    b = t[17],
    S = t[18],
    C = t[19],
    w = t[20],
    x = t[21]);
    const E = m === void 0 ? !1 : m
      , T = v === void 0 ? "tertiary" : v
      , k = _ === void 0 ? "default" : _
      , A = y === void 0 ? !1 : y
      , O = b === void 0 ? !1 : b
      , M = S === void 0 ? !1 : S
      , I = C === void 0 ? !1 : C
      , R = w === void 0 ? !1 : w
      , D = x === void 0 ? !1 : x;
    let P;
    if (h.isValidElement(a) && !d && !i)
        P = a;
    else {
        let se;
        t[22] !== d ? (se = d && g.jsx(vse, {
            children: d
        }),
        t[22] = d,
        t[23] = se) : se = t[23];
        let G;
        t[24] !== i ? (G = i && g.jsx(mw, {
            children: i
        }),
        t[24] = i,
        t[25] = G) : G = t[25];
        let F;
        t[26] !== a || t[27] !== se || t[28] !== G ? (F = g.jsxs("div", {
            className: "flex min-w-0 grow items-center gap-2.5 group-data-no-contents-gap:gap-0",
            children: [se, a, G]
        }),
        t[26] = a,
        t[27] = se,
        t[28] = G,
        t[29] = F) : F = t[29],
        P = F
    }
    if (p) {
        let se;
        t[30] !== p ? (se = g.jsx("div", {
            className: "not-group-data-disabled:text-token-text-tertiary leading-dense mb-0.5 text-xs group-data-sheet-item:mt-0.5 group-data-sheet-item:mb-0",
            children: p
        }),
        t[30] = p,
        t[31] = se) : se = t[31];
        let G;
        t[32] !== P || t[33] !== se ? (G = g.jsxs("div", {
            className: "min-w-0",
            children: [P, se]
        }),
        t[32] = P,
        t[33] = se,
        t[34] = G) : G = t[34],
        P = G
    }
    if (r) {
        const se = k === "large" ? "icon-lg" : "icon";
        let G;
        t[35] !== se ? (G = we("flex items-center justify-center group-disabled:opacity-50 group-data-disabled:opacity-50", se),
        t[35] = se,
        t[36] = G) : G = t[36];
        let F;
        t[37] !== r || t[38] !== u || t[39] !== D ? (F = typeof r != "function" ? r : g.jsx(r, {
            className: "icon",
            "aria-hidden": D ? "false" : "true",
            "aria-label": D ? u : void 0
        }),
        t[37] = r,
        t[38] = u,
        t[39] = D,
        t[40] = F) : F = t[40];
        let ke;
        t[41] !== G || t[42] !== F ? (ke = g.jsx("div", {
            className: G,
            children: F
        }),
        t[41] = G,
        t[42] = F,
        t[43] = ke) : ke = t[43];
        const Ee = !D && P;
        let Y;
        t[44] !== ke || t[45] !== Ee ? (Y = g.jsxs(g.Fragment, {
            children: [ke, Ee]
        }),
        t[44] = ke,
        t[45] = Ee,
        t[46] = Y) : Y = t[46],
        P = Y
    }
    let L;
    if (s) {
        const se = T === "tertiary" && "text-token-text-tertiary";
        let G;
        t[47] !== se ? (G = we("trailing", se),
        t[47] = se,
        t[48] = G) : G = t[48];
        const F = n ? -1 : void 0;
        let ke;
        t[49] !== s ? (ke = typeof s != "function" ? s : g.jsx(s, {
            className: "icon",
            "aria-hidden": "true"
        }),
        t[49] = s,
        t[50] = ke) : ke = t[50];
        let Ee;
        t[51] !== G || t[52] !== F || t[53] !== ke ? (Ee = g.jsx("div", {
            className: G,
            tabIndex: F,
            children: ke
        }),
        t[51] = G,
        t[52] = F,
        t[53] = ke,
        t[54] = Ee) : Ee = t[54],
        L = Ee
    }
    if (n) {
        const se = T === "tertiary" && "text-token-text-tertiary";
        let G;
        t[55] !== se ? (G = we("trailing highlight", se),
        t[55] = se,
        t[56] = G) : G = t[56];
        let F;
        t[57] !== n ? (F = typeof n != "function" ? n : g.jsx(n, {
            className: "icon",
            "aria-hidden": "true"
        }),
        t[57] = n,
        t[58] = F) : F = t[58];
        let ke;
        t[59] !== G || t[60] !== F ? (ke = g.jsx("div", {
            className: G,
            children: F
        }),
        t[59] = G,
        t[60] = F,
        t[61] = ke) : ke = t[61];
        const Ee = ke;
        let Y;
        t[62] !== Ee || t[63] !== L ? (Y = L ? g.jsxs("div", {
            className: "trailing-pair",
            children: [Ee, L]
        }) : Ee,
        t[62] = Ee,
        t[63] = L,
        t[64] = Y) : Y = t[64],
        L = Y
    }
    if (I) {
        let se;
        t[65] === Symbol.for("react.memo_cache_sentinel") ? (se = g.jsx(uF, {
            className: "icon-sm -me-0.25"
        }),
        t[65] = se) : se = t[65];
        const G = se;
        let F;
        t[66] !== L ? (F = L ? g.jsxs("div", {
            className: "flex items-center gap-1 self-stretch",
            children: [L, G]
        }) : G,
        t[66] = L,
        t[67] = F) : F = t[67],
        L = F
    }
    if (L && !D) {
        if (r) {
            const G = k === "large" ? "gap-2" : "gap-1.5";
            let F;
            t[68] !== G ? (F = we("flex min-w-0 items-center", G),
            t[68] = G,
            t[69] = F) : F = t[69];
            let ke;
            t[70] !== P || t[71] !== F ? (ke = g.jsx("div", {
                className: F,
                children: P
            }),
            t[70] = P,
            t[71] = F,
            t[72] = ke) : ke = t[72],
            P = ke
        }
        let se;
        t[73] !== P || t[74] !== L ? (se = g.jsxs(g.Fragment, {
            children: [P, L]
        }),
        t[73] = P,
        t[74] = L,
        t[75] = se) : se = t[75],
        P = se
    }
    const N = o
      , B = h.useRef(null)
      , H = h.useRef(!1);
    let ye, Ie;
    t[76] !== O ? (ye = () => {
        if (H.current) {
            H.current = !1;
            return
        }
        O && requestAnimationFrame( () => {
            B.current?.scrollIntoView({
                block: "nearest"
            })
        }
        )
    }
    ,
    Ie = [O],
    t[76] = O,
    t[77] = ye,
    t[78] = Ie) : (ye = t[77],
    Ie = t[78]),
    h.useEffect(ye, Ie);
    const be = f.disabled ? -1 : 0
      , me = f.disabled ?? !1;
    let ge;
    t[79] !== me ? (ge = Wr(me),
    t[79] = me,
    t[80] = ge) : ge = t[80];
    let ce;
    t[81] !== A ? (ce = Wr(A),
    t[81] = A,
    t[82] = ce) : ce = t[82];
    let Z;
    t[83] !== O ? (Z = Wr(O),
    t[83] = O,
    t[84] = Z) : Z = t[84];
    let ne;
    t[85] !== I ? (ne = Wr(I),
    t[85] = I,
    t[86] = ne) : ne = t[86];
    let _e;
    t[87] !== R ? (_e = Wr(R),
    t[87] = R,
    t[88] = _e) : _e = t[88];
    let ee;
    t[89] !== E ? (ee = Wr(E),
    t[89] = E,
    t[90] = ee) : ee = t[90];
    const oe = k === "large" ? "large" : void 0
      , te = c !== "default" ? c : void 0
      , ve = !M && "hoverable"
      , Ue = r && !L && (k === "large" ? "gap-2" : "gap-1.5")
      , re = k === "large" && D && "p-2";
    let W;
    t[91] !== l || t[92] !== ve || t[93] !== Ue || t[94] !== re ? (W = we("group __menu-item", ve, Ue, re, l),
    t[91] = l,
    t[92] = ve,
    t[93] = Ue,
    t[94] = re,
    t[95] = W) : W = t[95];
    let X;
    t[96] !== f ? (X = se => {
        H.current = !0,
        f.onPointerMoveCapture?.(se)
    }
    ,
    t[96] = f,
    t[97] = X) : X = t[97];
    let Te;
    return t[98] !== N || t[99] !== P || t[100] !== f || t[101] !== be || t[102] !== ge || t[103] !== ce || t[104] !== Z || t[105] !== ne || t[106] !== _e || t[107] !== ee || t[108] !== oe || t[109] !== te || t[110] !== W || t[111] !== X ? (Te = g.jsx(N, {
        ref: B,
        tabIndex: be,
        "data-disabled": ge,
        "data-active": ce,
        "data-highlighted": Z,
        "data-has-submenu": ne,
        "data-fill": _e,
        "data-revealed": ee,
        "data-size": oe,
        "data-color": te,
        className: W,
        ...f,
        onPointerMoveCapture: X,
        children: P
    }),
    t[98] = N,
    t[99] = P,
    t[100] = f,
    t[101] = be,
    t[102] = ge,
    t[103] = ce,
    t[104] = Z,
    t[105] = ne,
    t[106] = _e,
    t[107] = ee,
    t[108] = oe,
    t[109] = te,
    t[110] = W,
    t[111] = X,
    t[112] = Te) : Te = t[112],
    Te
}
  , gse = ({external: e, ...t}) => g.jsx(ki, {
    as: Bf,
    ...e ? {
        highlightTrailing: g.jsx(dse, {
            className: "icon-sm"
        }),
        target: "_blank",
        rel: "noopener noreferrer"
    } : null,
    ...t
})
  , pw = e => {
    const {row: t, className: n, ...r} = e
      , s = e.as ?? "button";
    return g.jsx(ki, {
        "data-sheet-item": !0,
        ...r,
        as: s,
        className: we("bg-token-bg-tertiary dark:bg-token-bg-secondary mx-0 w-full py-4 leading-5", t ? "justify-between px-4 text-start" : "flex-col justify-center px-0", n)
    })
}
  , vse = h.memo(function({children: t}) {
    return g.jsx("div", {
        className: "truncate",
        ref: n => {
            n?.textContent && n.scrollWidth > n.clientWidth && (n.title = n.textContent)
        }
        ,
        children: t
    })
})
  , mw = ({children: e}) => g.jsx("span", {
    className: "__menu-item-badge",
    children: e
})
  , rTe = ({disabled: e, icon: t, children: n, className: r, ...s}) => g.jsx("button", {
    disabled: e,
    tabIndex: e ? void 0 : 0,
    "data-trailing-button": Wr(!0),
    className: we("__menu-item-trailing-btn", r),
    ...s,
    onClick: o => {
        o.preventDefault(),
        o.stopPropagation(),
        s.onClick?.(o)
    }
    ,
    onDoubleClick: o => {
        o.preventDefault(),
        o.stopPropagation(),
        s.onDoubleClick?.(o)
    }
    ,
    onPointerDown: o => {
        s.onPointerDown?.(o),
        o.preventDefault(),
        o.stopPropagation()
    }
    ,
    onMouseDown: o => {
        s.onMouseDown?.(o),
        o.preventDefault(),
        o.stopPropagation()
    }
    ,
    children: g.jsx("div", {
        children: t ? g.jsx(t, {
            className: "icon",
            "aria-hidden": "true"
        }) : n
    })
})
  , sTe = ({children: e, className: t, ...n}) => g.jsx(Bf, {
    "data-trailing-button": Wr(!0),
    className: we("__menu-item-trailing-lnk", t),
    ...n,
    onClick: r => {
        r.preventDefault(),
        r.stopPropagation(),
        n.onClick?.(r)
    }
    ,
    onDoubleClick: r => {
        r.preventDefault(),
        r.stopPropagation(),
        n.onDoubleClick?.(r)
    }
    ,
    children: e
})
  , _se = ({as: e, className: t, ...n}) => {
    const r = e;
    return g.jsx(r, {
        className: we("__menu-label", t),
        ...n
    })
}
;
function yse({size: e="long"}) {
    const t = e === "long" ? 220 : 120
      , [n] = h.useState( () => .75 + .25 * Math.random());
    return g.jsx(ki, {
        as: "div",
        disabled: !0,
        children: g.jsx("div", {
            className: "loading-results-shimmer h-4 rounded-sm",
            style: {
                width: Math.round(n * t)
            }
        })
    })
}
const bse = e => {
    "use forget";
    const t = De.c(44);
    let n, r, s, o, i, a, l, c, u, d;
    t[0] !== e ? ({holdFocus: c, selectAllOnFocus: u, submitIcon: n, onClick: s, onFocus: o, onKeyDownCapture: i, onSubmit: a, border: d, className: r, ...l} = e,
    t[0] = e,
    t[1] = n,
    t[2] = r,
    t[3] = s,
    t[4] = o,
    t[5] = i,
    t[6] = a,
    t[7] = l,
    t[8] = c,
    t[9] = u,
    t[10] = d) : (n = t[1],
    r = t[2],
    s = t[3],
    o = t[4],
    i = t[5],
    a = t[6],
    l = t[7],
    c = t[8],
    u = t[9],
    d = t[10]);
    const f = c === void 0 ? !1 : c
      , p = u === void 0 ? !0 : u
      , m = d === void 0 ? !0 : d
      , v = gt();
    let _;
    t[11] !== r ? (_ = we("text-token-text-primary bg-token-bg-primary data-border:border-token-border-default m-[-1px] w-full min-w-[200px] rounded-[10px] border-transparent px-2.5 py-2 text-sm focus:ring-0 focus:ring-offset-0 focus:outline-hidden disabled:opacity-50 data-border:border-1 data-submit-icon:ps-2.5 data-submit-icon:pe-9 dark:bg-transparent", r),
    t[11] = r,
    t[12] = _) : _ = t[12];
    let y;
    t[13] !== f ? (y = Wr(f),
    t[13] = f,
    t[14] = y) : y = t[14];
    let b;
    t[15] !== m ? (b = Wr(m),
    t[15] = m,
    t[16] = b) : b = t[16];
    const S = !!n;
    let C;
    t[17] !== S ? (C = Wr(S),
    t[17] = S,
    t[18] = C) : C = t[18];
    let w;
    t[19] !== s ? (w = M => {
        s?.(M),
        M.preventDefault()
    }
    ,
    t[19] = s,
    t[20] = w) : w = t[20];
    let x;
    t[21] !== o || t[22] !== p ? (x = M => {
        o?.(M),
        p && M.currentTarget.select()
    }
    ,
    t[21] = o,
    t[22] = p,
    t[23] = x) : x = t[23];
    let E;
    t[24] !== i || t[25] !== a ? (E = M => {
        i?.(M);
        const {key: I} = M;
        mse(M) || (M.stopPropagation(),
        I === "Enter" && a?.(M))
    }
    ,
    t[24] = i,
    t[25] = a,
    t[26] = E) : E = t[26];
    let T;
    t[27] !== l || t[28] !== x || t[29] !== E || t[30] !== _ || t[31] !== y || t[32] !== b || t[33] !== C || t[34] !== w ? (T = g.jsx("input", {
        type: "text",
        className: _,
        "data-hold-focus": y,
        "data-border": b,
        "data-submit-icon": C,
        autoComplete: "off",
        onClick: w,
        onFocus: x,
        onKeyDownCapture: E,
        ...l
    }),
    t[27] = l,
    t[28] = x,
    t[29] = E,
    t[30] = _,
    t[31] = y,
    t[32] = b,
    t[33] = C,
    t[34] = w,
    t[35] = T) : T = t[35];
    const k = T;
    let A;
    t[36] !== n || t[37] !== v || t[38] !== a || t[39] !== l?.value ? (A = n && g.jsx("div", {
        className: "absolute end-2.5 top-1/2 flex -translate-y-1/2 items-center justify-center",
        children: g.jsx("button", {
            className: "icon composer-submit-btn size-5",
            disabled: l?.value?.toString().trim() === "",
            onClick: a,
            "aria-label": v.formatMessage({
                defaultMessage: "Submit",
                id: "aria.submit"
            }),
            "data-in-menu": Wr(!0),
            children: g.jsx(n, {
                className: "icon-xs"
            })
        })
    }),
    t[36] = n,
    t[37] = v,
    t[38] = a,
    t[39] = l?.value,
    t[40] = A) : A = t[40];
    let O;
    return t[41] !== k || t[42] !== A ? (O = g.jsxs("div", {
        className: "relative mx-1.5 mb-1 w-[calc(100%---spacing(3))]",
        children: [A, k]
    }),
    t[41] = k,
    t[42] = A,
    t[43] = O) : O = t[43],
    O
}
;
function Cse(e) {
    const t = h.useRef({
        value: e,
        previous: e
    });
    return h.useMemo( () => (t.current.value !== e && (t.current.previous = t.current.value,
    t.current.value = e),
    t.current.previous), [e])
}
function hF(e) {
    const [t,n] = h.useState(void 0);
    return Dl( () => {
        if (e) {
            n({
                width: e.offsetWidth,
                height: e.offsetHeight
            });
            const r = new ResizeObserver(s => {
                if (!Array.isArray(s) || !s.length)
                    return;
                const o = s[0];
                let i, a;
                if ("borderBoxSize"in o) {
                    const l = o.borderBoxSize
                      , c = Array.isArray(l) ? l[0] : l;
                    i = c.inlineSize,
                    a = c.blockSize
                } else
                    i = e.offsetWidth,
                    a = e.offsetHeight;
                n({
                    width: i,
                    height: a
                })
            }
            );
            return r.observe(e, {
                box: "border-box"
            }),
            () => r.unobserve(e)
        } else
            n(void 0)
    }
    , [e]),
    t
}
var gw = "Switch"
  , [Sse,oTe] = $u(gw)
  , [wse,Ese] = Sse(gw)
  , pF = h.forwardRef( (e, t) => {
    const {__scopeSwitch: n, name: r, checked: s, defaultChecked: o, required: i, disabled: a, value: l="on", onCheckedChange: c, form: u, ...d} = e
      , [f,p] = h.useState(null)
      , m = xn(t, S => p(S))
      , v = h.useRef(!1)
      , _ = f ? u || !!f.closest("form") : !0
      , [y=!1,b] = Ql({
        prop: s,
        defaultProp: o,
        onChange: c
    });
    return g.jsxs(wse, {
        scope: n,
        checked: y,
        disabled: a,
        children: [g.jsx(Vt.button, {
            type: "button",
            role: "switch",
            "aria-checked": y,
            "aria-required": i,
            "data-state": vF(y),
            "data-disabled": a ? "" : void 0,
            disabled: a,
            value: l,
            ...d,
            ref: m,
            onClick: Qe(e.onClick, S => {
                b(C => !C),
                _ && (v.current = S.isPropagationStopped(),
                v.current || S.stopPropagation())
            }
            )
        }), _ && g.jsx(xse, {
            control: f,
            bubbles: !v.current,
            name: r,
            value: l,
            checked: y,
            required: i,
            disabled: a,
            form: u,
            style: {
                transform: "translateX(-100%)"
            }
        })]
    })
}
);
pF.displayName = gw;
var mF = "SwitchThumb"
  , gF = h.forwardRef( (e, t) => {
    const {__scopeSwitch: n, ...r} = e
      , s = Ese(mF, n);
    return g.jsx(Vt.span, {
        "data-state": vF(s.checked),
        "data-disabled": s.disabled ? "" : void 0,
        ...r,
        ref: t
    })
}
);
gF.displayName = mF;
var xse = e => {
    const {control: t, checked: n, bubbles: r=!0, ...s} = e
      , o = h.useRef(null)
      , i = Cse(n)
      , a = hF(t);
    return h.useEffect( () => {
        const l = o.current
          , c = window.HTMLInputElement.prototype
          , d = Object.getOwnPropertyDescriptor(c, "checked").set;
        if (i !== n && d) {
            const f = new Event("click",{
                bubbles: r
            });
            d.call(l, n),
            l.dispatchEvent(f)
        }
    }
    , [i, n, r]),
    g.jsx("input", {
        type: "checkbox",
        "aria-hidden": !0,
        defaultChecked: n,
        ...s,
        tabIndex: -1,
        ref: o,
        style: {
            ...e.style,
            ...a,
            position: "absolute",
            pointerEvents: "none",
            opacity: 0,
            margin: 0
        }
    })
}
;
function vF(e) {
    return e ? "checked" : "unchecked"
}
var Tse = pF
  , kse = gF;
const _F = ({size: e, className: t, icon: n, withinLabel: r, ...s}) => g.jsx(Tse, {
    className: we("radix-state-checked:bg-blue-400 focus-visible:ring-token-text-primary relative box-content aspect-7/4 shrink-0 rounded-full bg-gray-200 p-[2px] focus-visible:ring-2 focus-visible:ring-offset-2 focus-visible:outline-hidden disabled:opacity-50 dark:bg-gray-600", e === "small" ? "h-3" : "h-4", t),
    ...s,
    children: g.jsx(kse, {
        className: "radix-state-checked:translate-x-[calc(var(--dir,1)*100%*(7/4-1))] flex aspect-square h-full items-center justify-center rounded-full bg-white transition-transform duration-100 rtl:[--dir:-1]",
        children: n
    })
});
function vw(e, t=[]) {
    let n = [];
    function r(o, i) {
        const a = h.createContext(i)
          , l = n.length;
        n = [...n, i];
        function c(d) {
            const {scope: f, children: p, ...m} = d
              , v = f?.[e][l] || a
              , _ = h.useMemo( () => m, Object.values(m));
            return g.jsx(v.Provider, {
                value: _,
                children: p
            })
        }
        function u(d, f) {
            const p = f?.[e][l] || a
              , m = h.useContext(p);
            if (m)
                return m;
            if (i !== void 0)
                return i;
            throw new Error(`\`${d}\` must be used within \`${o}\``)
        }
        return c.displayName = o + "Provider",
        [c, u]
    }
    const s = () => {
        const o = n.map(i => h.createContext(i));
        return function(a) {
            const l = a?.[e] || o;
            return h.useMemo( () => ({
                [`__scope${e}`]: {
                    ...a,
                    [e]: l
                }
            }), [a, l])
        }
    }
    ;
    return s.scopeName = e,
    [r, Ose(s, ...t)]
}
function Ose(...e) {
    const t = e[0];
    if (e.length === 1)
        return t;
    const n = () => {
        const r = e.map(s => ({
            useScope: s(),
            scopeName: s.scopeName
        }));
        return function(o) {
            const i = r.reduce( (a, {useScope: l, scopeName: c}) => {
                const d = l(o)[`__scope${c}`];
                return {
                    ...a,
                    ...d
                }
            }
            , {});
            return h.useMemo( () => ({
                [`__scope${t.scopeName}`]: i
            }), [i])
        }
    }
    ;
    return n.scopeName = t.scopeName,
    n
}
function yF(e) {
    const t = e + "CollectionProvider"
      , [n,r] = vw(t)
      , [s,o] = n(t, {
        collectionRef: {
            current: null
        },
        itemMap: new Map
    })
      , i = p => {
        const {scope: m, children: v} = p
          , _ = Ne.useRef(null)
          , y = Ne.useRef(new Map).current;
        return g.jsx(s, {
            scope: m,
            itemMap: y,
            collectionRef: _,
            children: v
        })
    }
    ;
    i.displayName = t;
    const a = e + "CollectionSlot"
      , l = Ne.forwardRef( (p, m) => {
        const {scope: v, children: _} = p
          , y = o(a, v)
          , b = xn(m, y.collectionRef);
        return g.jsx(xu, {
            ref: b,
            children: _
        })
    }
    );
    l.displayName = a;
    const c = e + "CollectionItemSlot"
      , u = "data-radix-collection-item"
      , d = Ne.forwardRef( (p, m) => {
        const {scope: v, children: _, ...y} = p
          , b = Ne.useRef(null)
          , S = xn(m, b)
          , C = o(c, v);
        return Ne.useEffect( () => (C.itemMap.set(b, {
            ref: b,
            ...y
        }),
        () => void C.itemMap.delete(b))),
        g.jsx(xu, {
            [u]: "",
            ref: S,
            children: _
        })
    }
    );
    d.displayName = c;
    function f(p) {
        const m = o(e + "CollectionConsumer", p);
        return Ne.useCallback( () => {
            const _ = m.collectionRef.current;
            if (!_)
                return [];
            const y = Array.from(_.querySelectorAll(`[${u}]`));
            return Array.from(m.itemMap.values()).sort( (C, w) => y.indexOf(C.ref.current) - y.indexOf(w.ref.current))
        }
        , [m.collectionRef, m.itemMap])
    }
    return [{
        Provider: i,
        Slot: l,
        ItemSlot: d
    }, f, r]
}
var bF = h.createContext(void 0)
  , Ase = e => {
    const {dir: t, children: n} = e;
    return g.jsx(bF.Provider, {
        value: t,
        children: n
    })
}
;
function _w(e) {
    const t = h.useContext(bF);
    return e || t || "ltr"
}
var ry = "rovingFocusGroup.onEntryFocus"
  , Mse = {
    bubbles: !1,
    cancelable: !0
}
  , C1 = "RovingFocusGroup"
  , [g5,CF,Ise] = yF(C1)
  , [Rse,S1] = vw(C1, [Ise])
  , [Nse,Pse] = Rse(C1)
  , SF = h.forwardRef( (e, t) => g.jsx(g5.Provider, {
    scope: e.__scopeRovingFocusGroup,
    children: g.jsx(g5.Slot, {
        scope: e.__scopeRovingFocusGroup,
        children: g.jsx(Dse, {
            ...e,
            ref: t
        })
    })
}));
SF.displayName = C1;
var Dse = h.forwardRef( (e, t) => {
    const {__scopeRovingFocusGroup: n, orientation: r, loop: s=!1, dir: o, currentTabStopId: i, defaultCurrentTabStopId: a, onCurrentTabStopIdChange: l, onEntryFocus: c, preventScrollOnEntryFocus: u=!1, ...d} = e
      , f = h.useRef(null)
      , p = xn(t, f)
      , m = _w(o)
      , [v=null,_] = Ql({
        prop: i,
        defaultProp: a,
        onChange: l
    })
      , [y,b] = h.useState(!1)
      , S = xs(c)
      , C = CF(n)
      , w = h.useRef(!1)
      , [x,E] = h.useState(0);
    return h.useEffect( () => {
        const T = f.current;
        if (T)
            return T.addEventListener(ry, S),
            () => T.removeEventListener(ry, S)
    }
    , [S]),
    g.jsx(Nse, {
        scope: n,
        orientation: r,
        dir: m,
        loop: s,
        currentTabStopId: v,
        onItemFocus: h.useCallback(T => _(T), [_]),
        onItemShiftTab: h.useCallback( () => b(!0), []),
        onFocusableItemAdd: h.useCallback( () => E(T => T + 1), []),
        onFocusableItemRemove: h.useCallback( () => E(T => T - 1), []),
        children: g.jsx(Vt.div, {
            tabIndex: y || x === 0 ? -1 : 0,
            "data-orientation": r,
            ...d,
            ref: p,
            style: {
                outline: "none",
                ...e.style
            },
            onMouseDown: Qe(e.onMouseDown, () => {
                w.current = !0
            }
            ),
            onFocus: Qe(e.onFocus, T => {
                const k = !w.current;
                if (T.target === T.currentTarget && k && !y) {
                    const A = new CustomEvent(ry,Mse);
                    if (T.currentTarget.dispatchEvent(A),
                    !A.defaultPrevented) {
                        const O = C().filter(P => P.focusable)
                          , M = O.find(P => P.active)
                          , I = O.find(P => P.id === v)
                          , D = [M, I, ...O].filter(Boolean).map(P => P.ref.current);
                        xF(D, u)
                    }
                }
                w.current = !1
            }
            ),
            onBlur: Qe(e.onBlur, () => b(!1))
        })
    })
}
)
  , wF = "RovingFocusGroupItem"
  , EF = h.forwardRef( (e, t) => {
    const {__scopeRovingFocusGroup: n, focusable: r=!0, active: s=!1, tabStopId: o, ...i} = e
      , a = Ro()
      , l = o || a
      , c = Pse(wF, n)
      , u = c.currentTabStopId === l
      , d = CF(n)
      , {onFocusableItemAdd: f, onFocusableItemRemove: p} = c;
    return h.useEffect( () => {
        if (r)
            return f(),
            () => p()
    }
    , [r, f, p]),
    g.jsx(g5.ItemSlot, {
        scope: n,
        id: l,
        focusable: r,
        active: s,
        children: g.jsx(Vt.span, {
            tabIndex: u ? 0 : -1,
            "data-orientation": c.orientation,
            ...i,
            ref: t,
            onMouseDown: Qe(e.onMouseDown, m => {
                r ? c.onItemFocus(l) : m.preventDefault()
            }
            ),
            onFocus: Qe(e.onFocus, () => c.onItemFocus(l)),
            onKeyDown: Qe(e.onKeyDown, m => {
                if (m.key === "Tab" && m.shiftKey) {
                    c.onItemShiftTab();
                    return
                }
                if (m.target !== m.currentTarget)
                    return;
                const v = jse(m, c.orientation, c.dir);
                if (v !== void 0) {
                    if (m.metaKey || m.ctrlKey || m.altKey || m.shiftKey)
                        return;
                    m.preventDefault();
                    let y = d().filter(b => b.focusable).map(b => b.ref.current);
                    if (v === "last")
                        y.reverse();
                    else if (v === "prev" || v === "next") {
                        v === "prev" && y.reverse();
                        const b = y.indexOf(m.currentTarget);
                        y = c.loop ? Use(y, b + 1) : y.slice(b + 1)
                    }
                    setTimeout( () => xF(y))
                }
            }
            )
        })
    })
}
);
EF.displayName = wF;
var Lse = {
    ArrowLeft: "prev",
    ArrowUp: "prev",
    ArrowRight: "next",
    ArrowDown: "next",
    PageUp: "first",
    Home: "first",
    PageDown: "last",
    End: "last"
};
function Fse(e, t) {
    return t !== "rtl" ? e : e === "ArrowLeft" ? "ArrowRight" : e === "ArrowRight" ? "ArrowLeft" : e
}
function jse(e, t, n) {
    const r = Fse(e.key, n);
    if (!(t === "vertical" && ["ArrowLeft", "ArrowRight"].includes(r)) && !(t === "horizontal" && ["ArrowUp", "ArrowDown"].includes(r)))
        return Lse[r]
}
function xF(e, t=!1) {
    const n = document.activeElement;
    for (const r of e)
        if (r === n || (r.focus({
            preventScroll: t
        }),
        document.activeElement !== n))
            return
}
function Use(e, t) {
    return e.map( (n, r) => e[(t + r) % e.length])
}
var TF = SF
  , kF = EF
  , yw = "Tabs"
  , [Bse,iTe] = $u(yw, [S1])
  , OF = S1()
  , [qse,bw] = Bse(yw)
  , AF = h.forwardRef( (e, t) => {
    const {__scopeTabs: n, value: r, onValueChange: s, defaultValue: o, orientation: i="horizontal", dir: a, activationMode: l="automatic", ...c} = e
      , u = _w(a)
      , [d,f] = Ql({
        prop: r,
        onChange: s,
        defaultProp: o
    });
    return g.jsx(qse, {
        scope: n,
        baseId: Ro(),
        value: d,
        onValueChange: f,
        orientation: i,
        dir: u,
        activationMode: l,
        children: g.jsx(Vt.div, {
            dir: u,
            "data-orientation": i,
            ...c,
            ref: t
        })
    })
}
);
AF.displayName = yw;
var MF = "TabsList"
  , IF = h.forwardRef( (e, t) => {
    const {__scopeTabs: n, loop: r=!0, ...s} = e
      , o = bw(MF, n)
      , i = OF(n);
    return g.jsx(TF, {
        asChild: !0,
        ...i,
        orientation: o.orientation,
        dir: o.dir,
        loop: r,
        children: g.jsx(Vt.div, {
            role: "tablist",
            "aria-orientation": o.orientation,
            ...s,
            ref: t
        })
    })
}
);
IF.displayName = MF;
var RF = "TabsTrigger"
  , NF = h.forwardRef( (e, t) => {
    const {__scopeTabs: n, value: r, disabled: s=!1, ...o} = e
      , i = bw(RF, n)
      , a = OF(n)
      , l = LF(i.baseId, r)
      , c = FF(i.baseId, r)
      , u = r === i.value;
    return g.jsx(kF, {
        asChild: !0,
        ...a,
        focusable: !s,
        active: u,
        children: g.jsx(Vt.button, {
            type: "button",
            role: "tab",
            "aria-selected": u,
            "aria-controls": c,
            "data-state": u ? "active" : "inactive",
            "data-disabled": s ? "" : void 0,
            disabled: s,
            id: l,
            ...o,
            ref: t,
            onMouseDown: Qe(e.onMouseDown, d => {
                !s && d.button === 0 && d.ctrlKey === !1 ? i.onValueChange(r) : d.preventDefault()
            }
            ),
            onKeyDown: Qe(e.onKeyDown, d => {
                [" ", "Enter"].includes(d.key) && i.onValueChange(r)
            }
            ),
            onFocus: Qe(e.onFocus, () => {
                const d = i.activationMode !== "manual";
                !u && !s && d && i.onValueChange(r)
            }
            )
        })
    })
}
);
NF.displayName = RF;
var PF = "TabsContent"
  , DF = h.forwardRef( (e, t) => {
    const {__scopeTabs: n, value: r, forceMount: s, children: o, ...i} = e
      , a = bw(PF, n)
      , l = LF(a.baseId, r)
      , c = FF(a.baseId, r)
      , u = r === a.value
      , d = h.useRef(u);
    return h.useEffect( () => {
        const f = requestAnimationFrame( () => d.current = !1);
        return () => cancelAnimationFrame(f)
    }
    , []),
    g.jsx(co, {
        present: s || u,
        children: ({present: f}) => g.jsx(Vt.div, {
            "data-state": u ? "active" : "inactive",
            "data-orientation": a.orientation,
            role: "tabpanel",
            "aria-labelledby": l,
            hidden: !f,
            id: c,
            tabIndex: 0,
            ...i,
            ref: t,
            style: {
                ...e.style,
                animationDuration: d.current ? "0s" : void 0
            },
            children: f && o
        })
    })
}
);
DF.displayName = PF;
function LF(e, t) {
    return `${e}-trigger-${t}`
}
function FF(e, t) {
    return `${e}-content-${t}`
}
var aTe = AF
  , lTe = IF
  , Gse = NF
  , Vse = DF;
function Hse() {
    for (var e = 0, t, n, r = ""; e < arguments.length; )
        (t = arguments[e++]) && (n = jF(t)) && (r && (r += " "),
        r += n);
    return r
}
function jF(e) {
    if (typeof e == "string")
        return e;
    for (var t, n = "", r = 0; r < e.length; r++)
        e[r] && (t = jF(e[r])) && (n && (n += " "),
        n += t);
    return n
}
function v5() {
    return v5 = Object.assign ? Object.assign.bind() : function(e) {
        for (var t = 1; t < arguments.length; t++) {
            var n = arguments[t];
            for (var r in n)
                Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r])
        }
        return e
    }
    ,
    v5.apply(this, arguments)
}
function zse(e) {
    if (e < 1)
        return {
            get: function() {},
            set: function() {}
        };
    var t = 0
      , n = new Map
      , r = new Map;
    function s(o, i) {
        n.set(o, i),
        t++,
        t > e && (t = 0,
        r = n,
        n = new Map)
    }
    return {
        get: function(i) {
            var a = n.get(i);
            if (a !== void 0)
                return a;
            if ((a = r.get(i)) !== void 0)
                return s(i, a),
                a
        },
        set: function(i, a) {
            n.has(i) ? n.set(i, a) : s(i, a)
        }
    }
}
var Cw = "-";
function $se(e) {
    var t = Kse(e);
    function n(s) {
        var o = s.split(Cw);
        return o[0] === "" && o.length !== 1 && o.shift(),
        UF(o, t) || Wse(s)
    }
    function r(s) {
        return e.conflictingClassGroups[s] || []
    }
    return {
        getClassGroupId: n,
        getConflictingClassGroupIds: r
    }
}
function UF(e, t) {
    var n;
    if (e.length === 0)
        return t.classGroupId;
    var r = e[0]
      , s = t.nextPart.get(r)
      , o = s ? UF(e.slice(1), s) : void 0;
    if (o)
        return o;
    if (t.validators.length !== 0) {
        var i = e.join(Cw);
        return (n = t.validators.find(function(a) {
            var l = a.validator;
            return l(i)
        })) == null ? void 0 : n.classGroupId
    }
}
var qx = /^\[(.+)\]$/;
function Wse(e) {
    if (qx.test(e)) {
        var t = qx.exec(e)[1]
          , n = t?.substring(0, t.indexOf(":"));
        if (n)
            return "arbitrary.." + n
    }
}
function Kse(e) {
    var t = e.theme
      , n = e.prefix
      , r = {
        nextPart: new Map,
        validators: []
    }
      , s = Zse(Object.entries(e.classGroups), n);
    return s.forEach(function(o) {
        var i = o[0]
          , a = o[1];
        _5(a, r, i, t)
    }),
    r
}
function _5(e, t, n, r) {
    e.forEach(function(s) {
        if (typeof s == "string") {
            var o = s === "" ? t : Gx(t, s);
            o.classGroupId = n;
            return
        }
        if (typeof s == "function") {
            if (Yse(s)) {
                _5(s(r), t, n, r);
                return
            }
            t.validators.push({
                validator: s,
                classGroupId: n
            });
            return
        }
        Object.entries(s).forEach(function(i) {
            var a = i[0]
              , l = i[1];
            _5(l, Gx(t, a), n, r)
        })
    })
}
function Gx(e, t) {
    var n = e;
    return t.split(Cw).forEach(function(r) {
        n.nextPart.has(r) || n.nextPart.set(r, {
            nextPart: new Map,
            validators: []
        }),
        n = n.nextPart.get(r)
    }),
    n
}
function Yse(e) {
    return e.isThemeGetter
}
function Zse(e, t) {
    return t ? e.map(function(n) {
        var r = n[0]
          , s = n[1]
          , o = s.map(function(i) {
            return typeof i == "string" ? t + i : typeof i == "object" ? Object.fromEntries(Object.entries(i).map(function(a) {
                var l = a[0]
                  , c = a[1];
                return [t + l, c]
            })) : i
        });
        return [r, o]
    }) : e
}
var BF = "!";
function Jse(e) {
    var t = e.separator || ":";
    return function(r) {
        for (var s = 0, o = [], i = 0, a = 0; a < r.length; a++) {
            var l = r[a];
            s === 0 && l === t[0] && (t.length === 1 || r.slice(a, a + t.length) === t) && (o.push(r.slice(i, a)),
            i = a + t.length),
            l === "[" ? s++ : l === "]" && s--
        }
        var c = o.length === 0 ? r : r.substring(i)
          , u = c.startsWith(BF)
          , d = u ? c.substring(1) : c;
        return {
            modifiers: o,
            hasImportantModifier: u,
            baseClassName: d
        }
    }
}
function Xse(e) {
    if (e.length <= 1)
        return e;
    var t = []
      , n = [];
    return e.forEach(function(r) {
        var s = r[0] === "[";
        s ? (t.push.apply(t, n.sort().concat([r])),
        n = []) : n.push(r)
    }),
    t.push.apply(t, n.sort()),
    t
}
function Qse(e) {
    return v5({
        cache: zse(e.cacheSize),
        splitModifiers: Jse(e)
    }, $se(e))
}
var eoe = /\s+/;
function toe(e, t) {
    var n = t.splitModifiers
      , r = t.getClassGroupId
      , s = t.getConflictingClassGroupIds
      , o = new Set;
    return e.trim().split(eoe).map(function(i) {
        var a = n(i)
          , l = a.modifiers
          , c = a.hasImportantModifier
          , u = a.baseClassName
          , d = r(u);
        if (!d)
            return {
                isTailwindClass: !1,
                originalClassName: i
            };
        var f = Xse(l).join(":")
          , p = c ? f + BF : f;
        return {
            isTailwindClass: !0,
            modifierId: p,
            classGroupId: d,
            originalClassName: i
        }
    }).reverse().filter(function(i) {
        if (!i.isTailwindClass)
            return !0;
        var a = i.modifierId
          , l = i.classGroupId
          , c = a + l;
        return o.has(c) ? !1 : (o.add(c),
        s(l).forEach(function(u) {
            return o.add(a + u)
        }),
        !0)
    }).reverse().map(function(i) {
        return i.originalClassName
    }).join(" ")
}
function noe() {
    for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
        t[n] = arguments[n];
    var r, s, o, i = a;
    function a(c) {
        var u = t[0]
          , d = t.slice(1)
          , f = d.reduce(function(p, m) {
            return m(p)
        }, u());
        return r = Qse(f),
        s = r.cache.get,
        o = r.cache.set,
        i = l,
        l(c)
    }
    function l(c) {
        var u = s(c);
        if (u)
            return u;
        var d = toe(c, r);
        return o(c, d),
        d
    }
    return function() {
        return i(Hse.apply(null, arguments))
    }
}
function nn(e) {
    var t = function(r) {
        return r[e] || []
    };
    return t.isThemeGetter = !0,
    t
}
var Fa = /^\[(.+)\]$/
  , roe = /^\d+\/\d+$/
  , soe = new Set(["px", "full", "screen"])
  , ooe = /^(\d+)?(xs|sm|md|lg|xl)$/
  , ioe = /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh)/
  , aoe = /^-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/;
function Rs(e) {
    return !Number.isNaN(Number(e)) || soe.has(e) || roe.test(e) || sl(e)
}
function sl(e) {
    var t, n = (t = Fa.exec(e)) == null ? void 0 : t[1];
    return n ? n.startsWith("length:") || ioe.test(n) : !1
}
function loe(e) {
    var t, n = (t = Fa.exec(e)) == null ? void 0 : t[1];
    return n ? n.startsWith("size:") : !1
}
function coe(e) {
    var t, n = (t = Fa.exec(e)) == null ? void 0 : t[1];
    return n ? n.startsWith("position:") : !1
}
function uoe(e) {
    var t, n = (t = Fa.exec(e)) == null ? void 0 : t[1];
    return n ? n.startsWith("url(") || n.startsWith("url:") : !1
}
function Vx(e) {
    var t, n = (t = Fa.exec(e)) == null ? void 0 : t[1];
    return n ? !Number.isNaN(Number(n)) || n.startsWith("number:") : !1
}
function yr(e) {
    var t, n = (t = Fa.exec(e)) == null ? void 0 : t[1];
    return n ? Number.isInteger(Number(n)) : Number.isInteger(Number(e))
}
function Wn(e) {
    return Fa.test(e)
}
function Cd() {
    return !0
}
function Vi(e) {
    return ooe.test(e)
}
function doe(e) {
    var t, n = (t = Fa.exec(e)) == null ? void 0 : t[1];
    return n ? aoe.test(n) : !1
}
function foe() {
    var e = nn("colors")
      , t = nn("spacing")
      , n = nn("blur")
      , r = nn("brightness")
      , s = nn("borderColor")
      , o = nn("borderRadius")
      , i = nn("borderSpacing")
      , a = nn("borderWidth")
      , l = nn("contrast")
      , c = nn("grayscale")
      , u = nn("hueRotate")
      , d = nn("invert")
      , f = nn("gap")
      , p = nn("gradientColorStops")
      , m = nn("inset")
      , v = nn("margin")
      , _ = nn("opacity")
      , y = nn("padding")
      , b = nn("saturate")
      , S = nn("scale")
      , C = nn("sepia")
      , w = nn("skew")
      , x = nn("space")
      , E = nn("translate")
      , T = function() {
        return ["auto", "contain", "none"]
    }
      , k = function() {
        return ["auto", "hidden", "clip", "visible", "scroll"]
    }
      , A = function() {
        return ["auto", t]
    }
      , O = function() {
        return ["", Rs]
    }
      , M = function() {
        return ["auto", yr]
    }
      , I = function() {
        return ["bottom", "center", "left", "left-bottom", "left-top", "right", "right-bottom", "right-top", "top"]
    }
      , R = function() {
        return ["solid", "dashed", "dotted", "double", "none"]
    }
      , D = function() {
        return ["normal", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "hue", "saturation", "color", "luminosity", "plus-lighter"]
    }
      , P = function() {
        return ["start", "end", "center", "between", "around", "evenly"]
    }
      , L = function() {
        return ["", "0", Wn]
    }
      , N = function() {
        return ["auto", "avoid", "all", "avoid-page", "page", "left", "right", "column"]
    };
    return {
        cacheSize: 500,
        theme: {
            colors: [Cd],
            spacing: [Rs],
            blur: ["none", "", Vi, sl],
            brightness: [yr],
            borderColor: [e],
            borderRadius: ["none", "", "full", Vi, sl],
            borderSpacing: [t],
            borderWidth: O(),
            contrast: [yr],
            grayscale: L(),
            hueRotate: [yr],
            invert: L(),
            gap: [t],
            gradientColorStops: [e],
            inset: A(),
            margin: A(),
            opacity: [yr],
            padding: [t],
            saturate: [yr],
            scale: [yr],
            sepia: L(),
            skew: [yr, Wn],
            space: [t],
            translate: [t]
        },
        classGroups: {
            aspect: [{
                aspect: ["auto", "square", "video", Wn]
            }],
            container: ["container"],
            columns: [{
                columns: [Vi]
            }],
            "break-after": [{
                "break-after": N()
            }],
            "break-before": [{
                "break-before": N()
            }],
            "break-inside": [{
                "break-inside": ["auto", "avoid", "avoid-page", "avoid-column"]
            }],
            "box-decoration": [{
                "box-decoration": ["slice", "clone"]
            }],
            box: [{
                box: ["border", "content"]
            }],
            display: ["block", "inline-block", "inline", "flex", "inline-flex", "table", "inline-table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row-group", "table-row", "flow-root", "grid", "inline-grid", "contents", "list-item", "hidden"],
            float: [{
                float: ["right", "left", "none"]
            }],
            clear: [{
                clear: ["left", "right", "both", "none"]
            }],
            isolation: ["isolate", "isolation-auto"],
            "object-fit": [{
                object: ["contain", "cover", "fill", "none", "scale-down"]
            }],
            "object-position": [{
                object: [].concat(I(), [Wn])
            }],
            overflow: [{
                overflow: k()
            }],
            "overflow-x": [{
                "overflow-x": k()
            }],
            "overflow-y": [{
                "overflow-y": k()
            }],
            overscroll: [{
                overscroll: T()
            }],
            "overscroll-x": [{
                "overscroll-x": T()
            }],
            "overscroll-y": [{
                "overscroll-y": T()
            }],
            position: ["static", "fixed", "absolute", "relative", "sticky"],
            inset: [{
                inset: [m]
            }],
            "inset-x": [{
                "inset-x": [m]
            }],
            "inset-y": [{
                "inset-y": [m]
            }],
            top: [{
                top: [m]
            }],
            right: [{
                right: [m]
            }],
            bottom: [{
                bottom: [m]
            }],
            left: [{
                left: [m]
            }],
            visibility: ["visible", "invisible", "collapse"],
            z: [{
                z: [yr]
            }],
            basis: [{
                basis: [t]
            }],
            "flex-direction": [{
                flex: ["row", "row-reverse", "col", "col-reverse"]
            }],
            "flex-wrap": [{
                flex: ["wrap", "wrap-reverse", "nowrap"]
            }],
            flex: [{
                flex: ["1", "auto", "initial", "none", Wn]
            }],
            grow: [{
                grow: L()
            }],
            shrink: [{
                shrink: L()
            }],
            order: [{
                order: ["first", "last", "none", yr]
            }],
            "grid-cols": [{
                "grid-cols": [Cd]
            }],
            "col-start-end": [{
                col: ["auto", {
                    span: [yr]
                }]
            }],
            "col-start": [{
                "col-start": M()
            }],
            "col-end": [{
                "col-end": M()
            }],
            "grid-rows": [{
                "grid-rows": [Cd]
            }],
            "row-start-end": [{
                row: ["auto", {
                    span: [yr]
                }]
            }],
            "row-start": [{
                "row-start": M()
            }],
            "row-end": [{
                "row-end": M()
            }],
            "grid-flow": [{
                "grid-flow": ["row", "col", "dense", "row-dense", "col-dense"]
            }],
            "auto-cols": [{
                "auto-cols": ["auto", "min", "max", "fr", Wn]
            }],
            "auto-rows": [{
                "auto-rows": ["auto", "min", "max", "fr", Wn]
            }],
            gap: [{
                gap: [f]
            }],
            "gap-x": [{
                "gap-x": [f]
            }],
            "gap-y": [{
                "gap-y": [f]
            }],
            "justify-content": [{
                justify: P()
            }],
            "justify-items": [{
                "justify-items": ["start", "end", "center", "stretch"]
            }],
            "justify-self": [{
                "justify-self": ["auto", "start", "end", "center", "stretch"]
            }],
            "align-content": [{
                content: [].concat(P(), ["baseline"])
            }],
            "align-items": [{
                items: ["start", "end", "center", "baseline", "stretch"]
            }],
            "align-self": [{
                self: ["auto", "start", "end", "center", "stretch", "baseline"]
            }],
            "place-content": [{
                "place-content": [].concat(P(), ["baseline", "stretch"])
            }],
            "place-items": [{
                "place-items": ["start", "end", "center", "baseline", "stretch"]
            }],
            "place-self": [{
                "place-self": ["auto", "start", "end", "center", "stretch"]
            }],
            p: [{
                p: [y]
            }],
            px: [{
                px: [y]
            }],
            py: [{
                py: [y]
            }],
            pt: [{
                pt: [y]
            }],
            pr: [{
                pr: [y]
            }],
            pb: [{
                pb: [y]
            }],
            pl: [{
                pl: [y]
            }],
            m: [{
                m: [v]
            }],
            mx: [{
                mx: [v]
            }],
            my: [{
                my: [v]
            }],
            mt: [{
                mt: [v]
            }],
            mr: [{
                mr: [v]
            }],
            mb: [{
                mb: [v]
            }],
            ml: [{
                ml: [v]
            }],
            "space-x": [{
                "space-x": [x]
            }],
            "space-x-reverse": ["space-x-reverse"],
            "space-y": [{
                "space-y": [x]
            }],
            "space-y-reverse": ["space-y-reverse"],
            w: [{
                w: ["auto", "min", "max", "fit", t]
            }],
            "min-w": [{
                "min-w": ["min", "max", "fit", Rs]
            }],
            "max-w": [{
                "max-w": ["0", "none", "full", "min", "max", "fit", "prose", {
                    screen: [Vi]
                }, Vi, sl]
            }],
            h: [{
                h: [t, "auto", "min", "max", "fit"]
            }],
            "min-h": [{
                "min-h": ["min", "max", "fit", Rs]
            }],
            "max-h": [{
                "max-h": [t, "min", "max", "fit"]
            }],
            "font-size": [{
                text: ["base", Vi, sl]
            }],
            "font-smoothing": ["antialiased", "subpixel-antialiased"],
            "font-style": ["italic", "not-italic"],
            "font-weight": [{
                font: ["thin", "extralight", "light", "normal", "medium", "semibold", "bold", "extrabold", "black", Vx]
            }],
            "font-family": [{
                font: [Cd]
            }],
            "fvn-normal": ["normal-nums"],
            "fvn-ordinal": ["ordinal"],
            "fvn-slashed-zero": ["slashed-zero"],
            "fvn-figure": ["lining-nums", "oldstyle-nums"],
            "fvn-spacing": ["proportional-nums", "tabular-nums"],
            "fvn-fraction": ["diagonal-fractions", "stacked-fractons"],
            tracking: [{
                tracking: ["tighter", "tight", "normal", "wide", "wider", "widest", sl]
            }],
            leading: [{
                leading: ["none", "tight", "snug", "normal", "relaxed", "loose", Rs]
            }],
            "list-style-type": [{
                list: ["none", "disc", "decimal", Wn]
            }],
            "list-style-position": [{
                list: ["inside", "outside"]
            }],
            "placeholder-color": [{
                placeholder: [e]
            }],
            "placeholder-opacity": [{
                "placeholder-opacity": [_]
            }],
            "text-alignment": [{
                text: ["left", "center", "right", "justify", "start", "end"]
            }],
            "text-color": [{
                text: [e]
            }],
            "text-opacity": [{
                "text-opacity": [_]
            }],
            "text-decoration": ["underline", "overline", "line-through", "no-underline"],
            "text-decoration-style": [{
                decoration: [].concat(R(), ["wavy"])
            }],
            "text-decoration-thickness": [{
                decoration: ["auto", "from-font", Rs]
            }],
            "underline-offset": [{
                "underline-offset": ["auto", Rs]
            }],
            "text-decoration-color": [{
                decoration: [e]
            }],
            "text-transform": ["uppercase", "lowercase", "capitalize", "normal-case"],
            "text-overflow": ["truncate", "text-ellipsis", "text-clip"],
            indent: [{
                indent: [t]
            }],
            "vertical-align": [{
                align: ["baseline", "top", "middle", "bottom", "text-top", "text-bottom", "sub", "super", sl]
            }],
            whitespace: [{
                whitespace: ["normal", "nowrap", "pre", "pre-line", "pre-wrap"]
            }],
            break: [{
                break: ["normal", "words", "all", "keep"]
            }],
            content: [{
                content: ["none", Wn]
            }],
            "bg-attachment": [{
                bg: ["fixed", "local", "scroll"]
            }],
            "bg-clip": [{
                "bg-clip": ["border", "padding", "content", "text"]
            }],
            "bg-opacity": [{
                "bg-opacity": [_]
            }],
            "bg-origin": [{
                "bg-origin": ["border", "padding", "content"]
            }],
            "bg-position": [{
                bg: [].concat(I(), [coe])
            }],
            "bg-repeat": [{
                bg: ["no-repeat", {
                    repeat: ["", "x", "y", "round", "space"]
                }]
            }],
            "bg-size": [{
                bg: ["auto", "cover", "contain", loe]
            }],
            "bg-image": [{
                bg: ["none", {
                    "gradient-to": ["t", "tr", "r", "br", "b", "bl", "l", "tl"]
                }, uoe]
            }],
            "bg-color": [{
                bg: [e]
            }],
            "gradient-from": [{
                from: [p]
            }],
            "gradient-via": [{
                via: [p]
            }],
            "gradient-to": [{
                to: [p]
            }],
            rounded: [{
                rounded: [o]
            }],
            "rounded-t": [{
                "rounded-t": [o]
            }],
            "rounded-r": [{
                "rounded-r": [o]
            }],
            "rounded-b": [{
                "rounded-b": [o]
            }],
            "rounded-l": [{
                "rounded-l": [o]
            }],
            "rounded-tl": [{
                "rounded-tl": [o]
            }],
            "rounded-tr": [{
                "rounded-tr": [o]
            }],
            "rounded-br": [{
                "rounded-br": [o]
            }],
            "rounded-bl": [{
                "rounded-bl": [o]
            }],
            "border-w": [{
                border: [a]
            }],
            "border-w-x": [{
                "border-x": [a]
            }],
            "border-w-y": [{
                "border-y": [a]
            }],
            "border-w-t": [{
                "border-t": [a]
            }],
            "border-w-r": [{
                "border-r": [a]
            }],
            "border-w-b": [{
                "border-b": [a]
            }],
            "border-w-l": [{
                "border-l": [a]
            }],
            "border-opacity": [{
                "border-opacity": [_]
            }],
            "border-style": [{
                border: [].concat(R(), ["hidden"])
            }],
            "divide-x": [{
                "divide-x": [a]
            }],
            "divide-x-reverse": ["divide-x-reverse"],
            "divide-y": [{
                "divide-y": [a]
            }],
            "divide-y-reverse": ["divide-y-reverse"],
            "divide-opacity": [{
                "divide-opacity": [_]
            }],
            "divide-style": [{
                divide: R()
            }],
            "border-color": [{
                border: [s]
            }],
            "border-color-x": [{
                "border-x": [s]
            }],
            "border-color-y": [{
                "border-y": [s]
            }],
            "border-color-t": [{
                "border-t": [s]
            }],
            "border-color-r": [{
                "border-r": [s]
            }],
            "border-color-b": [{
                "border-b": [s]
            }],
            "border-color-l": [{
                "border-l": [s]
            }],
            "divide-color": [{
                divide: [s]
            }],
            "outline-style": [{
                outline: [""].concat(R())
            }],
            "outline-offset": [{
                "outline-offset": [Rs]
            }],
            "outline-w": [{
                outline: [Rs]
            }],
            "outline-color": [{
                outline: [e]
            }],
            "ring-w": [{
                ring: O()
            }],
            "ring-w-inset": ["ring-inset"],
            "ring-color": [{
                ring: [e]
            }],
            "ring-opacity": [{
                "ring-opacity": [_]
            }],
            "ring-offset-w": [{
                "ring-offset": [Rs]
            }],
            "ring-offset-color": [{
                "ring-offset": [e]
            }],
            shadow: [{
                shadow: ["", "inner", "none", Vi, doe]
            }],
            "shadow-color": [{
                shadow: [Cd]
            }],
            opacity: [{
                opacity: [_]
            }],
            "mix-blend": [{
                "mix-blend": D()
            }],
            "bg-blend": [{
                "bg-blend": D()
            }],
            filter: [{
                filter: ["", "none"]
            }],
            blur: [{
                blur: [n]
            }],
            brightness: [{
                brightness: [r]
            }],
            contrast: [{
                contrast: [l]
            }],
            "drop-shadow": [{
                "drop-shadow": ["", "none", Vi, Wn]
            }],
            grayscale: [{
                grayscale: [c]
            }],
            "hue-rotate": [{
                "hue-rotate": [u]
            }],
            invert: [{
                invert: [d]
            }],
            saturate: [{
                saturate: [b]
            }],
            sepia: [{
                sepia: [C]
            }],
            "backdrop-filter": [{
                "backdrop-filter": ["", "none"]
            }],
            "backdrop-blur": [{
                "backdrop-blur": [n]
            }],
            "backdrop-brightness": [{
                "backdrop-brightness": [r]
            }],
            "backdrop-contrast": [{
                "backdrop-contrast": [l]
            }],
            "backdrop-grayscale": [{
                "backdrop-grayscale": [c]
            }],
            "backdrop-hue-rotate": [{
                "backdrop-hue-rotate": [u]
            }],
            "backdrop-invert": [{
                "backdrop-invert": [d]
            }],
            "backdrop-opacity": [{
                "backdrop-opacity": [_]
            }],
            "backdrop-saturate": [{
                "backdrop-saturate": [b]
            }],
            "backdrop-sepia": [{
                "backdrop-sepia": [C]
            }],
            "border-collapse": [{
                border: ["collapse", "separate"]
            }],
            "border-spacing": [{
                "border-spacing": [i]
            }],
            "border-spacing-x": [{
                "border-spacing-x": [i]
            }],
            "border-spacing-y": [{
                "border-spacing-y": [i]
            }],
            "table-layout": [{
                table: ["auto", "fixed"]
            }],
            transition: [{
                transition: ["none", "all", "", "colors", "opacity", "shadow", "transform", Wn]
            }],
            duration: [{
                duration: [yr]
            }],
            ease: [{
                ease: ["linear", "in", "out", "in-out", Wn]
            }],
            delay: [{
                delay: [yr]
            }],
            animate: [{
                animate: ["none", "spin", "ping", "pulse", "bounce", Wn]
            }],
            transform: [{
                transform: ["", "gpu", "none"]
            }],
            scale: [{
                scale: [S]
            }],
            "scale-x": [{
                "scale-x": [S]
            }],
            "scale-y": [{
                "scale-y": [S]
            }],
            rotate: [{
                rotate: [yr, Wn]
            }],
            "translate-x": [{
                "translate-x": [E]
            }],
            "translate-y": [{
                "translate-y": [E]
            }],
            "skew-x": [{
                "skew-x": [w]
            }],
            "skew-y": [{
                "skew-y": [w]
            }],
            "transform-origin": [{
                origin: ["center", "top", "top-right", "right", "bottom-right", "bottom", "bottom-left", "left", "top-left", Wn]
            }],
            accent: [{
                accent: ["auto", e]
            }],
            appearance: ["appearance-none"],
            cursor: [{
                cursor: ["auto", "default", "pointer", "wait", "text", "move", "help", "not-allowed", "none", "context-menu", "progress", "cell", "crosshair", "vertical-text", "alias", "copy", "no-drop", "grab", "grabbing", "all-scroll", "col-resize", "row-resize", "n-resize", "e-resize", "s-resize", "w-resize", "ne-resize", "nw-resize", "se-resize", "sw-resize", "ew-resize", "ns-resize", "nesw-resize", "nwse-resize", "zoom-in", "zoom-out", Wn]
            }],
            "caret-color": [{
                caret: [e]
            }],
            "pointer-events": [{
                "pointer-events": ["none", "auto"]
            }],
            resize: [{
                resize: ["none", "y", "x", ""]
            }],
            "scroll-behavior": [{
                scroll: ["auto", "smooth"]
            }],
            "scroll-m": [{
                "scroll-m": [t]
            }],
            "scroll-mx": [{
                "scroll-mx": [t]
            }],
            "scroll-my": [{
                "scroll-my": [t]
            }],
            "scroll-mt": [{
                "scroll-mt": [t]
            }],
            "scroll-mr": [{
                "scroll-mr": [t]
            }],
            "scroll-mb": [{
                "scroll-mb": [t]
            }],
            "scroll-ml": [{
                "scroll-ml": [t]
            }],
            "scroll-p": [{
                "scroll-p": [t]
            }],
            "scroll-px": [{
                "scroll-px": [t]
            }],
            "scroll-py": [{
                "scroll-py": [t]
            }],
            "scroll-pt": [{
                "scroll-pt": [t]
            }],
            "scroll-pr": [{
                "scroll-pr": [t]
            }],
            "scroll-pb": [{
                "scroll-pb": [t]
            }],
            "scroll-pl": [{
                "scroll-pl": [t]
            }],
            "snap-align": [{
                snap: ["start", "end", "center", "align-none"]
            }],
            "snap-stop": [{
                snap: ["normal", "always"]
            }],
            "snap-type": [{
                snap: ["none", "x", "y", "both"]
            }],
            "snap-strictness": [{
                snap: ["mandatory", "proximity"]
            }],
            touch: [{
                touch: ["auto", "none", "pinch-zoom", "manipulation", {
                    pan: ["x", "left", "right", "y", "up", "down"]
                }]
            }],
            select: [{
                select: ["none", "text", "all", "auto"]
            }],
            "will-change": [{
                "will-change": ["auto", "scroll", "contents", "transform", Wn]
            }],
            fill: [{
                fill: [e, "none"]
            }],
            "stroke-w": [{
                stroke: [Rs, Vx]
            }],
            stroke: [{
                stroke: [e, "none"]
            }],
            sr: ["sr-only", "not-sr-only"]
        },
        conflictingClassGroups: {
            overflow: ["overflow-x", "overflow-y"],
            overscroll: ["overscroll-x", "overscroll-y"],
            inset: ["inset-x", "inset-y", "top", "right", "bottom", "left"],
            "inset-x": ["right", "left"],
            "inset-y": ["top", "bottom"],
            flex: ["basis", "grow", "shrink"],
            "col-start-end": ["col-start", "col-end"],
            "row-start-end": ["row-start", "row-end"],
            gap: ["gap-x", "gap-y"],
            p: ["px", "py", "pt", "pr", "pb", "pl"],
            px: ["pr", "pl"],
            py: ["pt", "pb"],
            m: ["mx", "my", "mt", "mr", "mb", "ml"],
            mx: ["mr", "ml"],
            my: ["mt", "mb"],
            "font-size": ["leading"],
            "fvn-normal": ["fvn-ordinal", "fvn-slashed-zero", "fvn-figure", "fvn-spacing", "fvn-fraction"],
            "fvn-ordinal": ["fvn-normal"],
            "fvn-slashed-zero": ["fvn-normal"],
            "fvn-figure": ["fvn-normal"],
            "fvn-spacing": ["fvn-normal"],
            "fvn-fraction": ["fvn-normal"],
            rounded: ["rounded-t", "rounded-r", "rounded-b", "rounded-l", "rounded-tl", "rounded-tr", "rounded-br", "rounded-bl"],
            "rounded-t": ["rounded-tl", "rounded-tr"],
            "rounded-r": ["rounded-tr", "rounded-br"],
            "rounded-b": ["rounded-br", "rounded-bl"],
            "rounded-l": ["rounded-tl", "rounded-bl"],
            "border-spacing": ["border-spacing-x", "border-spacing-y"],
            "border-w": ["border-w-t", "border-w-r", "border-w-b", "border-w-l"],
            "border-w-x": ["border-w-r", "border-w-l"],
            "border-w-y": ["border-w-t", "border-w-b"],
            "border-color": ["border-color-t", "border-color-r", "border-color-b", "border-color-l"],
            "border-color-x": ["border-color-r", "border-color-l"],
            "border-color-y": ["border-color-t", "border-color-b"],
            "scroll-m": ["scroll-mx", "scroll-my", "scroll-mt", "scroll-mr", "scroll-mb", "scroll-ml"],
            "scroll-mx": ["scroll-mr", "scroll-ml"],
            "scroll-my": ["scroll-mt", "scroll-mb"],
            "scroll-p": ["scroll-px", "scroll-py", "scroll-pt", "scroll-pr", "scroll-pb", "scroll-pl"],
            "scroll-px": ["scroll-pr", "scroll-pl"],
            "scroll-py": ["scroll-pt", "scroll-pb"]
        }
    }
}
var hoe = noe(foe)
  , poe = ["a", "abbr", "address", "area", "article", "aside", "audio", "b", "base", "bdi", "bdo", "big", "blockquote", "body", "br", "button", "canvas", "caption", "cite", "code", "col", "colgroup", "data", "datalist", "dd", "del", "details", "dfn", "dialog", "div", "dl", "dt", "em", "embed", "fieldset", "figcaption", "figure", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "iframe", "img", "input", "ins", "kbd", "keygen", "label", "legend", "li", "link", "main", "map", "mark", "menu", "menuitem", "meta", "meter", "nav", "noscript", "object", "ol", "optgroup", "option", "output", "p", "param", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "script", "section", "select", "small", "source", "span", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "textarea", "tfoot", "th", "thead", "time", "title", "tr", "track", "u", "ul", "var", "video", "wbr", "circle", "clipPath", "defs", "ellipse", "foreignObject", "g", "image", "line", "linearGradient", "marker", "mask", "path", "pattern", "polygon", "polyline", "radialGradient", "rect", "stop", "svg", "text", "tspan"]
  , moe = poe
  , qF = Symbol("isTwElement?")
  , goe = (e, t) => e.reduce( (n, r, s) => n.concat(r || [], t[s] || []), [])
  , voe = (e, t="") => {
    let n = e.join(" ").trim().replace(/\n/g, " ").replace(/\s{2,}/g, " ").split(" ").filter(s => s !== ",")
      , r = t ? t.split(" ") : [];
    return hoe(...n.concat(r).filter(s => s !== " "))
}
  , _oe = ([e]) => e.charAt(0) !== "$"
  , sy = e => e[qF] === !0
  , GF = e => (t, ...n) => {
    let r = (s=[]) => {
        let o = Ne.forwardRef( (i, a) => {
            let {$as: l=e, style: c={}, ...u} = i
              , d = sy(e) ? e : l
              , f = s ? s.reduce( (m, v) => Object.assign(m, typeof v == "function" ? v(i) : v), {}) : {}
              , p = sy(d) ? u : Object.fromEntries(Object.entries(u).filter(_oe));
            return Ne.createElement(d, {
                ...p,
                style: {
                    ...f,
                    ...c
                },
                ref: a,
                className: voe(goe(t, n.map(m => m({
                    ...u,
                    $as: l
                }))), u.className),
                ...sy(e) ? {
                    $as: l
                } : {}
            })
        }
        );
        return o[qF] = !0,
        typeof e != "string" ? o.displayName = e.displayName || e.name || "tw.Component" : o.displayName = "tw." + e,
        o.withStyle = i => r(s.concat(i)),
        o
    }
    ;
    return r()
}
  , yoe = moe.reduce( (e, t) => ({
    ...e,
    [t]: GF(t)
}), {})
  , boe = Object.assign(GF, yoe)
  , ja = boe;
function Hx() {
    return g.jsx("div", {
        className: "border-token-text-quartenary text-token-text-secondary dark:border-token-border-heavy dark:text-token-text-tertiary items-center rounded-full border px-1 py-0.5 text-[8px] leading-3 font-semibold uppercase",
        children: g.jsx(de, {
            id: "PoPvGE",
            defaultMessage: "Alpha"
        })
    })
}
function zx(e, t) {
    if (typeof e == "function")
        return e(t);
    e != null && (e.current = t)
}
function VF(...e) {
    return t => {
        let n = !1;
        const r = e.map(s => {
            const o = zx(s, t);
            return !n && typeof o == "function" && (n = !0),
            o
        }
        );
        if (n)
            return () => {
                for (let s = 0; s < r.length; s++) {
                    const o = r[s];
                    typeof o == "function" ? o() : zx(e[s], null)
                }
            }
    }
}
function cTe(...e) {
    return h.useCallback(VF(...e), e)
}
function Coe(e) {
    const t = Soe(e)
      , n = h.forwardRef( (r, s) => {
        const {children: o, ...i} = r
          , a = h.Children.toArray(o)
          , l = a.find(Eoe);
        if (l) {
            const c = l.props.children
              , u = a.map(d => d === l ? h.Children.count(c) > 1 ? h.Children.only(null) : h.isValidElement(c) ? c.props.children : null : d);
            return g.jsx(t, {
                ...i,
                ref: s,
                children: h.isValidElement(c) ? h.cloneElement(c, void 0, u) : null
            })
        }
        return g.jsx(t, {
            ...i,
            ref: s,
            children: o
        })
    }
    );
    return n.displayName = `${e}.Slot`,
    n
}
var HF = Coe("Slot");
function Soe(e) {
    const t = h.forwardRef( (n, r) => {
        const {children: s, ...o} = n;
        if (h.isValidElement(s)) {
            const i = Toe(s)
              , a = xoe(o, s.props);
            return s.type !== h.Fragment && (a.ref = r ? VF(r, i) : i),
            h.cloneElement(s, a)
        }
        return h.Children.count(s) > 1 ? h.Children.only(null) : null
    }
    );
    return t.displayName = `${e}.SlotClone`,
    t
}
var woe = Symbol("radix.slottable");
function Eoe(e) {
    return h.isValidElement(e) && typeof e.type == "function" && "__radixId"in e.type && e.type.__radixId === woe
}
function xoe(e, t) {
    const n = {
        ...t
    };
    for (const r in t) {
        const s = e[r]
          , o = t[r];
        /^on[A-Z]/.test(r) ? s && o ? n[r] = (...a) => {
            const l = o(...a);
            return s(...a),
            l
        }
        : s && (n[r] = s) : r === "style" ? n[r] = {
            ...s,
            ...o
        } : r === "className" && (n[r] = [s, o].filter(Boolean).join(" "))
    }
    return {
        ...e,
        ...n
    }
}
function Toe(e) {
    let t = Object.getOwnPropertyDescriptor(e.props, "ref")?.get
      , n = t && "isReactWarning"in t && t.isReactWarning;
    return n ? e.ref : (t = Object.getOwnPropertyDescriptor(e, "ref")?.get,
    n = t && "isReactWarning"in t && t.isReactWarning,
    n ? e.props.ref : e.props.ref || e.ref)
}
const koe = ["top", "right", "bottom", "left"]
  , wa = Math.min
  , Kr = Math.max
  , Bm = Math.round
  , hp = Math.floor
  , Ea = e => ({
    x: e,
    y: e
})
  , Ooe = {
    left: "right",
    right: "left",
    bottom: "top",
    top: "bottom"
}
  , Aoe = {
    start: "end",
    end: "start"
};
function y5(e, t, n) {
    return Kr(e, wa(t, n))
}
function Si(e, t) {
    return typeof e == "function" ? e(t) : e
}
function wi(e) {
    return e.split("-")[0]
}
function Zu(e) {
    return e.split("-")[1]
}
function Sw(e) {
    return e === "x" ? "y" : "x"
}
function ww(e) {
    return e === "y" ? "height" : "width"
}
function Ju(e) {
    return ["top", "bottom"].includes(wi(e)) ? "y" : "x"
}
function Ew(e) {
    return Sw(Ju(e))
}
function Moe(e, t, n) {
    n === void 0 && (n = !1);
    const r = Zu(e)
      , s = Ew(e)
      , o = ww(s);
    let i = s === "x" ? r === (n ? "end" : "start") ? "right" : "left" : r === "start" ? "bottom" : "top";
    return t.reference[o] > t.floating[o] && (i = qm(i)),
    [i, qm(i)]
}
function Ioe(e) {
    const t = qm(e);
    return [b5(e), t, b5(t)]
}
function b5(e) {
    return e.replace(/start|end/g, t => Aoe[t])
}
function Roe(e, t, n) {
    const r = ["left", "right"]
      , s = ["right", "left"]
      , o = ["top", "bottom"]
      , i = ["bottom", "top"];
    switch (e) {
    case "top":
    case "bottom":
        return n ? t ? s : r : t ? r : s;
    case "left":
    case "right":
        return t ? o : i;
    default:
        return []
    }
}
function Noe(e, t, n, r) {
    const s = Zu(e);
    let o = Roe(wi(e), n === "start", r);
    return s && (o = o.map(i => i + "-" + s),
    t && (o = o.concat(o.map(b5)))),
    o
}
function qm(e) {
    return e.replace(/left|right|bottom|top/g, t => Ooe[t])
}
function Poe(e) {
    return {
        top: 0,
        right: 0,
        bottom: 0,
        left: 0,
        ...e
    }
}
function zF(e) {
    return typeof e != "number" ? Poe(e) : {
        top: e,
        right: e,
        bottom: e,
        left: e
    }
}
function Gm(e) {
    const {x: t, y: n, width: r, height: s} = e;
    return {
        width: r,
        height: s,
        top: n,
        left: t,
        right: t + r,
        bottom: n + s,
        x: t,
        y: n
    }
}
function $x(e, t, n) {
    let {reference: r, floating: s} = e;
    const o = Ju(t)
      , i = Ew(t)
      , a = ww(i)
      , l = wi(t)
      , c = o === "y"
      , u = r.x + r.width / 2 - s.width / 2
      , d = r.y + r.height / 2 - s.height / 2
      , f = r[a] / 2 - s[a] / 2;
    let p;
    switch (l) {
    case "top":
        p = {
            x: u,
            y: r.y - s.height
        };
        break;
    case "bottom":
        p = {
            x: u,
            y: r.y + r.height
        };
        break;
    case "right":
        p = {
            x: r.x + r.width,
            y: d
        };
        break;
    case "left":
        p = {
            x: r.x - s.width,
            y: d
        };
        break;
    default:
        p = {
            x: r.x,
            y: r.y
        }
    }
    switch (Zu(t)) {
    case "start":
        p[i] -= f * (n && c ? -1 : 1);
        break;
    case "end":
        p[i] += f * (n && c ? -1 : 1);
        break
    }
    return p
}
const Doe = async (e, t, n) => {
    const {placement: r="bottom", strategy: s="absolute", middleware: o=[], platform: i} = n
      , a = o.filter(Boolean)
      , l = await (i.isRTL == null ? void 0 : i.isRTL(t));
    let c = await i.getElementRects({
        reference: e,
        floating: t,
        strategy: s
    })
      , {x: u, y: d} = $x(c, r, l)
      , f = r
      , p = {}
      , m = 0;
    for (let v = 0; v < a.length; v++) {
        const {name: _, fn: y} = a[v]
          , {x: b, y: S, data: C, reset: w} = await y({
            x: u,
            y: d,
            initialPlacement: r,
            placement: f,
            strategy: s,
            middlewareData: p,
            rects: c,
            platform: i,
            elements: {
                reference: e,
                floating: t
            }
        });
        u = b ?? u,
        d = S ?? d,
        p = {
            ...p,
            [_]: {
                ...p[_],
                ...C
            }
        },
        w && m <= 50 && (m++,
        typeof w == "object" && (w.placement && (f = w.placement),
        w.rects && (c = w.rects === !0 ? await i.getElementRects({
            reference: e,
            floating: t,
            strategy: s
        }) : w.rects),
        {x: u, y: d} = $x(c, f, l)),
        v = -1)
    }
    return {
        x: u,
        y: d,
        placement: f,
        strategy: s,
        middlewareData: p
    }
}
;
async function wf(e, t) {
    var n;
    t === void 0 && (t = {});
    const {x: r, y: s, platform: o, rects: i, elements: a, strategy: l} = e
      , {boundary: c="clippingAncestors", rootBoundary: u="viewport", elementContext: d="floating", altBoundary: f=!1, padding: p=0} = Si(t, e)
      , m = zF(p)
      , _ = a[f ? d === "floating" ? "reference" : "floating" : d]
      , y = Gm(await o.getClippingRect({
        element: (n = await (o.isElement == null ? void 0 : o.isElement(_))) == null || n ? _ : _.contextElement || await (o.getDocumentElement == null ? void 0 : o.getDocumentElement(a.floating)),
        boundary: c,
        rootBoundary: u,
        strategy: l
    }))
      , b = d === "floating" ? {
        ...i.floating,
        x: r,
        y: s
    } : i.reference
      , S = await (o.getOffsetParent == null ? void 0 : o.getOffsetParent(a.floating))
      , C = await (o.isElement == null ? void 0 : o.isElement(S)) ? await (o.getScale == null ? void 0 : o.getScale(S)) || {
        x: 1,
        y: 1
    } : {
        x: 1,
        y: 1
    }
      , w = Gm(o.convertOffsetParentRelativeRectToViewportRelativeRect ? await o.convertOffsetParentRelativeRectToViewportRelativeRect({
        elements: a,
        rect: b,
        offsetParent: S,
        strategy: l
    }) : b);
    return {
        top: (y.top - w.top + m.top) / C.y,
        bottom: (w.bottom - y.bottom + m.bottom) / C.y,
        left: (y.left - w.left + m.left) / C.x,
        right: (w.right - y.right + m.right) / C.x
    }
}
const Loe = e => ({
    name: "arrow",
    options: e,
    async fn(t) {
        const {x: n, y: r, placement: s, rects: o, platform: i, elements: a, middlewareData: l} = t
          , {element: c, padding: u=0} = Si(e, t) || {};
        if (c == null)
            return {};
        const d = zF(u)
          , f = {
            x: n,
            y: r
        }
          , p = Ew(s)
          , m = ww(p)
          , v = await i.getDimensions(c)
          , _ = p === "y"
          , y = _ ? "top" : "left"
          , b = _ ? "bottom" : "right"
          , S = _ ? "clientHeight" : "clientWidth"
          , C = o.reference[m] + o.reference[p] - f[p] - o.floating[m]
          , w = f[p] - o.reference[p]
          , x = await (i.getOffsetParent == null ? void 0 : i.getOffsetParent(c));
        let E = x ? x[S] : 0;
        (!E || !await (i.isElement == null ? void 0 : i.isElement(x))) && (E = a.floating[S] || o.floating[m]);
        const T = C / 2 - w / 2
          , k = E / 2 - v[m] / 2 - 1
          , A = wa(d[y], k)
          , O = wa(d[b], k)
          , M = A
          , I = E - v[m] - O
          , R = E / 2 - v[m] / 2 + T
          , D = y5(M, R, I)
          , P = !l.arrow && Zu(s) != null && R !== D && o.reference[m] / 2 - (R < M ? A : O) - v[m] / 2 < 0
          , L = P ? R < M ? R - M : R - I : 0;
        return {
            [p]: f[p] + L,
            data: {
                [p]: D,
                centerOffset: R - D - L,
                ...P && {
                    alignmentOffset: L
                }
            },
            reset: P
        }
    }
})
  , Foe = function(e) {
    return e === void 0 && (e = {}),
    {
        name: "flip",
        options: e,
        async fn(t) {
            var n, r;
            const {placement: s, middlewareData: o, rects: i, initialPlacement: a, platform: l, elements: c} = t
              , {mainAxis: u=!0, crossAxis: d=!0, fallbackPlacements: f, fallbackStrategy: p="bestFit", fallbackAxisSideDirection: m="none", flipAlignment: v=!0, ..._} = Si(e, t);
            if ((n = o.arrow) != null && n.alignmentOffset)
                return {};
            const y = wi(s)
              , b = wi(a) === a
              , S = await (l.isRTL == null ? void 0 : l.isRTL(c.floating))
              , C = f || (b || !v ? [qm(a)] : Ioe(a));
            !f && m !== "none" && C.push(...Noe(a, v, m, S));
            const w = [a, ...C]
              , x = await wf(t, _)
              , E = [];
            let T = ((r = o.flip) == null ? void 0 : r.overflows) || [];
            if (u && E.push(x[y]),
            d) {
                const M = Moe(s, i, S);
                E.push(x[M[0]], x[M[1]])
            }
            if (T = [...T, {
                placement: s,
                overflows: E
            }],
            !E.every(M => M <= 0)) {
                var k, A;
                const M = (((k = o.flip) == null ? void 0 : k.index) || 0) + 1
                  , I = w[M];
                if (I)
                    return {
                        data: {
                            index: M,
                            overflows: T
                        },
                        reset: {
                            placement: I
                        }
                    };
                let R = (A = T.filter(D => D.overflows[0] <= 0).sort( (D, P) => D.overflows[1] - P.overflows[1])[0]) == null ? void 0 : A.placement;
                if (!R)
                    switch (p) {
                    case "bestFit":
                        {
                            var O;
                            const D = (O = T.map(P => [P.placement, P.overflows.filter(L => L > 0).reduce( (L, N) => L + N, 0)]).sort( (P, L) => P[1] - L[1])[0]) == null ? void 0 : O[0];
                            D && (R = D);
                            break
                        }
                    case "initialPlacement":
                        R = a;
                        break
                    }
                if (s !== R)
                    return {
                        reset: {
                            placement: R
                        }
                    }
            }
            return {}
        }
    }
};
function Wx(e, t) {
    return {
        top: e.top - t.height,
        right: e.right - t.width,
        bottom: e.bottom - t.height,
        left: e.left - t.width
    }
}
function Kx(e) {
    return koe.some(t => e[t] >= 0)
}
const joe = function(e) {
    return e === void 0 && (e = {}),
    {
        name: "hide",
        options: e,
        async fn(t) {
            const {rects: n} = t
              , {strategy: r="referenceHidden", ...s} = Si(e, t);
            switch (r) {
            case "referenceHidden":
                {
                    const o = await wf(t, {
                        ...s,
                        elementContext: "reference"
                    })
                      , i = Wx(o, n.reference);
                    return {
                        data: {
                            referenceHiddenOffsets: i,
                            referenceHidden: Kx(i)
                        }
                    }
                }
            case "escaped":
                {
                    const o = await wf(t, {
                        ...s,
                        altBoundary: !0
                    })
                      , i = Wx(o, n.floating);
                    return {
                        data: {
                            escapedOffsets: i,
                            escaped: Kx(i)
                        }
                    }
                }
            default:
                return {}
            }
        }
    }
};
async function Uoe(e, t) {
    const {placement: n, platform: r, elements: s} = e
      , o = await (r.isRTL == null ? void 0 : r.isRTL(s.floating))
      , i = wi(n)
      , a = Zu(n)
      , l = Ju(n) === "y"
      , c = ["left", "top"].includes(i) ? -1 : 1
      , u = o && l ? -1 : 1
      , d = Si(t, e);
    let {mainAxis: f, crossAxis: p, alignmentAxis: m} = typeof d == "number" ? {
        mainAxis: d,
        crossAxis: 0,
        alignmentAxis: null
    } : {
        mainAxis: 0,
        crossAxis: 0,
        alignmentAxis: null,
        ...d
    };
    return a && typeof m == "number" && (p = a === "end" ? m * -1 : m),
    l ? {
        x: p * u,
        y: f * c
    } : {
        x: f * c,
        y: p * u
    }
}
const Boe = function(e) {
    return e === void 0 && (e = 0),
    {
        name: "offset",
        options: e,
        async fn(t) {
            var n, r;
            const {x: s, y: o, placement: i, middlewareData: a} = t
              , l = await Uoe(t, e);
            return i === ((n = a.offset) == null ? void 0 : n.placement) && (r = a.arrow) != null && r.alignmentOffset ? {} : {
                x: s + l.x,
                y: o + l.y,
                data: {
                    ...l,
                    placement: i
                }
            }
        }
    }
}
  , qoe = function(e) {
    return e === void 0 && (e = {}),
    {
        name: "shift",
        options: e,
        async fn(t) {
            const {x: n, y: r, placement: s} = t
              , {mainAxis: o=!0, crossAxis: i=!1, limiter: a={
                fn: _ => {
                    let {x: y, y: b} = _;
                    return {
                        x: y,
                        y: b
                    }
                }
            }, ...l} = Si(e, t)
              , c = {
                x: n,
                y: r
            }
              , u = await wf(t, l)
              , d = Ju(wi(s))
              , f = Sw(d);
            let p = c[f]
              , m = c[d];
            if (o) {
                const _ = f === "y" ? "top" : "left"
                  , y = f === "y" ? "bottom" : "right"
                  , b = p + u[_]
                  , S = p - u[y];
                p = y5(b, p, S)
            }
            if (i) {
                const _ = d === "y" ? "top" : "left"
                  , y = d === "y" ? "bottom" : "right"
                  , b = m + u[_]
                  , S = m - u[y];
                m = y5(b, m, S)
            }
            const v = a.fn({
                ...t,
                [f]: p,
                [d]: m
            });
            return {
                ...v,
                data: {
                    x: v.x - n,
                    y: v.y - r
                }
            }
        }
    }
}
  , Goe = function(e) {
    return e === void 0 && (e = {}),
    {
        options: e,
        fn(t) {
            const {x: n, y: r, placement: s, rects: o, middlewareData: i} = t
              , {offset: a=0, mainAxis: l=!0, crossAxis: c=!0} = Si(e, t)
              , u = {
                x: n,
                y: r
            }
              , d = Ju(s)
              , f = Sw(d);
            let p = u[f]
              , m = u[d];
            const v = Si(a, t)
              , _ = typeof v == "number" ? {
                mainAxis: v,
                crossAxis: 0
            } : {
                mainAxis: 0,
                crossAxis: 0,
                ...v
            };
            if (l) {
                const S = f === "y" ? "height" : "width"
                  , C = o.reference[f] - o.floating[S] + _.mainAxis
                  , w = o.reference[f] + o.reference[S] - _.mainAxis;
                p < C ? p = C : p > w && (p = w)
            }
            if (c) {
                var y, b;
                const S = f === "y" ? "width" : "height"
                  , C = ["top", "left"].includes(wi(s))
                  , w = o.reference[d] - o.floating[S] + (C && ((y = i.offset) == null ? void 0 : y[d]) || 0) + (C ? 0 : _.crossAxis)
                  , x = o.reference[d] + o.reference[S] + (C ? 0 : ((b = i.offset) == null ? void 0 : b[d]) || 0) - (C ? _.crossAxis : 0);
                m < w ? m = w : m > x && (m = x)
            }
            return {
                [f]: p,
                [d]: m
            }
        }
    }
}
  , Voe = function(e) {
    return e === void 0 && (e = {}),
    {
        name: "size",
        options: e,
        async fn(t) {
            const {placement: n, rects: r, platform: s, elements: o} = t
              , {apply: i= () => {}
            , ...a} = Si(e, t)
              , l = await wf(t, a)
              , c = wi(n)
              , u = Zu(n)
              , d = Ju(n) === "y"
              , {width: f, height: p} = r.floating;
            let m, v;
            c === "top" || c === "bottom" ? (m = c,
            v = u === (await (s.isRTL == null ? void 0 : s.isRTL(o.floating)) ? "start" : "end") ? "left" : "right") : (v = c,
            m = u === "end" ? "top" : "bottom");
            const _ = p - l[m]
              , y = f - l[v]
              , b = !t.middlewareData.shift;
            let S = _
              , C = y;
            if (d) {
                const x = f - l.left - l.right;
                C = u || b ? wa(y, x) : x
            } else {
                const x = p - l.top - l.bottom;
                S = u || b ? wa(_, x) : x
            }
            if (b && !u) {
                const x = Kr(l.left, 0)
                  , E = Kr(l.right, 0)
                  , T = Kr(l.top, 0)
                  , k = Kr(l.bottom, 0);
                d ? C = f - 2 * (x !== 0 || E !== 0 ? x + E : Kr(l.left, l.right)) : S = p - 2 * (T !== 0 || k !== 0 ? T + k : Kr(l.top, l.bottom))
            }
            await i({
                ...t,
                availableWidth: C,
                availableHeight: S
            });
            const w = await s.getDimensions(o.floating);
            return f !== w.width || p !== w.height ? {
                reset: {
                    rects: !0
                }
            } : {}
        }
    }
};
function w1() {
    return typeof window < "u"
}
function Xu(e) {
    return $F(e) ? (e.nodeName || "").toLowerCase() : "#document"
}
function es(e) {
    var t;
    return (e == null || (t = e.ownerDocument) == null ? void 0 : t.defaultView) || window
}
function qo(e) {
    var t;
    return (t = ($F(e) ? e.ownerDocument : e.document) || window.document) == null ? void 0 : t.documentElement
}
function $F(e) {
    return w1() ? e instanceof Node || e instanceof es(e).Node : !1
}
function Qs(e) {
    return w1() ? e instanceof Element || e instanceof es(e).Element : !1
}
function Lo(e) {
    return w1() ? e instanceof HTMLElement || e instanceof es(e).HTMLElement : !1
}
function Yx(e) {
    return !w1() || typeof ShadowRoot > "u" ? !1 : e instanceof ShadowRoot || e instanceof es(e).ShadowRoot
}
function ch(e) {
    const {overflow: t, overflowX: n, overflowY: r, display: s} = eo(e);
    return /auto|scroll|overlay|hidden|clip/.test(t + r + n) && !["inline", "contents"].includes(s)
}
function Hoe(e) {
    return ["table", "td", "th"].includes(Xu(e))
}
function E1(e) {
    return [":popover-open", ":modal"].some(t => {
        try {
            return e.matches(t)
        } catch {
            return !1
        }
    }
    )
}
function xw(e) {
    const t = Tw()
      , n = Qs(e) ? eo(e) : e;
    return n.transform !== "none" || n.perspective !== "none" || (n.containerType ? n.containerType !== "normal" : !1) || !t && (n.backdropFilter ? n.backdropFilter !== "none" : !1) || !t && (n.filter ? n.filter !== "none" : !1) || ["transform", "perspective", "filter"].some(r => (n.willChange || "").includes(r)) || ["paint", "layout", "strict", "content"].some(r => (n.contain || "").includes(r))
}
function zoe(e) {
    let t = xa(e);
    for (; Lo(t) && !Ru(t); ) {
        if (xw(t))
            return t;
        if (E1(t))
            return null;
        t = xa(t)
    }
    return null
}
function Tw() {
    return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none")
}
function Ru(e) {
    return ["html", "body", "#document"].includes(Xu(e))
}
function eo(e) {
    return es(e).getComputedStyle(e)
}
function x1(e) {
    return Qs(e) ? {
        scrollLeft: e.scrollLeft,
        scrollTop: e.scrollTop
    } : {
        scrollLeft: e.scrollX,
        scrollTop: e.scrollY
    }
}
function xa(e) {
    if (Xu(e) === "html")
        return e;
    const t = e.assignedSlot || e.parentNode || Yx(e) && e.host || qo(e);
    return Yx(t) ? t.host : t
}
function WF(e) {
    const t = xa(e);
    return Ru(t) ? e.ownerDocument ? e.ownerDocument.body : e.body : Lo(t) && ch(t) ? t : WF(t)
}
function Ef(e, t, n) {
    var r;
    t === void 0 && (t = []),
    n === void 0 && (n = !0);
    const s = WF(e)
      , o = s === ((r = e.ownerDocument) == null ? void 0 : r.body)
      , i = es(s);
    if (o) {
        const a = C5(i);
        return t.concat(i, i.visualViewport || [], ch(s) ? s : [], a && n ? Ef(a) : [])
    }
    return t.concat(s, Ef(s, [], n))
}
function C5(e) {
    return e.parent && Object.getPrototypeOf(e.parent) ? e.frameElement : null
}
function KF(e) {
    const t = eo(e);
    let n = parseFloat(t.width) || 0
      , r = parseFloat(t.height) || 0;
    const s = Lo(e)
      , o = s ? e.offsetWidth : n
      , i = s ? e.offsetHeight : r
      , a = Bm(n) !== o || Bm(r) !== i;
    return a && (n = o,
    r = i),
    {
        width: n,
        height: r,
        $: a
    }
}
function kw(e) {
    return Qs(e) ? e : e.contextElement
}
function uu(e) {
    const t = kw(e);
    if (!Lo(t))
        return Ea(1);
    const n = t.getBoundingClientRect()
      , {width: r, height: s, $: o} = KF(t);
    let i = (o ? Bm(n.width) : n.width) / r
      , a = (o ? Bm(n.height) : n.height) / s;
    return (!i || !Number.isFinite(i)) && (i = 1),
    (!a || !Number.isFinite(a)) && (a = 1),
    {
        x: i,
        y: a
    }
}
const $oe = Ea(0);
function YF(e) {
    const t = es(e);
    return !Tw() || !t.visualViewport ? $oe : {
        x: t.visualViewport.offsetLeft,
        y: t.visualViewport.offsetTop
    }
}
function Woe(e, t, n) {
    return t === void 0 && (t = !1),
    !n || t && n !== es(e) ? !1 : t
}
function Ul(e, t, n, r) {
    t === void 0 && (t = !1),
    n === void 0 && (n = !1);
    const s = e.getBoundingClientRect()
      , o = kw(e);
    let i = Ea(1);
    t && (r ? Qs(r) && (i = uu(r)) : i = uu(e));
    const a = Woe(o, n, r) ? YF(o) : Ea(0);
    let l = (s.left + a.x) / i.x
      , c = (s.top + a.y) / i.y
      , u = s.width / i.x
      , d = s.height / i.y;
    if (o) {
        const f = es(o)
          , p = r && Qs(r) ? es(r) : r;
        let m = f
          , v = C5(m);
        for (; v && r && p !== m; ) {
            const _ = uu(v)
              , y = v.getBoundingClientRect()
              , b = eo(v)
              , S = y.left + (v.clientLeft + parseFloat(b.paddingLeft)) * _.x
              , C = y.top + (v.clientTop + parseFloat(b.paddingTop)) * _.y;
            l *= _.x,
            c *= _.y,
            u *= _.x,
            d *= _.y,
            l += S,
            c += C,
            m = es(v),
            v = C5(m)
        }
    }
    return Gm({
        width: u,
        height: d,
        x: l,
        y: c
    })
}
function Koe(e) {
    let {elements: t, rect: n, offsetParent: r, strategy: s} = e;
    const o = s === "fixed"
      , i = qo(r)
      , a = t ? E1(t.floating) : !1;
    if (r === i || a && o)
        return n;
    let l = {
        scrollLeft: 0,
        scrollTop: 0
    }
      , c = Ea(1);
    const u = Ea(0)
      , d = Lo(r);
    if ((d || !d && !o) && ((Xu(r) !== "body" || ch(i)) && (l = x1(r)),
    Lo(r))) {
        const f = Ul(r);
        c = uu(r),
        u.x = f.x + r.clientLeft,
        u.y = f.y + r.clientTop
    }
    return {
        width: n.width * c.x,
        height: n.height * c.y,
        x: n.x * c.x - l.scrollLeft * c.x + u.x,
        y: n.y * c.y - l.scrollTop * c.y + u.y
    }
}
function Yoe(e) {
    return Array.from(e.getClientRects())
}
function S5(e, t) {
    const n = x1(e).scrollLeft;
    return t ? t.left + n : Ul(qo(e)).left + n
}
function Zoe(e) {
    const t = qo(e)
      , n = x1(e)
      , r = e.ownerDocument.body
      , s = Kr(t.scrollWidth, t.clientWidth, r.scrollWidth, r.clientWidth)
      , o = Kr(t.scrollHeight, t.clientHeight, r.scrollHeight, r.clientHeight);
    let i = -n.scrollLeft + S5(e);
    const a = -n.scrollTop;
    return eo(r).direction === "rtl" && (i += Kr(t.clientWidth, r.clientWidth) - s),
    {
        width: s,
        height: o,
        x: i,
        y: a
    }
}
function Joe(e, t) {
    const n = es(e)
      , r = qo(e)
      , s = n.visualViewport;
    let o = r.clientWidth
      , i = r.clientHeight
      , a = 0
      , l = 0;
    if (s) {
        o = s.width,
        i = s.height;
        const c = Tw();
        (!c || c && t === "fixed") && (a = s.offsetLeft,
        l = s.offsetTop)
    }
    return {
        width: o,
        height: i,
        x: a,
        y: l
    }
}
function Xoe(e, t) {
    const n = Ul(e, !0, t === "fixed")
      , r = n.top + e.clientTop
      , s = n.left + e.clientLeft
      , o = Lo(e) ? uu(e) : Ea(1)
      , i = e.clientWidth * o.x
      , a = e.clientHeight * o.y
      , l = s * o.x
      , c = r * o.y;
    return {
        width: i,
        height: a,
        x: l,
        y: c
    }
}
function Zx(e, t, n) {
    let r;
    if (t === "viewport")
        r = Joe(e, n);
    else if (t === "document")
        r = Zoe(qo(e));
    else if (Qs(t))
        r = Xoe(t, n);
    else {
        const s = YF(e);
        r = {
            ...t,
            x: t.x - s.x,
            y: t.y - s.y
        }
    }
    return Gm(r)
}
function ZF(e, t) {
    const n = xa(e);
    return n === t || !Qs(n) || Ru(n) ? !1 : eo(n).position === "fixed" || ZF(n, t)
}
function Qoe(e, t) {
    const n = t.get(e);
    if (n)
        return n;
    let r = Ef(e, [], !1).filter(a => Qs(a) && Xu(a) !== "body")
      , s = null;
    const o = eo(e).position === "fixed";
    let i = o ? xa(e) : e;
    for (; Qs(i) && !Ru(i); ) {
        const a = eo(i)
          , l = xw(i);
        !l && a.position === "fixed" && (s = null),
        (o ? !l && !s : !l && a.position === "static" && !!s && ["absolute", "fixed"].includes(s.position) || ch(i) && !l && ZF(e, i)) ? r = r.filter(u => u !== i) : s = a,
        i = xa(i)
    }
    return t.set(e, r),
    r
}
function eie(e) {
    let {element: t, boundary: n, rootBoundary: r, strategy: s} = e;
    const i = [...n === "clippingAncestors" ? E1(t) ? [] : Qoe(t, this._c) : [].concat(n), r]
      , a = i[0]
      , l = i.reduce( (c, u) => {
        const d = Zx(t, u, s);
        return c.top = Kr(d.top, c.top),
        c.right = wa(d.right, c.right),
        c.bottom = wa(d.bottom, c.bottom),
        c.left = Kr(d.left, c.left),
        c
    }
    , Zx(t, a, s));
    return {
        width: l.right - l.left,
        height: l.bottom - l.top,
        x: l.left,
        y: l.top
    }
}
function tie(e) {
    const {width: t, height: n} = KF(e);
    return {
        width: t,
        height: n
    }
}
function nie(e, t, n) {
    const r = Lo(t)
      , s = qo(t)
      , o = n === "fixed"
      , i = Ul(e, !0, o, t);
    let a = {
        scrollLeft: 0,
        scrollTop: 0
    };
    const l = Ea(0);
    if (r || !r && !o)
        if ((Xu(t) !== "body" || ch(s)) && (a = x1(t)),
        r) {
            const p = Ul(t, !0, o, t);
            l.x = p.x + t.clientLeft,
            l.y = p.y + t.clientTop
        } else
            s && (l.x = S5(s));
    let c = 0
      , u = 0;
    if (s && !r && !o) {
        const p = s.getBoundingClientRect();
        u = p.top + a.scrollTop,
        c = p.left + a.scrollLeft - S5(s, p)
    }
    const d = i.left + a.scrollLeft - l.x - c
      , f = i.top + a.scrollTop - l.y - u;
    return {
        x: d,
        y: f,
        width: i.width,
        height: i.height
    }
}
function oy(e) {
    return eo(e).position === "static"
}
function Jx(e, t) {
    if (!Lo(e) || eo(e).position === "fixed")
        return null;
    if (t)
        return t(e);
    let n = e.offsetParent;
    return qo(e) === n && (n = n.ownerDocument.body),
    n
}
function JF(e, t) {
    const n = es(e);
    if (E1(e))
        return n;
    if (!Lo(e)) {
        let s = xa(e);
        for (; s && !Ru(s); ) {
            if (Qs(s) && !oy(s))
                return s;
            s = xa(s)
        }
        return n
    }
    let r = Jx(e, t);
    for (; r && Hoe(r) && oy(r); )
        r = Jx(r, t);
    return r && Ru(r) && oy(r) && !xw(r) ? n : r || zoe(e) || n
}
const rie = async function(e) {
    const t = this.getOffsetParent || JF
      , n = this.getDimensions
      , r = await n(e.floating);
    return {
        reference: nie(e.reference, await t(e.floating), e.strategy),
        floating: {
            x: 0,
            y: 0,
            width: r.width,
            height: r.height
        }
    }
};
function sie(e) {
    return eo(e).direction === "rtl"
}
const oie = {
    convertOffsetParentRelativeRectToViewportRelativeRect: Koe,
    getDocumentElement: qo,
    getClippingRect: eie,
    getOffsetParent: JF,
    getElementRects: rie,
    getClientRects: Yoe,
    getDimensions: tie,
    getScale: uu,
    isElement: Qs,
    isRTL: sie
};
function iie(e, t) {
    let n = null, r;
    const s = qo(e);
    function o() {
        var a;
        clearTimeout(r),
        (a = n) == null || a.disconnect(),
        n = null
    }
    function i(a, l) {
        a === void 0 && (a = !1),
        l === void 0 && (l = 1),
        o();
        const {left: c, top: u, width: d, height: f} = e.getBoundingClientRect();
        if (a || t(),
        !d || !f)
            return;
        const p = hp(u)
          , m = hp(s.clientWidth - (c + d))
          , v = hp(s.clientHeight - (u + f))
          , _ = hp(c)
          , b = {
            rootMargin: -p + "px " + -m + "px " + -v + "px " + -_ + "px",
            threshold: Kr(0, wa(1, l)) || 1
        };
        let S = !0;
        function C(w) {
            const x = w[0].intersectionRatio;
            if (x !== l) {
                if (!S)
                    return i();
                x ? i(!1, x) : r = setTimeout( () => {
                    i(!1, 1e-7)
                }
                , 1e3)
            }
            S = !1
        }
        try {
            n = new IntersectionObserver(C,{
                ...b,
                root: s.ownerDocument
            })
        } catch {
            n = new IntersectionObserver(C,b)
        }
        n.observe(e)
    }
    return i(!0),
    o
}
function aie(e, t, n, r) {
    r === void 0 && (r = {});
    const {ancestorScroll: s=!0, ancestorResize: o=!0, elementResize: i=typeof ResizeObserver == "function", layoutShift: a=typeof IntersectionObserver == "function", animationFrame: l=!1} = r
      , c = kw(e)
      , u = s || o ? [...c ? Ef(c) : [], ...Ef(t)] : [];
    u.forEach(y => {
        s && y.addEventListener("scroll", n, {
            passive: !0
        }),
        o && y.addEventListener("resize", n)
    }
    );
    const d = c && a ? iie(c, n) : null;
    let f = -1
      , p = null;
    i && (p = new ResizeObserver(y => {
        let[b] = y;
        b && b.target === c && p && (p.unobserve(t),
        cancelAnimationFrame(f),
        f = requestAnimationFrame( () => {
            var S;
            (S = p) == null || S.observe(t)
        }
        )),
        n()
    }
    ),
    c && !l && p.observe(c),
    p.observe(t));
    let m, v = l ? Ul(e) : null;
    l && _();
    function _() {
        const y = Ul(e);
        v && (y.x !== v.x || y.y !== v.y || y.width !== v.width || y.height !== v.height) && n(),
        v = y,
        m = requestAnimationFrame(_)
    }
    return n(),
    () => {
        var y;
        u.forEach(b => {
            s && b.removeEventListener("scroll", n),
            o && b.removeEventListener("resize", n)
        }
        ),
        d?.(),
        (y = p) == null || y.disconnect(),
        p = null,
        l && cancelAnimationFrame(m)
    }
}
const lie = Boe
  , cie = qoe
  , uie = Foe
  , die = Voe
  , fie = joe
  , Xx = Loe
  , hie = Goe
  , pie = (e, t, n) => {
    const r = new Map
      , s = {
        platform: oie,
        ...n
    }
      , o = {
        ...s.platform,
        _c: r
    };
    return Doe(e, t, {
        ...s,
        platform: o
    })
}
;
var Zp = typeof document < "u" ? h.useLayoutEffect : h.useEffect;
function Vm(e, t) {
    if (e === t)
        return !0;
    if (typeof e != typeof t)
        return !1;
    if (typeof e == "function" && e.toString() === t.toString())
        return !0;
    let n, r, s;
    if (e && t && typeof e == "object") {
        if (Array.isArray(e)) {
            if (n = e.length,
            n !== t.length)
                return !1;
            for (r = n; r-- !== 0; )
                if (!Vm(e[r], t[r]))
                    return !1;
            return !0
        }
        if (s = Object.keys(e),
        n = s.length,
        n !== Object.keys(t).length)
            return !1;
        for (r = n; r-- !== 0; )
            if (!{}.hasOwnProperty.call(t, s[r]))
                return !1;
        for (r = n; r-- !== 0; ) {
            const o = s[r];
            if (!(o === "_owner" && e.$$typeof) && !Vm(e[o], t[o]))
                return !1
        }
        return !0
    }
    return e !== e && t !== t
}
function XF(e) {
    return typeof window > "u" ? 1 : (e.ownerDocument.defaultView || window).devicePixelRatio || 1
}
function Qx(e, t) {
    const n = XF(e);
    return Math.round(t * n) / n
}
function iy(e) {
    const t = h.useRef(e);
    return Zp( () => {
        t.current = e
    }
    ),
    t
}
function mie(e) {
    e === void 0 && (e = {});
    const {placement: t="bottom", strategy: n="absolute", middleware: r=[], platform: s, elements: {reference: o, floating: i}={}, transform: a=!0, whileElementsMounted: l, open: c} = e
      , [u,d] = h.useState({
        x: 0,
        y: 0,
        strategy: n,
        placement: t,
        middlewareData: {},
        isPositioned: !1
    })
      , [f,p] = h.useState(r);
    Vm(f, r) || p(r);
    const [m,v] = h.useState(null)
      , [_,y] = h.useState(null)
      , b = h.useCallback(N => {
        N !== x.current && (x.current = N,
        v(N))
    }
    , [])
      , S = h.useCallback(N => {
        N !== E.current && (E.current = N,
        y(N))
    }
    , [])
      , C = o || m
      , w = i || _
      , x = h.useRef(null)
      , E = h.useRef(null)
      , T = h.useRef(u)
      , k = l != null
      , A = iy(l)
      , O = iy(s)
      , M = iy(c)
      , I = h.useCallback( () => {
        if (!x.current || !E.current)
            return;
        const N = {
            placement: t,
            strategy: n,
            middleware: f
        };
        O.current && (N.platform = O.current),
        pie(x.current, E.current, N).then(B => {
            const H = {
                ...B,
                isPositioned: M.current !== !1
            };
            R.current && !Vm(T.current, H) && (T.current = H,
            IS.flushSync( () => {
                d(H)
            }
            ))
        }
        )
    }
    , [f, t, n, O, M]);
    Zp( () => {
        c === !1 && T.current.isPositioned && (T.current.isPositioned = !1,
        d(N => ({
            ...N,
            isPositioned: !1
        })))
    }
    , [c]);
    const R = h.useRef(!1);
    Zp( () => (R.current = !0,
    () => {
        R.current = !1
    }
    ), []),
    Zp( () => {
        if (C && (x.current = C),
        w && (E.current = w),
        C && w) {
            if (A.current)
                return A.current(C, w, I);
            I()
        }
    }
    , [C, w, I, A, k]);
    const D = h.useMemo( () => ({
        reference: x,
        floating: E,
        setReference: b,
        setFloating: S
    }), [b, S])
      , P = h.useMemo( () => ({
        reference: C,
        floating: w
    }), [C, w])
      , L = h.useMemo( () => {
        const N = {
            position: n,
            left: 0,
            top: 0
        };
        if (!P.floating)
            return N;
        const B = Qx(P.floating, u.x)
          , H = Qx(P.floating, u.y);
        return a ? {
            ...N,
            transform: "translate(" + B + "px, " + H + "px)",
            ...XF(P.floating) >= 1.5 && {
                willChange: "transform"
            }
        } : {
            position: n,
            left: B,
            top: H
        }
    }
    , [n, a, P.floating, u.x, u.y]);
    return h.useMemo( () => ({
        ...u,
        update: I,
        refs: D,
        elements: P,
        floatingStyles: L
    }), [u, I, D, P, L])
}
const gie = e => {
    function t(n) {
        return {}.hasOwnProperty.call(n, "current")
    }
    return {
        name: "arrow",
        options: e,
        fn(n) {
            const {element: r, padding: s} = typeof e == "function" ? e(n) : e;
            return r && t(r) ? r.current != null ? Xx({
                element: r.current,
                padding: s
            }).fn(n) : {} : r ? Xx({
                element: r,
                padding: s
            }).fn(n) : {}
        }
    }
}
  , vie = (e, t) => ({
    ...lie(e),
    options: [e, t]
})
  , _ie = (e, t) => ({
    ...cie(e),
    options: [e, t]
})
  , yie = (e, t) => ({
    ...hie(e),
    options: [e, t]
})
  , bie = (e, t) => ({
    ...uie(e),
    options: [e, t]
})
  , Cie = (e, t) => ({
    ...die(e),
    options: [e, t]
})
  , Sie = (e, t) => ({
    ...fie(e),
    options: [e, t]
})
  , wie = (e, t) => ({
    ...gie(e),
    options: [e, t]
});
var Eie = "Arrow"
  , QF = h.forwardRef( (e, t) => {
    const {children: n, width: r=10, height: s=5, ...o} = e;
    return g.jsx(Vt.svg, {
        ...o,
        ref: t,
        width: r,
        height: s,
        viewBox: "0 0 30 10",
        preserveAspectRatio: "none",
        children: e.asChild ? n : g.jsx("polygon", {
            points: "0,0 30,0 15,10"
        })
    })
}
);
QF.displayName = Eie;
var xie = QF
  , Ow = "Popper"
  , [ej,T1] = vw(Ow)
  , [Tie,tj] = ej(Ow)
  , nj = e => {
    const {__scopePopper: t, children: n} = e
      , [r,s] = h.useState(null);
    return g.jsx(Tie, {
        scope: t,
        anchor: r,
        onAnchorChange: s,
        children: n
    })
}
;
nj.displayName = Ow;
var rj = "PopperAnchor"
  , sj = h.forwardRef( (e, t) => {
    const {__scopePopper: n, virtualRef: r, ...s} = e
      , o = tj(rj, n)
      , i = h.useRef(null)
      , a = xn(t, i);
    return h.useEffect( () => {
        o.onAnchorChange(r?.current || i.current)
    }
    ),
    r ? null : g.jsx(Vt.div, {
        ...s,
        ref: a
    })
}
);
sj.displayName = rj;
var Aw = "PopperContent"
  , [kie,Oie] = ej(Aw)
  , oj = h.forwardRef( (e, t) => {
    const {__scopePopper: n, side: r="bottom", sideOffset: s=0, align: o="center", alignOffset: i=0, arrowPadding: a=0, avoidCollisions: l=!0, collisionBoundary: c=[], collisionPadding: u=0, sticky: d="partial", hideWhenDetached: f=!1, updatePositionStrategy: p="optimized", onPlaced: m, ...v} = e
      , _ = tj(Aw, n)
      , [y,b] = h.useState(null)
      , S = xn(t, Z => b(Z))
      , [C,w] = h.useState(null)
      , x = hF(C)
      , E = x?.width ?? 0
      , T = x?.height ?? 0
      , k = r + (o !== "center" ? "-" + o : "")
      , A = typeof u == "number" ? u : {
        top: 0,
        right: 0,
        bottom: 0,
        left: 0,
        ...u
    }
      , O = Array.isArray(c) ? c : [c]
      , M = O.length > 0
      , I = {
        padding: A,
        boundary: O.filter(Mie),
        altBoundary: M
    }
      , {refs: R, floatingStyles: D, placement: P, isPositioned: L, middlewareData: N} = mie({
        strategy: "fixed",
        placement: k,
        whileElementsMounted: (...Z) => aie(...Z, {
            animationFrame: p === "always"
        }),
        elements: {
            reference: _.anchor
        },
        middleware: [vie({
            mainAxis: s + T,
            alignmentAxis: i
        }), l && _ie({
            mainAxis: !0,
            crossAxis: !1,
            limiter: d === "partial" ? yie() : void 0,
            ...I
        }), l && bie({
            ...I
        }), Cie({
            ...I,
            apply: ({elements: Z, rects: ne, availableWidth: _e, availableHeight: ee}) => {
                const {width: oe, height: te} = ne.reference
                  , ve = Z.floating.style;
                ve.setProperty("--radix-popper-available-width", `${_e}px`),
                ve.setProperty("--radix-popper-available-height", `${ee}px`),
                ve.setProperty("--radix-popper-anchor-width", `${oe}px`),
                ve.setProperty("--radix-popper-anchor-height", `${te}px`)
            }
        }), C && wie({
            element: C,
            padding: a
        }), Iie({
            arrowWidth: E,
            arrowHeight: T
        }), f && Sie({
            strategy: "referenceHidden",
            ...I
        })]
    })
      , [B,H] = lj(P)
      , ye = xs(m);
    Dl( () => {
        L && ye?.()
    }
    , [L, ye]);
    const Ie = N.arrow?.x
      , be = N.arrow?.y
      , me = N.arrow?.centerOffset !== 0
      , [ge,ce] = h.useState();
    return Dl( () => {
        y && ce(window.getComputedStyle(y).zIndex)
    }
    , [y]),
    g.jsx("div", {
        ref: R.setFloating,
        "data-radix-popper-content-wrapper": "",
        style: {
            ...D,
            transform: L ? D.transform : "translate(0, -200%)",
            minWidth: "max-content",
            zIndex: ge,
            "--radix-popper-transform-origin": [N.transformOrigin?.x, N.transformOrigin?.y].join(" "),
            ...N.hide?.referenceHidden && {
                visibility: "hidden",
                pointerEvents: "none"
            }
        },
        dir: e.dir,
        children: g.jsx(kie, {
            scope: n,
            placedSide: B,
            onArrowChange: w,
            arrowX: Ie,
            arrowY: be,
            shouldHideArrow: me,
            children: g.jsx(Vt.div, {
                "data-side": B,
                "data-align": H,
                ...v,
                ref: S,
                style: {
                    ...v.style,
                    animation: L ? void 0 : "none"
                }
            })
        })
    })
}
);
oj.displayName = Aw;
var ij = "PopperArrow"
  , Aie = {
    top: "bottom",
    right: "left",
    bottom: "top",
    left: "right"
}
  , aj = h.forwardRef(function(t, n) {
    const {__scopePopper: r, ...s} = t
      , o = Oie(ij, r)
      , i = Aie[o.placedSide];
    return g.jsx("span", {
        ref: o.onArrowChange,
        style: {
            position: "absolute",
            left: o.arrowX,
            top: o.arrowY,
            [i]: 0,
            transformOrigin: {
                top: "",
                right: "0 0",
                bottom: "center 0",
                left: "100% 0"
            }[o.placedSide],
            transform: {
                top: "translateY(100%)",
                right: "translateY(50%) rotate(90deg) translateX(-50%)",
                bottom: "rotate(180deg)",
                left: "translateY(50%) rotate(-90deg) translateX(50%)"
            }[o.placedSide],
            visibility: o.shouldHideArrow ? "hidden" : void 0
        },
        children: g.jsx(xie, {
            ...s,
            ref: n,
            style: {
                ...s.style,
                display: "block"
            }
        })
    })
});
aj.displayName = ij;
function Mie(e) {
    return e !== null
}
var Iie = e => ({
    name: "transformOrigin",
    options: e,
    fn(t) {
        const {placement: n, rects: r, middlewareData: s} = t
          , i = s.arrow?.centerOffset !== 0
          , a = i ? 0 : e.arrowWidth
          , l = i ? 0 : e.arrowHeight
          , [c,u] = lj(n)
          , d = {
            start: "0%",
            center: "50%",
            end: "100%"
        }[u]
          , f = (s.arrow?.x ?? 0) + a / 2
          , p = (s.arrow?.y ?? 0) + l / 2;
        let m = ""
          , v = "";
        return c === "bottom" ? (m = i ? d : `${f}px`,
        v = `${-l}px`) : c === "top" ? (m = i ? d : `${f}px`,
        v = `${r.floating.height + l}px`) : c === "right" ? (m = `${-l}px`,
        v = i ? d : `${p}px`) : c === "left" && (m = `${r.floating.width + l}px`,
        v = i ? d : `${p}px`),
        {
            data: {
                x: m,
                y: v
            }
        }
    }
});
function lj(e) {
    const [t,n="center"] = e.split("-");
    return [t, n]
}
var Mw = nj
  , cj = sj
  , uj = oj
  , dj = aj
  , [k1,uTe] = $u("Tooltip", [T1])
  , O1 = T1()
  , fj = "TooltipProvider"
  , Rie = 700
  , w5 = "tooltip.open"
  , [Nie,Iw] = k1(fj)
  , hj = e => {
    const {__scopeTooltip: t, delayDuration: n=Rie, skipDelayDuration: r=300, disableHoverableContent: s=!1, children: o} = e
      , [i,a] = h.useState(!0)
      , l = h.useRef(!1)
      , c = h.useRef(0);
    return h.useEffect( () => {
        const u = c.current;
        return () => window.clearTimeout(u)
    }
    , []),
    g.jsx(Nie, {
        scope: t,
        isOpenDelayed: i,
        delayDuration: n,
        onOpen: h.useCallback( () => {
            window.clearTimeout(c.current),
            a(!1)
        }
        , []),
        onClose: h.useCallback( () => {
            window.clearTimeout(c.current),
            c.current = window.setTimeout( () => a(!0), r)
        }
        , [r]),
        isPointerInTransitRef: l,
        onPointerInTransitChange: h.useCallback(u => {
            l.current = u
        }
        , []),
        disableHoverableContent: s,
        children: o
    })
}
;
hj.displayName = fj;
var A1 = "Tooltip"
  , [Pie,uh] = k1(A1)
  , pj = e => {
    const {__scopeTooltip: t, children: n, open: r, defaultOpen: s=!1, onOpenChange: o, disableHoverableContent: i, delayDuration: a} = e
      , l = Iw(A1, e.__scopeTooltip)
      , c = O1(t)
      , [u,d] = h.useState(null)
      , f = Ro()
      , p = h.useRef(0)
      , m = i ?? l.disableHoverableContent
      , v = a ?? l.delayDuration
      , _ = h.useRef(!1)
      , [y=!1,b] = Ql({
        prop: r,
        defaultProp: s,
        onChange: E => {
            E ? (l.onOpen(),
            document.dispatchEvent(new CustomEvent(w5))) : l.onClose(),
            o?.(E)
        }
    })
      , S = h.useMemo( () => y ? _.current ? "delayed-open" : "instant-open" : "closed", [y])
      , C = h.useCallback( () => {
        window.clearTimeout(p.current),
        p.current = 0,
        _.current = !1,
        b(!0)
    }
    , [b])
      , w = h.useCallback( () => {
        window.clearTimeout(p.current),
        p.current = 0,
        b(!1)
    }
    , [b])
      , x = h.useCallback( () => {
        window.clearTimeout(p.current),
        p.current = window.setTimeout( () => {
            _.current = !0,
            b(!0),
            p.current = 0
        }
        , v)
    }
    , [v, b]);
    return h.useEffect( () => () => {
        p.current && (window.clearTimeout(p.current),
        p.current = 0)
    }
    , []),
    g.jsx(Mw, {
        ...c,
        children: g.jsx(Pie, {
            scope: t,
            contentId: f,
            open: y,
            stateAttribute: S,
            trigger: u,
            onTriggerChange: d,
            onTriggerEnter: h.useCallback( () => {
                l.isOpenDelayed ? x() : C()
            }
            , [l.isOpenDelayed, x, C]),
            onTriggerLeave: h.useCallback( () => {
                m ? w() : (window.clearTimeout(p.current),
                p.current = 0)
            }
            , [w, m]),
            onOpen: C,
            onClose: w,
            disableHoverableContent: m,
            children: n
        })
    })
}
;
pj.displayName = A1;
var E5 = "TooltipTrigger"
  , mj = h.forwardRef( (e, t) => {
    const {__scopeTooltip: n, ...r} = e
      , s = uh(E5, n)
      , o = Iw(E5, n)
      , i = O1(n)
      , a = h.useRef(null)
      , l = xn(t, a, s.onTriggerChange)
      , c = h.useRef(!1)
      , u = h.useRef(!1)
      , d = h.useCallback( () => c.current = !1, []);
    return h.useEffect( () => () => document.removeEventListener("pointerup", d), [d]),
    g.jsx(cj, {
        asChild: !0,
        ...i,
        children: g.jsx(Vt.button, {
            "aria-describedby": s.open ? s.contentId : void 0,
            "data-state": s.stateAttribute,
            ...r,
            ref: l,
            onPointerMove: Qe(e.onPointerMove, f => {
                f.pointerType !== "touch" && !u.current && !o.isPointerInTransitRef.current && (s.onTriggerEnter(),
                u.current = !0)
            }
            ),
            onPointerLeave: Qe(e.onPointerLeave, () => {
                s.onTriggerLeave(),
                u.current = !1
            }
            ),
            onPointerDown: Qe(e.onPointerDown, () => {
                c.current = !0,
                document.addEventListener("pointerup", d, {
                    once: !0
                })
            }
            ),
            onFocus: Qe(e.onFocus, () => {
                c.current || s.onOpen()
            }
            ),
            onBlur: Qe(e.onBlur, s.onClose),
            onClick: Qe(e.onClick, s.onClose)
        })
    })
}
);
mj.displayName = E5;
var Rw = "TooltipPortal"
  , [Die,Lie] = k1(Rw, {
    forceMount: void 0
})
  , gj = e => {
    const {__scopeTooltip: t, forceMount: n, children: r, container: s} = e
      , o = uh(Rw, t);
    return g.jsx(Die, {
        scope: t,
        forceMount: n,
        children: g.jsx(co, {
            present: n || o.open,
            children: g.jsx(rh, {
                asChild: !0,
                container: s,
                children: r
            })
        })
    })
}
;
gj.displayName = Rw;
var Nu = "TooltipContent"
  , vj = h.forwardRef( (e, t) => {
    const n = Lie(Nu, e.__scopeTooltip)
      , {forceMount: r=n.forceMount, side: s="top", ...o} = e
      , i = uh(Nu, e.__scopeTooltip);
    return g.jsx(co, {
        present: r || i.open,
        children: i.disableHoverableContent ? g.jsx(_j, {
            side: s,
            ...o,
            ref: t
        }) : g.jsx(Fie, {
            side: s,
            ...o,
            ref: t
        })
    })
}
)
  , Fie = h.forwardRef( (e, t) => {
    const n = uh(Nu, e.__scopeTooltip)
      , r = Iw(Nu, e.__scopeTooltip)
      , s = h.useRef(null)
      , o = xn(t, s)
      , [i,a] = h.useState(null)
      , {trigger: l, onClose: c} = n
      , u = s.current
      , {onPointerInTransitChange: d} = r
      , f = h.useCallback( () => {
        a(null),
        d(!1)
    }
    , [d])
      , p = h.useCallback( (m, v) => {
        const _ = m.currentTarget
          , y = {
            x: m.clientX,
            y: m.clientY
        }
          , b = Bie(y, _.getBoundingClientRect())
          , S = qie(y, b)
          , C = Gie(v.getBoundingClientRect())
          , w = Hie([...S, ...C]);
        a(w),
        d(!0)
    }
    , [d]);
    return h.useEffect( () => () => f(), [f]),
    h.useEffect( () => {
        if (l && u) {
            const m = _ => p(_, u)
              , v = _ => p(_, l);
            return l.addEventListener("pointerleave", m),
            u.addEventListener("pointerleave", v),
            () => {
                l.removeEventListener("pointerleave", m),
                u.removeEventListener("pointerleave", v)
            }
        }
    }
    , [l, u, p, f]),
    h.useEffect( () => {
        if (i) {
            const m = v => {
                const _ = v.target
                  , y = {
                    x: v.clientX,
                    y: v.clientY
                }
                  , b = l?.contains(_) || u?.contains(_)
                  , S = !Vie(y, i);
                b ? f() : S && (f(),
                c())
            }
            ;
            return document.addEventListener("pointermove", m),
            () => document.removeEventListener("pointermove", m)
        }
    }
    , [l, u, i, c, f]),
    g.jsx(_j, {
        ...e,
        ref: o
    })
}
)
  , [jie,Uie] = k1(A1, {
    isInside: !1
})
  , _j = h.forwardRef( (e, t) => {
    const {__scopeTooltip: n, children: r, "aria-label": s, onEscapeKeyDown: o, onPointerDownOutside: i, ...a} = e
      , l = uh(Nu, n)
      , c = O1(n)
      , {onClose: u} = l;
    return h.useEffect( () => (document.addEventListener(w5, u),
    () => document.removeEventListener(w5, u)), [u]),
    h.useEffect( () => {
        if (l.trigger) {
            const d = f => {
                f.target?.contains(l.trigger) && u()
            }
            ;
            return window.addEventListener("scroll", d, {
                capture: !0
            }),
            () => window.removeEventListener("scroll", d, {
                capture: !0
            })
        }
    }
    , [l.trigger, u]),
    g.jsx(nh, {
        asChild: !0,
        disableOutsidePointerEvents: !1,
        onEscapeKeyDown: o,
        onPointerDownOutside: i,
        onFocusOutside: d => d.preventDefault(),
        onDismiss: u,
        children: g.jsxs(uj, {
            "data-state": l.stateAttribute,
            ...c,
            ...a,
            ref: t,
            style: {
                ...a.style,
                "--radix-tooltip-content-transform-origin": "var(--radix-popper-transform-origin)",
                "--radix-tooltip-content-available-width": "var(--radix-popper-available-width)",
                "--radix-tooltip-content-available-height": "var(--radix-popper-available-height)",
                "--radix-tooltip-trigger-width": "var(--radix-popper-anchor-width)",
                "--radix-tooltip-trigger-height": "var(--radix-popper-anchor-height)"
            },
            children: [g.jsx(sD, {
                children: r
            }), g.jsx(jie, {
                scope: n,
                isInside: !0,
                children: g.jsx(UX, {
                    id: l.contentId,
                    role: "tooltip",
                    children: s || r
                })
            })]
        })
    })
}
);
vj.displayName = Nu;
var yj = "TooltipArrow"
  , bj = h.forwardRef( (e, t) => {
    const {__scopeTooltip: n, ...r} = e
      , s = O1(n);
    return Uie(yj, n).isInside ? null : g.jsx(dj, {
        ...s,
        ...r,
        ref: t
    })
}
);
bj.displayName = yj;
function Bie(e, t) {
    const n = Math.abs(t.top - e.y)
      , r = Math.abs(t.bottom - e.y)
      , s = Math.abs(t.right - e.x)
      , o = Math.abs(t.left - e.x);
    switch (Math.min(n, r, s, o)) {
    case o:
        return "left";
    case s:
        return "right";
    case n:
        return "top";
    case r:
        return "bottom";
    default:
        throw new Error("unreachable")
    }
}
function qie(e, t, n=5) {
    const r = [];
    switch (t) {
    case "top":
        r.push({
            x: e.x - n,
            y: e.y + n
        }, {
            x: e.x + n,
            y: e.y + n
        });
        break;
    case "bottom":
        r.push({
            x: e.x - n,
            y: e.y - n
        }, {
            x: e.x + n,
            y: e.y - n
        });
        break;
    case "left":
        r.push({
            x: e.x + n,
            y: e.y - n
        }, {
            x: e.x + n,
            y: e.y + n
        });
        break;
    case "right":
        r.push({
            x: e.x - n,
            y: e.y - n
        }, {
            x: e.x - n,
            y: e.y + n
        });
        break
    }
    return r
}
function Gie(e) {
    const {top: t, right: n, bottom: r, left: s} = e;
    return [{
        x: s,
        y: t
    }, {
        x: n,
        y: t
    }, {
        x: n,
        y: r
    }, {
        x: s,
        y: r
    }]
}
function Vie(e, t) {
    const {x: n, y: r} = e;
    let s = !1;
    for (let o = 0, i = t.length - 1; o < t.length; i = o++) {
        const a = t[o].x
          , l = t[o].y
          , c = t[i].x
          , u = t[i].y;
        l > r != u > r && n < (c - a) * (r - l) / (u - l) + a && (s = !s)
    }
    return s
}
function Hie(e) {
    const t = e.slice();
    return t.sort( (n, r) => n.x < r.x ? -1 : n.x > r.x ? 1 : n.y < r.y ? -1 : n.y > r.y ? 1 : 0),
    zie(t)
}
function zie(e) {
    if (e.length <= 1)
        return e.slice();
    const t = [];
    for (let r = 0; r < e.length; r++) {
        const s = e[r];
        for (; t.length >= 2; ) {
            const o = t[t.length - 1]
              , i = t[t.length - 2];
            if ((o.x - i.x) * (s.y - i.y) >= (o.y - i.y) * (s.x - i.x))
                t.pop();
            else
                break
        }
        t.push(s)
    }
    t.pop();
    const n = [];
    for (let r = e.length - 1; r >= 0; r--) {
        const s = e[r];
        for (; n.length >= 2; ) {
            const o = n[n.length - 1]
              , i = n[n.length - 2];
            if ((o.x - i.x) * (s.y - i.y) >= (o.y - i.y) * (s.x - i.x))
                n.pop();
            else
                break
        }
        n.push(s)
    }
    return n.pop(),
    t.length === 1 && n.length === 1 && t[0].x === n[0].x && t[0].y === n[0].y ? t : t.concat(n)
}
var $ie = hj
  , Wie = pj
  , Kie = mj
  , Yie = gj
  , Zie = vj
  , Jie = bj;
function Cj(e, t) {
    const n = h.useLayoutEffect;
    n(e, t)
}
const Xie = () => document?.body ?? null
  , Sj = h.createContext(Xie);
function dTe(e) {
    "use forget";
    const t = De.c(17)
      , {children: n, className: r, open: s, onClose: o, closedBy: i} = e
      , a = h.useRef(null);
    let l;
    t[0] === Symbol.for("react.memo_cache_sentinel") ? (l = () => a.current,
    t[0] = l) : l = t[0];
    const c = l;
    let u, d;
    t[1] !== s ? (u = () => {
        const S = a.current;
        if (!(!s || !S))
            return s === "modal" ? S.showModal() : S.show(),
            () => {
                S.close()
            }
    }
    ,
    d = [s],
    t[1] = s,
    t[2] = u,
    t[3] = d) : (u = t[2],
    d = t[3]),
    h.useEffect(u, d);
    let f;
    t[4] !== o ? (f = S => {
        S.target === S.currentTarget && o?.()
    }
    ,
    t[4] = o,
    t[5] = f) : f = t[5];
    const p = f;
    let m;
    t[6] !== i || t[7] !== o ? (m = S => {
        i && ["any", "closerequest"].includes(i) && S.key === "Escape" && o?.()
    }
    ,
    t[6] = i,
    t[7] = o,
    t[8] = m) : m = t[8];
    const v = m
      , _ = s === !0;
    let y;
    t[9] !== n ? (y = g.jsx(Sj, {
        value: c,
        children: n
    }),
    t[9] = n,
    t[10] = y) : y = t[10];
    let b;
    return t[11] !== r || t[12] !== p || t[13] !== v || t[14] !== _ || t[15] !== y ? (b = g.jsx("dialog", {
        className: r,
        open: _,
        ref: a,
        onClick: p,
        onKeyUp: v,
        children: y
    }),
    t[11] = r,
    t[12] = p,
    t[13] = v,
    t[14] = _,
    t[15] = y,
    t[16] = b) : b = t[16],
    b
}
function wj() {
    "use forget";
    const e = De.c(7)
      , [t,n] = h.useState(null)
      , r = h.use(Sj);
    let s;
    e[0] !== r ? (s = r(),
    e[0] = r,
    e[1] = s) : s = e[1];
    const o = s;
    let i, a;
    e[2] !== o ? (i = () => {
        n(o)
    }
    ,
    a = [o],
    e[2] = o,
    e[3] = i,
    e[4] = a) : (i = e[3],
    a = e[4]),
    Cj(i, a);
    let l;
    return e[5] !== t ? (l = t != null ? {
        container: t
    } : {},
    e[5] = t,
    e[6] = l) : l = e[6],
    l
}
const ls = e => {
    "use forget";
    const t = De.c(69)
      , {ariaLive: n, triggerAs: r, disabled: s, label: o, secondaryLabel: i, contentClassName: a, customPaddingClassName: l, customBorderClassName: c, customBackgroundColorClassName: u, theme: d, cornerRadius: f, side: p, sideOffset: m, align: v, alignOffset: _, withArrow: y, wide: b, interactive: S, usePortal: C, className: w, children: x, delayDuration: E, closeOnOutsideClick: T, open: k, onOpenChange: A, onDismissClick: O, isLeftArrow: M, labelTextAlign: I, ignoreTriggerOnOutsideClick: R, labelOrientation: D, defaultOpen: P, labelClassName: L} = e
      , N = r === void 0 ? "span" : r
      , B = d === void 0 ? "default" : d
      , H = f === void 0 ? "lg" : f
      , ye = p === void 0 ? "bottom" : p
      , Ie = m === void 0 ? 8 : m
      , be = v === void 0 ? "center" : v
      , me = _ === void 0 ? 0 : _
      , ge = y === void 0 ? !1 : y
      , ce = b === void 0 ? !1 : b
      , Z = S === void 0 ? !1 : S
      , ne = C === void 0 ? !0 : C
      , _e = E === void 0 ? 0 : E
      , ee = T === void 0 ? !0 : T
      , oe = M === void 0 ? !1 : M
      , te = I === void 0 ? "center" : I
      , ve = R === void 0 ? !1 : R
      , Ue = D === void 0 ? "vertical" : D
      , re = P === void 0 ? !1 : P
      , W = gt()
      , X = h.useRef(null);
    if (s) {
        let hn;
        return t[0] !== x ? (hn = g.jsx(g.Fragment, {
            children: x
        }),
        t[0] = x,
        t[1] = hn) : hn = t[1],
        hn
    }
    if (!o) {
        let hn;
        return t[2] !== N || t[3] !== x || t[4] !== w ? (hn = N ? g.jsx(N, {
            className: w,
            children: x
        }) : x,
        t[2] = N,
        t[3] = x,
        t[4] = w,
        t[5] = hn) : hn = t[5],
        hn
    }
    let Te;
    e: switch (B) {
    case "white":
        {
            Te = "light bg-white";
            break e
        }
    case "primary":
        {
            Te = "bg-token-main-surface-primary";
            break e
        }
    case "default":
        Te = "dark bg-black"
    }
    u != null && (Te = u);
    const se = te === "left" ? "text-start" : "text-center";
    let G;
    t[6] !== ee || t[7] !== ve ? (G = ee ? ve ? hn => {
        X.current?.contains(hn.target) && hn.preventDefault()
    }
    : void 0 : lae,
    t[6] = ee,
    t[7] = ve,
    t[8] = G) : G = t[8];
    const F = l ?? "px-2 py-1"
      , ke = B === "white" && "shadow-xs"
      , Ee = `rounded-${H}`
      , Y = !ge && "overflow-hidden"
      , le = ce ? "max-w-sm" : "max-w-xs";
    let Oe;
    t[9] !== Te || t[10] !== a || t[11] !== c || t[12] !== F || t[13] !== ke || t[14] !== Ee || t[15] !== Y || t[16] !== le ? (Oe = we("relative z-50 transition-opacity select-none", F, ke, Ee, Y, c, Te, le, a),
    t[9] = Te,
    t[10] = a,
    t[11] = c,
    t[12] = F,
    t[13] = ke,
    t[14] = Ee,
    t[15] = Y,
    t[16] = le,
    t[17] = Oe) : Oe = t[17];
    const ae = Ue === "horizontal" ? "flex gap-2" : void 0;
    let je;
    t[18] !== L || t[19] !== se ? (je = we("text-token-text-primary text-xs font-semibold whitespace-pre-wrap", se, L),
    t[18] = L,
    t[19] = se,
    t[20] = je) : je = t[20];
    let ot;
    t[21] !== o || t[22] !== je ? (ot = g.jsx("div", {
        className: je,
        children: o
    }),
    t[21] = o,
    t[22] = je,
    t[23] = ot) : ot = t[23];
    let St;
    t[24] !== i || t[25] !== se ? (St = i && g.jsx("div", {
        className: we("text-token-text-tertiary text-xs font-medium whitespace-pre-wrap", se),
        children: i
    }),
    t[24] = i,
    t[25] = se,
    t[26] = St) : St = t[26];
    let Tt;
    t[27] !== Te || t[28] !== oe || t[29] !== ge ? (Tt = ge && g.jsx(Jie, {
        asChild: !0,
        children: oe ? g.jsx(tae, {
            className: Te
        }) : g.jsx(eae, {
            className: Te
        })
    }),
    t[27] = Te,
    t[28] = oe,
    t[29] = ge,
    t[30] = Tt) : Tt = t[30];
    let wt;
    t[31] !== ae || t[32] !== ot || t[33] !== St || t[34] !== Tt ? (wt = g.jsxs("div", {
        className: ae,
        children: [ot, St, Tt]
    }),
    t[31] = ae,
    t[32] = ot,
    t[33] = St,
    t[34] = Tt,
    t[35] = wt) : wt = t[35];
    let ut;
    t[36] !== W || t[37] !== O ? (ut = O && g.jsx(ND, {
        role: "button",
        "aria-label": W.formatMessage(nae.dismissTooltip),
        tabIndex: 0,
        className: "icon -me-1 cursor-pointer text-gray-400",
        onClick: O
    }),
    t[36] = W,
    t[37] = O,
    t[38] = ut) : ut = t[38];
    let Mt;
    t[39] !== wt || t[40] !== ut ? (Mt = g.jsxs("div", {
        className: "flex items-center gap-1",
        children: [wt, ut]
    }),
    t[39] = wt,
    t[40] = ut,
    t[41] = Mt) : Mt = t[41];
    let fn;
    t[42] !== be || t[43] !== me || t[44] !== n || t[45] !== ye || t[46] !== Ie || t[47] !== G || t[48] !== Oe || t[49] !== Mt ? (fn = g.jsx(Zie, {
        onEscapeKeyDown: aae,
        collisionPadding: 8,
        onPointerDownOutside: G,
        "aria-live": n,
        side: ye,
        sideOffset: Ie,
        alignOffset: me,
        align: be,
        className: Oe,
        children: Mt
    }),
    t[42] = be,
    t[43] = me,
    t[44] = n,
    t[45] = ye,
    t[46] = Ie,
    t[47] = G,
    t[48] = Oe,
    t[49] = Mt,
    t[50] = fn) : fn = t[50];
    const Yt = fn
      , jt = !Z
      , gn = ve ? cae : void 0;
    let kn;
    t[51] !== N || t[52] !== x || t[53] !== w ? (kn = N ? g.jsx(rae, {
        as: N,
        className: w,
        children: x
    }) : x,
    t[51] = N,
    t[52] = x,
    t[53] = w,
    t[54] = kn) : kn = t[54];
    let On;
    t[55] !== gn || t[56] !== kn ? (On = g.jsx(Kie, {
        asChild: !0,
        ref: X,
        onClick: gn,
        children: kn
    }),
    t[55] = gn,
    t[56] = kn,
    t[57] = On) : On = t[57];
    let Ut;
    t[58] !== Yt || t[59] !== ne ? (Ut = ne ? g.jsx(Qie, {
        children: g.jsx(eT, {
            children: Yt
        })
    }) : g.jsx(eT, {
        children: Yt
    }),
    t[58] = Yt,
    t[59] = ne,
    t[60] = Ut) : Ut = t[60];
    let Os;
    return t[61] !== re || t[62] !== _e || t[63] !== A || t[64] !== k || t[65] !== jt || t[66] !== On || t[67] !== Ut ? (Os = g.jsxs(Wie, {
        delayDuration: _e,
        disableHoverableContent: jt,
        defaultOpen: re,
        open: k,
        onOpenChange: A,
        children: [On, Ut]
    }),
    t[61] = re,
    t[62] = _e,
    t[63] = A,
    t[64] = k,
    t[65] = jt,
    t[66] = On,
    t[67] = Ut,
    t[68] = Os) : Os = t[68],
    Os
}
;
function Qie(e) {
    "use forget";
    const t = De.c(3)
      , {children: n} = e
      , r = wj();
    let s;
    return t[0] !== n || t[1] !== r ? (s = g.jsx(Yie, {
        ...r,
        children: n
    }),
    t[0] = n,
    t[1] = r,
    t[2] = s) : s = t[2],
    s
}
const eae = ja.div`relative top-[-4px] h-2 w-2 rotate-45 transform shadow-xs dark:border-e dark:border-b border-white/10`
  , tae = ja.div`relative top-[-4px] end-[-135px] h-2 w-2 rotate-45 transform shadow-xs dark:border-e dark:border-b border-white/10`
  , nae = xt({
    dismissTooltip: {
        id: "Tooltip.dismissTooltip",
        defaultMessage: "Close Tooltip"
    }
})
  , rae = e => {
    "use forget";
    const t = De.c(15);
    let n, r, s;
    if (t[0] !== e ? ({as: n, children: r, ...s} = e,
    t[0] = e,
    t[1] = n,
    t[2] = r,
    t[3] = s) : (n = t[1],
    r = t[2],
    s = t[3]),
    !h.isValidElement(r)) {
        let l;
        return t[4] !== n || t[5] !== r || t[6] !== s ? (l = g.jsx(n, {
            ...s,
            children: r
        }),
        t[4] = n,
        t[5] = r,
        t[6] = s,
        t[7] = l) : l = t[7],
        l
    }
    const o = s["aria-describedby"];
    let i;
    t[8] !== r || t[9] !== o ? (i = g.jsx(HF, {
        "aria-describedby": o,
        children: r
    }),
    t[8] = r,
    t[9] = o,
    t[10] = i) : i = t[10];
    let a;
    return t[11] !== n || t[12] !== s || t[13] !== i ? (a = g.jsx(n, {
        ...s,
        onFocusCapture: s.onFocus,
        children: i
    }),
    t[11] = n,
    t[12] = s,
    t[13] = i,
    t[14] = a) : a = t[14],
    a
}
  , Hm = h.createContext(!1)
  , eT = e => {
    "use forget";
    const t = De.c(5)
      , {children: n} = e
      , s = h.use(Hm) && "sr-only!";
    let o;
    t[0] !== s ? (o = we(s),
    t[0] = s,
    t[1] = o) : o = t[1];
    let i;
    return t[2] !== n || t[3] !== o ? (i = g.jsx(HF, {
        className: o,
        children: n
    }),
    t[2] = n,
    t[3] = o,
    t[4] = i) : i = t[4],
    i
}
  , sae = ({children: e}) => g.jsx(Hm.Provider, {
    value: !1,
    children: e
})
  , oae = e => {
    "use forget";
    const t = De.c(6)
      , {children: n} = e
      , r = h.use(Hm)
      , [s,o] = h.useState(!1);
    let i;
    t[0] !== r || t[1] !== n ? (i = r ? n : h.cloneElement(n, {
        onOpenChange: d => {
            o(d),
            n.props.onOpenChange?.(d)
        }
    }),
    t[0] = r,
    t[1] = n,
    t[2] = i) : i = t[2];
    const a = i
      , l = n.props.open ?? s
      , c = r === !0 || l;
    let u;
    return t[3] !== a || t[4] !== c ? (u = g.jsx(Hm.Provider, {
        value: c,
        children: a
    }),
    t[3] = a,
    t[4] = c,
    t[5] = u) : u = t[5],
    u
}
;
function iae() {
    document.dispatchEvent(new KeyboardEvent("keydown",{
        key: "Escape",
        bubbles: !0
    }))
}
function aae(e) {
    e.preventDefault(),
    e.stopPropagation(),
    queueMicrotask(iae)
}
function lae(e) {
    return e.preventDefault()
}
function cae(e) {
    e.preventDefault()
}
var dh = (e => (e.General = "General",
e.Notifications = "Notifications",
e.Personalization = "Personalization",
e.Connectors = "Connectors",
e.DataControls = "DataControls",
e.Schedules = "Schedules",
e.Orders = "Orders",
e.Security = "Security",
e.Account = "Account",
e.Internal = "Internal",
e))(dh || {});
function uae(e) {
    return e.startsWith("#settings")
}
function fTe(e) {
    if (!uae(e))
        return null;
    const t = e.split("?")[0].split("/")[1];
    if (Object.values(dh).includes(t))
        return t;
    switch (t) {
    case "Subscription":
    case "BuilderProfile":
    case "Referrals":
        return "Account";
    case "ConnectorSettings":
        return "Connectors";
    case "SecureSignIn":
        return "Security";
    case "Record":
        return "Personalization"
    }
    return "General"
}
function hTe(e) {
    return {
        hash: e && e !== "General" ? `settings/${e}` : "settings"
    }
}
const pTe = e => g.jsx(ki, {
    as: Gse,
    fillContainer: !0,
    ...e
});
function mTe({value: e, children: t}) {
    return g.jsx(Vse, {
        className: "text-token-text-primary relative flex max-h-[calc(100vh-150px)] w-full flex-col overflow-y-auto px-4 text-sm md:min-h-[380px]",
        value: e,
        children: t
    })
}
const dae = ({title: e, description: t, learnMoreHref: n, children: r, noBorder: s=!1}) => {
    let o;
    return e && (o = g.jsx("div", {
        className: "truncate select-none",
        children: e
    }),
    n && (o = g.jsxs("div", {
        className: "touch:justify-between flex items-center gap-2",
        children: [o, g.jsx(ls, {
            label: g.jsx(de, {
                id: "WbGW2C",
                defaultMessage: "Learn more"
            }),
            contentClassName: "touch:hidden",
            side: "right",
            triggerAs: null,
            children: g.jsxs("a", {
                href: n,
                target: "_blank",
                rel: "noopener noreferrer",
                className: "text-token-text-tertiary not-touch:mt-0.5 flex shrink-0 items-center gap-1 text-sm",
                children: [g.jsx("span", {
                    className: "not-touch:hidden",
                    children: g.jsx(de, {
                        id: "WbGW2C",
                        defaultMessage: "Learn more"
                    })
                }), g.jsx(use, {
                    className: "icon-sm"
                })]
            })
        })]
    })),
    o = g.jsxs("h3", {
        className: we("min-h-header-height justify-center py-3 text-lg font-normal", !s && "border-token-border-default border-b"),
        children: [o, t && g.jsx("div", {
            className: "text-token-text-tertiary mt-0.5 text-xs",
            children: t
        })]
    })),
    g.jsxs("section", {
        className: "relative mb-4 not-has-[>div]:hidden",
        children: [o, r]
    })
}
;
function fae({children: e}) {
    return g.jsx("div", {
        className: "border-token-border-light flex min-h-15 items-center border-b py-2 last-of-type:border-none",
        children: g.jsx("div", {
            className: "w-full",
            children: e
        })
    })
}
const x5 = ja.div`text-xs text-token-text-tertiary pe-15 my-1`;
function gTe({label: e, disabled: t, enabled: n, onChange: r, description: s, toggleTooltip: o, isLoading: i=!1, testId: a, compactDescription: l=!1, centerToggleVertically: c=!1, showAlphaPill: u=!1, ariaLabel: d}) {
    const f = typeof e == "string" ? e : d
      , p = f ? {
        "aria-label": f
    } : {
        "aria-hidden": !0
    }
      , m = g.jsx(_F, {
        disabled: t,
        checked: n,
        onCheckedChange: r,
        size: "normal",
        "data-testid": a,
        ...p
    })
      , v = o ? g.jsx(ls, {
        label: o,
        side: "top",
        children: m
    }) : m;
    return c ? g.jsxs("div", {
        className: "flex justify-between gap-2",
        children: [g.jsxs("div", {
            className: "flex flex-col",
            children: [g.jsxs("div", {
                className: "flex items-center gap-2",
                children: [e, u && g.jsx(Hx, {})]
            }), s != null && g.jsx(x5, {
                className: l ? "mt-0.5" : void 0,
                children: s
            })]
        }), g.jsx("div", {
            className: "flex items-center",
            children: i ? g.jsx(vf, {}) : v
        })]
    }) : g.jsxs(g.Fragment, {
        children: [g.jsxs("div", {
            className: "flex items-center justify-between gap-2",
            children: [g.jsxs("div", {
                className: "flex items-center gap-2",
                children: [e, u && g.jsx(Hx, {})]
            }), i ? g.jsx(vf, {}) : v]
        }), s != null && g.jsx(x5, {
            className: l ? "mt-0.5" : void 0,
            children: s
        })]
    })
}
function vTe({color: e="secondary", disabled: t, label: n, buttonLabel: r, onClick: s, description: o, testId: i}) {
    const a = o ? "items-start" : "items-center";
    return g.jsxs("div", {
        className: we("flex", a, "justify-between"),
        children: [g.jsxs("div", {
            children: [g.jsx("div", {
                children: n
            }), o != null && g.jsx(x5, {
                children: o
            })]
        }), g.jsx(an, {
            className: "shrink-0",
            color: e,
            disabled: !!t,
            onClick: s,
            "data-testid": i,
            children: r
        })]
    })
}
function _Te({onClick: e, label: t, stateLabel: n, testId: r}) {
    return g.jsx("button", {
        className: "w-full",
        onClick: e,
        "data-testid": r,
        children: g.jsxs("div", {
            className: "flex items-center justify-between",
            children: [g.jsx("div", {
                children: t
            }), g.jsxs("div", {
                className: "text-token-text-secondary flex min-h-[38px] items-center",
                children: [n && g.jsx("div", {
                    className: "me-1 flex items-center",
                    children: n
                }), g.jsx(uF, {
                    className: "icon-sm"
                })]
            })]
        })
    })
}
function yTe(e) {
    return ie.safeDelete("/aip/connectors/{connector_id}", {
        parameters: {
            path: {
                connector_id: e
            }
        }
    })
}
function hae(e) {
    "use forget";
    const t = De.c(108);
    let n, r, s, o, i, a, l, c, u, d, f, p, m, v, _, y, b, S, C, w, x, E, T, k, A, O, M, I, R, D, P, L;
    t[0] !== e ? ({name: v, placeholder: T, type: P, role: A, list: p, ariaLabel: r, displayName: u, onChange: y, onFocus: b, onBlur: _, value: L, saveOnBlur: O, icon: n, iconPosition: I, onInputIconClick: S, className: a, inputClassName: d, containerInputClassName: l, autoComplete: o, autoCapitalize: s, spellCheck: M, autoFocus: i, onPressEnter: x, onPaste: w, disabled: c, maxLength: m, color: R, onKeyDown: C, suppressFocus: D, ref: k, insideContainerChildren: f, ...E} = e,
    t[0] = e,
    t[1] = n,
    t[2] = r,
    t[3] = s,
    t[4] = o,
    t[5] = i,
    t[6] = a,
    t[7] = l,
    t[8] = c,
    t[9] = u,
    t[10] = d,
    t[11] = f,
    t[12] = p,
    t[13] = m,
    t[14] = v,
    t[15] = _,
    t[16] = y,
    t[17] = b,
    t[18] = S,
    t[19] = C,
    t[20] = w,
    t[21] = x,
    t[22] = E,
    t[23] = T,
    t[24] = k,
    t[25] = A,
    t[26] = O,
    t[27] = M,
    t[28] = I,
    t[29] = R,
    t[30] = D,
    t[31] = P,
    t[32] = L) : (n = t[1],
    r = t[2],
    s = t[3],
    o = t[4],
    i = t[5],
    a = t[6],
    l = t[7],
    c = t[8],
    u = t[9],
    d = t[10],
    f = t[11],
    p = t[12],
    m = t[13],
    v = t[14],
    _ = t[15],
    y = t[16],
    b = t[17],
    S = t[18],
    C = t[19],
    w = t[20],
    x = t[21],
    E = t[22],
    T = t[23],
    k = t[24],
    A = t[25],
    O = t[26],
    M = t[27],
    I = t[28],
    R = t[29],
    D = t[30],
    P = t[31],
    L = t[32]);
    const N = I === void 0 ? "right" : I
      , B = R === void 0 ? "tertiary" : R
      , H = D === void 0 ? !1 : D
      , [ye,Ie] = h.useState(L);
    let be;
    t[33] !== _ || t[34] !== O ? (be = ut => {
        _?.(ut),
        O && Ie(ut.target.value)
    }
    ,
    t[33] = _,
    t[34] = O,
    t[35] = be) : be = t[35];
    const me = be;
    let ge;
    t[36] !== y || t[37] !== O ? (ge = ut => {
        y?.(ut),
        O && Ie(ut.target.value)
    }
    ,
    t[36] = y,
    t[37] = O,
    t[38] = ge) : ge = t[38];
    const ce = ge;
    let Z;
    t[39] !== ye || t[40] !== C || t[41] !== x ? (Z = ut => {
        C?.(ut),
        !ut.nativeEvent.isComposing && ut.key === "Enter" && x && (ut.preventDefault(),
        x(ye, ut))
    }
    ,
    t[39] = ye,
    t[40] = C,
    t[41] = x,
    t[42] = Z) : Z = t[42];
    const ne = Z;
    let _e, ee;
    t[43] !== L ? (_e = () => {
        Ie(L)
    }
    ,
    ee = [L],
    t[43] = L,
    t[44] = _e,
    t[45] = ee) : (_e = t[44],
    ee = t[45]),
    h.useEffect(_e, ee);
    let oe;
    t[46] !== O || t[47] !== L ? (oe = O ? {} : {
        value: L
    },
    t[46] = O,
    t[47] = L,
    t[48] = oe) : oe = t[48];
    let te;
    t[49] !== ye || t[50] !== O ? (te = O ? {
        value: ye
    } : {},
    t[49] = ye,
    t[50] = O,
    t[51] = te) : te = t[51];
    let ve;
    t[52] !== te || t[53] !== oe ? (ve = {
        ...oe,
        ...te
    },
    t[52] = te,
    t[53] = oe,
    t[54] = ve) : ve = t[54];
    const Ue = ve
      , re = B === "neutral" && (H ? "-main-surface-tertiary hover:bg-token-main-surface-tertiary border-transparent px-3 py-2" : "focus-within:bg-token-main-surface-tertiary hover:bg-token-main-surface-tertiary border-transparent px-3 py-2 focus-within:border-green-500 focus-within:ring-1 focus-within:ring-transparent")
      , W = B === "tertiary" && (H ? "border-token-border-medium px-3 py-2" : "border-token-border-medium focus-within:border-token-border-xheavy focus-within:ring-token-text-secondary px-3 py-2 focus-within:ring-1")
      , X = B === "search" && (H ? "border-token-border-medium bg-token-main-surface-primary dark:border-token-border-medium rounded-xl p-4" : "border-token-border-medium bg-token-main-surface-primary focus-within:border-token-border-xheavy dark:border-token-border-medium dark:focus-within:border-token-border-xheavy rounded-xl p-4 focus-within:ring-0 dark:focus-within:ring-0")
      , Te = B === "quaternary" && (H ? "border-token-main-surface-quaternary text-token-text-quaternary px-3 py-2" : "border-token-main-surface-quaternary text-token-text-quaternary focus-within:border-token-border-xheavy focus-within:ring-token-text-secondary px-3 py-2 focus-within:ring-1");
    let se;
    t[55] !== a || t[56] !== re || t[57] !== W || t[58] !== X || t[59] !== Te ? (se = we("rounded-md border shadow-none", re, W, X, Te, a),
    t[55] = a,
    t[56] = re,
    t[57] = W,
    t[58] = X,
    t[59] = Te,
    t[60] = se) : se = t[60];
    let G;
    t[61] !== u || t[62] !== v ? (G = g.jsx("label", {
        htmlFor: v,
        className: "text-token-text-primary block text-xs font-semibold",
        children: u
    }),
    t[61] = u,
    t[62] = v,
    t[63] = G) : G = t[63];
    const F = u && "mt-1";
    let ke;
    t[64] !== l || t[65] !== F ? (ke = we(F, "relative", l),
    t[64] = l,
    t[65] = F,
    t[66] = ke) : ke = t[66];
    const Ee = r || void 0
      , Y = n != null && N === "right" && "pe-6"
      , le = n != null && N === "left" && "ps-6"
      , Oe = B === "neutral" || B === "search" ? "bg-transparent" : "bg-token-main-surface-primary text-token-text-primary"
      , ae = B === "quaternary" ? "placeholder:text-token-text-quaternary" : "placeholder-gray-500";
    let je;
    t[67] !== d || t[68] !== Y || t[69] !== le || t[70] !== Oe || t[71] !== ae ? (je = we("block w-full border-0 p-0 shadow-none outline-hidden focus-within:shadow-none focus-within:ring-0 focus-within:outline-hidden focus:border-none focus:ring-0 sm:text-sm", Y, le, Oe, ae, d),
    t[67] = d,
    t[68] = Y,
    t[69] = le,
    t[70] = Oe,
    t[71] = ae,
    t[72] = je) : je = t[72];
    let ot;
    t[73] !== Ue || t[74] !== s || t[75] !== o || t[76] !== i || t[77] !== c || t[78] !== me || t[79] !== ce || t[80] !== ne || t[81] !== p || t[82] !== m || t[83] !== v || t[84] !== b || t[85] !== w || t[86] !== E || t[87] !== T || t[88] !== k || t[89] !== A || t[90] !== M || t[91] !== Ee || t[92] !== je || t[93] !== P ? (ot = g.jsx("input", {
        ...E,
        ref: k,
        type: P,
        name: v,
        id: v,
        list: p,
        role: A,
        "aria-label": Ee,
        onPaste: w,
        className: je,
        placeholder: T,
        onBlur: me,
        onFocus: b,
        onChange: ce,
        onKeyDown: ne,
        autoComplete: o,
        spellCheck: M,
        autoCapitalize: s,
        autoFocus: i,
        disabled: c,
        maxLength: m,
        ...Ue
    }),
    t[73] = Ue,
    t[74] = s,
    t[75] = o,
    t[76] = i,
    t[77] = c,
    t[78] = me,
    t[79] = ce,
    t[80] = ne,
    t[81] = p,
    t[82] = m,
    t[83] = v,
    t[84] = b,
    t[85] = w,
    t[86] = E,
    t[87] = T,
    t[88] = k,
    t[89] = A,
    t[90] = M,
    t[91] = Ee,
    t[92] = je,
    t[93] = P,
    t[94] = ot) : ot = t[94];
    let St;
    t[95] !== n || t[96] !== N || t[97] !== S ? (St = n != null && g.jsx("button", {
        className: we("absolute top-1/2 -translate-y-1/2", {
            "end-0": N === "right",
            "start-0": N === "left"
        }),
        onClick: S,
        children: g.jsx(n, {
            className: "icon-sm"
        })
    }),
    t[95] = n,
    t[96] = N,
    t[97] = S,
    t[98] = St) : St = t[98];
    let Tt;
    t[99] !== f || t[100] !== ke || t[101] !== ot || t[102] !== St ? (Tt = g.jsxs("div", {
        className: ke,
        children: [ot, St, f]
    }),
    t[99] = f,
    t[100] = ke,
    t[101] = ot,
    t[102] = St,
    t[103] = Tt) : Tt = t[103];
    let wt;
    return t[104] !== se || t[105] !== G || t[106] !== Tt ? (wt = g.jsxs("div", {
        className: se,
        children: [G, Tt]
    }),
    t[104] = se,
    t[105] = G,
    t[106] = Tt,
    t[107] = wt) : wt = t[107],
    wt
}
function Ej(e) {
    return g.jsxs("div", {
        className: "relative w-full",
        children: [g.jsx(hae, {
            ...e,
            className: we(e.className, e.error && "border-red-500!")
        }), g.jsx("p", {
            className: "mt-1 flex items-center text-xs text-red-500",
            children: e.error
        })]
    })
}
var pae = {};
async function xj(e) {
    return ie.safePost("/accounts/add_email/begin", {
        requestBody: {
            email: e,
            auth0_client_id: pae.AUTH0_CLIENT_ID
        },
        authOption: Qt.Required
    })
}
const ts = xt({
    sendEmailFailure: {
        id: "emailVerify.sendEmailFailure",
        defaultMessage: "Could not send email verification code, please try again later."
    },
    sendEmailFailureInvalidEmail: {
        id: "emailVerify.invalidEmail",
        defaultMessage: 'The email address "{email}" is not formatted correctly.'
    },
    sendEmailFailureInvalidEmailEmpty: {
        id: "emailVerify.invalidEmailEmpty",
        defaultMessage: "Please enter a valid email address to continue."
    },
    sendEmailFailureRateLimited: {
        id: "emailVerify.sendEmailFailure.rateLimited",
        defaultMessage: "You've sent too many requests. Please try again later."
    },
    verifyOtpFailure: {
        id: "emailVerify.verifyOtpFailure",
        defaultMessage: "Something went wrong, please try again later."
    },
    verifyOtpFailureInvalidOtp: {
        id: "emailVerify.verifyOtpFailure.invalidOtp",
        defaultMessage: "The code you entered is invalid. Please try again."
    },
    verifyOtpFailureInvalidFormat: {
        id: "emailVerify.verifyOtpFailure.invalidFormat",
        defaultMessage: "The code you entered is formatted incorrectly."
    },
    verifyOtpFailureEmailAlreadyLinked: {
        id: "emailVerify.verifyOtpFailure.emailAlreadyLinked",
        defaultMessage: '{branch, select, email {"{emailValue}"} other {Your email}} is already linked to another account.'
    },
    verifyOtpFailureRateLimited: {
        id: "emailVerify.verifyOtpFailure.rateLimited",
        defaultMessage: "You've sent too many requests. Please try again later."
    },
    verifyOtpSuccess: {
        id: "emailVerify.verifyOtpSuccess",
        defaultMessage: "Email confirmed."
    }
});
class tT extends Error {
    constructor(t) {
        super(t),
        this.name = "EmailValidationError"
    }
}
const mae = (e, t) => t.trim() === "" ? e.formatMessage(ts.sendEmailFailureInvalidEmailEmpty) : /^(([^<>()[\]\\.,;:\s@"]+(\.[^<>()[\]\\.,;:\s@"]+)*)|.(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/.test(t) ? null : e.formatMessage(ts.sendEmailFailureInvalidEmail, {
    email: t
})
  , Tj = (e, t, n) => {
    switch (n.status) {
    case 429:
        throw new Error(e.formatMessage(ts.sendEmailFailureRateLimited));
    case 403:
        throw new Error(e.formatMessage(ts.verifyOtpFailureEmailAlreadyLinked, {
            branch: t ? "email" : "other",
            emailValue: t
        }));
    default:
        return
    }
}
;
function gae(e) {
    const t = gt()
      , [n,r] = h.useState(null)
      , s = nr({
        mutationFn: async o => {
            try {
                const i = mae(t, o);
                if (i)
                    throw new tT(i);
                return await xj(o)
            } catch (i) {
                throw i instanceof tT ? i : (i instanceof _t && Tj(t, o, i),
                new Error(t.formatMessage(ts.sendEmailFailure)))
            }
        }
        ,
        onSuccess: () => {
            e.setStep("verifyOtp")
        }
        ,
        onError: o => {
            r(o.message),
            V.logEventWithStatsig("Email Verify Enter Email Step - Error Sending Verification Email", "chatgpt_email_verify_enter_email_step_error", {
                error: o.message
            })
        }
    });
    return h.useEffect( () => {
        V.logEventWithStatsig("Email Verify Enter Email Step - Shown", "chatgpt_email_verify_enter_email_step_shown")
    }
    , []),
    g.jsx("form", {
        onSubmit: o => {
            o.preventDefault(),
            s.mutate(e.email),
            V.logEventWithStatsig("Email Verify Enter Email Step - Attempted Continue", "chatgpt_email_verify_enter_email_step_continue")
        }
        ,
        noValidate: !0,
        children: g.jsxs("div", {
            className: "flex w-full flex-col items-center gap-3",
            children: [g.jsx("p", {
                className: "text-3xl font-semibold",
                children: e.title ? e.title : g.jsx(de, {
                    id: "emailVerify.enterEmailTitle",
                    defaultMessage: "Add your email"
                })
            }), e.description && g.jsx("p", {
                className: "text-token-text-primary text-center text-base",
                children: e.description
            }), g.jsx(Ej, {
                ariaLabel: t.formatMessage({
                    id: "emailVerify.emailAddress",
                    defaultMessage: "Email Address"
                }),
                placeholder: t.formatMessage({
                    id: "emailVerify.emailAddressPlaceholder",
                    defaultMessage: "Email Address"
                }),
                name: "email",
                type: "email",
                className: "mt-6 w-full",
                value: e.email,
                onChange: o => {
                    r(null),
                    e.onEmailChange?.(o.target.value),
                    V.logEventWithStatsig("Email Verify Enter Email Step - Typed", "chatgpt_email_verify_enter_email_step_type")
                }
                ,
                autoFocus: !0,
                autoComplete: "email",
                error: n ?? void 0
            }), g.jsx(an, {
                className: "w-full rounded-md",
                color: "green",
                type: "submit",
                loading: s.isPending,
                disabled: s.isPending,
                children: g.jsx(de, {
                    id: "emailVerify.continue",
                    defaultMessage: "Continue"
                })
            }), e.cancelFlowButton]
        })
    })
}
function vae(e) {
    "use forget";
    const {children: t, fallback: n} = e
      , r = n === void 0 ? null : n;
    return Vg() ? t : r
}
const nT = e => h.createElement("svg", {
    width: 20,
    height: 20,
    viewBox: "0 0 20 20",
    fill: "currentColor",
    xmlns: "http://www.w3.org/2000/svg",
    ...e
}, h.createElement("path", {
    d: "M12.498 6.90887C12.7094 6.60867 13.1245 6.53642 13.4248 6.74774C13.7249 6.95913 13.7971 7.37424 13.5859 7.6745L9.62695 13.2995C9.51084 13.4644 9.32628 13.5681 9.125 13.5807C8.94863 13.5918 8.77583 13.5319 8.64453 13.4167L8.59082 13.364L6.50781 11.072L6.42773 10.9645C6.26956 10.6986 6.31486 10.3488 6.55273 10.1325C6.79045 9.91663 7.14198 9.9053 7.3916 10.0876L7.49219 10.1774L9.0166 11.8542L12.498 6.90887Z"
}), h.createElement("path", {
    fillRule: "evenodd",
    clipRule: "evenodd",
    d: "M10.3333 2.08496C14.7046 2.08496 18.2483 5.62867 18.2483 10C18.2483 14.3713 14.7046 17.915 10.3333 17.915C5.96192 17.915 2.41821 14.3713 2.41821 10C2.41821 5.62867 5.96192 2.08496 10.3333 2.08496ZM10.3333 3.41504C6.69646 3.41504 3.74829 6.3632 3.74829 10C3.74829 13.6368 6.69646 16.585 10.3333 16.585C13.97 16.585 16.9182 13.6368 16.9182 10C16.9182 6.3632 13.97 3.41504 10.3333 3.41504Z"
}))
  , Pu = e => h.createElement("svg", {
    width: 20,
    height: 20,
    viewBox: "0 0 20 20",
    fill: "currentColor",
    xmlns: "http://www.w3.org/2000/svg",
    ...e
}, h.createElement("path", {
    d: "M10.0002 12.189C10.5523 12.1891 11 12.6369 11.0002 13.189C11.0002 13.7412 10.5524 14.1889 10.0002 14.189C9.44791 14.189 9.00019 13.7413 9.00019 13.189C9.00035 12.6368 9.44801 12.189 10.0002 12.189Z"
}), h.createElement("path", {
    d: "M10.0002 7.02394C10.3673 7.02405 10.6651 7.32191 10.6652 7.68898V10.356C10.6651 10.723 10.3673 11.0209 10.0002 11.021C9.63303 11.021 9.33532 10.7231 9.33515 10.356V7.68898C9.33531 7.32184 9.63302 7.02394 10.0002 7.02394Z"
}), h.createElement("path", {
    d: "M7.76484 3.14894C8.89036 1.56557 11.3015 1.61886 12.341 3.30812L18.6125 13.4995C19.7387 15.3305 18.4214 17.6879 16.2717 17.688H3.72871C1.57877 17.688 0.261434 15.3306 1.38789 13.4995L7.65937 3.30812L7.76484 3.14894ZM11.2082 4.00441C10.689 3.1609 9.50658 3.10813 8.90449 3.84621L8.79219 4.00441L2.5207 14.1958C1.93937 15.1408 2.61919 16.3579 3.72871 16.3579H16.2717C17.381 16.3578 18.0608 15.1407 17.4797 14.1958L11.2082 4.00441Z"
}))
  , bTe = "https://help.openai.com/en/collections/3943089-billing"
  , CTe = "https://openai.com/chatgpt/enterprise"
  , STe = "https://help.openai.com/en/articles/7905690-how-do-i-cancel-my-apple-subscription-for-chatgpt-plus-in-the-chatgpt-ios-app"
  , wTe = "https://help.openai.com/en/articles/8258076-how-to-cancel-my-plus-subscription-in-the-chatgpt-android-app"
  , ETe = "https://help.openai.com/en/articles/7864572-what-is-the-chatgpt-model-selector"
  , xTe = "https://help.openai.com/en/articles/11989085-chatgpt-go"
  , kj = "pricing"
  , Nw = "team-pricing"
  , TTe = "plus-pricing"
  , _ae = "team-pricing-direct"
  , Oj = "account-payment-modal-open-from-location"
  , kTe = {
    MOBILE_IOS: "chatgpt_mobile_ios",
    MOBILE_ANDROID: "chatgpt_mobile_android"
};
function OTe(e) {
    return e.hash.split("#")[1] === kj
}
function ATe(e) {
    return e.hash.split("#")[1] === Nw
}
function MTe(e) {
    return e.hash.split("#")[1] === _ae
}
function Pw(e, t, n=kj) {
    e({
        hash: n,
        search: window.location.search
    }, {
        state: {
            [Oj]: t
        }
    })
}
function ITe(e) {
    e({
        hash: ""
    })
}
function RTe() {
    return li.upgradeToGo
}
function yae(e) {
    switch ($t(e, "2788179050").get("plus_upsell_cta_copy", "get_plus")) {
    case "upgrade_to_plan":
        return li.upgradeToPlus;
    case "upgrade_your_plan":
        return li.upgradeYourPlan;
    case "upgrade":
        return li.upgrade;
    case "get_plus":
    default:
        return li.getPlus
    }
}
function NTe(e) {
    switch ($t(e, "2788179050").get("pro_upsell_cta_copy", "get_pro")) {
    case "upgrade_to_plan":
        return li.upgradeToPro;
    case "upgrade_your_plan":
        return li.upgradeYourPlan;
    case "upgrade":
        return li.upgrade;
    case "get_pro":
    default:
        return li.getPro
    }
}
function bae(e) {
    return Xe(e, "3600660324")
}
function rT() {
    return rT = Object.assign ? Object.assign.bind() : function(e) {
        for (var t = 1; t < arguments.length; t++) {
            var n = arguments[t];
            for (var r in n)
                ({}).hasOwnProperty.call(n, r) && (e[r] = n[r])
        }
        return e
    }
    ,
    rT.apply(null, arguments)
}
function Cae(e, t) {
    if (e == null)
        return {};
    var n = {};
    for (var r in e)
        if ({}.hasOwnProperty.call(e, r)) {
            if (t.indexOf(r) >= 0)
                continue;
            n[r] = e[r]
        }
    return n
}
function T5(e, t) {
    return T5 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(n, r) {
        return n.__proto__ = r,
        n
    }
    ,
    T5(e, t)
}
function Sae(e, t) {
    e.prototype = Object.create(t.prototype),
    e.prototype.constructor = e,
    T5(e, t)
}
var ay = {
    exports: {}
}, ly, sT;
function wae() {
    if (sT)
        return ly;
    sT = 1;
    var e = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
    return ly = e,
    ly
}
var cy, oT;
function Eae() {
    if (oT)
        return cy;
    oT = 1;
    var e = wae();
    function t() {}
    function n() {}
    return n.resetWarningCache = t,
    cy = function() {
        function r(i, a, l, c, u, d) {
            if (d !== e) {
                var f = new Error("Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types");
                throw f.name = "Invariant Violation",
                f
            }
        }
        r.isRequired = r;
        function s() {
            return r
        }
        var o = {
            array: r,
            bigint: r,
            bool: r,
            func: r,
            number: r,
            object: r,
            string: r,
            symbol: r,
            any: r,
            arrayOf: s,
            element: r,
            elementType: r,
            instanceOf: s,
            node: r,
            objectOf: s,
            oneOf: s,
            oneOfType: s,
            shape: s,
            exact: s,
            checkPropTypes: n,
            resetWarningCache: t
        };
        return o.PropTypes = o,
        o
    }
    ,
    cy
}
var iT;
function xae() {
    return iT || (iT = 1,
    ay.exports = Eae()()),
    ay.exports
}
var Tae = xae();
const PTe = mn(Tae)
  , aT = {
    disabled: !1
}
  , Aj = Ne.createContext(null);
var kae = function(t) {
    return t.scrollTop
}
  , jd = "unmounted"
  , ol = "exited"
  , il = "entering"
  , Hc = "entered"
  , k5 = "exiting"
  , Oi = function(e) {
    Sae(t, e);
    function t(r, s) {
        var o;
        o = e.call(this, r, s) || this;
        var i = s, a = i && !i.isMounting ? r.enter : r.appear, l;
        return o.appearStatus = null,
        r.in ? a ? (l = ol,
        o.appearStatus = il) : l = Hc : r.unmountOnExit || r.mountOnEnter ? l = jd : l = ol,
        o.state = {
            status: l
        },
        o.nextCallback = null,
        o
    }
    t.getDerivedStateFromProps = function(s, o) {
        var i = s.in;
        return i && o.status === jd ? {
            status: ol
        } : null
    }
    ;
    var n = t.prototype;
    return n.componentDidMount = function() {
        this.updateStatus(!0, this.appearStatus)
    }
    ,
    n.componentDidUpdate = function(s) {
        var o = null;
        if (s !== this.props) {
            var i = this.state.status;
            this.props.in ? i !== il && i !== Hc && (o = il) : (i === il || i === Hc) && (o = k5)
        }
        this.updateStatus(!1, o)
    }
    ,
    n.componentWillUnmount = function() {
        this.cancelNextCallback()
    }
    ,
    n.getTimeouts = function() {
        var s = this.props.timeout, o, i, a;
        return o = i = a = s,
        s != null && typeof s != "number" && (o = s.exit,
        i = s.enter,
        a = s.appear !== void 0 ? s.appear : i),
        {
            exit: o,
            enter: i,
            appear: a
        }
    }
    ,
    n.updateStatus = function(s, o) {
        if (s === void 0 && (s = !1),
        o !== null)
            if (this.cancelNextCallback(),
            o === il) {
                if (this.props.unmountOnExit || this.props.mountOnEnter) {
                    var i = this.props.nodeRef ? this.props.nodeRef.current : fl.findDOMNode(this);
                    i && kae(i)
                }
                this.performEnter(s)
            } else
                this.performExit();
        else
            this.props.unmountOnExit && this.state.status === ol && this.setState({
                status: jd
            })
    }
    ,
    n.performEnter = function(s) {
        var o = this
          , i = this.props.enter
          , a = this.context ? this.context.isMounting : s
          , l = this.props.nodeRef ? [a] : [fl.findDOMNode(this), a]
          , c = l[0]
          , u = l[1]
          , d = this.getTimeouts()
          , f = a ? d.appear : d.enter;
        if (!s && !i || aT.disabled) {
            this.safeSetState({
                status: Hc
            }, function() {
                o.props.onEntered(c)
            });
            return
        }
        this.props.onEnter(c, u),
        this.safeSetState({
            status: il
        }, function() {
            o.props.onEntering(c, u),
            o.onTransitionEnd(f, function() {
                o.safeSetState({
                    status: Hc
                }, function() {
                    o.props.onEntered(c, u)
                })
            })
        })
    }
    ,
    n.performExit = function() {
        var s = this
          , o = this.props.exit
          , i = this.getTimeouts()
          , a = this.props.nodeRef ? void 0 : fl.findDOMNode(this);
        if (!o || aT.disabled) {
            this.safeSetState({
                status: ol
            }, function() {
                s.props.onExited(a)
            });
            return
        }
        this.props.onExit(a),
        this.safeSetState({
            status: k5
        }, function() {
            s.props.onExiting(a),
            s.onTransitionEnd(i.exit, function() {
                s.safeSetState({
                    status: ol
                }, function() {
                    s.props.onExited(a)
                })
            })
        })
    }
    ,
    n.cancelNextCallback = function() {
        this.nextCallback !== null && (this.nextCallback.cancel(),
        this.nextCallback = null)
    }
    ,
    n.safeSetState = function(s, o) {
        o = this.setNextCallback(o),
        this.setState(s, o)
    }
    ,
    n.setNextCallback = function(s) {
        var o = this
          , i = !0;
        return this.nextCallback = function(a) {
            i && (i = !1,
            o.nextCallback = null,
            s(a))
        }
        ,
        this.nextCallback.cancel = function() {
            i = !1
        }
        ,
        this.nextCallback
    }
    ,
    n.onTransitionEnd = function(s, o) {
        this.setNextCallback(o);
        var i = this.props.nodeRef ? this.props.nodeRef.current : fl.findDOMNode(this)
          , a = s == null && !this.props.addEndListener;
        if (!i || a) {
            setTimeout(this.nextCallback, 0);
            return
        }
        if (this.props.addEndListener) {
            var l = this.props.nodeRef ? [this.nextCallback] : [i, this.nextCallback]
              , c = l[0]
              , u = l[1];
            this.props.addEndListener(c, u)
        }
        s != null && setTimeout(this.nextCallback, s)
    }
    ,
    n.render = function() {
        var s = this.state.status;
        if (s === jd)
            return null;
        var o = this.props
          , i = o.children;
        o.in,
        o.mountOnEnter,
        o.unmountOnExit,
        o.appear,
        o.enter,
        o.exit,
        o.timeout,
        o.addEndListener,
        o.onEnter,
        o.onEntering,
        o.onEntered,
        o.onExit,
        o.onExiting,
        o.onExited,
        o.nodeRef;
        var a = Cae(o, ["children", "in", "mountOnEnter", "unmountOnExit", "appear", "enter", "exit", "timeout", "addEndListener", "onEnter", "onEntering", "onEntered", "onExit", "onExiting", "onExited", "nodeRef"]);
        return Ne.createElement(Aj.Provider, {
            value: null
        }, typeof i == "function" ? i(s, a) : Ne.cloneElement(Ne.Children.only(i), a))
    }
    ,
    t
}(Ne.Component);
Oi.contextType = Aj;
Oi.propTypes = {};
function Mc() {}
Oi.defaultProps = {
    in: !1,
    mountOnEnter: !1,
    unmountOnExit: !1,
    appear: !1,
    enter: !0,
    exit: !0,
    onEnter: Mc,
    onEntering: Mc,
    onEntered: Mc,
    onExit: Mc,
    onExiting: Mc,
    onExited: Mc
};
Oi.UNMOUNTED = jd;
Oi.EXITED = ol;
Oi.ENTERING = il;
Oi.ENTERED = Hc;
Oi.EXITING = k5;
function DTe(e) {
    if (e === void 0)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e
}
function Oae(e) {
    const t = h.useRef(null);
    return h.useInsertionEffect( () => {
        t.current = e
    }
    , [e]),
    h.useCallback( (...n) => {
        const r = t.current;
        return r(...n)
    }
    , [])
}
const Aae = e => h.createElement("svg", {
    width: 16,
    height: 16,
    viewBox: "0 0 16 16",
    fill: "currentColor",
    xmlns: "http://www.w3.org/2000/svg",
    ...e
}, h.createElement("path", {
    d: "M11.1152 3.91503C11.3868 3.73594 11.756 3.7658 11.9951 4.00488C12.2341 4.24395 12.264 4.61309 12.0849 4.88476L11.9951 4.99511L8.99018 7.99999L11.9951 11.0049L12.0849 11.1152C12.264 11.3869 12.2341 11.756 11.9951 11.9951C11.756 12.2342 11.3868 12.2641 11.1152 12.085L11.0048 11.9951L7.99995 8.99023L4.99506 11.9951C4.7217 12.2685 4.2782 12.2685 4.00483 11.9951C3.73146 11.7217 3.73146 11.2782 4.00483 11.0049L7.00971 7.99999L4.00483 4.99511L3.91499 4.88476C3.73589 4.61309 3.76575 4.24395 4.00483 4.00488C4.24391 3.7658 4.61305 3.73594 4.88471 3.91503L4.99506 4.00488L7.99995 7.00976L11.0048 4.00488L11.1152 3.91503Z"
}));
var _n = (e => (e.info = "info",
e.neutral = "neutral",
e.success = "success",
e.successNeutral = "successNeutral",
e.warning = "warning",
e.danger = "danger",
e))(_n || {});
const Mae = xt({
    closeButtonLabel: {
        id: "Alert.closeButtonLabel",
        defaultMessage: "Close"
    }
})
  , Iae = Ne.memo(function(t) {
    const n = gt()
      , {className: r, intent: s="info", fullWidth: o, children: i, icon: a, onRemove: l, testId: c} = t
      , u = we({
        "px-3 py-2 rounded-lg inline-flex flex-row border pointer-events-auto gap-2": !0,
        flex: o,
        "popover shadow-lg bg-token-main-surface-primary text-token-text-secondary dark:border-black/20": s === _n.neutral || s === _n.info,
        "border-green-600 bg-green-600 text-white": s === _n.success,
        "border-orange-500 text-white bg-orange-500": s === _n.warning,
        "border-red-500 text-white bg-red-500": s === _n.danger,
        "bg-black text-white border-black dark:bg-white dark:text-black dark:border-white": s === _n.successNeutral
    }, r);
    return g.jsxs("div", {
        className: u,
        role: "alert",
        "data-testid": c,
        children: [a != null && g.jsx("div", {
            className: "mt-1 shrink-0 grow-0",
            children: g.jsx(a, {
                className: "icon-sm"
            })
        }), g.jsx("div", {
            className: "flex-1 justify-center gap-2",
            children: typeof i == "string" ? g.jsx("div", {
                className: "font-semibold",
                children: i
            }) : i
        }), l ? g.jsx("div", {
            className: "flex shrink-0 grow-0",
            children: g.jsx("button", {
                onClick: l,
                "aria-label": n.formatMessage(Mae.closeButtonLabel),
                className: "hover:opacity-80",
                children: g.jsx(Aae, {
                    className: "icon-sm"
                })
            })
        }) : null]
    })
})
  , Rae = {
    liveRegionAssertive: "",
    liveRegionPolite: ""
}
  , pp = dn()( () => ({
    ...Rae
}));
let uy, dy;
const Nae = {
    setLiveRegionAssertive: e => {
        window.clearTimeout(uy),
        pp.setState({
            liveRegionAssertive: e
        }),
        uy = window.setTimeout( () => {
            pp.setState({
                liveRegionAssertive: ""
            }),
            uy = void 0
        }
        , 5e3)
    }
    ,
    setLiveRegionPolite: e => {
        window.clearTimeout(dy),
        pp.setState({
            liveRegionPolite: e
        }),
        dy = window.setTimeout( () => {
            pp.setState({
                liveRegionPolite: ""
            }),
            dy = void 0
        }
        , 5e3)
    }
};
var Dw = (e => (e.file_upload_rate_limit_upsell_plus = "file_upload_rate_limit_upsell_plus",
e))(Dw || {});
const lT = e => Object.hasOwnProperty.call(e, "id");
let Pae = 0;
class Dae {
    intl;
    constructor(t) {
        this.intl = t
    }
    toasts = [];
    listeners = new Set;
    subscribe = t => (this.listeners.add(t),
    () => this.listeners.delete(t));
    toastsChanged() {
        this.listeners.forEach(t => t())
    }
    announceToScreenReader(t, n) {
        let r, s;
        try {
            switch (n.intent) {
            case _n.success:
                s = {
                    defaultMessage: "Success",
                    description: "Prefix for success toast announcements",
                    id: "toast.success"
                };
                break;
            case _n.warning:
                s = {
                    defaultMessage: "Warning",
                    description: "Prefix for warning toast announcements",
                    id: "toast.warning"
                };
                break;
            case _n.danger:
                s = {
                    defaultMessage: "Error",
                    description: "Prefix for error toast announcements",
                    id: "toast.error"
                };
                break;
            default:
                s = void 0
            }
            s ? r = this.intl.formatMessage({
                id: "SieQiR",
                defaultMessage: "{prefix}: {message}"
            }, {
                prefix: this.intl.formatMessage(s),
                message: t
            }) : r = this.intl.formatMessage({
                id: "opr5Yt",
                defaultMessage: "{message}"
            }, {
                message: t
            }),
            Nae.setLiveRegionPolite(r)
        } catch (o) {
            q.addError(o)
        }
    }
    notify(t, n) {
        if (lT(n))
            for (const s of this.toasts)
                String(s.id).startsWith(n.id) && this.closeToast(s.id);
        const r = this.createToastInstance(t, n);
        return this.announceToScreenReader(t, n),
        this.toasts = [r, ...this.toasts],
        this.toastsChanged(),
        r
    }
    createToastInstance(t, n) {
        const r = ++Pae
          , s = lT(n) ? `${n.id}-${r}` : r;
        return {
            id: s,
            title: t,
            description: n.description,
            hasCloseButton: !!n.hasCloseButton,
            duration: typeof n.duration == "number" ? n.duration : 5,
            close: () => this.closeToast(s),
            onRemove: n.onRemove,
            intent: n.intent ?? _n.info,
            isShown: !0,
            testId: n.testId,
            action: n.action
        }
    }
    getToasts() {
        return this.toasts
    }
    closeToast(t) {
        this.toasts = this.toasts.map(n => n.id === t ? {
            ...n,
            isShown: !1
        } : n),
        this.toastsChanged()
    }
    removeToast(t) {
        this.toasts.find(n => n.id === t)?.onRemove?.(),
        this.toasts = this.toasts.filter(n => n.id !== t),
        this.toastsChanged()
    }
    closeAll() {
        this.toasts.forEach(t => t.close())
    }
    info(t, n) {
        return this.notify(t, {
            ...n,
            intent: _n.info
        })
    }
    success(t, n) {
        return this.notify(t, {
            ...n,
            intent: _n.success
        })
    }
    successNeutral(t, n) {
        return this.notify(t, {
            ...n,
            intent: _n.successNeutral
        })
    }
    warning(t, n) {
        return this.notify(t, {
            ...n,
            intent: _n.warning
        })
    }
    danger(t, n) {
        let r = ""
          , s = ""
          , o = "";
        return typeof t == "string" ? (r = t,
        s = t) : (r = this.intl.formatMessage(t),
        s = String(t.defaultMessage ?? ""),
        o = String(t.description ?? "")),
        V.logEvent("error_toast_shown", {
            category: n?.toastId ?? "unknown",
            title: n?.loggingTitle ?? s,
            description: n?.loggingDescription ?? o
        }),
        this.notify(r, {
            ...n,
            intent: _n.danger
        })
    }
}
const Lae = {
    [_n.success]: nT,
    [_n.successNeutral]: nT,
    [_n.warning]: Pu,
    [_n.danger]: Pu
}
  , Fae = ({zIndex: e, action: t, duration: n, onRemove: r, intent: s=_n.info, title: o, description: i, hasCloseButton: a, isShown: l=!0, testId: c}) => {
    const u = ue()
      , [d,f] = h.useState(0)
      , p = oo()
      , m = bn(u)
      , [v,_] = h.useState(l)
      , y = h.useRef(null)
      , b = h.useRef(null)
      , S = Oae( () => {
        r?.(),
        w(),
        _(!1)
    }
    )
      , C = h.useCallback( () => {
        n && (b.current = setTimeout( () => {
            S()
        }
        , n * 1e3))
    }
    , [S, n]);
    h.useEffect( () => (C(),
    () => {
        w()
    }
    ), [v, C]);
    const w = () => {
        b.current && (clearTimeout(b.current),
        b.current = null)
    }
      , x = () => {
        w()
    }
      , E = () => {
        C()
    }
      , T = O => {
        if (O === null)
            return;
        const {height: M} = O.getBoundingClientRect();
        f(M)
    }
      , k = $t(u, "1916748563")
      , A = t && t === Dw.file_upload_rate_limit_upsell_plus && k.get("is_upgrade_link_shown", !1);
    return g.jsx(Oi, {
        appear: !0,
        unmountOnExit: !0,
        timeout: 240,
        in: v,
        onExited: r,
        nodeRef: y,
        children: O => g.jsx("div", {
            ref: y,
            "data-state": O,
            className: "toast-root",
            onMouseEnter: x,
            onMouseLeave: E,
            style: {
                height: d,
                zIndex: e,
                marginBottom: v ? 0 : -d
            },
            children: g.jsx("div", {
                ref: T,
                className: "w-full p-1 text-center md:w-auto md:text-justify",
                children: g.jsx(Iae, {
                    icon: Lae[s] ?? void 0,
                    intent: s,
                    onRemove: a ? () => S() : void 0,
                    testId: c,
                    children: A ? g.jsxs("div", {
                        className: "flex w-full items-center gap-3",
                        children: [g.jsx("div", {
                            className: "flex-1 text-start text-sm whitespace-pre-wrap",
                            children: o
                        }), g.jsx(an, {
                            onClick: M => {
                                M.preventDefault(),
                                Pw(p, "Plus upsell toast"),
                                V.logRateLimitGetPlusButtonClicked({
                                    location: "toast",
                                    type: "upsell_plus",
                                    plan_type: m?.planType ?? "unknown",
                                    is_hard_block: !1,
                                    hard_block_reason: ""
                                })
                            }
                            ,
                            color: "secondary",
                            size: "small",
                            className: "shrink-0",
                            children: g.jsx(de, {
                                ...yae(u)
                            })
                        })]
                    }) : g.jsxs(g.Fragment, {
                        children: [g.jsx("div", {
                            className: we("text-start whitespace-pre-wrap", {
                                "font-semibold": i != null && i !== ""
                            }),
                            children: o
                        }), i && g.jsx("div", {
                            children: i
                        })]
                    })
                })
            })
        })
    })
}
  , Mj = h.createContext(null)
  , {Provider: jae} = Mj;
function Tn() {
    "use forget";
    return h.useContext(Mj)
}
function Uae() {
    "use forget";
    const e = De.c(4)
      , t = Tn();
    let n;
    e[0] !== t ? (n = s => t.subscribe(s),
    e[0] = t,
    e[1] = n) : n = e[1];
    let r;
    return e[2] !== t.toasts ? (r = () => t.toasts,
    e[2] = t.toasts,
    e[3] = r) : r = e[3],
    h.useSyncExternalStore(n, r, Bae)
}
function Bae() {
    return []
}
function qae() {
    "use forget";
    const e = De.c(10)
      , t = Uae()
      , n = Tn();
    let r, s, o;
    if (e[0] !== n || e[1] !== t) {
        o = Symbol.for("react.early_return_sentinel");
        e: {
            const a = t.filter(Gae);
            if (a.length === 0) {
                o = null;
                break e
            }
            r = "pointer-events-none fixed inset-0 z-60 mx-auto my-2 flex max-w-[560px] flex-col items-stretch justify-start md:pb-5";
            let l;
            e[5] !== n ? (l = c => {
                const {id: u, ...d} = c;
                return g.jsx(Fae, {
                    ...d,
                    onRemove: () => n.removeToast(u)
                }, u)
            }
            ,
            e[5] = n,
            e[6] = l) : l = e[6],
            s = a.map(l)
        }
        e[0] = n,
        e[1] = t,
        e[2] = r,
        e[3] = s,
        e[4] = o
    } else
        r = e[2],
        s = e[3],
        o = e[4];
    if (o !== Symbol.for("react.early_return_sentinel"))
        return o;
    let i;
    return e[7] !== r || e[8] !== s ? (i = g.jsx("span", {
        className: r,
        children: s
    }),
    e[7] = r,
    e[8] = s,
    e[9] = i) : i = e[9],
    i
}
function Gae(e) {
    return e.isShown !== !1
}
function Vae(e) {
    "use forget";
    const t = De.c(6)
      , {children: n} = e
      , r = gt();
    let s;
    t[0] !== r ? (s = () => new Dae(r),
    t[0] = r,
    t[1] = s) : s = t[1];
    const [o] = h.useState(s);
    let i;
    t[2] === Symbol.for("react.memo_cache_sentinel") ? (i = g.jsx(vae, {
        children: g.jsx(qae, {})
    }),
    t[2] = i) : i = t[2];
    let a;
    return t[3] !== n || t[4] !== o ? (a = g.jsxs(jae, {
        value: o,
        children: [n, i]
    }),
    t[3] = n,
    t[4] = o,
    t[5] = a) : a = t[5],
    a
}
class cT extends Error {
    constructor(t) {
        super(t),
        this.name = "OtpValidationError"
    }
}
const Hae = (e, t) => {
    if (t.length !== 6)
        return e.formatMessage(ts.verifyOtpFailureInvalidFormat);
    try {
        parseInt(t)
    } catch {
        return e.formatMessage(ts.verifyOtpFailureInvalidFormat)
    }
    return null
}
  , zae = (e, t, n) => {
    switch (n.status) {
    case 403:
        throw new Error(e.formatMessage(ts.verifyOtpFailureEmailAlreadyLinked, {
            branch: t ? "email" : "other",
            emailValue: t
        }));
    case 429:
        throw new Error(e.formatMessage(ts.verifyOtpFailureRateLimited));
    case 401:
    case 422:
        throw new Error(e.formatMessage(ts.verifyOtpFailureInvalidOtp));
    default:
        return
    }
}
;
function $ae(e) {
    const t = ue()
      , n = gt()
      , r = Tn()
      , [s,o] = h.useState(null)
      , i = e.showChangeEmailButton ?? !0
      , a = h.useCallback(u => {
        const d = u.target.value.trim();
        if (typeof d == "string") {
            if (d.match(/\D/)) {
                u.preventDefault();
                return
            }
            e.onOtpChange?.(d.substring(0, 6))
        }
    }
    , [e])
      , l = nr({
        mutationFn: async () => {
            try {
                return e.onResendOtp ? await e.onResendOtp() : await xj(e.email ?? "")
            } catch (u) {
                throw u instanceof _t && Tj(n, e.email ?? "", u),
                new Error(n.formatMessage(ts.sendEmailFailure))
            }
        }
        ,
        onSuccess: () => {
            e.setStep("verifyOtp")
        }
        ,
        onError: u => {
            o(u.message),
            V.logEventWithStatsig("Email Verify Verify OTP Step - Error Resending OTP", "chatgpt_email_verify_verify_otp_step_resend_error", {
                error: u.message
            })
        }
    })
      , c = nr({
        mutationFn: async u => {
            try {
                const d = Hae(n, u.code);
                if (d)
                    throw new cT(d);
                if (e.onVerifyOtp)
                    return await e.onVerifyOtp(u.code, u.email);
                await ie.safePost("/accounts/add_email/verify", {
                    requestBody: u
                }),
                await HP(t, {
                    reason: "verify_otp"
                })
            } catch (d) {
                throw d instanceof cT ? d : (d instanceof _t && zae(n, e.email, d),
                new Error(n.formatMessage(ts.verifyOtpFailure)))
            }
        }
        ,
        onSuccess: () => {
            r.success(n.formatMessage(ts.verifyOtpSuccess)),
            e.onVerified?.()
        }
        ,
        onError: u => {
            o(u.message),
            V.logEventWithStatsig("Email Verify Verify OTP Step - Error Verifying OTP", "chatgpt_email_verify_verify_otp_step_error", {
                error: u.message
            })
        }
    });
    return h.useEffect( () => {
        V.logEventWithStatsig("Email Verify Verify OTP Step - Shown", "chatgpt_email_verify_verify_otp_step_shown")
    }
    , []),
    g.jsxs("div", {
        className: "flex w-full flex-col items-center gap-3",
        children: [g.jsx("p", {
            className: "text-3xl font-semibold",
            children: g.jsx(de, {
                id: "verifyOtp.title",
                defaultMessage: "Check your email"
            })
        }), g.jsxs("p", {
            className: "text-center",
            children: [g.jsx("span", {
                className: "text-token-text-primary text-base",
                children: g.jsx(de, {
                    id: "verifyOtp.description",
                    defaultMessage: "Enter the verification code we just sent to"
                })
            }), e.email && g.jsx("br", {}), g.jsx("span", {
                className: `text-token-text-primary text-base leading-snug ${e.email && "font-semibold"}`,
                children: g.jsx(de, {
                    id: "verifyOtp.email",
                    defaultMessage: "{branch, select, email {{emailValue}} other { your email.}}",
                    values: {
                        branch: e.email ? "email" : "other",
                        emailValue: e.email
                    }
                })
            })]
        }), g.jsxs("form", {
            onSubmit: u => {
                u.preventDefault(),
                c.mutate({
                    code: e.otp,
                    email: e.email ?? ""
                }),
                V.logEventWithStatsig("Email Verify Verify OTP Step - Attempted Continue", "chatgpt_email_verify_verify_otp_step_continue")
            }
            ,
            className: "flex w-full flex-col items-center gap-3",
            children: [g.jsx(Ej, {
                error: s ?? void 0,
                ariaLabel: n.formatMessage({
                    id: "emailVerify.otpAriaLabel",
                    defaultMessage: "OTP"
                }),
                value: e.otp,
                onChange: u => {
                    o(null),
                    a(u),
                    V.logEventWithStatsig("Email Verify Verify OTP Step - Typed", "chatgpt_email_verify_verify_otp_step_type")
                }
                ,
                name: "otp",
                type: "text",
                placeholder: "XXXXXX",
                className: "mt-6 w-full",
                autoComplete: "off",
                autoFocus: !0
            }), g.jsx(an, {
                className: "w-full rounded-md",
                color: "green",
                type: "submit",
                loading: c.isPending,
                disabled: c.isPending,
                children: g.jsx(de, {
                    id: "verifyOtp.continue",
                    defaultMessage: "Continue"
                })
            }), e.cancelFlowButton]
        }), g.jsxs("div", {
            className: "mt-6 flex w-full flex-col items-center gap-3",
            children: [g.jsx("p", {
                className: "text-token-text-primary text-sm",
                children: g.jsx(de, {
                    id: "verifyOtp.resendMessage",
                    defaultMessage: "Didn't receive the code?"
                })
            }), g.jsx(an, {
                className: "w-full rounded-md",
                color: "secondary",
                onClick: () => {
                    l.mutate(),
                    V.logEventWithStatsig("Email Verify Verify OTP Step - Resend", "chatgpt_email_verify_verify_otp_step_resend")
                }
                ,
                loading: l.isPending,
                disabled: l.isPending,
                children: g.jsx(de, {
                    id: "verifyOtp.resend",
                    defaultMessage: "Resend code"
                })
            }), i && g.jsx(an, {
                className: "w-full rounded-md",
                color: "secondary",
                onClick: () => {
                    e.setStep("enterEmail"),
                    V.logEventWithStatsig("Email Verify Verify OTP Step - Back to Enter Email Step", "chatgpt_email_verify_verify_otp_step_change_email")
                }
                ,
                children: g.jsx(de, {
                    id: "verifyOtp.changeEmail",
                    defaultMessage: "Change email"
                })
            })]
        })]
    })
}
function Wae(e) {
    const [t,n] = h.useState(e.initialStep ?? "enterEmail")
      , [r,s] = h.useState("")
      , [o,i] = h.useState("")
      , a = e.email ? {
        email: e.email,
        onEmailChange: e.onEmailChange
    } : {
        email: r,
        onEmailChange: s
    }
      , l = e.otp ? {
        otp: e.otp,
        onOtpChange: e.onOtpChange
    } : {
        otp: o,
        onOtpChange: i
    };
    return t === "enterEmail" ? g.jsx(gae, {
        title: e.enterEmailTitle,
        description: e.enterEmailDescription,
        cancelFlowButton: e.cancelFlowButton,
        step: t,
        setStep: n,
        ...a
    }) : g.jsx($ae, {
        email: a.email,
        onVerified: e.onVerified,
        cancelFlowButton: e.cancelFlowButton,
        step: t,
        setStep: n,
        showChangeEmailButton: e.showChangeEmailButton,
        onResendOtp: e.onResendOtp,
        onVerifyOtp: e.onVerifyOtp,
        ...l
    })
}
function Kae({onVerify: e, onClose: t, onResendOtp: n}) {
    const {session: r} = Qf()
      , [s,o] = h.useState("");
    return g.jsx(Ti, {
        testId: "modal-connector-email-verify",
        isOpen: !0,
        onClose: t,
        type: "success",
        className: "max-w-sm",
        children: g.jsx(Wae, {
            initialStep: "verifyOtp",
            email: r?.user?.email,
            otp: s,
            onOtpChange: o,
            onVerified: t,
            onResendOtp: n,
            onVerifyOtp: async (i, a) => {
                await e(i)
            }
            ,
            showChangeEmailButton: !1,
            cancelFlowButton: g.jsx(an, {
                className: "w-full rounded-md",
                color: "secondary",
                onClick: t,
                children: g.jsx(de, {
                    id: "ConnectorEmailVerifyModal.cancel",
                    defaultMessage: "Cancel"
                })
            })
        })
    })
}
const Jp = new BroadcastChannel("plugin_oauth_channel")
  , LTe = e => {
    Jp.postMessage(e)
}
  , FTe = "connector_bd313622bce5485cb3d0b338715f7108"
  , O5 = {
    gdrive_sync_connector: "gdrive_sync_connector",
    slack_sync_connector: "slack_sync_connector",
    github_sync_connector: "github_sync_connector",
    notion_sync_connector: "notion_sync_connector",
    sharepoint_sync_connector: "sharepoint_sync_connector",
    linear_sync_connector: "linear_sync_connector"
}
  , mr = {
    [U.GDRIVE_ACTION_CONNECTOR]: "connector_5f3c8c41a1e54ad7a76272c89e2554fa",
    [U.GITHUB_CONNECTOR]: "connector_76869538009648d5b282a4bb21c3d157",
    [U.LINEAR_CONNECTOR]: "connector_686fad9b54914a35b75be6d06a0f6f31",
    [U.DROPBOX_CONNECTOR]: "connector_14e85e16800b4e53bc6246019a83a307",
    [U.HUBSPOT_CONNECTOR]: "connector_2a3c0c472f6f4238b47d41acfb317307",
    [U.SHAREPOINT_CONNECTOR]: "connector_1e4f6a44acf14e3ca1d96672f8c945bc",
    [U.GCAL_CONNECTOR]: "connector_947e0d954944416db111db556030eea6",
    [U.GMAIL_CONNECTOR]: "connector_2128aebfecb84f64a069897515042a44",
    [U.GOOGLE_CONTACTS_CONNECTOR]: "connector_c0f748249d6a42aea4b00fd375570ded",
    [U.TEAMS_CONNECTOR]: "connector_246af0940da3457da0e751171dc1ce60",
    [U.OUTLOOK_EMAIL_CONNECTOR]: "connector_4aaab2856305417b993eca9a216aaf6e",
    [U.OUTLOOK_CALENDAR_CONNECTOR]: "connector_e6a7394682e24467ac68c60696f275a4",
    [U.BOX_CONNECTOR]: "connector_2fc94c70cbb74b7caa6d07bf7231202e",
    [U.INTERCOM_CONNECTOR]: "connector_25f8569426254c019971d2481ddda775",
    [U.NOTION_CONNECTOR]: "connector_37316be7febe4224b3d31465bae4dbd7",
    [U.CANVA_CONNECTOR]: "connector_ef718304ffe64e31947b71887e3d51fa",
    [U.SLACK_CONNECTOR]: "connector_0f9c9d4592e54d0a9a12b3f44a1e2010"
}
  , fh = {
    connector_5f3c8c41a1e54ad7a76272c89e2554fa: U.GDRIVE_ACTION_CONNECTOR,
    connector_76869538009648d5b282a4bb21c3d157: U.GITHUB_CONNECTOR,
    connector_686fad9b54914a35b75be6d06a0f6f31: U.LINEAR_CONNECTOR,
    connector_14e85e16800b4e53bc6246019a83a307: U.DROPBOX_CONNECTOR,
    connector_2a3c0c472f6f4238b47d41acfb317307: U.HUBSPOT_CONNECTOR,
    connector_1e4f6a44acf14e3ca1d96672f8c945bc: U.SHAREPOINT_CONNECTOR,
    connector_947e0d954944416db111db556030eea6: U.GCAL_CONNECTOR,
    connector_2128aebfecb84f64a069897515042a44: U.GMAIL_CONNECTOR,
    connector_c0f748249d6a42aea4b00fd375570ded: U.GOOGLE_CONTACTS_CONNECTOR,
    connector_246af0940da3457da0e751171dc1ce60: U.TEAMS_CONNECTOR,
    connector_4aaab2856305417b993eca9a216aaf6e: U.OUTLOOK_EMAIL_CONNECTOR,
    connector_e6a7394682e24467ac68c60696f275a4: U.OUTLOOK_CALENDAR_CONNECTOR,
    connector_2fc94c70cbb74b7caa6d07bf7231202e: U.BOX_CONNECTOR,
    connector_25f8569426254c019971d2481ddda775: U.INTERCOM_CONNECTOR,
    connector_37316be7febe4224b3d31465bae4dbd7: U.NOTION_CONNECTOR,
    connector_ef718304ffe64e31947b71887e3d51fa: U.CANVA_CONNECTOR,
    connector_6887fff96c948190aa97fd69c3041dea: U.UAE_PASS_CONNECTOR,
    connector_0f9c9d4592e54d0a9a12b3f44a1e2010: U.SLACK_CONNECTOR
};
function Yae(e) {
    return Object.keys(fh).includes(e)
}
function jTe(e) {
    return !(e === "web" || e === "cloud" || e in mr || e in O5)
}
function Ij(e) {
    return typeof window < "u" ? `${window.location.origin}/connector_platform_oauth_redirect` : ""
}
const Zae = "https://github.com/apps/chatgpt-codex-connector";
function Jae(e) {
    return `${Zae}/${e}`
}
const Xae = {
    [U.GITHUB_CONNECTOR]: "github-connector",
    [U.GDRIVE_ACTION_CONNECTOR]: "gdrive-connector",
    [U.LINEAR_CONNECTOR]: "linear-connector",
    [U.DROPBOX_CONNECTOR]: "dropbox-connector",
    [U.HUBSPOT_CONNECTOR]: "hubspot-connector",
    [U.SHAREPOINT_CONNECTOR]: "sharepoint-connector",
    [U.GCAL_CONNECTOR]: "gcal-connector",
    [U.GMAIL_CONNECTOR]: "gmail-connector",
    [U.GOOGLE_CONTACTS_CONNECTOR]: "google-contacts-connector",
    [U.TEAMS_CONNECTOR]: "teams-connector",
    [U.OUTLOOK_EMAIL_CONNECTOR]: "outlook-email-connector",
    [U.OUTLOOK_CALENDAR_CONNECTOR]: "outlook-calendar-connector",
    [U.BOX_CONNECTOR]: "box-connector",
    [U.INTERCOM_CONNECTOR]: "intercom-connector",
    [U.NOTION_CONNECTOR]: "notion-connector",
    [U.CANVA_CONNECTOR]: "canva-connector",
    [U.SLACK_CONNECTOR]: "slack-connector"
}
  , UTe = ({openPopup: e, connectorType: t, customRedirectUrl: n, onError: r, toaster: s, intl: o, productSku: i}) => {
    const a = {
        connectorId: mr[t],
        name: t,
        actionNames: null,
        oauthClientId: null,
        oauthClientScopes: null
    }
      , l = n ?? `#settings/${dh.Connectors}?scroll=${Xae[t]}`;
    Rj({
        redirectUri: Ij(),
        connectorPlatformParams: a,
        redirectTo: l,
        onError: r,
        openPopup: e,
        toaster: s,
        intl: o,
        productSku: i
    })
}
  , Qae = {
    [U.GITHUB_CONNECTOR]: Rn.GitHub,
    [U.GDRIVE_ACTION_CONNECTOR]: Rn.GoogleDrive,
    [U.DROPBOX_CONNECTOR]: Rn.Dropbox,
    [U.LINEAR_CONNECTOR]: Rn.Linear,
    [U.SHAREPOINT_CONNECTOR]: Rn.Sharepoint,
    [U.TEAMS_CONNECTOR]: Rn.Teams,
    [U.OUTLOOK_EMAIL_CONNECTOR]: Rn.OutlookEmail,
    [U.OUTLOOK_CALENDAR_CONNECTOR]: Rn.OutlookCalendar,
    [U.BOX_CONNECTOR]: Rn.Box,
    [U.INTERCOM_CONNECTOR]: Rn.Intercom,
    [U.GCAL_CONNECTOR]: Rn.GoogleCalendar,
    [U.GMAIL_CONNECTOR]: Rn.Gmail,
    [U.GOOGLE_CONTACTS_CONNECTOR]: Rn.GoogleContacts,
    [U.HUBSPOT_CONNECTOR]: Rn.Hubspot,
    [U.CANVA_CONNECTOR]: Rn.Canva,
    [U.NOTION_CONNECTOR]: Rn.Notion,
    [U.SLACK_CONNECTOR]: Rn.Slack
}
  , ele = e => [...Object.values(U), ...Object.values(JP)].includes(e) ? e : null
  , BTe = e => e.map(t => ele(t)).filter(t => t != null);
async function Rj({redirectUri: e, connectorPlatformParams: t, redirectTo: n, onError: r, openPopup: s=!1, toaster: o, intl: i, productSku: a}) {
    V.logEventWithStatsig("Connector OAuth Connect", "chatgpt_connectors_oauth_connect_initiated", {
        event: "start",
        type: t.connectorId
    });
    try {
        const l = {
            connector_id: t.connectorId,
            oauth_client_id: t.oauthClientId,
            name: t.name,
            action_names: t.actionNames,
            requested_scopes: t.oauthClientScopes,
            callback_url: e,
            post_auth_url: n
        };
        let c = await ie.safePost("/aip/connectors/links/oauth", {
            requestBody: l,
            additionalHeaders: a ? {
                [pr]: a
            } : void 0
        });
        c.email_challenge_sent && await new Promise( (f, p) => {
            Gg(Ot(), ({onClose: m}) => Ne.createElement(Kae, {
                onClose: () => {
                    m(),
                    p(null)
                }
                ,
                onVerify: async v => {
                    c = await ie.safePost("/aip/connectors/links/oauth", {
                        requestBody: {
                            ...l,
                            otp_code: v
                        },
                        additionalHeaders: a ? {
                            [pr]: a
                        } : void 0
                    }),
                    m(),
                    f()
                }
                ,
                onResendOtp: async () => {
                    await ie.safePost("/aip/connectors/links/oauth", {
                        requestBody: l,
                        additionalHeaders: a ? {
                            [pr]: a
                        } : void 0
                    })
                }
            }))
        }
        );
        let u = null;
        Yae(t.connectorId) && fh[t.connectorId] === U.HUBSPOT_CONNECTOR ? u = c.redirect_url + "&utm_source=chatgpt" : u = c.redirect_url;
        let d = null;
        if (s && (d = window.open("about:blank", "_blank")),
        !d)
            window.location.href = u;
        else if (d)
            return d.location.href = u,
            new Promise(f => {
                const p = m => {
                    const {error: v, errorDesc: _, errorType: y, connectorId: b, success: S, linkId: C} = m.data;
                    if (m.origin === window.location.origin && !(b && t.connectorId !== b)) {
                        if (S)
                            V.logEventWithStatsig("Connector OAuth Connect", "chatgpt_connectors_oauth_connect_success", {
                                success: !0,
                                type: t.connectorId
                            }),
                            o?.success(i.formatMessage(fy.createLinkSuccess, {
                                connectorName: t.name
                            })),
                            f({
                                success: !0,
                                linkId: C,
                                message: ""
                            });
                        else {
                            V.logEventWithStatsig("Connector OAuth Connect", "chatgpt_connectors_oauth_connect_error", {
                                success: !1,
                                type: t.connectorId,
                                errorType: y
                            }),
                            y !== "oauth_failed_scope_mismatch" && o?.danger(i.formatMessage(fy.createLinkError, {
                                connectorName: t.name
                            }), {
                                toastId: "connector_oauth_connect",
                                loggingTitle: fy.createLinkError.defaultMessage,
                                loggingDescription: "Failed to link connector"
                            });
                            const w = `${v}${_ ? `: ${_}` : ""}`;
                            f({
                                errorType: y,
                                success: S,
                                message: w
                            })
                        }
                        Jp.removeEventListener("message", p, !1)
                    }
                }
                ;
                Jp.addEventListener("message", p, !1),
                d.addEventListener("beforeunload", () => {
                    Jp.removeEventListener("message", p, !1)
                }
                )
            }
            )
    } catch (l) {
        if (r)
            r(l);
        else
            throw l
    }
}
const qTe = {
    box: U.BOX_CONNECTOR,
    dropbox: U.DROPBOX_CONNECTOR,
    github: U.GITHUB_CONNECTOR,
    gmail: U.GMAIL_CONNECTOR,
    "google drive": U.GDRIVE_ACTION_CONNECTOR,
    "google calendar": U.GCAL_CONNECTOR,
    outlook: U.OUTLOOK_EMAIL_CONNECTOR,
    "outlook email": U.OUTLOOK_EMAIL_CONNECTOR,
    "outlook calendar": U.OUTLOOK_CALENDAR_CONNECTOR,
    sharepoint: U.SHAREPOINT_CONNECTOR,
    linear: U.LINEAR_CONNECTOR,
    teams: U.TEAMS_CONNECTOR,
    intercom: U.INTERCOM_CONNECTOR,
    hubspot: U.HUBSPOT_CONNECTOR,
    notion: U.NOTION_CONNECTOR,
    canva: U.CANVA_CONNECTOR,
    slack: U.SLACK_CONNECTOR
}
  , fy = xt({
    createLinkSuccess: {
        id: "KVbj6o",
        defaultMessage: "{connectorName} is now connected."
    },
    createLinkError: {
        id: "Y6p1d0",
        defaultMessage: "There was a problem connecting {connectorName}. Try again later."
    }
});
function mp(e) {
    switch (e) {
    case U.GOOGLE_CONTACTS_CONNECTOR:
        return "gcontacts";
    case U.GMAIL_CONNECTOR:
        return "gmail";
    case U.GCAL_CONNECTOR:
        return "gcal";
    default:
        return null
    }
}
function tle(e) {
    switch (e) {
    case "gmail":
        return U.GMAIL_CONNECTOR;
    case "gcal":
        return U.GCAL_CONNECTOR;
    case "gcontacts":
        return U.GOOGLE_CONTACTS_CONNECTOR;
    default:
        return null
    }
}
function GTe(e) {
    switch (e) {
    case "gmail":
        return mr[U.GMAIL_CONNECTOR];
    case "gcal":
        return mr[U.GCAL_CONNECTOR];
    case "gcontacts":
        return mr[U.GOOGLE_CONTACTS_CONNECTOR];
    default:
        return null
    }
}
const nle = [xe.Slurm, xe.Research, Zs]
  , rle = e => {
    const t = new Map([[void 0, new Set(Object.keys(O5))], [xe.Slurm, new Set(Object.keys(O5))], [xe.Research, new Set(["web"])], [Zs, new Set(["web"])]]);
    try {
        const n = sle(e);
        n && n.forEach( (r, s) => {
            nle.includes(s) && t.set(s, new Set(r))
        }
        )
    } catch {}
    return t
}
  , Nj = "v1.1"
  , Pj = e => {
    const t = Wt.getItem(Ft.SelectedSources, e);
    if (!t)
        return {};
    try {
        const {version: n, data: r} = JSON.parse(t);
        if (n !== Nj)
            return Wt.removeItem(Ft.SelectedSources),
            {};
        const s = new Map([...r.selected_sources].map( ([i,a]) => [i, new Set(a)]))
          , o = new Map((r.selected_mcp_sources ?? []).map( ([i,a]) => [i, new Set(a)]));
        return {
            selectedSources: s,
            selectedMCPSources: o
        }
    } catch {
        return {}
    }
}
  , sle = e => Pj(e).selectedSources
  , ole = e => Pj(e).selectedMCPSources
  , ile = e => ole(e) ?? new Map
  , VTe = ({selectedSourcesMap: e, selectedMCPSourcesMap: t, scope: n}) => {
    if (!e && !t) {
        Wt.removeItem(Ft.SelectedSources);
        return
    }
    const r = {
        selected_sources: [...e ?? new Map].map( ([o,i]) => [o, [...i]]),
        selected_mcp_sources: [...t ?? new Map].map( ([o,i]) => [o, [...i]])
    }
      , s = {
        version: Nj,
        data: r
    };
    Wt.setItem(Ft.SelectedSources, JSON.stringify(s), n)
}
  , ale = "placeholder-";
class Hs {
    #e;
    rootId;
    constructor(t) {
        const n = {};
        let r;
        for (const s of t)
            n[s.id] = s,
            !r && s.message.author.role === Ke.Root && (r = s.id);
        if (!r)
            throw new Error("Missing root node");
        this.#e = n,
        this.rootId = r
    }
    static emptyTree() {
        return new Hs([Hs.createRootNode("client-created-root")])
    }
    static createNode(t, n, r=[], s) {
        const o = s ?? t.id;
        if (o === n)
            throw new Error(`createNode: parent.id and node.id cannot be the same: ${o}`);
        return {
            id: o,
            parentId: n,
            children: r,
            message: t
        }
    }
    static createRootNode(t) {
        const n = {
            id: t,
            author: {
                role: Ke.Root
            },
            content: {
                content_type: rt.Text,
                parts: []
            }
        };
        return Hs.createNode(n, "")
    }
    get nodes() {
        return Object.values(this.#e)
    }
    messageIdToNodeId(t) {
        return this.messageIdToExistingNodeId(t) ?? t
    }
    messageIdToExistingNodeId(t) {
        if (this.#e[t] != null)
            return t;
        for (const n of Object.values(this.#e))
            if (n.message?.id === t)
                return Dj(n.id, n.message.id),
                n.id
    }
    containsNodeOrMessageId(t) {
        return this.messageIdToExistingNodeId(t) != null
    }
    getNodeByIdOrMessageId(t) {
        const n = this.getNodeIfExists(t);
        if (n)
            return n;
        throw V.logEvent("chatgpt_conversation_tree__node_not_found", {
            rootId: this.rootId,
            nodeOrMessageId: t
        }),
        new Error(`getNodeByIdOrMessageId - no node found by id: ${t}`)
    }
    getNodeIfExists(t) {
        const n = this.messageIdToExistingNodeId(t);
        if (n)
            return this.#e[n]
    }
    findNode(t, n, r=this.rootId) {
        const s = this.getNodeIfExists(r);
        let o = this.getNodeIfExists(n);
        for (; s && o && o !== s; ) {
            if (t(o))
                return o;
            o = this.getNodeIfExists(o.parentId)
        }
    }
    findFirst(t) {
        let n = this.getNodeByIdOrMessageId(this.rootId);
        for (; n && n.children.length === 1; )
            if (n = this.getNodeByIdOrMessageId(n.children[0]),
            t(n))
                return n
    }
    findFirstFromLeaf(t, n) {
        let r, s = this.getNodeByIdOrMessageId(n);
        for (; s; )
            t(s) && (r = s),
            s = this.getNodeIfExists(s.parentId);
        return r
    }
    getLeafFromNode(t) {
        let n = this.getNodeByIdOrMessageId(t);
        for (; n.children.length > 0; )
            n = this.getNodeByIdOrMessageId(n.children[0]);
        return n
    }
    getParent(t) {
        const n = this.getNodeByIdOrMessageId(t).parentId;
        return this.getNodeByIdOrMessageId(n)
    }
    getBranchFromLeaf(t) {
        let n = []
          , r = this.getNodeByIdOrMessageId(t);
        for (; r != null; ) {
            if (n.includes(r)) {
                q.addError(`Infinite loop detected in getBranchFromLeaf. Branch already contains node ${r?.id}. Parent id: ${r?.parentId}.`, {
                    branch: n
                });
                break
            }
            if (n.push(r),
            r.message.author.role === Ke.Root)
                break;
            r = this.getNodeByIdOrMessageId(r.parentId)
        }
        return n = n.reverse(),
        n
    }
    addMessageNode(t, n) {
        const r = this.messageIdToNodeId(n.id)
          , s = this.getNodeByIdOrMessageId(t)
          , o = Hs.createNode(n, s.id, [], r);
        return this.#e = Bs(this.#e, i => {
            i[o.id] = o;
            const a = i[o.parentId];
            a.children.includes(o.id) || a.children.push(o.id)
        }
        ),
        o.id
    }
    prependNode(t, n) {
        const r = this.messageIdToNodeId(n.id)
          , s = this.getNodeByIdOrMessageId(t)
          , o = Hs.createNode(n, s.parentId, [s.id], r);
        this.#e = Bs(this.#e, i => {
            i[o.id] = o;
            const a = i[o.parentId];
            a.children = a.children.filter(c => c !== s.id),
            a.children.includes(o.id) || a.children.push(o.id);
            const l = i[s.id];
            l.parentId = o.id
        }
        )
    }
    deleteNode(t) {
        const n = this.getNodeByIdOrMessageId(t);
        this.#e = Bs(this.#e, r => {
            const s = n.parentId
              , o = n.children;
            for (const a of o) {
                const l = r[this.messageIdToNodeId(a)];
                l.parentId = s
            }
            const i = r[this.messageIdToNodeId(s)];
            if (i == null) {
                console.warn(`Cannot deleteNode with nodeId: ${t} - parent not found. Either this is root or in an orphaned branch`);
                return
            }
            i.children = i.children.flatMap(a => this.messageIdToNodeId(a) === this.messageIdToNodeId(n.id) ? o : [a]),
            delete r[n.id]
        }
        )
    }
    clearNodeMessageParts(t) {
        this.#e = Bs(this.#e, n => {
            const r = n[this.messageIdToNodeId(t)];
            r && r.message && "parts"in r.message.content && (r.message.content.parts = [])
        }
        )
    }
    updateNodeMetadata(t, n) {
        this.#e = Bs(this.#e, r => {
            const s = r[this.messageIdToNodeId(t)];
            s && (s.message.clientMetadata = {
                ...s?.message.clientMetadata,
                ...n
            })
        }
        )
    }
    updateNodeMessage(t, n) {
        this.#e = Bs(this.#e, r => {
            const s = r[this.messageIdToNodeId(t)];
            if (s) {
                const o = s.message.clientMetadata;
                s.message = o ? {
                    ...n,
                    clientMetadata: o
                } : n
            }
        }
        )
    }
    updateNodeMessageMetadata(t, n) {
        this.#e = Bs(this.#e, r => {
            const s = r[this.messageIdToNodeId(t)];
            s && (s.message.metadata = {
                ...s.message.metadata,
                ...n
            })
        }
        )
    }
    prettyPrint(t=this.rootId, n=0) {
        const r = this.getNodeByIdOrMessageId(t)
          , s = m1(r.message);
        let o = `${"	".repeat(n)}->${t} - ${s.replaceAll(`
`, "\\n")}
`;
        const i = r.children.map(a => this.getNodeByIdOrMessageId(a));
        for (const a of i)
            o += this.prettyPrint(a.id, n + 1);
        return o
    }
}
const uT = new Set;
function Dj(e, t, n) {
    const r = new Error(`Found TreeNode where message.id ${t} != node.id ${e}`);
    console.warn(r),
    uT.has(e) || (uT.add(e),
    n ? q.addAction("tree_node_id_mismatch_api", {
        nodeId: e,
        messageId: t,
        conversationId: n
    }) : q.addAction("tree_node_id_mismatch_client", {
        nodeId: e,
        messageId: t
    }))
}
function lle(e, t) {
    const n = new Set
      , r = new Set
      , s = new Set
      , o = new Map;
    return (e.moderation_results ?? []).forEach(a => {
        o.set(a.message_id, a),
        a.blocked ? r.add(a.message_id) : a.flagged && n.add(a.message_id),
        a.disclaimers?.length && !a.blocked && s.add(a.message_id)
    }
    ),
    {
        nodes: Object.values(e.mapping).map( ({id: a, parent: l, children: c, message: u}) => {
            if (!l)
                return Hs.createRootNode(a);
            if (!u)
                throw new Error(`Missing message for node ${a}`);
            a !== u.id && Dj(a, u.id, t);
            const d = {}
              , f = o.get(u.id);
            let p = !1;
            if (r.has(u.id)) {
                const v = f?.should_disable_conversation ?? !1
                  , _ = f?.blocked ?? !1
                  , y = f?.metadata?.safety_limited ?? !1;
                Object.assign(d, {
                    isSafetyLimited: y
                }),
                Object.assign(d, qL({
                    isSafetyLimited: y,
                    shouldDisableConversation: v,
                    isModelIncompatibility: _
                })),
                p = !0
            } else
                n.has(u.id) && Object.assign(d, jL);
            if (s.has(u.id)) {
                const v = o.get(u.id);
                v?.disclaimers?.length && Object.assign(d, BL(v.disclaimers, p))
            }
            const m = {
                ...u,
                clientMetadata: d
            };
            return Hs.createNode(m, l, c, a)
        }
        , {}),
        initialCurrentLeafId: e.current_node
    }
}
var gp = {
    exports: {}
}, dT;
function cle() {
    if (dT)
        return gp.exports;
    dT = 1;
    var e = typeof Reflect == "object" ? Reflect : null, t = e && typeof e.apply == "function" ? e.apply : function(w, x, E) {
        return Function.prototype.apply.call(w, x, E)
    }
    , n;
    e && typeof e.ownKeys == "function" ? n = e.ownKeys : Object.getOwnPropertySymbols ? n = function(w) {
        return Object.getOwnPropertyNames(w).concat(Object.getOwnPropertySymbols(w))
    }
    : n = function(w) {
        return Object.getOwnPropertyNames(w)
    }
    ;
    function r(C) {
        console && console.warn && console.warn(C)
    }
    var s = Number.isNaN || function(w) {
        return w !== w
    }
    ;
    function o() {
        o.init.call(this)
    }
    gp.exports = o,
    gp.exports.once = y,
    o.EventEmitter = o,
    o.prototype._events = void 0,
    o.prototype._eventsCount = 0,
    o.prototype._maxListeners = void 0;
    var i = 10;
    function a(C) {
        if (typeof C != "function")
            throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof C)
    }
    Object.defineProperty(o, "defaultMaxListeners", {
        enumerable: !0,
        get: function() {
            return i
        },
        set: function(C) {
            if (typeof C != "number" || C < 0 || s(C))
                throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + C + ".");
            i = C
        }
    }),
    o.init = function() {
        (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = Object.create(null),
        this._eventsCount = 0),
        this._maxListeners = this._maxListeners || void 0
    }
    ,
    o.prototype.setMaxListeners = function(w) {
        if (typeof w != "number" || w < 0 || s(w))
            throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + w + ".");
        return this._maxListeners = w,
        this
    }
    ;
    function l(C) {
        return C._maxListeners === void 0 ? o.defaultMaxListeners : C._maxListeners
    }
    o.prototype.getMaxListeners = function() {
        return l(this)
    }
    ,
    o.prototype.emit = function(w) {
        for (var x = [], E = 1; E < arguments.length; E++)
            x.push(arguments[E]);
        var T = w === "error"
          , k = this._events;
        if (k !== void 0)
            T = T && k.error === void 0;
        else if (!T)
            return !1;
        if (T) {
            var A;
            if (x.length > 0 && (A = x[0]),
            A instanceof Error)
                throw A;
            var O = new Error("Unhandled error." + (A ? " (" + A.message + ")" : ""));
            throw O.context = A,
            O
        }
        var M = k[w];
        if (M === void 0)
            return !1;
        if (typeof M == "function")
            t(M, this, x);
        else
            for (var I = M.length, R = m(M, I), E = 0; E < I; ++E)
                t(R[E], this, x);
        return !0
    }
    ;
    function c(C, w, x, E) {
        var T, k, A;
        if (a(x),
        k = C._events,
        k === void 0 ? (k = C._events = Object.create(null),
        C._eventsCount = 0) : (k.newListener !== void 0 && (C.emit("newListener", w, x.listener ? x.listener : x),
        k = C._events),
        A = k[w]),
        A === void 0)
            A = k[w] = x,
            ++C._eventsCount;
        else if (typeof A == "function" ? A = k[w] = E ? [x, A] : [A, x] : E ? A.unshift(x) : A.push(x),
        T = l(C),
        T > 0 && A.length > T && !A.warned) {
            A.warned = !0;
            var O = new Error("Possible EventEmitter memory leak detected. " + A.length + " " + String(w) + " listeners added. Use emitter.setMaxListeners() to increase limit");
            O.name = "MaxListenersExceededWarning",
            O.emitter = C,
            O.type = w,
            O.count = A.length,
            r(O)
        }
        return C
    }
    o.prototype.addListener = function(w, x) {
        return c(this, w, x, !1)
    }
    ,
    o.prototype.on = o.prototype.addListener,
    o.prototype.prependListener = function(w, x) {
        return c(this, w, x, !0)
    }
    ;
    function u() {
        if (!this.fired)
            return this.target.removeListener(this.type, this.wrapFn),
            this.fired = !0,
            arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments)
    }
    function d(C, w, x) {
        var E = {
            fired: !1,
            wrapFn: void 0,
            target: C,
            type: w,
            listener: x
        }
          , T = u.bind(E);
        return T.listener = x,
        E.wrapFn = T,
        T
    }
    o.prototype.once = function(w, x) {
        return a(x),
        this.on(w, d(this, w, x)),
        this
    }
    ,
    o.prototype.prependOnceListener = function(w, x) {
        return a(x),
        this.prependListener(w, d(this, w, x)),
        this
    }
    ,
    o.prototype.removeListener = function(w, x) {
        var E, T, k, A, O;
        if (a(x),
        T = this._events,
        T === void 0)
            return this;
        if (E = T[w],
        E === void 0)
            return this;
        if (E === x || E.listener === x)
            --this._eventsCount === 0 ? this._events = Object.create(null) : (delete T[w],
            T.removeListener && this.emit("removeListener", w, E.listener || x));
        else if (typeof E != "function") {
            for (k = -1,
            A = E.length - 1; A >= 0; A--)
                if (E[A] === x || E[A].listener === x) {
                    O = E[A].listener,
                    k = A;
                    break
                }
            if (k < 0)
                return this;
            k === 0 ? E.shift() : v(E, k),
            E.length === 1 && (T[w] = E[0]),
            T.removeListener !== void 0 && this.emit("removeListener", w, O || x)
        }
        return this
    }
    ,
    o.prototype.off = o.prototype.removeListener,
    o.prototype.removeAllListeners = function(w) {
        var x, E, T;
        if (E = this._events,
        E === void 0)
            return this;
        if (E.removeListener === void 0)
            return arguments.length === 0 ? (this._events = Object.create(null),
            this._eventsCount = 0) : E[w] !== void 0 && (--this._eventsCount === 0 ? this._events = Object.create(null) : delete E[w]),
            this;
        if (arguments.length === 0) {
            var k = Object.keys(E), A;
            for (T = 0; T < k.length; ++T)
                A = k[T],
                A !== "removeListener" && this.removeAllListeners(A);
            return this.removeAllListeners("removeListener"),
            this._events = Object.create(null),
            this._eventsCount = 0,
            this
        }
        if (x = E[w],
        typeof x == "function")
            this.removeListener(w, x);
        else if (x !== void 0)
            for (T = x.length - 1; T >= 0; T--)
                this.removeListener(w, x[T]);
        return this
    }
    ;
    function f(C, w, x) {
        var E = C._events;
        if (E === void 0)
            return [];
        var T = E[w];
        return T === void 0 ? [] : typeof T == "function" ? x ? [T.listener || T] : [T] : x ? _(T) : m(T, T.length)
    }
    o.prototype.listeners = function(w) {
        return f(this, w, !0)
    }
    ,
    o.prototype.rawListeners = function(w) {
        return f(this, w, !1)
    }
    ,
    o.listenerCount = function(C, w) {
        return typeof C.listenerCount == "function" ? C.listenerCount(w) : p.call(C, w)
    }
    ,
    o.prototype.listenerCount = p;
    function p(C) {
        var w = this._events;
        if (w !== void 0) {
            var x = w[C];
            if (typeof x == "function")
                return 1;
            if (x !== void 0)
                return x.length
        }
        return 0
    }
    o.prototype.eventNames = function() {
        return this._eventsCount > 0 ? n(this._events) : []
    }
    ;
    function m(C, w) {
        for (var x = new Array(w), E = 0; E < w; ++E)
            x[E] = C[E];
        return x
    }
    function v(C, w) {
        for (; w + 1 < C.length; w++)
            C[w] = C[w + 1];
        C.pop()
    }
    function _(C) {
        for (var w = new Array(C.length), x = 0; x < w.length; ++x)
            w[x] = C[x].listener || C[x];
        return w
    }
    function y(C, w) {
        return new Promise(function(x, E) {
            function T(A) {
                C.removeListener(w, k),
                E(A)
            }
            function k() {
                typeof C.removeListener == "function" && C.removeListener("error", T),
                x([].slice.call(arguments))
            }
            S(C, w, k, {
                once: !0
            }),
            w !== "error" && b(C, T, {
                once: !0
            })
        }
        )
    }
    function b(C, w, x) {
        typeof C.on == "function" && S(C, "error", w, x)
    }
    function S(C, w, x, E) {
        if (typeof C.on == "function")
            E.once ? C.once(w, x) : C.on(w, x);
        else if (typeof C.addEventListener == "function")
            C.addEventListener(w, function T(k) {
                E.once && C.removeEventListener(w, T),
                x(k)
            });
        else
            throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof C)
    }
    return gp.exports
}
var ule = cle();
const dle = mn(ule);
class Lw {
    emitter = new dle;
    constructor() {
        this.emitter.setMaxListeners(1e3)
    }
    on(t, n) {
        return this.emitter.on(t, n),
        () => {
            this.emitter.off(t, n)
        }
    }
    off(t, n) {
        this.emitter.off(t, n)
    }
    publish(t) {
        this.emitter.emit(t.kind, t),
        this.emitter.emit("anyEvent", t)
    }
}
const du = new Lw;
var hy, fT;
function fle() {
    if (fT)
        return hy;
    fT = 1;
    function e(t) {
        for (var n = -1, r = t == null ? 0 : t.length, s = 0, o = []; ++n < r; ) {
            var i = t[n];
            i && (o[s++] = i)
        }
        return o
    }
    return hy = e,
    hy
}
var hle = fle();
const Lj = mn(hle)
  , ple = "text/plain"
  , mle = "us-ascii"
  , py = (e, t) => t.some(n => n instanceof RegExp ? n.test(e) : n === e)
  , gle = new Set(["https:", "http:", "file:"])
  , vle = e => {
    try {
        const {protocol: t} = new URL(e);
        return t.endsWith(":") && !t.includes(".") && !gle.has(t)
    } catch {
        return !1
    }
}
  , _le = (e, {stripHash: t}) => {
    const n = /^data:(?<type>[^,]*?),(?<data>[^#]*?)(?:#(?<hash>.*))?$/.exec(e);
    if (!n)
        throw new Error(`Invalid URL: ${e}`);
    let {type: r, data: s, hash: o} = n.groups;
    const i = r.split(";");
    o = t ? "" : o;
    let a = !1;
    i[i.length - 1] === "base64" && (i.pop(),
    a = !0);
    const l = i.shift()?.toLowerCase() ?? ""
      , u = [...i.map(d => {
        let[f,p=""] = d.split("=").map(m => m.trim());
        return f === "charset" && (p = p.toLowerCase(),
        p === mle) ? "" : `${f}${p ? `=${p}` : ""}`
    }
    ).filter(Boolean)];
    return a && u.push("base64"),
    (u.length > 0 || l && l !== ple) && u.unshift(l),
    `data:${u.join(";")},${a ? s.trim() : s}${o ? `#${o}` : ""}`
}
;
function yle(e, t) {
    if (t = {
        defaultProtocol: "http",
        normalizeProtocol: !0,
        forceHttp: !1,
        forceHttps: !1,
        stripAuthentication: !0,
        stripHash: !1,
        stripTextFragment: !0,
        stripWWW: !0,
        removeQueryParameters: [/^utm_\w+/i],
        removeTrailingSlash: !0,
        removeSingleSlash: !0,
        removeDirectoryIndex: !1,
        removeExplicitPort: !1,
        sortQueryParameters: !0,
        ...t
    },
    typeof t.defaultProtocol == "string" && !t.defaultProtocol.endsWith(":") && (t.defaultProtocol = `${t.defaultProtocol}:`),
    e = e.trim(),
    /^data:/i.test(e))
        return _le(e, t);
    if (vle(e))
        return e;
    const n = e.startsWith("//");
    !n && /^\.*\//.test(e) || (e = e.replace(/^(?!(?:\w+:)?\/\/)|^\/\//, t.defaultProtocol));
    const s = new URL(e);
    if (t.forceHttp && t.forceHttps)
        throw new Error("The `forceHttp` and `forceHttps` options cannot be used together");
    if (t.forceHttp && s.protocol === "https:" && (s.protocol = "http:"),
    t.forceHttps && s.protocol === "http:" && (s.protocol = "https:"),
    t.stripAuthentication && (s.username = "",
    s.password = ""),
    t.stripHash ? s.hash = "" : t.stripTextFragment && (s.hash = s.hash.replace(/#?:~:text.*?$/i, "")),
    s.pathname) {
        const i = /\b[a-z][a-z\d+\-.]{1,50}:\/\//g;
        let a = 0
          , l = "";
        for (; ; ) {
            const u = i.exec(s.pathname);
            if (!u)
                break;
            const d = u[0]
              , f = u.index
              , p = s.pathname.slice(a, f);
            l += p.replace(/\/{2,}/g, "/"),
            l += d,
            a = f + d.length
        }
        const c = s.pathname.slice(a, s.pathname.length);
        l += c.replace(/\/{2,}/g, "/"),
        s.pathname = l
    }
    if (s.pathname)
        try {
            s.pathname = decodeURI(s.pathname).replace(/\\/g, "%5C")
        } catch {}
    if (t.removeDirectoryIndex === !0 && (t.removeDirectoryIndex = [/^index\.[a-z]+$/]),
    Array.isArray(t.removeDirectoryIndex) && t.removeDirectoryIndex.length > 0) {
        let i = s.pathname.split("/");
        const a = i[i.length - 1];
        py(a, t.removeDirectoryIndex) && (i = i.slice(0, -1),
        s.pathname = i.slice(1).join("/") + "/")
    }
    if (s.hostname && (s.hostname = s.hostname.replace(/\.$/, ""),
    t.stripWWW && /^www\.(?!www\.)[a-z\-\d]{1,63}\.[a-z.\-\d]{2,63}$/.test(s.hostname) && (s.hostname = s.hostname.replace(/^www\./, ""))),
    Array.isArray(t.removeQueryParameters))
        for (const i of [...s.searchParams.keys()])
            py(i, t.removeQueryParameters) && s.searchParams.delete(i);
    if (!Array.isArray(t.keepQueryParameters) && t.removeQueryParameters === !0 && (s.search = ""),
    Array.isArray(t.keepQueryParameters) && t.keepQueryParameters.length > 0)
        for (const i of [...s.searchParams.keys()])
            py(i, t.keepQueryParameters) || s.searchParams.delete(i);
    if (t.sortQueryParameters) {
        s.searchParams.sort();
        try {
            s.search = decodeURIComponent(s.search)
        } catch {}
    }
    t.removeTrailingSlash && (s.pathname = s.pathname.replace(/\/$/, "")),
    t.removeExplicitPort && s.port && (s.port = "");
    const o = e;
    return e = s.toString(),
    !t.removeSingleSlash && s.pathname === "/" && !o.endsWith("/") && s.hash === "" && (e = e.replace(/\/$/, "")),
    (t.removeTrailingSlash || s.pathname === "/") && s.hash === "" && t.removeSingleSlash && (e = e.replace(/\/$/, "")),
    n && !t.normalizeProtocol && (e = e.replace(/^http:\/\//, "//")),
    t.stripProtocol && (e = e.replace(/^(?:https?:)?\/\//, "")),
    e
}
const ble = {}
  , Cle = e => (t, n, r) => {
    const s = r.subscribe;
    return r.subscribe = (i, a, l) => {
        let c = i;
        if (a) {
            const u = l?.equalityFn || Object.is;
            let d = i(r.getState());
            c = f => {
                const p = i(f);
                if (!u(d, p)) {
                    const m = d;
                    a(d = p, m)
                }
            }
            ,
            l?.fireImmediately && a(d, d)
        }
        return s(c)
    }
    ,
    e(t, n, r)
}
  , Sle = Cle;
function wle(e, t) {
    let n;
    try {
        n = e()
    } catch {
        return
    }
    return {
        getItem: s => {
            var o;
            const i = l => l === null ? null : JSON.parse(l, void 0)
              , a = (o = n.getItem(s)) != null ? o : null;
            return a instanceof Promise ? a.then(i) : i(a)
        }
        ,
        setItem: (s, o) => n.setItem(s, JSON.stringify(o, void 0)),
        removeItem: s => n.removeItem(s)
    }
}
const xf = e => t => {
    try {
        const n = e(t);
        return n instanceof Promise ? n : {
            then(r) {
                return xf(r)(n)
            },
            catch(r) {
                return this
            }
        }
    } catch (n) {
        return {
            then(r) {
                return this
            },
            catch(r) {
                return xf(r)(n)
            }
        }
    }
}
  , Ele = (e, t) => (n, r, s) => {
    let o = {
        getStorage: () => localStorage,
        serialize: JSON.stringify,
        deserialize: JSON.parse,
        partialize: _ => _,
        version: 0,
        merge: (_, y) => ({
            ...y,
            ..._
        }),
        ...t
    }
      , i = !1;
    const a = new Set
      , l = new Set;
    let c;
    try {
        c = o.getStorage()
    } catch {}
    if (!c)
        return e( (..._) => {
            console.warn(`[zustand persist middleware] Unable to update item '${o.name}', the given storage is currently unavailable.`),
            n(..._)
        }
        , r, s);
    const u = xf(o.serialize)
      , d = () => {
        const _ = o.partialize({
            ...r()
        });
        let y;
        const b = u({
            state: _,
            version: o.version
        }).then(S => c.setItem(o.name, S)).catch(S => {
            y = S
        }
        );
        if (y)
            throw y;
        return b
    }
      , f = s.setState;
    s.setState = (_, y) => {
        f(_, y),
        d()
    }
    ;
    const p = e( (..._) => {
        n(..._),
        d()
    }
    , r, s);
    let m;
    const v = () => {
        var _;
        if (!c)
            return;
        i = !1,
        a.forEach(b => b(r()));
        const y = ((_ = o.onRehydrateStorage) == null ? void 0 : _.call(o, r())) || void 0;
        return xf(c.getItem.bind(c))(o.name).then(b => {
            if (b)
                return o.deserialize(b)
        }
        ).then(b => {
            if (b)
                if (typeof b.version == "number" && b.version !== o.version) {
                    if (o.migrate)
                        return o.migrate(b.state, b.version);
                    console.error("State loaded from storage couldn't be migrated since no migrate function was provided")
                } else
                    return b.state
        }
        ).then(b => {
            var S;
            return m = o.merge(b, (S = r()) != null ? S : p),
            n(m, !0),
            d()
        }
        ).then( () => {
            y?.(m, void 0),
            i = !0,
            l.forEach(b => b(m))
        }
        ).catch(b => {
            y?.(void 0, b)
        }
        )
    }
    ;
    return s.persist = {
        setOptions: _ => {
            o = {
                ...o,
                ..._
            },
            _.getStorage && (c = _.getStorage())
        }
        ,
        clearStorage: () => {
            c?.removeItem(o.name)
        }
        ,
        getOptions: () => o,
        rehydrate: () => v(),
        hasHydrated: () => i,
        onHydrate: _ => (a.add(_),
        () => {
            a.delete(_)
        }
        ),
        onFinishHydration: _ => (l.add(_),
        () => {
            l.delete(_)
        }
        )
    },
    v(),
    m || p
}
  , xle = (e, t) => (n, r, s) => {
    let o = {
        storage: wle( () => localStorage),
        partialize: v => v,
        version: 0,
        merge: (v, _) => ({
            ..._,
            ...v
        }),
        ...t
    }
      , i = !1;
    const a = new Set
      , l = new Set;
    let c = o.storage;
    if (!c)
        return e( (...v) => {
            console.warn(`[zustand persist middleware] Unable to update item '${o.name}', the given storage is currently unavailable.`),
            n(...v)
        }
        , r, s);
    const u = () => {
        const v = o.partialize({
            ...r()
        });
        return c.setItem(o.name, {
            state: v,
            version: o.version
        })
    }
      , d = s.setState;
    s.setState = (v, _) => {
        d(v, _),
        u()
    }
    ;
    const f = e( (...v) => {
        n(...v),
        u()
    }
    , r, s);
    s.getInitialState = () => f;
    let p;
    const m = () => {
        var v, _;
        if (!c)
            return;
        i = !1,
        a.forEach(b => {
            var S;
            return b((S = r()) != null ? S : f)
        }
        );
        const y = ((_ = o.onRehydrateStorage) == null ? void 0 : _.call(o, (v = r()) != null ? v : f)) || void 0;
        return xf(c.getItem.bind(c))(o.name).then(b => {
            if (b)
                if (typeof b.version == "number" && b.version !== o.version) {
                    if (o.migrate)
                        return o.migrate(b.state, b.version);
                    console.error("State loaded from storage couldn't be migrated since no migrate function was provided")
                } else
                    return b.state
        }
        ).then(b => {
            var S;
            return p = o.merge(b, (S = r()) != null ? S : f),
            n(p, !0),
            u()
        }
        ).then( () => {
            y?.(p, void 0),
            p = r(),
            i = !0,
            l.forEach(b => b(p))
        }
        ).catch(b => {
            y?.(void 0, b)
        }
        )
    }
    ;
    return s.persist = {
        setOptions: v => {
            o = {
                ...o,
                ...v
            },
            v.storage && (c = v.storage)
        }
        ,
        clearStorage: () => {
            c?.removeItem(o.name)
        }
        ,
        getOptions: () => o,
        rehydrate: () => m(),
        hasHydrated: () => i,
        onHydrate: v => (a.add(v),
        () => {
            a.delete(v)
        }
        ),
        onFinishHydration: v => (l.add(v),
        () => {
            l.delete(v)
        }
        )
    },
    o.skipHydration || m(),
    p || f
}
  , Tle = (e, t) => "getStorage"in t || "serialize"in t || "deserialize"in t ? ((ble ? "production" : void 0) !== "production" && console.warn("[DEPRECATED] `getStorage`, `serialize` and `deserialize` options are deprecated. Use `storage` option instead."),
Ele(e, t)) : xle(e, t)
  , Fj = Tle;
function kle(e, t) {
    if (Object.is(e, t))
        return !0;
    if (typeof e != "object" || e === null || typeof t != "object" || t === null)
        return !1;
    if (e instanceof Map && t instanceof Map) {
        if (e.size !== t.size)
            return !1;
        for (const [r,s] of e)
            if (!Object.is(s, t.get(r)))
                return !1;
        return !0
    }
    if (e instanceof Set && t instanceof Set) {
        if (e.size !== t.size)
            return !1;
        for (const r of e)
            if (!t.has(r))
                return !1;
        return !0
    }
    const n = Object.keys(e);
    if (n.length !== Object.keys(t).length)
        return !1;
    for (const r of n)
        if (!Object.prototype.hasOwnProperty.call(t, r) || !Object.is(e[r], t[r]))
            return !1;
    return !0
}
function jj(e, t) {
    return e.findNode(n => Uj(n, t), t)?.children ?? Ale
}
function Ole(e, t) {
    return jj(e, t).find(n => n === t || n === e.findNode(r => r.id === n || Uj(r, t), t)?.id)
}
function Uj(e, t) {
    return e.id !== t && (e.children.length > 1 || !Ca(e.message))
}
const Ale = Object.freeze([]);
function HTe() {
    return `${T6}${Ts()}`
}
let Mle = 0;
function Bj() {
    return Mle++
}
function hh(e) {
    return e.startsWith(T6)
}
const qj = () => Hs.emptyTree()
  , Ile = Object.freeze({});
var Fw = (e => (e.NewChat = "NewChat",
e.Server = "Server",
e.User = "User",
e.Generated = "Generated",
e.Unknown = "Unknown",
e))(Fw || {});
const Fs = {};
function Rle(e, t) {
    Fs[e] && (clearTimeout(Fs[e]),
    delete Fs[e]);
    const n = 3e4;
    Fs[e] = setTimeout( () => {
        const r = zs();
        if (r.threads[e] == null) {
            clearTimeout(Fs[e]),
            delete Fs[e];
            return
        }
        if ((r.threadRetainCounts[e] ?? 0) > 0) {
            clearTimeout(Fs[e]),
            delete Fs[e];
            return
        }
        Du.deleteThread(e),
        clearTimeout(Fs[e]),
        delete Fs[e]
    }
    , n)
}
function Nle(e) {
    return e
}
const Ple = Nle
  , ph = dn(Ple(Da( () => ({
    threads: {},
    clientNewThreadIdToServerIdMapping: {},
    threadRetainCounts: {}
}))))
  , zs = ph.getState
  , al = ph.setState;
function to(e, t=zs()) {
    return hh(e) ? t.clientNewThreadIdToServerIdMapping[e] : e
}
function zTe(e, t=zs()) {
    return Object.entries(t.clientNewThreadIdToServerIdMapping).find( ([r,s]) => s === e)?.[0] ?? e
}
const Dle = e => ph(t => e ? to(e, t) : void 0);
function $Te(e, t=zs()) {
    for (const [n,r] of Object.entries(t.clientNewThreadIdToServerIdMapping))
        if (r === e)
            return n
}
function A5(e, t=zs()) {
    return t.clientNewThreadIdToServerIdMapping[e] ?? e
}
function sn(e, t=zs()) {
    const n = A5(e, t);
    return t.threads[n]
}
function Lle(e, t) {
    const n = h.useRef(void 0);
    return h.useMemo( () => [], [t.clientThreadId]),
    r => {
        const s = e(r);
        return kle(n.current, s) || (n.current = s),
        n.current
    }
}
function Ai(e, t, n) {
    return ph(Lle(r => t(e && sn(e, r)), {
        disablePerfDetector: n?.disablePerfDetector === !0,
        clientThreadId: e
    }))
}
function kt(e, t) {
    al(n => {
        const r = sn(e, n);
        r && t(r)
    }
    )
}
const Fle = ["utm_source"]
  , hT = e => {
    try {
        return yle(e, {
            stripWWW: !1,
            removeTrailingSlash: !0,
            sortQueryParameters: !0,
            removeQueryParameters: Fle
        })
    } catch {
        return e
    }
}
  , jle = e => (e?.search_result_groups ?? []).flatMap(t => t.entries ?? []).map(t => t?.url)
  , Ce = {
    getGizmoId: e => e?.mode.kind === cn.GizmoInteraction || e?.mode.kind === cn.GizmoTest ? e.mode.gizmo_id : void 0,
    getTree: e => e?.tree ?? qj(),
    getBranch: (e, t=Ce.getCurrentLeafId(e)) => e?.tree.getBranchFromLeaf(t) ?? [],
    getThreadTitleSource: e => e?.titleSource ?? "Unknown",
    getThreadCreateTime: e => e?.createTime,
    getIsNewConversation: e => Ce.getCurrentLeafId(e) === Ce.getTree(e).rootId,
    getCurrentLeafId: e => e?.currentLeafId ?? Ce.getTree(e).rootId,
    getCurrentNode: e => Ce.getNode(e, Ce.getCurrentLeafId(e)),
    getNode: (e, t) => Ce.getTree(e).getNodeByIdOrMessageId(t),
    getParentNode: (e, t) => Ce.getTree(e).getParent(t),
    getParentPromptNode: (e, t=Ce.getCurrentLeafId(e)) => Ce.findNode(e, n => GL(n.message), t),
    getAsyncTurns: e => e?.asyncTurns ?? Ile,
    isThreadUrlSafe: (e, t) => e?.safeUrls.map(n => hT(n)).includes(hT(t)) ?? !1,
    getTurnContentReferences: (e, t) => Lj(Ce.getConversationTurnAtIndex(e, t).messages.flatMap(qle) ?? []),
    isArchived: e => e?.isArchived ?? !1,
    isStarred: e => e?.isStarred ?? !1,
    getUpdateTime: e => e?.update_time ?? (e?.createTime ? e.createTime.getTime() / 1e3 : null),
    hasUserMessage: e => Ce.findNode(e, t => Vc(t.message)) != null,
    lastUserMessage: e => Ce.findNode(e, t => Vc(t.message))?.message ?? null,
    firstUserMessage: e => Ce.findFirstFromLeaf(e, t => Vc(t.message))?.message ?? null,
    isLastActorMessage: (e, t) => Ce.getTree(e).findNode(n => n.message.author.role === Ke.Assistant || n.message.author.role === Ke.User || n.message.author.role === Ke.Tool && n.message.author.name === bl.A8KM123, Ce.getCurrentLeafId(e), t) == null,
    findNode: (e, t, n=Ce.getCurrentLeafId(e)) => Ce.getTree(e).findNode(t, n),
    findFirstFromLeaf(e, t, n=Ce.getCurrentLeafId(e)) {
        return Ce.getTree(e).findFirstFromLeaf(t, n)
    },
    isMessageTurnEnded: (e, t=Ce.getCurrentLeafId(e)) => e?.tree.getNodeByIdOrMessageId(t).message.end_turn ?? !1,
    getConversationTurns: (e, t=Ce.getCurrentLeafId(e)) => XL(Ce.getTree(e), t, !1),
    getConversationTurnIds: e => Ule(Ce.getConversationTurns(e)),
    getConversationTurnAtIndex: (e, t, n=Ce.getCurrentLeafId(e)) => {
        const r = Ce.getConversationTurns(e, n);
        if (t >= r.length)
            throw new Error(`Turn index ${t} out of bounds`);
        return r[t]
    }
    ,
    getConversationLastTurn: (e, t=Ce.getCurrentLeafId(e)) => Iu(Ce.getConversationTurns(e, t)),
    getConversationSearchEntryUrls: (e, t=Ce.getCurrentLeafId(e)) => Ce.getConversationTurns(e, t).flatMap(n => n.messages).flatMap(n => jle(n?.metadata)),
    hasUserContextPrompt: e => Ce.getTree(e).findFirst(t => t.message.metadata?.is_user_system_message != null) != null || e?.sharedConversationMetadata?.hasUserEditableContextFlag != null,
    hasModelEditableContext: e => Ce.findNode(e, t => t.message.content.content_type === "model_editable_context") != null,
    hasRecentPIMWarning: e => {
        const t = e?.tree.getBranchFromLeaf(e.currentLeafId);
        if (!t)
            return !1;
        for (let n = t.length - 1; n >= 0; n--) {
            if (t[n].message.author.role === Ke.User)
                return !1;
            if (t[n].message.metadata?.is_pim_warning)
                return !0
        }
        return !1
    }
    ,
    getRequestId: (e, t=Ce.getCurrentLeafId(e)) => Ce.findNode(e, n => n.message.clientMetadata?.requestId != null, t)?.message.clientMetadata?.requestId,
    getLastMessageSystemHints: e => Ce.findNode(e, n => Vc(n.message))?.message.metadata?.system_hints ?? [],
    getVariantIds: (e, t=Ce.getCurrentLeafId(e)) => jj(Ce.getTree(e), t),
    getCurrentVariantId: (e, t=Ce.getCurrentLeafId(e)) => Ole(Ce.getTree(e), t),
    getIsDoNotRemember: e => e?.is_do_not_remember ?? !1,
    getSuperWidgetMessages: (e, t) => (t != null ? Ce.getConversationTurnAtIndex(e, t).messages : Ce.getConversationTurns(e).flatMap(r => r.messages)).filter(r => r.content.content_type === "super_widget"),
    getUserMessages: e => Ce.getConversationTurns(e).flatMap(t => t.messages).filter(Vc),
    isReasoningResponseMessage: (e, t) => {
        const n = Ce.getParentNode(e, t)?.message;
        return n != null && VL(n)
    }
    ,
    isUsingPromptTemplate: e => e?.isUsingPromptTemplate ?? !1
};
let pT = 0, mT, gT = [];
function Ule(e) {
    const t = e.length
      , n = Iu(e)?.id;
    return (pT !== t || mT !== n) && (pT = t,
    mT = n,
    gT = e.map(r => r.id)),
    gT
}
const kr = {
    updateTree(e, t) {
        const n = t(e.tree, Ce.getCurrentLeafId(e));
        e._treeVersion++,
        n && (e.currentLeafId = n)
    },
    setCurrentBranch(e, t) {
        kr.updateTree(e, n => n.getLeafFromNode(t).id)
    },
    appendMessage(e, t) {
        kr.updateTree(e, (n, r) => n.addMessageNode(r, t))
    },
    setRequestIdOnCurrentLeaf(e, t) {
        kr.updateTree(e, (n, r) => {
            n.updateNodeMetadata(r, {
                requestId: t
            })
        }
        )
    }
}
  , Du = {
    initThread: ({clientThreadId: e, conversationMode: t, modelId: n=null, userId: r=void 0, accountId: s=void 0}) => {
        const o = A5(e);
        zs().threads[o] == null && al(i => {
            const a = Hs.emptyTree();
            i.threads[o] = {
                createTime: new Date,
                isArchived: !1,
                isStarred: !1,
                mode: c5(t),
                modelId: n,
                tree: a,
                _treeVersion: 0,
                title: null,
                conduitToken: null,
                prepareState: null,
                lastPrepareTimestamp: null,
                stopConduitToken: null,
                titleSource: "NewChat",
                currentLeafId: a.rootId,
                safeUrls: [],
                selectedSources: rle({
                    userId: r,
                    workspaceId: s
                }),
                selectedMCPSources: ile({
                    userId: r,
                    workspaceId: s
                }),
                startedWithMcp: void 0,
                hasRemovedWebSource: !1,
                hasModifiedSources: !1,
                isLoading: !hh(o),
                docsReferencedByURL: {},
                conversationOrigin: null,
                selectedGithubRepos: new Map,
                hasModifiedGithubRepos: !1,
                disabledToolIds: null,
                is_do_not_remember: !1,
                prepareRequestBlocked: !1,
                lastCompletionFinishedTimestamp: null,
                interruptionInProgress: !1,
                asyncTurns: {},
                isUsingPromptTemplate: !1
            }
        }
        )
    }
    ,
    setServerIdForNewThread: (e, t) => {
        zs().clientNewThreadIdToServerIdMapping[e] === void 0 && al(n => {
            n.threads[t] = n.threads[e],
            delete n.threads[e],
            n.clientNewThreadIdToServerIdMapping[e] = t
        }
        )
    }
    ,
    updateThreadFromServer: (e, t, n={}) => {
        const r = A5(e)
          , {skipIfExisting: s, continuingFromSharedConversationId: o, continuingFromSharedProjectConversationId: i, sharedProjectConversationOwnerId: a, continuingFromSharedPostId: l, forkFromSharedPost: c, branchingFromConversationId: u, branchingFromMessageId: d, modelId: f} = n;
        if (s && zs().threads[r]?.isLoading === !1)
            return;
        const p = lle(t, r)
          , m = new Hs(p.nodes)
          , v = p.initialCurrentLeafId ?? m.rootId
          , _ = "has_user_editable_context"in t ? {
            hasUserEditableContextFlag: t.has_user_editable_context,
            authorName: t.author_name,
            model: "model"in t && t.model != null ? cF(t.model) : void 0
        } : void 0;
        let y;
        {
            const b = m.getBranchFromLeaf(v);
            for (const S of b) {
                const C = S.message;
                if (C.author.role !== Ke.User)
                    continue;
                y = (C.metadata?.selected_mcp_sources ?? []).length > 0;
                break
            }
        }
        al(b => {
            const S = b.threads[r];
            b.threads[r] = {
                createTime: "create_time"in t ? new Date(t.create_time * 1e3) : void 0,
                isArchived: t.is_archived ?? !1,
                isStarred: t.is_starred ?? !1,
                is_do_not_remember: t.is_do_not_remember ?? !1,
                selectedSources: S?.selectedSources,
                selectedMCPSources: S?.selectedMCPSources,
                startedWithMcp: S?.startedWithMcp ?? y,
                mentionedSources: S?.mentionedSources,
                selectedGithubRepos: S?.selectedGithubRepos ?? new Map,
                hasModifiedGithubRepos: S?.hasModifiedGithubRepos ?? !1,
                modelId: S?.modelId ?? f ?? null,
                conduitToken: null,
                prepareState: null,
                lastPrepareTimestamp: null,
                stopConduitToken: null,
                mode: t.gizmo_id != null ? {
                    kind: cn.GizmoInteraction,
                    gizmo_id: t.gizmo_id
                } : {
                    kind: cn.PrimaryAssistant
                },
                sharedConversationMetadata: c5(_),
                title: t.title ?? null,
                titleSource: "Server",
                tree: m,
                _treeVersion: 0,
                currentLeafId: v,
                isLoading: !1,
                continuingFromSharedProjectConversationId: i,
                sharedProjectConversationOwner: ( () => {
                    const C = S?.sharedProjectConversationOwner
                      , w = a ?? t?.owner?.user_id ?? C?.id
                      , x = t?.owner?.name ?? C?.name;
                    return w != null || x != null ? {
                        id: w,
                        name: x
                    } : void 0
                }
                )(),
                continuingFromSharedConversationId: o,
                continuingFromSharedPostId: l,
                forkFromSharedPost: c,
                continuingSharedConversationLastMessageId: (o != null || i != null || l != null || c) && !u ? v : void 0,
                continuedFromSharedProjectConversation: S?.continuedFromSharedProjectConversation || (i != null ? !0 : void 0),
                branchingFromConversationId: u,
                branchingFromMessageId: d,
                safeUrls: t.safe_urls ?? [],
                hasRemovedWebSource: S?.hasRemovedWebSource ?? !1,
                hasModifiedSources: S?.hasModifiedSources ?? !1,
                docsReferencedByURL: S?.docsReferencedByURL ?? {},
                conversationOrigin: S?.conversationOrigin ?? t.conversation_origin ?? null,
                disabledToolIds: t.disabled_tool_ids ?? [],
                update_time: t.update_time ?? null,
                scrollToMessageId: S?.scrollToMessageId,
                prepareRequestBlocked: S?.prepareRequestBlocked ?? !1,
                lastCompletionFinishedTimestamp: S?.lastCompletionFinishedTimestamp ?? null,
                interruptionInProgress: !1,
                asyncTurns: {},
                isUsingPromptTemplate: S?.isUsingPromptTemplate ?? !1
            }
        }
        ),
        du.publish({
            kind: "createConversation",
            clientThreadId: e
        })
    }
    ,
    deleteThread: e => {
        al(t => {
            delete t.threads[e],
            delete t.clientNewThreadIdToServerIdMapping[e]
        }
        )
    }
    ,
    retainThread: e => {
        al(t => {
            t.threadRetainCounts[e] = (t.threadRetainCounts[e] ?? 0) + 1
        }
        ),
        clearTimeout(Fs[e])
    }
    ,
    releaseThread: e => {
        zs().threads[e] != null && (al(t => {
            t.threadRetainCounts[e] = Math.max((t.threadRetainCounts[e] ?? 0) - 1, 0)
        }
        ),
        !(zs().threadRetainCounts[e] > 0) && Rle(e))
    }
    ,
    resetThread: e => {
        kt(e, t => {
            t.tree = qj(),
            t.currentLeafId = t.tree.rootId
        }
        )
    }
}
  , Ble = e => {
    const t = lw();
    return Ai(e, n => n ? Ce.getGizmoId(n) : t)
}
;
function WTe({clientThreadId: e}) {
    return Ai(e, t => {
        if (!t)
            return !1;
        const n = t.tree.getBranchFromLeaf(t.currentLeafId);
        return n ? n.some(r => r.message.clientMetadata?.errCode === Mu.ContentPolicy && r.message.clientMetadata.shouldDisableConversation) : !1
    }
    )
}
function KTe({clientThreadId: e}) {
    return Ai(e, t => {
        if (!t)
            return !1;
        const n = t.tree.getBranchFromLeaf(t.currentLeafId);
        return n ? n.some(r => r.message.clientMetadata?.errCode === Mu.ContentPolicy && r.message.clientMetadata.isSafetyLimited) : !1
    }
    )
}
const YTe = e => e?.metadata?.search_result_groups ?? []
  , qle = e => e?.metadata?.content_references ?? [];
function Zn(e) {
    this.content = e
}
Zn.prototype = {
    constructor: Zn,
    find: function(e) {
        for (var t = 0; t < this.content.length; t += 2)
            if (this.content[t] === e)
                return t;
        return -1
    },
    get: function(e) {
        var t = this.find(e);
        return t == -1 ? void 0 : this.content[t + 1]
    },
    update: function(e, t, n) {
        var r = n && n != e ? this.remove(n) : this
          , s = r.find(e)
          , o = r.content.slice();
        return s == -1 ? o.push(n || e, t) : (o[s + 1] = t,
        n && (o[s] = n)),
        new Zn(o)
    },
    remove: function(e) {
        var t = this.find(e);
        if (t == -1)
            return this;
        var n = this.content.slice();
        return n.splice(t, 2),
        new Zn(n)
    },
    addToStart: function(e, t) {
        return new Zn([e, t].concat(this.remove(e).content))
    },
    addToEnd: function(e, t) {
        var n = this.remove(e).content.slice();
        return n.push(e, t),
        new Zn(n)
    },
    addBefore: function(e, t, n) {
        var r = this.remove(t)
          , s = r.content.slice()
          , o = r.find(e);
        return s.splice(o == -1 ? s.length : o, 0, t, n),
        new Zn(s)
    },
    forEach: function(e) {
        for (var t = 0; t < this.content.length; t += 2)
            e(this.content[t], this.content[t + 1])
    },
    prepend: function(e) {
        return e = Zn.from(e),
        e.size ? new Zn(e.content.concat(this.subtract(e).content)) : this
    },
    append: function(e) {
        return e = Zn.from(e),
        e.size ? new Zn(this.subtract(e).content.concat(e.content)) : this
    },
    subtract: function(e) {
        var t = this;
        e = Zn.from(e);
        for (var n = 0; n < e.content.length; n += 2)
            t = t.remove(e.content[n]);
        return t
    },
    toObject: function() {
        var e = {};
        return this.forEach(function(t, n) {
            e[t] = n
        }),
        e
    },
    get size() {
        return this.content.length >> 1
    }
};
Zn.from = function(e) {
    if (e instanceof Zn)
        return e;
    var t = [];
    if (e)
        for (var n in e)
            t.push(n, e[n]);
    return new Zn(t)
}
;
function Gj(e, t, n) {
    for (let r = 0; ; r++) {
        if (r == e.childCount || r == t.childCount)
            return e.childCount == t.childCount ? null : n;
        let s = e.child(r)
          , o = t.child(r);
        if (s == o) {
            n += s.nodeSize;
            continue
        }
        if (!s.sameMarkup(o))
            return n;
        if (s.isText && s.text != o.text) {
            for (let i = 0; s.text[i] == o.text[i]; i++)
                n++;
            return n
        }
        if (s.content.size || o.content.size) {
            let i = Gj(s.content, o.content, n + 1);
            if (i != null)
                return i
        }
        n += s.nodeSize
    }
}
function Vj(e, t, n, r) {
    for (let s = e.childCount, o = t.childCount; ; ) {
        if (s == 0 || o == 0)
            return s == o ? null : {
                a: n,
                b: r
            };
        let i = e.child(--s)
          , a = t.child(--o)
          , l = i.nodeSize;
        if (i == a) {
            n -= l,
            r -= l;
            continue
        }
        if (!i.sameMarkup(a))
            return {
                a: n,
                b: r
            };
        if (i.isText && i.text != a.text) {
            let c = 0
              , u = Math.min(i.text.length, a.text.length);
            for (; c < u && i.text[i.text.length - c - 1] == a.text[a.text.length - c - 1]; )
                c++,
                n--,
                r--;
            return {
                a: n,
                b: r
            }
        }
        if (i.content.size || a.content.size) {
            let c = Vj(i.content, a.content, n - 1, r - 1);
            if (c)
                return c
        }
        n -= l,
        r -= l
    }
}
class pe {
    constructor(t, n) {
        if (this.content = t,
        this.size = n || 0,
        n == null)
            for (let r = 0; r < t.length; r++)
                this.size += t[r].nodeSize
    }
    nodesBetween(t, n, r, s=0, o) {
        for (let i = 0, a = 0; a < n; i++) {
            let l = this.content[i]
              , c = a + l.nodeSize;
            if (c > t && r(l, s + a, o || null, i) !== !1 && l.content.size) {
                let u = a + 1;
                l.nodesBetween(Math.max(0, t - u), Math.min(l.content.size, n - u), r, s + u)
            }
            a = c
        }
    }
    descendants(t) {
        this.nodesBetween(0, this.size, t)
    }
    textBetween(t, n, r, s) {
        let o = ""
          , i = !0;
        return this.nodesBetween(t, n, (a, l) => {
            let c = a.isText ? a.text.slice(Math.max(t, l) - l, n - l) : a.isLeaf ? s ? typeof s == "function" ? s(a) : s : a.type.spec.leafText ? a.type.spec.leafText(a) : "" : "";
            a.isBlock && (a.isLeaf && c || a.isTextblock) && r && (i ? i = !1 : o += r),
            o += c
        }
        , 0),
        o
    }
    append(t) {
        if (!t.size)
            return this;
        if (!this.size)
            return t;
        let n = this.lastChild
          , r = t.firstChild
          , s = this.content.slice()
          , o = 0;
        for (n.isText && n.sameMarkup(r) && (s[s.length - 1] = n.withText(n.text + r.text),
        o = 1); o < t.content.length; o++)
            s.push(t.content[o]);
        return new pe(s,this.size + t.size)
    }
    cut(t, n=this.size) {
        if (t == 0 && n == this.size)
            return this;
        let r = []
          , s = 0;
        if (n > t)
            for (let o = 0, i = 0; i < n; o++) {
                let a = this.content[o]
                  , l = i + a.nodeSize;
                l > t && ((i < t || l > n) && (a.isText ? a = a.cut(Math.max(0, t - i), Math.min(a.text.length, n - i)) : a = a.cut(Math.max(0, t - i - 1), Math.min(a.content.size, n - i - 1))),
                r.push(a),
                s += a.nodeSize),
                i = l
            }
        return new pe(r,s)
    }
    cutByIndex(t, n) {
        return t == n ? pe.empty : t == 0 && n == this.content.length ? this : new pe(this.content.slice(t, n))
    }
    replaceChild(t, n) {
        let r = this.content[t];
        if (r == n)
            return this;
        let s = this.content.slice()
          , o = this.size + n.nodeSize - r.nodeSize;
        return s[t] = n,
        new pe(s,o)
    }
    addToStart(t) {
        return new pe([t].concat(this.content),this.size + t.nodeSize)
    }
    addToEnd(t) {
        return new pe(this.content.concat(t),this.size + t.nodeSize)
    }
    eq(t) {
        if (this.content.length != t.content.length)
            return !1;
        for (let n = 0; n < this.content.length; n++)
            if (!this.content[n].eq(t.content[n]))
                return !1;
        return !0
    }
    get firstChild() {
        return this.content.length ? this.content[0] : null
    }
    get lastChild() {
        return this.content.length ? this.content[this.content.length - 1] : null
    }
    get childCount() {
        return this.content.length
    }
    child(t) {
        let n = this.content[t];
        if (!n)
            throw new RangeError("Index " + t + " out of range for " + this);
        return n
    }
    maybeChild(t) {
        return this.content[t] || null
    }
    forEach(t) {
        for (let n = 0, r = 0; n < this.content.length; n++) {
            let s = this.content[n];
            t(s, r, n),
            r += s.nodeSize
        }
    }
    findDiffStart(t, n=0) {
        return Gj(this, t, n)
    }
    findDiffEnd(t, n=this.size, r=t.size) {
        return Vj(this, t, n, r)
    }
    findIndex(t, n=-1) {
        if (t == 0)
            return vp(0, t);
        if (t == this.size)
            return vp(this.content.length, t);
        if (t > this.size || t < 0)
            throw new RangeError(`Position ${t} outside of fragment (${this})`);
        for (let r = 0, s = 0; ; r++) {
            let o = this.child(r)
              , i = s + o.nodeSize;
            if (i >= t)
                return i == t || n > 0 ? vp(r + 1, i) : vp(r, s);
            s = i
        }
    }
    toString() {
        return "<" + this.toStringInner() + ">"
    }
    toStringInner() {
        return this.content.join(", ")
    }
    toJSON() {
        return this.content.length ? this.content.map(t => t.toJSON()) : null
    }
    static fromJSON(t, n) {
        if (!n)
            return pe.empty;
        if (!Array.isArray(n))
            throw new RangeError("Invalid input for Fragment.fromJSON");
        return new pe(n.map(t.nodeFromJSON))
    }
    static fromArray(t) {
        if (!t.length)
            return pe.empty;
        let n, r = 0;
        for (let s = 0; s < t.length; s++) {
            let o = t[s];
            r += o.nodeSize,
            s && o.isText && t[s - 1].sameMarkup(o) ? (n || (n = t.slice(0, s)),
            n[n.length - 1] = o.withText(n[n.length - 1].text + o.text)) : n && n.push(o)
        }
        return new pe(n || t,r)
    }
    static from(t) {
        if (!t)
            return pe.empty;
        if (t instanceof pe)
            return t;
        if (Array.isArray(t))
            return this.fromArray(t);
        if (t.attrs)
            return new pe([t],t.nodeSize);
        throw new RangeError("Can not convert " + t + " to a Fragment" + (t.nodesBetween ? " (looks like multiple versions of prosemirror-model were loaded)" : ""))
    }
}
pe.empty = new pe([],0);
const my = {
    index: 0,
    offset: 0
};
function vp(e, t) {
    return my.index = e,
    my.offset = t,
    my
}
function zm(e, t) {
    if (e === t)
        return !0;
    if (!(e && typeof e == "object") || !(t && typeof t == "object"))
        return !1;
    let n = Array.isArray(e);
    if (Array.isArray(t) != n)
        return !1;
    if (n) {
        if (e.length != t.length)
            return !1;
        for (let r = 0; r < e.length; r++)
            if (!zm(e[r], t[r]))
                return !1
    } else {
        for (let r in e)
            if (!(r in t) || !zm(e[r], t[r]))
                return !1;
        for (let r in t)
            if (!(r in e))
                return !1
    }
    return !0
}
class Lt {
    constructor(t, n) {
        this.type = t,
        this.attrs = n
    }
    addToSet(t) {
        let n, r = !1;
        for (let s = 0; s < t.length; s++) {
            let o = t[s];
            if (this.eq(o))
                return t;
            if (this.type.excludes(o.type))
                n || (n = t.slice(0, s));
            else {
                if (o.type.excludes(this.type))
                    return t;
                !r && o.type.rank > this.type.rank && (n || (n = t.slice(0, s)),
                n.push(this),
                r = !0),
                n && n.push(o)
            }
        }
        return n || (n = t.slice()),
        r || n.push(this),
        n
    }
    removeFromSet(t) {
        for (let n = 0; n < t.length; n++)
            if (this.eq(t[n]))
                return t.slice(0, n).concat(t.slice(n + 1));
        return t
    }
    isInSet(t) {
        for (let n = 0; n < t.length; n++)
            if (this.eq(t[n]))
                return !0;
        return !1
    }
    eq(t) {
        return this == t || this.type == t.type && zm(this.attrs, t.attrs)
    }
    toJSON() {
        let t = {
            type: this.type.name
        };
        for (let n in this.attrs) {
            t.attrs = this.attrs;
            break
        }
        return t
    }
    static fromJSON(t, n) {
        if (!n)
            throw new RangeError("Invalid input for Mark.fromJSON");
        let r = t.marks[n.type];
        if (!r)
            throw new RangeError(`There is no mark type ${n.type} in this schema`);
        let s = r.create(n.attrs);
        return r.checkAttrs(s.attrs),
        s
    }
    static sameSet(t, n) {
        if (t == n)
            return !0;
        if (t.length != n.length)
            return !1;
        for (let r = 0; r < t.length; r++)
            if (!t[r].eq(n[r]))
                return !1;
        return !0
    }
    static setFrom(t) {
        if (!t || Array.isArray(t) && t.length == 0)
            return Lt.none;
        if (t instanceof Lt)
            return [t];
        let n = t.slice();
        return n.sort( (r, s) => r.type.rank - s.type.rank),
        n
    }
}
Lt.none = [];
class $m extends Error {
}
class Me {
    constructor(t, n, r) {
        this.content = t,
        this.openStart = n,
        this.openEnd = r
    }
    get size() {
        return this.content.size - this.openStart - this.openEnd
    }
    insertAt(t, n) {
        let r = zj(this.content, t + this.openStart, n);
        return r && new Me(r,this.openStart,this.openEnd)
    }
    removeBetween(t, n) {
        return new Me(Hj(this.content, t + this.openStart, n + this.openStart),this.openStart,this.openEnd)
    }
    eq(t) {
        return this.content.eq(t.content) && this.openStart == t.openStart && this.openEnd == t.openEnd
    }
    toString() {
        return this.content + "(" + this.openStart + "," + this.openEnd + ")"
    }
    toJSON() {
        if (!this.content.size)
            return null;
        let t = {
            content: this.content.toJSON()
        };
        return this.openStart > 0 && (t.openStart = this.openStart),
        this.openEnd > 0 && (t.openEnd = this.openEnd),
        t
    }
    static fromJSON(t, n) {
        if (!n)
            return Me.empty;
        let r = n.openStart || 0
          , s = n.openEnd || 0;
        if (typeof r != "number" || typeof s != "number")
            throw new RangeError("Invalid input for Slice.fromJSON");
        return new Me(pe.fromJSON(t, n.content),r,s)
    }
    static maxOpen(t, n=!0) {
        let r = 0
          , s = 0;
        for (let o = t.firstChild; o && !o.isLeaf && (n || !o.type.spec.isolating); o = o.firstChild)
            r++;
        for (let o = t.lastChild; o && !o.isLeaf && (n || !o.type.spec.isolating); o = o.lastChild)
            s++;
        return new Me(t,r,s)
    }
}
Me.empty = new Me(pe.empty,0,0);
function Hj(e, t, n) {
    let {index: r, offset: s} = e.findIndex(t)
      , o = e.maybeChild(r)
      , {index: i, offset: a} = e.findIndex(n);
    if (s == t || o.isText) {
        if (a != n && !e.child(i).isText)
            throw new RangeError("Removing non-flat range");
        return e.cut(0, t).append(e.cut(n))
    }
    if (r != i)
        throw new RangeError("Removing non-flat range");
    return e.replaceChild(r, o.copy(Hj(o.content, t - s - 1, n - s - 1)))
}
function zj(e, t, n, r) {
    let {index: s, offset: o} = e.findIndex(t)
      , i = e.maybeChild(s);
    if (o == t || i.isText)
        return e.cut(0, t).append(n).append(e.cut(t));
    let a = zj(i.content, t - o - 1, n);
    return a && e.replaceChild(s, i.copy(a))
}
function Gle(e, t, n) {
    if (n.openStart > e.depth)
        throw new $m("Inserted content deeper than insertion position");
    if (e.depth - n.openStart != t.depth - n.openEnd)
        throw new $m("Inconsistent open depths");
    return $j(e, t, n, 0)
}
function $j(e, t, n, r) {
    let s = e.index(r)
      , o = e.node(r);
    if (s == t.index(r) && r < e.depth - n.openStart) {
        let i = $j(e, t, n, r + 1);
        return o.copy(o.content.replaceChild(s, i))
    } else if (n.content.size)
        if (!n.openStart && !n.openEnd && e.depth == r && t.depth == r) {
            let i = e.parent
              , a = i.content;
            return Sl(i, a.cut(0, e.parentOffset).append(n.content).append(a.cut(t.parentOffset)))
        } else {
            let {start: i, end: a} = Vle(n, e);
            return Sl(o, Kj(e, i, a, t, r))
        }
    else
        return Sl(o, Wm(e, t, r))
}
function Wj(e, t) {
    if (!t.type.compatibleContent(e.type))
        throw new $m("Cannot join " + t.type.name + " onto " + e.type.name)
}
function M5(e, t, n) {
    let r = e.node(n);
    return Wj(r, t.node(n)),
    r
}
function Cl(e, t) {
    let n = t.length - 1;
    n >= 0 && e.isText && e.sameMarkup(t[n]) ? t[n] = e.withText(t[n].text + e.text) : t.push(e)
}
function ef(e, t, n, r) {
    let s = (t || e).node(n)
      , o = 0
      , i = t ? t.index(n) : s.childCount;
    e && (o = e.index(n),
    e.depth > n ? o++ : e.textOffset && (Cl(e.nodeAfter, r),
    o++));
    for (let a = o; a < i; a++)
        Cl(s.child(a), r);
    t && t.depth == n && t.textOffset && Cl(t.nodeBefore, r)
}
function Sl(e, t) {
    return e.type.checkContent(t),
    e.copy(t)
}
function Kj(e, t, n, r, s) {
    let o = e.depth > s && M5(e, t, s + 1)
      , i = r.depth > s && M5(n, r, s + 1)
      , a = [];
    return ef(null, e, s, a),
    o && i && t.index(s) == n.index(s) ? (Wj(o, i),
    Cl(Sl(o, Kj(e, t, n, r, s + 1)), a)) : (o && Cl(Sl(o, Wm(e, t, s + 1)), a),
    ef(t, n, s, a),
    i && Cl(Sl(i, Wm(n, r, s + 1)), a)),
    ef(r, null, s, a),
    new pe(a)
}
function Wm(e, t, n) {
    let r = [];
    if (ef(null, e, n, r),
    e.depth > n) {
        let s = M5(e, t, n + 1);
        Cl(Sl(s, Wm(e, t, n + 1)), r)
    }
    return ef(t, null, n, r),
    new pe(r)
}
function Vle(e, t) {
    let n = t.depth - e.openStart
      , s = t.node(n).copy(e.content);
    for (let o = n - 1; o >= 0; o--)
        s = t.node(o).copy(pe.from(s));
    return {
        start: s.resolveNoCache(e.openStart + n),
        end: s.resolveNoCache(s.content.size - e.openEnd - n)
    }
}
class Tf {
    constructor(t, n, r) {
        this.pos = t,
        this.path = n,
        this.parentOffset = r,
        this.depth = n.length / 3 - 1
    }
    resolveDepth(t) {
        return t == null ? this.depth : t < 0 ? this.depth + t : t
    }
    get parent() {
        return this.node(this.depth)
    }
    get doc() {
        return this.node(0)
    }
    node(t) {
        return this.path[this.resolveDepth(t) * 3]
    }
    index(t) {
        return this.path[this.resolveDepth(t) * 3 + 1]
    }
    indexAfter(t) {
        return t = this.resolveDepth(t),
        this.index(t) + (t == this.depth && !this.textOffset ? 0 : 1)
    }
    start(t) {
        return t = this.resolveDepth(t),
        t == 0 ? 0 : this.path[t * 3 - 1] + 1
    }
    end(t) {
        return t = this.resolveDepth(t),
        this.start(t) + this.node(t).content.size
    }
    before(t) {
        if (t = this.resolveDepth(t),
        !t)
            throw new RangeError("There is no position before the top-level node");
        return t == this.depth + 1 ? this.pos : this.path[t * 3 - 1]
    }
    after(t) {
        if (t = this.resolveDepth(t),
        !t)
            throw new RangeError("There is no position after the top-level node");
        return t == this.depth + 1 ? this.pos : this.path[t * 3 - 1] + this.path[t * 3].nodeSize
    }
    get textOffset() {
        return this.pos - this.path[this.path.length - 1]
    }
    get nodeAfter() {
        let t = this.parent
          , n = this.index(this.depth);
        if (n == t.childCount)
            return null;
        let r = this.pos - this.path[this.path.length - 1]
          , s = t.child(n);
        return r ? t.child(n).cut(r) : s
    }
    get nodeBefore() {
        let t = this.index(this.depth)
          , n = this.pos - this.path[this.path.length - 1];
        return n ? this.parent.child(t).cut(0, n) : t == 0 ? null : this.parent.child(t - 1)
    }
    posAtIndex(t, n) {
        n = this.resolveDepth(n);
        let r = this.path[n * 3]
          , s = n == 0 ? 0 : this.path[n * 3 - 1] + 1;
        for (let o = 0; o < t; o++)
            s += r.child(o).nodeSize;
        return s
    }
    marks() {
        let t = this.parent
          , n = this.index();
        if (t.content.size == 0)
            return Lt.none;
        if (this.textOffset)
            return t.child(n).marks;
        let r = t.maybeChild(n - 1)
          , s = t.maybeChild(n);
        if (!r) {
            let a = r;
            r = s,
            s = a
        }
        let o = r.marks;
        for (var i = 0; i < o.length; i++)
            o[i].type.spec.inclusive === !1 && (!s || !o[i].isInSet(s.marks)) && (o = o[i--].removeFromSet(o));
        return o
    }
    marksAcross(t) {
        let n = this.parent.maybeChild(this.index());
        if (!n || !n.isInline)
            return null;
        let r = n.marks
          , s = t.parent.maybeChild(t.index());
        for (var o = 0; o < r.length; o++)
            r[o].type.spec.inclusive === !1 && (!s || !r[o].isInSet(s.marks)) && (r = r[o--].removeFromSet(r));
        return r
    }
    sharedDepth(t) {
        for (let n = this.depth; n > 0; n--)
            if (this.start(n) <= t && this.end(n) >= t)
                return n;
        return 0
    }
    blockRange(t=this, n) {
        if (t.pos < this.pos)
            return t.blockRange(this);
        for (let r = this.depth - (this.parent.inlineContent || this.pos == t.pos ? 1 : 0); r >= 0; r--)
            if (t.pos <= this.end(r) && (!n || n(this.node(r))))
                return new $le(this,t,r);
        return null
    }
    sameParent(t) {
        return this.pos - this.parentOffset == t.pos - t.parentOffset
    }
    max(t) {
        return t.pos > this.pos ? t : this
    }
    min(t) {
        return t.pos < this.pos ? t : this
    }
    toString() {
        let t = "";
        for (let n = 1; n <= this.depth; n++)
            t += (t ? "/" : "") + this.node(n).type.name + "_" + this.index(n - 1);
        return t + ":" + this.parentOffset
    }
    static resolve(t, n) {
        if (!(n >= 0 && n <= t.content.size))
            throw new RangeError("Position " + n + " out of range");
        let r = []
          , s = 0
          , o = n;
        for (let i = t; ; ) {
            let {index: a, offset: l} = i.content.findIndex(o)
              , c = o - l;
            if (r.push(i, a, s + l),
            !c || (i = i.child(a),
            i.isText))
                break;
            o = c - 1,
            s += l + 1
        }
        return new Tf(n,r,o)
    }
    static resolveCached(t, n) {
        let r = vT.get(t);
        if (r)
            for (let o = 0; o < r.elts.length; o++) {
                let i = r.elts[o];
                if (i.pos == n)
                    return i
            }
        else
            vT.set(t, r = new Hle);
        let s = r.elts[r.i] = Tf.resolve(t, n);
        return r.i = (r.i + 1) % zle,
        s
    }
}
class Hle {
    constructor() {
        this.elts = [],
        this.i = 0
    }
}
const zle = 12
  , vT = new WeakMap;
class $le {
    constructor(t, n, r) {
        this.$from = t,
        this.$to = n,
        this.depth = r
    }
    get start() {
        return this.$from.before(this.depth + 1)
    }
    get end() {
        return this.$to.after(this.depth + 1)
    }
    get parent() {
        return this.$from.node(this.depth)
    }
    get startIndex() {
        return this.$from.index(this.depth)
    }
    get endIndex() {
        return this.$to.indexAfter(this.depth)
    }
}
const Wle = Object.create(null);
let wl = class I5 {
    constructor(t, n, r, s=Lt.none) {
        this.type = t,
        this.attrs = n,
        this.marks = s,
        this.content = r || pe.empty
    }
    get nodeSize() {
        return this.isLeaf ? 1 : 2 + this.content.size
    }
    get childCount() {
        return this.content.childCount
    }
    child(t) {
        return this.content.child(t)
    }
    maybeChild(t) {
        return this.content.maybeChild(t)
    }
    forEach(t) {
        this.content.forEach(t)
    }
    nodesBetween(t, n, r, s=0) {
        this.content.nodesBetween(t, n, r, s, this)
    }
    descendants(t) {
        this.nodesBetween(0, this.content.size, t)
    }
    get textContent() {
        return this.isLeaf && this.type.spec.leafText ? this.type.spec.leafText(this) : this.textBetween(0, this.content.size, "")
    }
    textBetween(t, n, r, s) {
        return this.content.textBetween(t, n, r, s)
    }
    get firstChild() {
        return this.content.firstChild
    }
    get lastChild() {
        return this.content.lastChild
    }
    eq(t) {
        return this == t || this.sameMarkup(t) && this.content.eq(t.content)
    }
    sameMarkup(t) {
        return this.hasMarkup(t.type, t.attrs, t.marks)
    }
    hasMarkup(t, n, r) {
        return this.type == t && zm(this.attrs, n || t.defaultAttrs || Wle) && Lt.sameSet(this.marks, r || Lt.none)
    }
    copy(t=null) {
        return t == this.content ? this : new I5(this.type,this.attrs,t,this.marks)
    }
    mark(t) {
        return t == this.marks ? this : new I5(this.type,this.attrs,this.content,t)
    }
    cut(t, n=this.content.size) {
        return t == 0 && n == this.content.size ? this : this.copy(this.content.cut(t, n))
    }
    slice(t, n=this.content.size, r=!1) {
        if (t == n)
            return Me.empty;
        let s = this.resolve(t)
          , o = this.resolve(n)
          , i = r ? 0 : s.sharedDepth(n)
          , a = s.start(i)
          , c = s.node(i).content.cut(s.pos - a, o.pos - a);
        return new Me(c,s.depth - i,o.depth - i)
    }
    replace(t, n, r) {
        return Gle(this.resolve(t), this.resolve(n), r)
    }
    nodeAt(t) {
        for (let n = this; ; ) {
            let {index: r, offset: s} = n.content.findIndex(t);
            if (n = n.maybeChild(r),
            !n)
                return null;
            if (s == t || n.isText)
                return n;
            t -= s + 1
        }
    }
    childAfter(t) {
        let {index: n, offset: r} = this.content.findIndex(t);
        return {
            node: this.content.maybeChild(n),
            index: n,
            offset: r
        }
    }
    childBefore(t) {
        if (t == 0)
            return {
                node: null,
                index: 0,
                offset: 0
            };
        let {index: n, offset: r} = this.content.findIndex(t);
        if (r < t)
            return {
                node: this.content.child(n),
                index: n,
                offset: r
            };
        let s = this.content.child(n - 1);
        return {
            node: s,
            index: n - 1,
            offset: r - s.nodeSize
        }
    }
    resolve(t) {
        return Tf.resolveCached(this, t)
    }
    resolveNoCache(t) {
        return Tf.resolve(this, t)
    }
    rangeHasMark(t, n, r) {
        let s = !1;
        return n > t && this.nodesBetween(t, n, o => (r.isInSet(o.marks) && (s = !0),
        !s)),
        s
    }
    get isBlock() {
        return this.type.isBlock
    }
    get isTextblock() {
        return this.type.isTextblock
    }
    get inlineContent() {
        return this.type.inlineContent
    }
    get isInline() {
        return this.type.isInline
    }
    get isText() {
        return this.type.isText
    }
    get isLeaf() {
        return this.type.isLeaf
    }
    get isAtom() {
        return this.type.isAtom
    }
    toString() {
        if (this.type.spec.toDebugString)
            return this.type.spec.toDebugString(this);
        let t = this.type.name;
        return this.content.size && (t += "(" + this.content.toStringInner() + ")"),
        Yj(this.marks, t)
    }
    contentMatchAt(t) {
        let n = this.type.contentMatch.matchFragment(this.content, 0, t);
        if (!n)
            throw new Error("Called contentMatchAt on a node with invalid content");
        return n
    }
    canReplace(t, n, r=pe.empty, s=0, o=r.childCount) {
        let i = this.contentMatchAt(t).matchFragment(r, s, o)
          , a = i && i.matchFragment(this.content, n);
        if (!a || !a.validEnd)
            return !1;
        for (let l = s; l < o; l++)
            if (!this.type.allowsMarks(r.child(l).marks))
                return !1;
        return !0
    }
    canReplaceWith(t, n, r, s) {
        if (s && !this.type.allowsMarks(s))
            return !1;
        let o = this.contentMatchAt(t).matchType(r)
          , i = o && o.matchFragment(this.content, n);
        return i ? i.validEnd : !1
    }
    canAppend(t) {
        return t.content.size ? this.canReplace(this.childCount, this.childCount, t.content) : this.type.compatibleContent(t.type)
    }
    check() {
        this.type.checkContent(this.content),
        this.type.checkAttrs(this.attrs);
        let t = Lt.none;
        for (let n = 0; n < this.marks.length; n++) {
            let r = this.marks[n];
            r.type.checkAttrs(r.attrs),
            t = r.addToSet(t)
        }
        if (!Lt.sameSet(t, this.marks))
            throw new RangeError(`Invalid collection of marks for node ${this.type.name}: ${this.marks.map(n => n.type.name)}`);
        this.content.forEach(n => n.check())
    }
    toJSON() {
        let t = {
            type: this.type.name
        };
        for (let n in this.attrs) {
            t.attrs = this.attrs;
            break
        }
        return this.content.size && (t.content = this.content.toJSON()),
        this.marks.length && (t.marks = this.marks.map(n => n.toJSON())),
        t
    }
    static fromJSON(t, n) {
        if (!n)
            throw new RangeError("Invalid input for Node.fromJSON");
        let r;
        if (n.marks) {
            if (!Array.isArray(n.marks))
                throw new RangeError("Invalid mark data for Node.fromJSON");
            r = n.marks.map(t.markFromJSON)
        }
        if (n.type == "text") {
            if (typeof n.text != "string")
                throw new RangeError("Invalid text node in JSON");
            return t.text(n.text, r)
        }
        let s = pe.fromJSON(t, n.content)
          , o = t.nodeType(n.type).create(n.attrs, s, r);
        return o.type.checkAttrs(o.attrs),
        o
    }
}
;
wl.prototype.text = void 0;
class Km extends wl {
    constructor(t, n, r, s) {
        if (super(t, n, null, s),
        !r)
            throw new RangeError("Empty text nodes are not allowed");
        this.text = r
    }
    toString() {
        return this.type.spec.toDebugString ? this.type.spec.toDebugString(this) : Yj(this.marks, JSON.stringify(this.text))
    }
    get textContent() {
        return this.text
    }
    textBetween(t, n) {
        return this.text.slice(t, n)
    }
    get nodeSize() {
        return this.text.length
    }
    mark(t) {
        return t == this.marks ? this : new Km(this.type,this.attrs,this.text,t)
    }
    withText(t) {
        return t == this.text ? this : new Km(this.type,this.attrs,t,this.marks)
    }
    cut(t=0, n=this.text.length) {
        return t == 0 && n == this.text.length ? this : this.withText(this.text.slice(t, n))
    }
    eq(t) {
        return this.sameMarkup(t) && this.text == t.text
    }
    toJSON() {
        let t = super.toJSON();
        return t.text = this.text,
        t
    }
}
function Yj(e, t) {
    for (let n = e.length - 1; n >= 0; n--)
        t = e[n].type.name + "(" + t + ")";
    return t
}
class Bl {
    constructor(t) {
        this.validEnd = t,
        this.next = [],
        this.wrapCache = []
    }
    static parse(t, n) {
        let r = new Kle(t,n);
        if (r.next == null)
            return Bl.empty;
        let s = Zj(r);
        r.next && r.err("Unexpected trailing text");
        let o = tce(ece(s));
        return nce(o, r),
        o
    }
    matchType(t) {
        for (let n = 0; n < this.next.length; n++)
            if (this.next[n].type == t)
                return this.next[n].next;
        return null
    }
    matchFragment(t, n=0, r=t.childCount) {
        let s = this;
        for (let o = n; s && o < r; o++)
            s = s.matchType(t.child(o).type);
        return s
    }
    get inlineContent() {
        return this.next.length != 0 && this.next[0].type.isInline
    }
    get defaultType() {
        for (let t = 0; t < this.next.length; t++) {
            let {type: n} = this.next[t];
            if (!(n.isText || n.hasRequiredAttrs()))
                return n
        }
        return null
    }
    compatible(t) {
        for (let n = 0; n < this.next.length; n++)
            for (let r = 0; r < t.next.length; r++)
                if (this.next[n].type == t.next[r].type)
                    return !0;
        return !1
    }
    fillBefore(t, n=!1, r=0) {
        let s = [this];
        function o(i, a) {
            let l = i.matchFragment(t, r);
            if (l && (!n || l.validEnd))
                return pe.from(a.map(c => c.createAndFill()));
            for (let c = 0; c < i.next.length; c++) {
                let {type: u, next: d} = i.next[c];
                if (!(u.isText || u.hasRequiredAttrs()) && s.indexOf(d) == -1) {
                    s.push(d);
                    let f = o(d, a.concat(u));
                    if (f)
                        return f
                }
            }
            return null
        }
        return o(this, [])
    }
    findWrapping(t) {
        for (let r = 0; r < this.wrapCache.length; r += 2)
            if (this.wrapCache[r] == t)
                return this.wrapCache[r + 1];
        let n = this.computeWrapping(t);
        return this.wrapCache.push(t, n),
        n
    }
    computeWrapping(t) {
        let n = Object.create(null)
          , r = [{
            match: this,
            type: null,
            via: null
        }];
        for (; r.length; ) {
            let s = r.shift()
              , o = s.match;
            if (o.matchType(t)) {
                let i = [];
                for (let a = s; a.type; a = a.via)
                    i.push(a.type);
                return i.reverse()
            }
            for (let i = 0; i < o.next.length; i++) {
                let {type: a, next: l} = o.next[i];
                !a.isLeaf && !a.hasRequiredAttrs() && !(a.name in n) && (!s.type || l.validEnd) && (r.push({
                    match: a.contentMatch,
                    type: a,
                    via: s
                }),
                n[a.name] = !0)
            }
        }
        return null
    }
    get edgeCount() {
        return this.next.length
    }
    edge(t) {
        if (t >= this.next.length)
            throw new RangeError(`There's no ${t}th edge in this content match`);
        return this.next[t]
    }
    toString() {
        let t = [];
        function n(r) {
            t.push(r);
            for (let s = 0; s < r.next.length; s++)
                t.indexOf(r.next[s].next) == -1 && n(r.next[s].next)
        }
        return n(this),
        t.map( (r, s) => {
            let o = s + (r.validEnd ? "*" : " ") + " ";
            for (let i = 0; i < r.next.length; i++)
                o += (i ? ", " : "") + r.next[i].type.name + "->" + t.indexOf(r.next[i].next);
            return o
        }
        ).join(`
`)
    }
}
Bl.empty = new Bl(!0);
class Kle {
    constructor(t, n) {
        this.string = t,
        this.nodeTypes = n,
        this.inline = null,
        this.pos = 0,
        this.tokens = t.split(/\s*(?=\b|\W|$)/),
        this.tokens[this.tokens.length - 1] == "" && this.tokens.pop(),
        this.tokens[0] == "" && this.tokens.shift()
    }
    get next() {
        return this.tokens[this.pos]
    }
    eat(t) {
        return this.next == t && (this.pos++ || !0)
    }
    err(t) {
        throw new SyntaxError(t + " (in content expression '" + this.string + "')")
    }
}
function Zj(e) {
    let t = [];
    do
        t.push(Yle(e));
    while (e.eat("|"));
    return t.length == 1 ? t[0] : {
        type: "choice",
        exprs: t
    }
}
function Yle(e) {
    let t = [];
    do
        t.push(Zle(e));
    while (e.next && e.next != ")" && e.next != "|");
    return t.length == 1 ? t[0] : {
        type: "seq",
        exprs: t
    }
}
function Zle(e) {
    let t = Qle(e);
    for (; ; )
        if (e.eat("+"))
            t = {
                type: "plus",
                expr: t
            };
        else if (e.eat("*"))
            t = {
                type: "star",
                expr: t
            };
        else if (e.eat("?"))
            t = {
                type: "opt",
                expr: t
            };
        else if (e.eat("{"))
            t = Jle(e, t);
        else
            break;
    return t
}
function _T(e) {
    /\D/.test(e.next) && e.err("Expected number, got '" + e.next + "'");
    let t = Number(e.next);
    return e.pos++,
    t
}
function Jle(e, t) {
    let n = _T(e)
      , r = n;
    return e.eat(",") && (e.next != "}" ? r = _T(e) : r = -1),
    e.eat("}") || e.err("Unclosed braced range"),
    {
        type: "range",
        min: n,
        max: r,
        expr: t
    }
}
function Xle(e, t) {
    let n = e.nodeTypes
      , r = n[t];
    if (r)
        return [r];
    let s = [];
    for (let o in n) {
        let i = n[o];
        i.groups.indexOf(t) > -1 && s.push(i)
    }
    return s.length == 0 && e.err("No node type or group '" + t + "' found"),
    s
}
function Qle(e) {
    if (e.eat("(")) {
        let t = Zj(e);
        return e.eat(")") || e.err("Missing closing paren"),
        t
    } else if (/\W/.test(e.next))
        e.err("Unexpected token '" + e.next + "'");
    else {
        let t = Xle(e, e.next).map(n => (e.inline == null ? e.inline = n.isInline : e.inline != n.isInline && e.err("Mixing inline and block content"),
        {
            type: "name",
            value: n
        }));
        return e.pos++,
        t.length == 1 ? t[0] : {
            type: "choice",
            exprs: t
        }
    }
}
function ece(e) {
    let t = [[]];
    return s(o(e, 0), n()),
    t;
    function n() {
        return t.push([]) - 1
    }
    function r(i, a, l) {
        let c = {
            term: l,
            to: a
        };
        return t[i].push(c),
        c
    }
    function s(i, a) {
        i.forEach(l => l.to = a)
    }
    function o(i, a) {
        if (i.type == "choice")
            return i.exprs.reduce( (l, c) => l.concat(o(c, a)), []);
        if (i.type == "seq")
            for (let l = 0; ; l++) {
                let c = o(i.exprs[l], a);
                if (l == i.exprs.length - 1)
                    return c;
                s(c, a = n())
            }
        else if (i.type == "star") {
            let l = n();
            return r(a, l),
            s(o(i.expr, l), l),
            [r(l)]
        } else if (i.type == "plus") {
            let l = n();
            return s(o(i.expr, a), l),
            s(o(i.expr, l), l),
            [r(l)]
        } else {
            if (i.type == "opt")
                return [r(a)].concat(o(i.expr, a));
            if (i.type == "range") {
                let l = a;
                for (let c = 0; c < i.min; c++) {
                    let u = n();
                    s(o(i.expr, l), u),
                    l = u
                }
                if (i.max == -1)
                    s(o(i.expr, l), l);
                else
                    for (let c = i.min; c < i.max; c++) {
                        let u = n();
                        r(l, u),
                        s(o(i.expr, l), u),
                        l = u
                    }
                return [r(l)]
            } else {
                if (i.type == "name")
                    return [r(a, void 0, i.value)];
                throw new Error("Unknown expr type")
            }
        }
    }
}
function Jj(e, t) {
    return t - e
}
function yT(e, t) {
    let n = [];
    return r(t),
    n.sort(Jj);
    function r(s) {
        let o = e[s];
        if (o.length == 1 && !o[0].term)
            return r(o[0].to);
        n.push(s);
        for (let i = 0; i < o.length; i++) {
            let {term: a, to: l} = o[i];
            !a && n.indexOf(l) == -1 && r(l)
        }
    }
}
function tce(e) {
    let t = Object.create(null);
    return n(yT(e, 0));
    function n(r) {
        let s = [];
        r.forEach(i => {
            e[i].forEach( ({term: a, to: l}) => {
                if (!a)
                    return;
                let c;
                for (let u = 0; u < s.length; u++)
                    s[u][0] == a && (c = s[u][1]);
                yT(e, l).forEach(u => {
                    c || s.push([a, c = []]),
                    c.indexOf(u) == -1 && c.push(u)
                }
                )
            }
            )
        }
        );
        let o = t[r.join(",")] = new Bl(r.indexOf(e.length - 1) > -1);
        for (let i = 0; i < s.length; i++) {
            let a = s[i][1].sort(Jj);
            o.next.push({
                type: s[i][0],
                next: t[a.join(",")] || n(a)
            })
        }
        return o
    }
}
function nce(e, t) {
    for (let n = 0, r = [e]; n < r.length; n++) {
        let s = r[n]
          , o = !s.validEnd
          , i = [];
        for (let a = 0; a < s.next.length; a++) {
            let {type: l, next: c} = s.next[a];
            i.push(l.name),
            o && !(l.isText || l.hasRequiredAttrs()) && (o = !1),
            r.indexOf(c) == -1 && r.push(c)
        }
        o && t.err("Only non-generatable nodes (" + i.join(", ") + ") in a required position (see https://prosemirror.net/docs/guide/#generatable)")
    }
}
function Xj(e) {
    let t = Object.create(null);
    for (let n in e) {
        let r = e[n];
        if (!r.hasDefault)
            return null;
        t[n] = r.default
    }
    return t
}
function Qj(e, t) {
    let n = Object.create(null);
    for (let r in e) {
        let s = t && t[r];
        if (s === void 0) {
            let o = e[r];
            if (o.hasDefault)
                s = o.default;
            else
                throw new RangeError("No value supplied for attribute " + r)
        }
        n[r] = s
    }
    return n
}
function eU(e, t, n, r) {
    for (let s in t)
        if (!(s in e))
            throw new RangeError(`Unsupported attribute ${s} for ${n} of type ${s}`);
    for (let s in e) {
        let o = e[s];
        o.validate && o.validate(t[s])
    }
}
function tU(e, t) {
    let n = Object.create(null);
    if (t)
        for (let r in t)
            n[r] = new sce(e,r,t[r]);
    return n
}
let bT = class nU {
    constructor(t, n, r) {
        this.name = t,
        this.schema = n,
        this.spec = r,
        this.markSet = null,
        this.groups = r.group ? r.group.split(" ") : [],
        this.attrs = tU(t, r.attrs),
        this.defaultAttrs = Xj(this.attrs),
        this.contentMatch = null,
        this.inlineContent = null,
        this.isBlock = !(r.inline || t == "text"),
        this.isText = t == "text"
    }
    get isInline() {
        return !this.isBlock
    }
    get isTextblock() {
        return this.isBlock && this.inlineContent
    }
    get isLeaf() {
        return this.contentMatch == Bl.empty
    }
    get isAtom() {
        return this.isLeaf || !!this.spec.atom
    }
    get whitespace() {
        return this.spec.whitespace || (this.spec.code ? "pre" : "normal")
    }
    hasRequiredAttrs() {
        for (let t in this.attrs)
            if (this.attrs[t].isRequired)
                return !0;
        return !1
    }
    compatibleContent(t) {
        return this == t || this.contentMatch.compatible(t.contentMatch)
    }
    computeAttrs(t) {
        return !t && this.defaultAttrs ? this.defaultAttrs : Qj(this.attrs, t)
    }
    create(t=null, n, r) {
        if (this.isText)
            throw new Error("NodeType.create can't construct text nodes");
        return new wl(this,this.computeAttrs(t),pe.from(n),Lt.setFrom(r))
    }
    createChecked(t=null, n, r) {
        return n = pe.from(n),
        this.checkContent(n),
        new wl(this,this.computeAttrs(t),n,Lt.setFrom(r))
    }
    createAndFill(t=null, n, r) {
        if (t = this.computeAttrs(t),
        n = pe.from(n),
        n.size) {
            let i = this.contentMatch.fillBefore(n);
            if (!i)
                return null;
            n = i.append(n)
        }
        let s = this.contentMatch.matchFragment(n)
          , o = s && s.fillBefore(pe.empty, !0);
        return o ? new wl(this,t,n.append(o),Lt.setFrom(r)) : null
    }
    validContent(t) {
        let n = this.contentMatch.matchFragment(t);
        if (!n || !n.validEnd)
            return !1;
        for (let r = 0; r < t.childCount; r++)
            if (!this.allowsMarks(t.child(r).marks))
                return !1;
        return !0
    }
    checkContent(t) {
        if (!this.validContent(t))
            throw new RangeError(`Invalid content for node ${this.name}: ${t.toString().slice(0, 50)}`)
    }
    checkAttrs(t) {
        eU(this.attrs, t, "node", this.name)
    }
    allowsMarkType(t) {
        return this.markSet == null || this.markSet.indexOf(t) > -1
    }
    allowsMarks(t) {
        if (this.markSet == null)
            return !0;
        for (let n = 0; n < t.length; n++)
            if (!this.allowsMarkType(t[n].type))
                return !1;
        return !0
    }
    allowedMarks(t) {
        if (this.markSet == null)
            return t;
        let n;
        for (let r = 0; r < t.length; r++)
            this.allowsMarkType(t[r].type) ? n && n.push(t[r]) : n || (n = t.slice(0, r));
        return n ? n.length ? n : Lt.none : t
    }
    static compile(t, n) {
        let r = Object.create(null);
        t.forEach( (o, i) => r[o] = new nU(o,n,i));
        let s = n.spec.topNode || "doc";
        if (!r[s])
            throw new RangeError("Schema is missing its top node type ('" + s + "')");
        if (!r.text)
            throw new RangeError("Every schema needs a 'text' type");
        for (let o in r.text.attrs)
            throw new RangeError("The text node type should not have attributes");
        return r
    }
}
;
function rce(e, t, n) {
    let r = n.split("|");
    return s => {
        let o = s === null ? "null" : typeof s;
        if (r.indexOf(o) < 0)
            throw new RangeError(`Expected value of type ${r} for attribute ${t} on type ${e}, got ${o}`)
    }
}
class sce {
    constructor(t, n, r) {
        this.hasDefault = Object.prototype.hasOwnProperty.call(r, "default"),
        this.default = r.default,
        this.validate = typeof r.validate == "string" ? rce(t, n, r.validate) : r.validate
    }
    get isRequired() {
        return !this.hasDefault
    }
}
class M1 {
    constructor(t, n, r, s) {
        this.name = t,
        this.rank = n,
        this.schema = r,
        this.spec = s,
        this.attrs = tU(t, s.attrs),
        this.excluded = null;
        let o = Xj(this.attrs);
        this.instance = o ? new Lt(this,o) : null
    }
    create(t=null) {
        return !t && this.instance ? this.instance : new Lt(this,Qj(this.attrs, t))
    }
    static compile(t, n) {
        let r = Object.create(null)
          , s = 0;
        return t.forEach( (o, i) => r[o] = new M1(o,s++,n,i)),
        r
    }
    removeFromSet(t) {
        for (var n = 0; n < t.length; n++)
            t[n].type == this && (t = t.slice(0, n).concat(t.slice(n + 1)),
            n--);
        return t
    }
    isInSet(t) {
        for (let n = 0; n < t.length; n++)
            if (t[n].type == this)
                return t[n]
    }
    checkAttrs(t) {
        eU(this.attrs, t, "mark", this.name)
    }
    excludes(t) {
        return this.excluded.indexOf(t) > -1
    }
}
class oce {
    constructor(t) {
        this.linebreakReplacement = null,
        this.cached = Object.create(null);
        let n = this.spec = {};
        for (let s in t)
            n[s] = t[s];
        n.nodes = Zn.from(t.nodes),
        n.marks = Zn.from(t.marks || {}),
        this.nodes = bT.compile(this.spec.nodes, this),
        this.marks = M1.compile(this.spec.marks, this);
        let r = Object.create(null);
        for (let s in this.nodes) {
            if (s in this.marks)
                throw new RangeError(s + " can not be both a node and a mark");
            let o = this.nodes[s]
              , i = o.spec.content || ""
              , a = o.spec.marks;
            if (o.contentMatch = r[i] || (r[i] = Bl.parse(i, this.nodes)),
            o.inlineContent = o.contentMatch.inlineContent,
            o.spec.linebreakReplacement) {
                if (this.linebreakReplacement)
                    throw new RangeError("Multiple linebreak nodes defined");
                if (!o.isInline || !o.isLeaf)
                    throw new RangeError("Linebreak replacement nodes must be inline leaf nodes");
                this.linebreakReplacement = o
            }
            o.markSet = a == "_" ? null : a ? CT(this, a.split(" ")) : a == "" || !o.inlineContent ? [] : null
        }
        for (let s in this.marks) {
            let o = this.marks[s]
              , i = o.spec.excludes;
            o.excluded = i == null ? [o] : i == "" ? [] : CT(this, i.split(" "))
        }
        this.nodeFromJSON = this.nodeFromJSON.bind(this),
        this.markFromJSON = this.markFromJSON.bind(this),
        this.topNodeType = this.nodes[this.spec.topNode || "doc"],
        this.cached.wrappings = Object.create(null)
    }
    node(t, n=null, r, s) {
        if (typeof t == "string")
            t = this.nodeType(t);
        else if (t instanceof bT) {
            if (t.schema != this)
                throw new RangeError("Node type from different schema used (" + t.name + ")")
        } else
            throw new RangeError("Invalid node type: " + t);
        return t.createChecked(n, r, s)
    }
    text(t, n) {
        let r = this.nodes.text;
        return new Km(r,r.defaultAttrs,t,Lt.setFrom(n))
    }
    mark(t, n) {
        return typeof t == "string" && (t = this.marks[t]),
        t.create(n)
    }
    nodeFromJSON(t) {
        return wl.fromJSON(this, t)
    }
    markFromJSON(t) {
        return Lt.fromJSON(this, t)
    }
    nodeType(t) {
        let n = this.nodes[t];
        if (!n)
            throw new RangeError("Unknown node type: " + t);
        return n
    }
}
function CT(e, t) {
    let n = [];
    for (let r = 0; r < t.length; r++) {
        let s = t[r]
          , o = e.marks[s]
          , i = o;
        if (o)
            n.push(o);
        else
            for (let a in e.marks) {
                let l = e.marks[a];
                (s == "_" || l.spec.group && l.spec.group.split(" ").indexOf(s) > -1) && n.push(i = l)
            }
        if (!i)
            throw new SyntaxError("Unknown mark type: '" + t[r] + "'")
    }
    return n
}
function ice(e) {
    return e.tag != null
}
function ace(e) {
    return e.style != null
}
class kf {
    constructor(t, n) {
        this.schema = t,
        this.rules = n,
        this.tags = [],
        this.styles = [];
        let r = this.matchedStyles = [];
        n.forEach(s => {
            if (ice(s))
                this.tags.push(s);
            else if (ace(s)) {
                let o = /[^=]*/.exec(s.style)[0];
                r.indexOf(o) < 0 && r.push(o),
                this.styles.push(s)
            }
        }
        ),
        this.normalizeLists = !this.tags.some(s => {
            if (!/^(ul|ol)\b/.test(s.tag) || !s.node)
                return !1;
            let o = t.nodes[s.node];
            return o.contentMatch.matchType(o)
        }
        )
    }
    parse(t, n={}) {
        let r = new wT(this,n,!1);
        return r.addAll(t, n.from, n.to),
        r.finish()
    }
    parseSlice(t, n={}) {
        let r = new wT(this,n,!0);
        return r.addAll(t, n.from, n.to),
        Me.maxOpen(r.finish())
    }
    matchTag(t, n, r) {
        for (let s = r ? this.tags.indexOf(r) + 1 : 0; s < this.tags.length; s++) {
            let o = this.tags[s];
            if (uce(t, o.tag) && (o.namespace === void 0 || t.namespaceURI == o.namespace) && (!o.context || n.matchesContext(o.context))) {
                if (o.getAttrs) {
                    let i = o.getAttrs(t);
                    if (i === !1)
                        continue;
                    o.attrs = i || void 0
                }
                return o
            }
        }
    }
    matchStyle(t, n, r, s) {
        for (let o = s ? this.styles.indexOf(s) + 1 : 0; o < this.styles.length; o++) {
            let i = this.styles[o]
              , a = i.style;
            if (!(a.indexOf(t) != 0 || i.context && !r.matchesContext(i.context) || a.length > t.length && (a.charCodeAt(t.length) != 61 || a.slice(t.length + 1) != n))) {
                if (i.getAttrs) {
                    let l = i.getAttrs(n);
                    if (l === !1)
                        continue;
                    i.attrs = l || void 0
                }
                return i
            }
        }
    }
    static schemaRules(t) {
        let n = [];
        function r(s) {
            let o = s.priority == null ? 50 : s.priority
              , i = 0;
            for (; i < n.length; i++) {
                let a = n[i];
                if ((a.priority == null ? 50 : a.priority) < o)
                    break
            }
            n.splice(i, 0, s)
        }
        for (let s in t.marks) {
            let o = t.marks[s].spec.parseDOM;
            o && o.forEach(i => {
                r(i = ET(i)),
                i.mark || i.ignore || i.clearMark || (i.mark = s)
            }
            )
        }
        for (let s in t.nodes) {
            let o = t.nodes[s].spec.parseDOM;
            o && o.forEach(i => {
                r(i = ET(i)),
                i.node || i.ignore || i.mark || (i.node = s)
            }
            )
        }
        return n
    }
    static fromSchema(t) {
        return t.cached.domParser || (t.cached.domParser = new kf(t,kf.schemaRules(t)))
    }
}
const rU = {
    address: !0,
    article: !0,
    aside: !0,
    blockquote: !0,
    canvas: !0,
    dd: !0,
    div: !0,
    dl: !0,
    fieldset: !0,
    figcaption: !0,
    figure: !0,
    footer: !0,
    form: !0,
    h1: !0,
    h2: !0,
    h3: !0,
    h4: !0,
    h5: !0,
    h6: !0,
    header: !0,
    hgroup: !0,
    hr: !0,
    li: !0,
    noscript: !0,
    ol: !0,
    output: !0,
    p: !0,
    pre: !0,
    section: !0,
    table: !0,
    tfoot: !0,
    ul: !0
}
  , lce = {
    head: !0,
    noscript: !0,
    object: !0,
    script: !0,
    style: !0,
    title: !0
}
  , sU = {
    ol: !0,
    ul: !0
}
  , Ym = 1
  , Zm = 2
  , Xp = 4;
function ST(e, t, n) {
    return t != null ? (t ? Ym : 0) | (t === "full" ? Zm : 0) : e && e.whitespace == "pre" ? Ym | Zm : n & -5
}
class _p {
    constructor(t, n, r, s, o, i, a) {
        this.type = t,
        this.attrs = n,
        this.marks = r,
        this.pendingMarks = s,
        this.solid = o,
        this.options = a,
        this.content = [],
        this.activeMarks = Lt.none,
        this.stashMarks = [],
        this.match = i || (a & Xp ? null : t.contentMatch)
    }
    findWrapping(t) {
        if (!this.match) {
            if (!this.type)
                return [];
            let n = this.type.contentMatch.fillBefore(pe.from(t));
            if (n)
                this.match = this.type.contentMatch.matchFragment(n);
            else {
                let r = this.type.contentMatch, s;
                return (s = r.findWrapping(t.type)) ? (this.match = r,
                s) : null
            }
        }
        return this.match.findWrapping(t.type)
    }
    finish(t) {
        if (!(this.options & Ym)) {
            let r = this.content[this.content.length - 1], s;
            if (r && r.isText && (s = /[ \t\r\n\u000c]+$/.exec(r.text))) {
                let o = r;
                r.text.length == s[0].length ? this.content.pop() : this.content[this.content.length - 1] = o.withText(o.text.slice(0, o.text.length - s[0].length))
            }
        }
        let n = pe.from(this.content);
        return !t && this.match && (n = n.append(this.match.fillBefore(pe.empty, !0))),
        this.type ? this.type.create(this.attrs, n, this.marks) : n
    }
    popFromStashMark(t) {
        for (let n = this.stashMarks.length - 1; n >= 0; n--)
            if (t.eq(this.stashMarks[n]))
                return this.stashMarks.splice(n, 1)[0]
    }
    applyPending(t) {
        for (let n = 0, r = this.pendingMarks; n < r.length; n++) {
            let s = r[n];
            (this.type ? this.type.allowsMarkType(s.type) : dce(s.type, t)) && !s.isInSet(this.activeMarks) && (this.activeMarks = s.addToSet(this.activeMarks),
            this.pendingMarks = s.removeFromSet(this.pendingMarks))
        }
    }
    inlineContext(t) {
        return this.type ? this.type.inlineContent : this.content.length ? this.content[0].isInline : t.parentNode && !rU.hasOwnProperty(t.parentNode.nodeName.toLowerCase())
    }
}
class wT {
    constructor(t, n, r) {
        this.parser = t,
        this.options = n,
        this.isOpen = r,
        this.open = 0;
        let s = n.topNode, o, i = ST(null, n.preserveWhitespace, 0) | (r ? Xp : 0);
        s ? o = new _p(s.type,s.attrs,Lt.none,Lt.none,!0,n.topMatch || s.type.contentMatch,i) : r ? o = new _p(null,null,Lt.none,Lt.none,!0,null,i) : o = new _p(t.schema.topNodeType,null,Lt.none,Lt.none,!0,null,i),
        this.nodes = [o],
        this.find = n.findPositions,
        this.needsBlock = !1
    }
    get top() {
        return this.nodes[this.open]
    }
    addDOM(t) {
        t.nodeType == 3 ? this.addTextNode(t) : t.nodeType == 1 && this.addElement(t)
    }
    withStyleRules(t, n) {
        let r = t.style;
        if (!r || !r.length)
            return n();
        let s = this.readStyles(t.style);
        if (!s)
            return;
        let[o,i] = s
          , a = this.top;
        for (let l = 0; l < i.length; l++)
            this.removePendingMark(i[l], a);
        for (let l = 0; l < o.length; l++)
            this.addPendingMark(o[l]);
        n();
        for (let l = 0; l < o.length; l++)
            this.removePendingMark(o[l], a);
        for (let l = 0; l < i.length; l++)
            this.addPendingMark(i[l])
    }
    addTextNode(t) {
        let n = t.nodeValue
          , r = this.top;
        if (r.options & Zm || r.inlineContext(t) || /[^ \t\r\n\u000c]/.test(n)) {
            if (r.options & Ym)
                r.options & Zm ? n = n.replace(/\r\n?/g, `
`) : n = n.replace(/\r?\n|\r/g, " ");
            else if (n = n.replace(/[ \t\r\n\u000c]+/g, " "),
            /^[ \t\r\n\u000c]/.test(n) && this.open == this.nodes.length - 1) {
                let s = r.content[r.content.length - 1]
                  , o = t.previousSibling;
                (!s || o && o.nodeName == "BR" || s.isText && /[ \t\r\n\u000c]$/.test(s.text)) && (n = n.slice(1))
            }
            n && this.insertNode(this.parser.schema.text(n)),
            this.findInText(t)
        } else
            this.findInside(t)
    }
    addElement(t, n) {
        let r = t.nodeName.toLowerCase(), s;
        sU.hasOwnProperty(r) && this.parser.normalizeLists && cce(t);
        let o = this.options.ruleFromNode && this.options.ruleFromNode(t) || (s = this.parser.matchTag(t, this, n));
        if (o ? o.ignore : lce.hasOwnProperty(r))
            this.findInside(t),
            this.ignoreFallback(t);
        else if (!o || o.skip || o.closeParent) {
            o && o.closeParent ? this.open = Math.max(0, this.open - 1) : o && o.skip.nodeType && (t = o.skip);
            let i, a = this.top, l = this.needsBlock;
            if (rU.hasOwnProperty(r))
                a.content.length && a.content[0].isInline && this.open && (this.open--,
                a = this.top),
                i = !0,
                a.type || (this.needsBlock = !0);
            else if (!t.firstChild) {
                this.leafFallback(t);
                return
            }
            o && o.skip ? this.addAll(t) : this.withStyleRules(t, () => this.addAll(t)),
            i && this.sync(a),
            this.needsBlock = l
        } else
            this.withStyleRules(t, () => {
                this.addElementByRule(t, o, o.consuming === !1 ? s : void 0)
            }
            )
    }
    leafFallback(t) {
        t.nodeName == "BR" && this.top.type && this.top.type.inlineContent && this.addTextNode(t.ownerDocument.createTextNode(`
`))
    }
    ignoreFallback(t) {
        t.nodeName == "BR" && (!this.top.type || !this.top.type.inlineContent) && this.findPlace(this.parser.schema.text("-"))
    }
    readStyles(t) {
        let n = Lt.none
          , r = Lt.none;
        if (t.length)
            for (let s = 0; s < this.parser.matchedStyles.length; s++) {
                let o = this.parser.matchedStyles[s]
                  , i = t.getPropertyValue(o);
                if (i)
                    for (let a = void 0; ; ) {
                        let l = this.parser.matchStyle(o, i, this, a);
                        if (!l)
                            break;
                        if (l.ignore)
                            return null;
                        if (l.clearMark ? this.top.pendingMarks.concat(this.top.activeMarks).forEach(c => {
                            l.clearMark(c) && (r = c.addToSet(r))
                        }
                        ) : n = this.parser.schema.marks[l.mark].create(l.attrs).addToSet(n),
                        l.consuming === !1)
                            a = l;
                        else
                            break
                    }
            }
        return [n, r]
    }
    addElementByRule(t, n, r) {
        let s, o, i;
        n.node ? (o = this.parser.schema.nodes[n.node],
        o.isLeaf ? this.insertNode(o.create(n.attrs)) || this.leafFallback(t) : s = this.enter(o, n.attrs || null, n.preserveWhitespace)) : (i = this.parser.schema.marks[n.mark].create(n.attrs),
        this.addPendingMark(i));
        let a = this.top;
        if (o && o.isLeaf)
            this.findInside(t);
        else if (r)
            this.addElement(t, r);
        else if (n.getContent)
            this.findInside(t),
            n.getContent(t, this.parser.schema).forEach(l => this.insertNode(l));
        else {
            let l = t;
            typeof n.contentElement == "string" ? l = t.querySelector(n.contentElement) : typeof n.contentElement == "function" ? l = n.contentElement(t) : n.contentElement && (l = n.contentElement),
            this.findAround(t, l, !0),
            this.addAll(l)
        }
        s && this.sync(a) && this.open--,
        i && this.removePendingMark(i, a)
    }
    addAll(t, n, r) {
        let s = n || 0;
        for (let o = n ? t.childNodes[n] : t.firstChild, i = r == null ? null : t.childNodes[r]; o != i; o = o.nextSibling,
        ++s)
            this.findAtPoint(t, s),
            this.addDOM(o);
        this.findAtPoint(t, s)
    }
    findPlace(t) {
        let n, r;
        for (let s = this.open; s >= 0; s--) {
            let o = this.nodes[s]
              , i = o.findWrapping(t);
            if (i && (!n || n.length > i.length) && (n = i,
            r = o,
            !i.length) || o.solid)
                break
        }
        if (!n)
            return !1;
        this.sync(r);
        for (let s = 0; s < n.length; s++)
            this.enterInner(n[s], null, !1);
        return !0
    }
    insertNode(t) {
        if (t.isInline && this.needsBlock && !this.top.type) {
            let n = this.textblockFromContext();
            n && this.enterInner(n)
        }
        if (this.findPlace(t)) {
            this.closeExtra();
            let n = this.top;
            n.applyPending(t.type),
            n.match && (n.match = n.match.matchType(t.type));
            let r = n.activeMarks;
            for (let s = 0; s < t.marks.length; s++)
                (!n.type || n.type.allowsMarkType(t.marks[s].type)) && (r = t.marks[s].addToSet(r));
            return n.content.push(t.mark(r)),
            !0
        }
        return !1
    }
    enter(t, n, r) {
        let s = this.findPlace(t.create(n));
        return s && this.enterInner(t, n, !0, r),
        s
    }
    enterInner(t, n=null, r=!1, s) {
        this.closeExtra();
        let o = this.top;
        o.applyPending(t),
        o.match = o.match && o.match.matchType(t);
        let i = ST(t, s, o.options);
        o.options & Xp && o.content.length == 0 && (i |= Xp),
        this.nodes.push(new _p(t,n,o.activeMarks,o.pendingMarks,r,null,i)),
        this.open++
    }
    closeExtra(t=!1) {
        let n = this.nodes.length - 1;
        if (n > this.open) {
            for (; n > this.open; n--)
                this.nodes[n - 1].content.push(this.nodes[n].finish(t));
            this.nodes.length = this.open + 1
        }
    }
    finish() {
        return this.open = 0,
        this.closeExtra(this.isOpen),
        this.nodes[0].finish(this.isOpen || this.options.topOpen)
    }
    sync(t) {
        for (let n = this.open; n >= 0; n--)
            if (this.nodes[n] == t)
                return this.open = n,
                !0;
        return !1
    }
    get currentPos() {
        this.closeExtra();
        let t = 0;
        for (let n = this.open; n >= 0; n--) {
            let r = this.nodes[n].content;
            for (let s = r.length - 1; s >= 0; s--)
                t += r[s].nodeSize;
            n && t++
        }
        return t
    }
    findAtPoint(t, n) {
        if (this.find)
            for (let r = 0; r < this.find.length; r++)
                this.find[r].node == t && this.find[r].offset == n && (this.find[r].pos = this.currentPos)
    }
    findInside(t) {
        if (this.find)
            for (let n = 0; n < this.find.length; n++)
                this.find[n].pos == null && t.nodeType == 1 && t.contains(this.find[n].node) && (this.find[n].pos = this.currentPos)
    }
    findAround(t, n, r) {
        if (t != n && this.find)
            for (let s = 0; s < this.find.length; s++)
                this.find[s].pos == null && t.nodeType == 1 && t.contains(this.find[s].node) && n.compareDocumentPosition(this.find[s].node) & (r ? 2 : 4) && (this.find[s].pos = this.currentPos)
    }
    findInText(t) {
        if (this.find)
            for (let n = 0; n < this.find.length; n++)
                this.find[n].node == t && (this.find[n].pos = this.currentPos - (t.nodeValue.length - this.find[n].offset))
    }
    matchesContext(t) {
        if (t.indexOf("|") > -1)
            return t.split(/\s*\|\s*/).some(this.matchesContext, this);
        let n = t.split("/")
          , r = this.options.context
          , s = !this.isOpen && (!r || r.parent.type == this.nodes[0].type)
          , o = -(r ? r.depth + 1 : 0) + (s ? 0 : 1)
          , i = (a, l) => {
            for (; a >= 0; a--) {
                let c = n[a];
                if (c == "") {
                    if (a == n.length - 1 || a == 0)
                        continue;
                    for (; l >= o; l--)
                        if (i(a - 1, l))
                            return !0;
                    return !1
                } else {
                    let u = l > 0 || l == 0 && s ? this.nodes[l].type : r && l >= o ? r.node(l - o).type : null;
                    if (!u || u.name != c && u.groups.indexOf(c) == -1)
                        return !1;
                    l--
                }
            }
            return !0
        }
        ;
        return i(n.length - 1, this.open)
    }
    textblockFromContext() {
        let t = this.options.context;
        if (t)
            for (let n = t.depth; n >= 0; n--) {
                let r = t.node(n).contentMatchAt(t.indexAfter(n)).defaultType;
                if (r && r.isTextblock && r.defaultAttrs)
                    return r
            }
        for (let n in this.parser.schema.nodes) {
            let r = this.parser.schema.nodes[n];
            if (r.isTextblock && r.defaultAttrs)
                return r
        }
    }
    addPendingMark(t) {
        let n = fce(t, this.top.pendingMarks);
        n && this.top.stashMarks.push(n),
        this.top.pendingMarks = t.addToSet(this.top.pendingMarks)
    }
    removePendingMark(t, n) {
        for (let r = this.open; r >= 0; r--) {
            let s = this.nodes[r];
            if (s.pendingMarks.lastIndexOf(t) > -1)
                s.pendingMarks = t.removeFromSet(s.pendingMarks);
            else {
                s.activeMarks = t.removeFromSet(s.activeMarks);
                let i = s.popFromStashMark(t);
                i && s.type && s.type.allowsMarkType(i.type) && (s.activeMarks = i.addToSet(s.activeMarks))
            }
            if (s == n)
                break
        }
    }
}
function cce(e) {
    for (let t = e.firstChild, n = null; t; t = t.nextSibling) {
        let r = t.nodeType == 1 ? t.nodeName.toLowerCase() : null;
        r && sU.hasOwnProperty(r) && n ? (n.appendChild(t),
        t = n) : r == "li" ? n = t : r && (n = null)
    }
}
function uce(e, t) {
    return (e.matches || e.msMatchesSelector || e.webkitMatchesSelector || e.mozMatchesSelector).call(e, t)
}
function ET(e) {
    let t = {};
    for (let n in e)
        t[n] = e[n];
    return t
}
function dce(e, t) {
    let n = t.schema.nodes;
    for (let r in n) {
        let s = n[r];
        if (!s.allowsMarkType(e))
            continue;
        let o = []
          , i = a => {
            o.push(a);
            for (let l = 0; l < a.edgeCount; l++) {
                let {type: c, next: u} = a.edge(l);
                if (c == t || o.indexOf(u) < 0 && i(u))
                    return !0
            }
        }
        ;
        if (i(s.contentMatch))
            return !0
    }
}
function fce(e, t) {
    for (let n = 0; n < t.length; n++)
        if (e.eq(t[n]))
            return t[n]
}
class Qu {
    constructor(t, n) {
        this.nodes = t,
        this.marks = n
    }
    serializeFragment(t, n={}, r) {
        r || (r = gy(n).createDocumentFragment());
        let s = r
          , o = [];
        return t.forEach(i => {
            if (o.length || i.marks.length) {
                let a = 0
                  , l = 0;
                for (; a < o.length && l < i.marks.length; ) {
                    let c = i.marks[l];
                    if (!this.marks[c.type.name]) {
                        l++;
                        continue
                    }
                    if (!c.eq(o[a][0]) || c.type.spec.spanning === !1)
                        break;
                    a++,
                    l++
                }
                for (; a < o.length; )
                    s = o.pop()[1];
                for (; l < i.marks.length; ) {
                    let c = i.marks[l++]
                      , u = this.serializeMark(c, i.isInline, n);
                    u && (o.push([c, s]),
                    s.appendChild(u.dom),
                    s = u.contentDOM || u.dom)
                }
            }
            s.appendChild(this.serializeNodeInner(i, n))
        }
        ),
        r
    }
    serializeNodeInner(t, n) {
        let {dom: r, contentDOM: s} = Qp(gy(n), this.nodes[t.type.name](t), null, t.attrs);
        if (s) {
            if (t.isLeaf)
                throw new RangeError("Content hole not allowed in a leaf node spec");
            this.serializeFragment(t.content, n, s)
        }
        return r
    }
    serializeNode(t, n={}) {
        let r = this.serializeNodeInner(t, n);
        for (let s = t.marks.length - 1; s >= 0; s--) {
            let o = this.serializeMark(t.marks[s], t.isInline, n);
            o && ((o.contentDOM || o.dom).appendChild(r),
            r = o.dom)
        }
        return r
    }
    serializeMark(t, n, r={}) {
        let s = this.marks[t.type.name];
        return s && Qp(gy(r), s(t, n), null, t.attrs)
    }
    static renderSpec(t, n, r=null, s) {
        return Qp(t, n, r, s)
    }
    static fromSchema(t) {
        return t.cached.domSerializer || (t.cached.domSerializer = new Qu(this.nodesFromSchema(t),this.marksFromSchema(t)))
    }
    static nodesFromSchema(t) {
        let n = xT(t.nodes);
        return n.text || (n.text = r => r.text),
        n
    }
    static marksFromSchema(t) {
        return xT(t.marks)
    }
}
function xT(e) {
    let t = {};
    for (let n in e) {
        let r = e[n].spec.toDOM;
        r && (t[n] = r)
    }
    return t
}
function gy(e) {
    return e.document || window.document
}
const TT = new WeakMap;
function hce(e) {
    let t = TT.get(e);
    return t === void 0 && TT.set(e, t = pce(e)),
    t
}
function pce(e) {
    let t = null;
    function n(r) {
        if (r && typeof r == "object")
            if (Array.isArray(r))
                if (typeof r[0] == "string")
                    t || (t = []),
                    t.push(r);
                else
                    for (let s = 0; s < r.length; s++)
                        n(r[s]);
            else
                for (let s in r)
                    n(r[s])
    }
    return n(e),
    t
}
function Qp(e, t, n, r) {
    if (typeof t == "string")
        return {
            dom: e.createTextNode(t)
        };
    if (t.nodeType != null)
        return {
            dom: t
        };
    if (t.dom && t.dom.nodeType != null)
        return t;
    let s = t[0], o;
    if (typeof s != "string")
        throw new RangeError("Invalid array passed to renderSpec");
    if (r && (o = hce(r)) && o.indexOf(t) > -1)
        throw new RangeError("Using an array from an attribute object as a DOM spec. This may be an attempted cross site scripting attack.");
    let i = s.indexOf(" ");
    i > 0 && (n = s.slice(0, i),
    s = s.slice(i + 1));
    let a, l = n ? e.createElementNS(n, s) : e.createElement(s), c = t[1], u = 1;
    if (c && typeof c == "object" && c.nodeType == null && !Array.isArray(c)) {
        u = 2;
        for (let d in c)
            if (c[d] != null) {
                let f = d.indexOf(" ");
                f > 0 ? l.setAttributeNS(d.slice(0, f), d.slice(f + 1), c[d]) : l.setAttribute(d, c[d])
            }
    }
    for (let d = u; d < t.length; d++) {
        let f = t[d];
        if (f === 0) {
            if (d < t.length - 1 || d > u)
                throw new RangeError("Content hole must be the only child of its parent node");
            return {
                dom: l,
                contentDOM: l
            }
        } else {
            let {dom: p, contentDOM: m} = Qp(e, f, n, r);
            if (l.appendChild(p),
            m) {
                if (a)
                    throw new RangeError("Multiple content holes");
                a = m
            }
        }
    }
    return {
        dom: l,
        contentDOM: a
    }
}
const oU = 65535
  , iU = Math.pow(2, 16);
function mce(e, t) {
    return e + t * iU
}
function kT(e) {
    return e & oU
}
function gce(e) {
    return (e - (e & oU)) / iU
}
const aU = 1
  , lU = 2
  , em = 4
  , cU = 8;
class R5 {
    constructor(t, n, r) {
        this.pos = t,
        this.delInfo = n,
        this.recover = r
    }
    get deleted() {
        return (this.delInfo & cU) > 0
    }
    get deletedBefore() {
        return (this.delInfo & (aU | em)) > 0
    }
    get deletedAfter() {
        return (this.delInfo & (lU | em)) > 0
    }
    get deletedAcross() {
        return (this.delInfo & em) > 0
    }
}
class Xr {
    constructor(t, n=!1) {
        if (this.ranges = t,
        this.inverted = n,
        !t.length && Xr.empty)
            return Xr.empty
    }
    recover(t) {
        let n = 0
          , r = kT(t);
        if (!this.inverted)
            for (let s = 0; s < r; s++)
                n += this.ranges[s * 3 + 2] - this.ranges[s * 3 + 1];
        return this.ranges[r * 3] + n + gce(t)
    }
    mapResult(t, n=1) {
        return this._map(t, n, !1)
    }
    map(t, n=1) {
        return this._map(t, n, !0)
    }
    _map(t, n, r) {
        let s = 0
          , o = this.inverted ? 2 : 1
          , i = this.inverted ? 1 : 2;
        for (let a = 0; a < this.ranges.length; a += 3) {
            let l = this.ranges[a] - (this.inverted ? s : 0);
            if (l > t)
                break;
            let c = this.ranges[a + o]
              , u = this.ranges[a + i]
              , d = l + c;
            if (t <= d) {
                let f = c ? t == l ? -1 : t == d ? 1 : n : n
                  , p = l + s + (f < 0 ? 0 : u);
                if (r)
                    return p;
                let m = t == (n < 0 ? l : d) ? null : mce(a / 3, t - l)
                  , v = t == l ? lU : t == d ? aU : em;
                return (n < 0 ? t != l : t != d) && (v |= cU),
                new R5(p,v,m)
            }
            s += u - c
        }
        return r ? t + s : new R5(t + s,0,null)
    }
    touches(t, n) {
        let r = 0
          , s = kT(n)
          , o = this.inverted ? 2 : 1
          , i = this.inverted ? 1 : 2;
        for (let a = 0; a < this.ranges.length; a += 3) {
            let l = this.ranges[a] - (this.inverted ? r : 0);
            if (l > t)
                break;
            let c = this.ranges[a + o]
              , u = l + c;
            if (t <= u && a == s * 3)
                return !0;
            r += this.ranges[a + i] - c
        }
        return !1
    }
    forEach(t) {
        let n = this.inverted ? 2 : 1
          , r = this.inverted ? 1 : 2;
        for (let s = 0, o = 0; s < this.ranges.length; s += 3) {
            let i = this.ranges[s]
              , a = i - (this.inverted ? o : 0)
              , l = i + (this.inverted ? 0 : o)
              , c = this.ranges[s + n]
              , u = this.ranges[s + r];
            t(a, a + c, l, l + u),
            o += u - c
        }
    }
    invert() {
        return new Xr(this.ranges,!this.inverted)
    }
    toString() {
        return (this.inverted ? "-" : "") + JSON.stringify(this.ranges)
    }
    static offset(t) {
        return t == 0 ? Xr.empty : new Xr(t < 0 ? [0, -t, 0] : [0, 0, t])
    }
}
Xr.empty = new Xr([]);
class fu {
    constructor(t=[], n, r=0, s=t.length) {
        this.maps = t,
        this.mirror = n,
        this.from = r,
        this.to = s
    }
    slice(t=0, n=this.maps.length) {
        return new fu(this.maps,this.mirror,t,n)
    }
    copy() {
        return new fu(this.maps.slice(),this.mirror && this.mirror.slice(),this.from,this.to)
    }
    appendMap(t, n) {
        this.to = this.maps.push(t),
        n != null && this.setMirror(this.maps.length - 1, n)
    }
    appendMapping(t) {
        for (let n = 0, r = this.maps.length; n < t.maps.length; n++) {
            let s = t.getMirror(n);
            this.appendMap(t.maps[n], s != null && s < n ? r + s : void 0)
        }
    }
    getMirror(t) {
        if (this.mirror) {
            for (let n = 0; n < this.mirror.length; n++)
                if (this.mirror[n] == t)
                    return this.mirror[n + (n % 2 ? -1 : 1)]
        }
    }
    setMirror(t, n) {
        this.mirror || (this.mirror = []),
        this.mirror.push(t, n)
    }
    appendMappingInverted(t) {
        for (let n = t.maps.length - 1, r = this.maps.length + t.maps.length; n >= 0; n--) {
            let s = t.getMirror(n);
            this.appendMap(t.maps[n].invert(), s != null && s > n ? r - s - 1 : void 0)
        }
    }
    invert() {
        let t = new fu;
        return t.appendMappingInverted(this),
        t
    }
    map(t, n=1) {
        if (this.mirror)
            return this._map(t, n, !0);
        for (let r = this.from; r < this.to; r++)
            t = this.maps[r].map(t, n);
        return t
    }
    mapResult(t, n=1) {
        return this._map(t, n, !1)
    }
    _map(t, n, r) {
        let s = 0;
        for (let o = this.from; o < this.to; o++) {
            let i = this.maps[o]
              , a = i.mapResult(t, n);
            if (a.recover != null) {
                let l = this.getMirror(o);
                if (l != null && l > o && l < this.to) {
                    o = l,
                    t = this.maps[l].recover(a.recover);
                    continue
                }
            }
            s |= a.delInfo,
            t = a.pos
        }
        return r ? t : new R5(t,s,null)
    }
}
const vy = Object.create(null);
class gr {
    getMap() {
        return Xr.empty
    }
    merge(t) {
        return null
    }
    static fromJSON(t, n) {
        if (!n || !n.stepType)
            throw new RangeError("Invalid input for Step.fromJSON");
        let r = vy[n.stepType];
        if (!r)
            throw new RangeError(`No step type ${n.stepType} defined`);
        return r.fromJSON(t, n)
    }
    static jsonID(t, n) {
        if (t in vy)
            throw new RangeError("Duplicate use of step JSON ID " + t);
        return vy[t] = n,
        n.prototype.jsonID = t,
        n
    }
}
class wn {
    constructor(t, n) {
        this.doc = t,
        this.failed = n
    }
    static ok(t) {
        return new wn(t,null)
    }
    static fail(t) {
        return new wn(null,t)
    }
    static fromReplace(t, n, r, s) {
        try {
            return wn.ok(t.replace(n, r, s))
        } catch (o) {
            if (o instanceof $m)
                return wn.fail(o.message);
            throw o
        }
    }
}
function jw(e, t, n) {
    let r = [];
    for (let s = 0; s < e.childCount; s++) {
        let o = e.child(s);
        o.content.size && (o = o.copy(jw(o.content, t, o))),
        o.isInline && (o = t(o, n, s)),
        r.push(o)
    }
    return pe.fromArray(r)
}
class sa extends gr {
    constructor(t, n, r) {
        super(),
        this.from = t,
        this.to = n,
        this.mark = r
    }
    apply(t) {
        let n = t.slice(this.from, this.to)
          , r = t.resolve(this.from)
          , s = r.node(r.sharedDepth(this.to))
          , o = new Me(jw(n.content, (i, a) => !i.isAtom || !a.type.allowsMarkType(this.mark.type) ? i : i.mark(this.mark.addToSet(i.marks)), s),n.openStart,n.openEnd);
        return wn.fromReplace(t, this.from, this.to, o)
    }
    invert() {
        return new Oo(this.from,this.to,this.mark)
    }
    map(t) {
        let n = t.mapResult(this.from, 1)
          , r = t.mapResult(this.to, -1);
        return n.deleted && r.deleted || n.pos >= r.pos ? null : new sa(n.pos,r.pos,this.mark)
    }
    merge(t) {
        return t instanceof sa && t.mark.eq(this.mark) && this.from <= t.to && this.to >= t.from ? new sa(Math.min(this.from, t.from),Math.max(this.to, t.to),this.mark) : null
    }
    toJSON() {
        return {
            stepType: "addMark",
            mark: this.mark.toJSON(),
            from: this.from,
            to: this.to
        }
    }
    static fromJSON(t, n) {
        if (typeof n.from != "number" || typeof n.to != "number")
            throw new RangeError("Invalid input for AddMarkStep.fromJSON");
        return new sa(n.from,n.to,t.markFromJSON(n.mark))
    }
}
gr.jsonID("addMark", sa);
class Oo extends gr {
    constructor(t, n, r) {
        super(),
        this.from = t,
        this.to = n,
        this.mark = r
    }
    apply(t) {
        let n = t.slice(this.from, this.to)
          , r = new Me(jw(n.content, s => s.mark(this.mark.removeFromSet(s.marks)), t),n.openStart,n.openEnd);
        return wn.fromReplace(t, this.from, this.to, r)
    }
    invert() {
        return new sa(this.from,this.to,this.mark)
    }
    map(t) {
        let n = t.mapResult(this.from, 1)
          , r = t.mapResult(this.to, -1);
        return n.deleted && r.deleted || n.pos >= r.pos ? null : new Oo(n.pos,r.pos,this.mark)
    }
    merge(t) {
        return t instanceof Oo && t.mark.eq(this.mark) && this.from <= t.to && this.to >= t.from ? new Oo(Math.min(this.from, t.from),Math.max(this.to, t.to),this.mark) : null
    }
    toJSON() {
        return {
            stepType: "removeMark",
            mark: this.mark.toJSON(),
            from: this.from,
            to: this.to
        }
    }
    static fromJSON(t, n) {
        if (typeof n.from != "number" || typeof n.to != "number")
            throw new RangeError("Invalid input for RemoveMarkStep.fromJSON");
        return new Oo(n.from,n.to,t.markFromJSON(n.mark))
    }
}
gr.jsonID("removeMark", Oo);
class oa extends gr {
    constructor(t, n) {
        super(),
        this.pos = t,
        this.mark = n
    }
    apply(t) {
        let n = t.nodeAt(this.pos);
        if (!n)
            return wn.fail("No node at mark step's position");
        let r = n.type.create(n.attrs, null, this.mark.addToSet(n.marks));
        return wn.fromReplace(t, this.pos, this.pos + 1, new Me(pe.from(r),0,n.isLeaf ? 0 : 1))
    }
    invert(t) {
        let n = t.nodeAt(this.pos);
        if (n) {
            let r = this.mark.addToSet(n.marks);
            if (r.length == n.marks.length) {
                for (let s = 0; s < n.marks.length; s++)
                    if (!n.marks[s].isInSet(r))
                        return new oa(this.pos,n.marks[s]);
                return new oa(this.pos,this.mark)
            }
        }
        return new Lu(this.pos,this.mark)
    }
    map(t) {
        let n = t.mapResult(this.pos, 1);
        return n.deletedAfter ? null : new oa(n.pos,this.mark)
    }
    toJSON() {
        return {
            stepType: "addNodeMark",
            pos: this.pos,
            mark: this.mark.toJSON()
        }
    }
    static fromJSON(t, n) {
        if (typeof n.pos != "number")
            throw new RangeError("Invalid input for AddNodeMarkStep.fromJSON");
        return new oa(n.pos,t.markFromJSON(n.mark))
    }
}
gr.jsonID("addNodeMark", oa);
class Lu extends gr {
    constructor(t, n) {
        super(),
        this.pos = t,
        this.mark = n
    }
    apply(t) {
        let n = t.nodeAt(this.pos);
        if (!n)
            return wn.fail("No node at mark step's position");
        let r = n.type.create(n.attrs, null, this.mark.removeFromSet(n.marks));
        return wn.fromReplace(t, this.pos, this.pos + 1, new Me(pe.from(r),0,n.isLeaf ? 0 : 1))
    }
    invert(t) {
        let n = t.nodeAt(this.pos);
        return !n || !this.mark.isInSet(n.marks) ? this : new oa(this.pos,this.mark)
    }
    map(t) {
        let n = t.mapResult(this.pos, 1);
        return n.deletedAfter ? null : new Lu(n.pos,this.mark)
    }
    toJSON() {
        return {
            stepType: "removeNodeMark",
            pos: this.pos,
            mark: this.mark.toJSON()
        }
    }
    static fromJSON(t, n) {
        if (typeof n.pos != "number")
            throw new RangeError("Invalid input for RemoveNodeMarkStep.fromJSON");
        return new Lu(n.pos,t.markFromJSON(n.mark))
    }
}
gr.jsonID("removeNodeMark", Lu);
class ur extends gr {
    constructor(t, n, r, s=!1) {
        super(),
        this.from = t,
        this.to = n,
        this.slice = r,
        this.structure = s
    }
    apply(t) {
        return this.structure && N5(t, this.from, this.to) ? wn.fail("Structure replace would overwrite content") : wn.fromReplace(t, this.from, this.to, this.slice)
    }
    getMap() {
        return new Xr([this.from, this.to - this.from, this.slice.size])
    }
    invert(t) {
        return new ur(this.from,this.from + this.slice.size,t.slice(this.from, this.to))
    }
    map(t) {
        let n = t.mapResult(this.from, 1)
          , r = t.mapResult(this.to, -1);
        return n.deletedAcross && r.deletedAcross ? null : new ur(n.pos,Math.max(n.pos, r.pos),this.slice)
    }
    merge(t) {
        if (!(t instanceof ur) || t.structure || this.structure)
            return null;
        if (this.from + this.slice.size == t.from && !this.slice.openEnd && !t.slice.openStart) {
            let n = this.slice.size + t.slice.size == 0 ? Me.empty : new Me(this.slice.content.append(t.slice.content),this.slice.openStart,t.slice.openEnd);
            return new ur(this.from,this.to + (t.to - t.from),n,this.structure)
        } else if (t.to == this.from && !this.slice.openStart && !t.slice.openEnd) {
            let n = this.slice.size + t.slice.size == 0 ? Me.empty : new Me(t.slice.content.append(this.slice.content),t.slice.openStart,this.slice.openEnd);
            return new ur(t.from,this.to,n,this.structure)
        } else
            return null
    }
    toJSON() {
        let t = {
            stepType: "replace",
            from: this.from,
            to: this.to
        };
        return this.slice.size && (t.slice = this.slice.toJSON()),
        this.structure && (t.structure = !0),
        t
    }
    static fromJSON(t, n) {
        if (typeof n.from != "number" || typeof n.to != "number")
            throw new RangeError("Invalid input for ReplaceStep.fromJSON");
        return new ur(n.from,n.to,Me.fromJSON(t, n.slice),!!n.structure)
    }
}
gr.jsonID("replace", ur);
class ns extends gr {
    constructor(t, n, r, s, o, i, a=!1) {
        super(),
        this.from = t,
        this.to = n,
        this.gapFrom = r,
        this.gapTo = s,
        this.slice = o,
        this.insert = i,
        this.structure = a
    }
    apply(t) {
        if (this.structure && (N5(t, this.from, this.gapFrom) || N5(t, this.gapTo, this.to)))
            return wn.fail("Structure gap-replace would overwrite content");
        let n = t.slice(this.gapFrom, this.gapTo);
        if (n.openStart || n.openEnd)
            return wn.fail("Gap is not a flat range");
        let r = this.slice.insertAt(this.insert, n.content);
        return r ? wn.fromReplace(t, this.from, this.to, r) : wn.fail("Content does not fit in gap")
    }
    getMap() {
        return new Xr([this.from, this.gapFrom - this.from, this.insert, this.gapTo, this.to - this.gapTo, this.slice.size - this.insert])
    }
    invert(t) {
        let n = this.gapTo - this.gapFrom;
        return new ns(this.from,this.from + this.slice.size + n,this.from + this.insert,this.from + this.insert + n,t.slice(this.from, this.to).removeBetween(this.gapFrom - this.from, this.gapTo - this.from),this.gapFrom - this.from,this.structure)
    }
    map(t) {
        let n = t.mapResult(this.from, 1)
          , r = t.mapResult(this.to, -1)
          , s = this.from == this.gapFrom ? n.pos : t.map(this.gapFrom, -1)
          , o = this.to == this.gapTo ? r.pos : t.map(this.gapTo, 1);
        return n.deletedAcross && r.deletedAcross || s < n.pos || o > r.pos ? null : new ns(n.pos,r.pos,s,o,this.slice,this.insert,this.structure)
    }
    toJSON() {
        let t = {
            stepType: "replaceAround",
            from: this.from,
            to: this.to,
            gapFrom: this.gapFrom,
            gapTo: this.gapTo,
            insert: this.insert
        };
        return this.slice.size && (t.slice = this.slice.toJSON()),
        this.structure && (t.structure = !0),
        t
    }
    static fromJSON(t, n) {
        if (typeof n.from != "number" || typeof n.to != "number" || typeof n.gapFrom != "number" || typeof n.gapTo != "number" || typeof n.insert != "number")
            throw new RangeError("Invalid input for ReplaceAroundStep.fromJSON");
        return new ns(n.from,n.to,n.gapFrom,n.gapTo,Me.fromJSON(t, n.slice),n.insert,!!n.structure)
    }
}
gr.jsonID("replaceAround", ns);
function N5(e, t, n) {
    let r = e.resolve(t)
      , s = n - t
      , o = r.depth;
    for (; s > 0 && o > 0 && r.indexAfter(o) == r.node(o).childCount; )
        o--,
        s--;
    if (s > 0) {
        let i = r.node(o).maybeChild(r.indexAfter(o));
        for (; s > 0; ) {
            if (!i || i.isLeaf)
                return !0;
            i = i.firstChild,
            s--
        }
    }
    return !1
}
function vce(e, t, n, r) {
    let s = [], o = [], i, a;
    e.doc.nodesBetween(t, n, (l, c, u) => {
        if (!l.isInline)
            return;
        let d = l.marks;
        if (!r.isInSet(d) && u.type.allowsMarkType(r.type)) {
            let f = Math.max(c, t)
              , p = Math.min(c + l.nodeSize, n)
              , m = r.addToSet(d);
            for (let v = 0; v < d.length; v++)
                d[v].isInSet(m) || (i && i.to == f && i.mark.eq(d[v]) ? i.to = p : s.push(i = new Oo(f,p,d[v])));
            a && a.to == f ? a.to = p : o.push(a = new sa(f,p,r))
        }
    }
    ),
    s.forEach(l => e.step(l)),
    o.forEach(l => e.step(l))
}
function _ce(e, t, n, r) {
    let s = []
      , o = 0;
    e.doc.nodesBetween(t, n, (i, a) => {
        if (!i.isInline)
            return;
        o++;
        let l = null;
        if (r instanceof M1) {
            let c = i.marks, u;
            for (; u = r.isInSet(c); )
                (l || (l = [])).push(u),
                c = u.removeFromSet(c)
        } else
            r ? r.isInSet(i.marks) && (l = [r]) : l = i.marks;
        if (l && l.length) {
            let c = Math.min(a + i.nodeSize, n);
            for (let u = 0; u < l.length; u++) {
                let d = l[u], f;
                for (let p = 0; p < s.length; p++) {
                    let m = s[p];
                    m.step == o - 1 && d.eq(s[p].style) && (f = m)
                }
                f ? (f.to = c,
                f.step = o) : s.push({
                    style: d,
                    from: Math.max(a, t),
                    to: c,
                    step: o
                })
            }
        }
    }
    ),
    s.forEach(i => e.step(new Oo(i.from,i.to,i.style)))
}
function uU(e, t, n, r=n.contentMatch, s=!0) {
    let o = e.doc.nodeAt(t)
      , i = []
      , a = t + 1;
    for (let l = 0; l < o.childCount; l++) {
        let c = o.child(l)
          , u = a + c.nodeSize
          , d = r.matchType(c.type);
        if (!d)
            i.push(new ur(a,u,Me.empty));
        else {
            r = d;
            for (let f = 0; f < c.marks.length; f++)
                n.allowsMarkType(c.marks[f].type) || e.step(new Oo(a,u,c.marks[f]));
            if (s && c.isText && n.whitespace != "pre") {
                let f, p = /\r?\n|\r/g, m;
                for (; f = p.exec(c.text); )
                    m || (m = new Me(pe.from(n.schema.text(" ", n.allowedMarks(c.marks))),0,0)),
                    i.push(new ur(a + f.index,a + f.index + f[0].length,m))
            }
        }
        a = u
    }
    if (!r.validEnd) {
        let l = r.fillBefore(pe.empty, !0);
        e.replace(a, a, new Me(l,0,0))
    }
    for (let l = i.length - 1; l >= 0; l--)
        e.step(i[l])
}
function yce(e, t, n) {
    return (t == 0 || e.canReplace(t, e.childCount)) && (n == e.childCount || e.canReplace(0, n))
}
function Uw(e) {
    let n = e.parent.content.cutByIndex(e.startIndex, e.endIndex);
    for (let r = e.depth; ; --r) {
        let s = e.$from.node(r)
          , o = e.$from.index(r)
          , i = e.$to.indexAfter(r);
        if (r < e.depth && s.canReplace(o, i, n))
            return r;
        if (r == 0 || s.type.spec.isolating || !yce(s, o, i))
            break
    }
    return null
}
function bce(e, t, n) {
    let {$from: r, $to: s, depth: o} = t
      , i = r.before(o + 1)
      , a = s.after(o + 1)
      , l = i
      , c = a
      , u = pe.empty
      , d = 0;
    for (let m = o, v = !1; m > n; m--)
        v || r.index(m) > 0 ? (v = !0,
        u = pe.from(r.node(m).copy(u)),
        d++) : l--;
    let f = pe.empty
      , p = 0;
    for (let m = o, v = !1; m > n; m--)
        v || s.after(m + 1) < s.end(m) ? (v = !0,
        f = pe.from(s.node(m).copy(f)),
        p++) : c++;
    e.step(new ns(l,c,i,a,new Me(u.append(f),d,p),u.size - d,!0))
}
function Cce(e, t, n=null, r=e) {
    let s = Sce(e, t)
      , o = s && wce(r, t);
    return o ? s.map(OT).concat({
        type: t,
        attrs: n
    }).concat(o.map(OT)) : null
}
function OT(e) {
    return {
        type: e,
        attrs: null
    }
}
function Sce(e, t) {
    let {parent: n, startIndex: r, endIndex: s} = e
      , o = n.contentMatchAt(r).findWrapping(t);
    if (!o)
        return null;
    let i = o.length ? o[0] : t;
    return n.canReplaceWith(r, s, i) ? o : null
}
function wce(e, t) {
    let {parent: n, startIndex: r, endIndex: s} = e
      , o = n.child(r)
      , i = t.contentMatch.findWrapping(o.type);
    if (!i)
        return null;
    let l = (i.length ? i[i.length - 1] : t).contentMatch;
    for (let c = r; l && c < s; c++)
        l = l.matchType(n.child(c).type);
    return !l || !l.validEnd ? null : i
}
function Ece(e, t, n) {
    let r = pe.empty;
    for (let i = n.length - 1; i >= 0; i--) {
        if (r.size) {
            let a = n[i].type.contentMatch.matchFragment(r);
            if (!a || !a.validEnd)
                throw new RangeError("Wrapper type given to Transform.wrap does not form valid content of its parent wrapper")
        }
        r = pe.from(n[i].type.create(n[i].attrs, r))
    }
    let s = t.start
      , o = t.end;
    e.step(new ns(s,o,s,o,new Me(r,0,0),n.length,!0))
}
function xce(e, t, n, r, s) {
    if (!r.isTextblock)
        throw new RangeError("Type given to setBlockType should be a textblock");
    let o = e.steps.length;
    e.doc.nodesBetween(t, n, (i, a) => {
        if (i.isTextblock && !i.hasMarkup(r, s) && Oce(e.doc, e.mapping.slice(o).map(a), r)) {
            let l = null;
            if (r.schema.linebreakReplacement) {
                let f = r.whitespace == "pre"
                  , p = !!r.contentMatch.matchType(r.schema.linebreakReplacement);
                f && !p ? l = !1 : !f && p && (l = !0)
            }
            l === !1 && kce(e, i, a, o),
            uU(e, e.mapping.slice(o).map(a, 1), r, void 0, l === null);
            let c = e.mapping.slice(o)
              , u = c.map(a, 1)
              , d = c.map(a + i.nodeSize, 1);
            return e.step(new ns(u,d,u + 1,d - 1,new Me(pe.from(r.create(s, null, i.marks)),0,0),1,!0)),
            l === !0 && Tce(e, i, a, o),
            !1
        }
    }
    )
}
function Tce(e, t, n, r) {
    t.forEach( (s, o) => {
        if (s.isText) {
            let i, a = /\r?\n|\r/g;
            for (; i = a.exec(s.text); ) {
                let l = e.mapping.slice(r).map(n + 1 + o + i.index);
                e.replaceWith(l, l + 1, t.type.schema.linebreakReplacement.create())
            }
        }
    }
    )
}
function kce(e, t, n, r) {
    t.forEach( (s, o) => {
        if (s.type == s.type.schema.linebreakReplacement) {
            let i = e.mapping.slice(r).map(n + 1 + o);
            e.replaceWith(i, i + 1, t.type.schema.text(`
`))
        }
    }
    )
}
function Oce(e, t, n) {
    let r = e.resolve(t)
      , s = r.index();
    return r.parent.canReplaceWith(s, s + 1, n)
}
function Ace(e, t, n, r, s) {
    let o = e.doc.nodeAt(t);
    if (!o)
        throw new RangeError("No node at given position");
    n || (n = o.type);
    let i = n.create(r, null, s || o.marks);
    if (o.isLeaf)
        return e.replaceWith(t, t + o.nodeSize, i);
    if (!n.validContent(o.content))
        throw new RangeError("Invalid content for node type " + n.name);
    e.step(new ns(t,t + o.nodeSize,t + 1,t + o.nodeSize - 1,new Me(pe.from(i),0,0),1,!0))
}
function tm(e, t, n=1, r) {
    let s = e.resolve(t)
      , o = s.depth - n
      , i = r && r[r.length - 1] || s.parent;
    if (o < 0 || s.parent.type.spec.isolating || !s.parent.canReplace(s.index(), s.parent.childCount) || !i.type.validContent(s.parent.content.cutByIndex(s.index(), s.parent.childCount)))
        return !1;
    for (let c = s.depth - 1, u = n - 2; c > o; c--,
    u--) {
        let d = s.node(c)
          , f = s.index(c);
        if (d.type.spec.isolating)
            return !1;
        let p = d.content.cutByIndex(f, d.childCount)
          , m = r && r[u + 1];
        m && (p = p.replaceChild(0, m.type.create(m.attrs)));
        let v = r && r[u] || d;
        if (!d.canReplace(f + 1, d.childCount) || !v.type.validContent(p))
            return !1
    }
    let a = s.indexAfter(o)
      , l = r && r[0];
    return s.node(o).canReplaceWith(a, a, l ? l.type : s.node(o + 1).type)
}
function Mce(e, t, n=1, r) {
    let s = e.doc.resolve(t)
      , o = pe.empty
      , i = pe.empty;
    for (let a = s.depth, l = s.depth - n, c = n - 1; a > l; a--,
    c--) {
        o = pe.from(s.node(a).copy(o));
        let u = r && r[c];
        i = pe.from(u ? u.type.create(u.attrs, i) : s.node(a).copy(i))
    }
    e.step(new ur(t,t,new Me(o.append(i),n,n),!0))
}
function dU(e, t) {
    let n = e.resolve(t)
      , r = n.index();
    return Ice(n.nodeBefore, n.nodeAfter) && n.parent.canReplace(r, r + 1)
}
function Ice(e, t) {
    return !!(e && t && !e.isLeaf && e.canAppend(t))
}
function Rce(e, t, n) {
    let r = new ur(t - n,t + n,Me.empty,!0);
    e.step(r)
}
function Nce(e, t, n) {
    let r = e.resolve(t);
    if (r.parent.canReplaceWith(r.index(), r.index(), n))
        return t;
    if (r.parentOffset == 0)
        for (let s = r.depth - 1; s >= 0; s--) {
            let o = r.index(s);
            if (r.node(s).canReplaceWith(o, o, n))
                return r.before(s + 1);
            if (o > 0)
                return null
        }
    if (r.parentOffset == r.parent.content.size)
        for (let s = r.depth - 1; s >= 0; s--) {
            let o = r.indexAfter(s);
            if (r.node(s).canReplaceWith(o, o, n))
                return r.after(s + 1);
            if (o < r.node(s).childCount)
                return null
        }
    return null
}
function Pce(e, t, n) {
    let r = e.resolve(t);
    if (!n.content.size)
        return t;
    let s = n.content;
    for (let o = 0; o < n.openStart; o++)
        s = s.firstChild.content;
    for (let o = 1; o <= (n.openStart == 0 && n.size ? 2 : 1); o++)
        for (let i = r.depth; i >= 0; i--) {
            let a = i == r.depth ? 0 : r.pos <= (r.start(i + 1) + r.end(i + 1)) / 2 ? -1 : 1
              , l = r.index(i) + (a > 0 ? 1 : 0)
              , c = r.node(i)
              , u = !1;
            if (o == 1)
                u = c.canReplace(l, l, s);
            else {
                let d = c.contentMatchAt(l).findWrapping(s.firstChild.type);
                u = d && c.canReplaceWith(l, l, d[0])
            }
            if (u)
                return a == 0 ? r.pos : a < 0 ? r.before(i + 1) : r.after(i + 1)
        }
    return null
}
function Bw(e, t, n=t, r=Me.empty) {
    if (t == n && !r.size)
        return null;
    let s = e.resolve(t)
      , o = e.resolve(n);
    return fU(s, o, r) ? new ur(t,n,r) : new Dce(s,o,r).fit()
}
function fU(e, t, n) {
    return !n.openStart && !n.openEnd && e.start() == t.start() && e.parent.canReplace(e.index(), t.index(), n.content)
}
class Dce {
    constructor(t, n, r) {
        this.$from = t,
        this.$to = n,
        this.unplaced = r,
        this.frontier = [],
        this.placed = pe.empty;
        for (let s = 0; s <= t.depth; s++) {
            let o = t.node(s);
            this.frontier.push({
                type: o.type,
                match: o.contentMatchAt(t.indexAfter(s))
            })
        }
        for (let s = t.depth; s > 0; s--)
            this.placed = pe.from(t.node(s).copy(this.placed))
    }
    get depth() {
        return this.frontier.length - 1
    }
    fit() {
        for (; this.unplaced.size; ) {
            let c = this.findFittable();
            c ? this.placeNodes(c) : this.openMore() || this.dropNode()
        }
        let t = this.mustMoveInline()
          , n = this.placed.size - this.depth - this.$from.depth
          , r = this.$from
          , s = this.close(t < 0 ? this.$to : r.doc.resolve(t));
        if (!s)
            return null;
        let o = this.placed
          , i = r.depth
          , a = s.depth;
        for (; i && a && o.childCount == 1; )
            o = o.firstChild.content,
            i--,
            a--;
        let l = new Me(o,i,a);
        return t > -1 ? new ns(r.pos,t,this.$to.pos,this.$to.end(),l,n) : l.size || r.pos != this.$to.pos ? new ur(r.pos,s.pos,l) : null
    }
    findFittable() {
        let t = this.unplaced.openStart;
        for (let n = this.unplaced.content, r = 0, s = this.unplaced.openEnd; r < t; r++) {
            let o = n.firstChild;
            if (n.childCount > 1 && (s = 0),
            o.type.spec.isolating && s <= r) {
                t = r;
                break
            }
            n = o.content
        }
        for (let n = 1; n <= 2; n++)
            for (let r = n == 1 ? t : this.unplaced.openStart; r >= 0; r--) {
                let s, o = null;
                r ? (o = _y(this.unplaced.content, r - 1).firstChild,
                s = o.content) : s = this.unplaced.content;
                let i = s.firstChild;
                for (let a = this.depth; a >= 0; a--) {
                    let {type: l, match: c} = this.frontier[a], u, d = null;
                    if (n == 1 && (i ? c.matchType(i.type) || (d = c.fillBefore(pe.from(i), !1)) : o && l.compatibleContent(o.type)))
                        return {
                            sliceDepth: r,
                            frontierDepth: a,
                            parent: o,
                            inject: d
                        };
                    if (n == 2 && i && (u = c.findWrapping(i.type)))
                        return {
                            sliceDepth: r,
                            frontierDepth: a,
                            parent: o,
                            wrap: u
                        };
                    if (o && c.matchType(o.type))
                        break
                }
            }
    }
    openMore() {
        let {content: t, openStart: n, openEnd: r} = this.unplaced
          , s = _y(t, n);
        return !s.childCount || s.firstChild.isLeaf ? !1 : (this.unplaced = new Me(t,n + 1,Math.max(r, s.size + n >= t.size - r ? n + 1 : 0)),
        !0)
    }
    dropNode() {
        let {content: t, openStart: n, openEnd: r} = this.unplaced
          , s = _y(t, n);
        if (s.childCount <= 1 && n > 0) {
            let o = t.size - n <= n + s.size;
            this.unplaced = new Me(Ud(t, n - 1, 1),n - 1,o ? n - 1 : r)
        } else
            this.unplaced = new Me(Ud(t, n, 1),n,r)
    }
    placeNodes({sliceDepth: t, frontierDepth: n, parent: r, inject: s, wrap: o}) {
        for (; this.depth > n; )
            this.closeFrontierNode();
        if (o)
            for (let v = 0; v < o.length; v++)
                this.openFrontierNode(o[v]);
        let i = this.unplaced
          , a = r ? r.content : i.content
          , l = i.openStart - t
          , c = 0
          , u = []
          , {match: d, type: f} = this.frontier[n];
        if (s) {
            for (let v = 0; v < s.childCount; v++)
                u.push(s.child(v));
            d = d.matchFragment(s)
        }
        let p = a.size + t - (i.content.size - i.openEnd);
        for (; c < a.childCount; ) {
            let v = a.child(c)
              , _ = d.matchType(v.type);
            if (!_)
                break;
            c++,
            (c > 1 || l == 0 || v.content.size) && (d = _,
            u.push(hU(v.mark(f.allowedMarks(v.marks)), c == 1 ? l : 0, c == a.childCount ? p : -1)))
        }
        let m = c == a.childCount;
        m || (p = -1),
        this.placed = Bd(this.placed, n, pe.from(u)),
        this.frontier[n].match = d,
        m && p < 0 && r && r.type == this.frontier[this.depth].type && this.frontier.length > 1 && this.closeFrontierNode();
        for (let v = 0, _ = a; v < p; v++) {
            let y = _.lastChild;
            this.frontier.push({
                type: y.type,
                match: y.contentMatchAt(y.childCount)
            }),
            _ = y.content
        }
        this.unplaced = m ? t == 0 ? Me.empty : new Me(Ud(i.content, t - 1, 1),t - 1,p < 0 ? i.openEnd : t - 1) : new Me(Ud(i.content, t, c),i.openStart,i.openEnd)
    }
    mustMoveInline() {
        if (!this.$to.parent.isTextblock)
            return -1;
        let t = this.frontier[this.depth], n;
        if (!t.type.isTextblock || !yy(this.$to, this.$to.depth, t.type, t.match, !1) || this.$to.depth == this.depth && (n = this.findCloseLevel(this.$to)) && n.depth == this.depth)
            return -1;
        let {depth: r} = this.$to
          , s = this.$to.after(r);
        for (; r > 1 && s == this.$to.end(--r); )
            ++s;
        return s
    }
    findCloseLevel(t) {
        e: for (let n = Math.min(this.depth, t.depth); n >= 0; n--) {
            let {match: r, type: s} = this.frontier[n]
              , o = n < t.depth && t.end(n + 1) == t.pos + (t.depth - (n + 1))
              , i = yy(t, n, s, r, o);
            if (i) {
                for (let a = n - 1; a >= 0; a--) {
                    let {match: l, type: c} = this.frontier[a]
                      , u = yy(t, a, c, l, !0);
                    if (!u || u.childCount)
                        continue e
                }
                return {
                    depth: n,
                    fit: i,
                    move: o ? t.doc.resolve(t.after(n + 1)) : t
                }
            }
        }
    }
    close(t) {
        let n = this.findCloseLevel(t);
        if (!n)
            return null;
        for (; this.depth > n.depth; )
            this.closeFrontierNode();
        n.fit.childCount && (this.placed = Bd(this.placed, n.depth, n.fit)),
        t = n.move;
        for (let r = n.depth + 1; r <= t.depth; r++) {
            let s = t.node(r)
              , o = s.type.contentMatch.fillBefore(s.content, !0, t.index(r));
            this.openFrontierNode(s.type, s.attrs, o)
        }
        return t
    }
    openFrontierNode(t, n=null, r) {
        let s = this.frontier[this.depth];
        s.match = s.match.matchType(t),
        this.placed = Bd(this.placed, this.depth, pe.from(t.create(n, r))),
        this.frontier.push({
            type: t,
            match: t.contentMatch
        })
    }
    closeFrontierNode() {
        let n = this.frontier.pop().match.fillBefore(pe.empty, !0);
        n.childCount && (this.placed = Bd(this.placed, this.frontier.length, n))
    }
}
function Ud(e, t, n) {
    return t == 0 ? e.cutByIndex(n, e.childCount) : e.replaceChild(0, e.firstChild.copy(Ud(e.firstChild.content, t - 1, n)))
}
function Bd(e, t, n) {
    return t == 0 ? e.append(n) : e.replaceChild(e.childCount - 1, e.lastChild.copy(Bd(e.lastChild.content, t - 1, n)))
}
function _y(e, t) {
    for (let n = 0; n < t; n++)
        e = e.firstChild.content;
    return e
}
function hU(e, t, n) {
    if (t <= 0)
        return e;
    let r = e.content;
    return t > 1 && (r = r.replaceChild(0, hU(r.firstChild, t - 1, r.childCount == 1 ? n - 1 : 0))),
    t > 0 && (r = e.type.contentMatch.fillBefore(r).append(r),
    n <= 0 && (r = r.append(e.type.contentMatch.matchFragment(r).fillBefore(pe.empty, !0)))),
    e.copy(r)
}
function yy(e, t, n, r, s) {
    let o = e.node(t)
      , i = s ? e.indexAfter(t) : e.index(t);
    if (i == o.childCount && !n.compatibleContent(o.type))
        return null;
    let a = r.fillBefore(o.content, !0, i);
    return a && !Lce(n, o.content, i) ? a : null
}
function Lce(e, t, n) {
    for (let r = n; r < t.childCount; r++)
        if (!e.allowsMarks(t.child(r).marks))
            return !0;
    return !1
}
function Fce(e) {
    return e.spec.defining || e.spec.definingForContent
}
function jce(e, t, n, r) {
    if (!r.size)
        return e.deleteRange(t, n);
    let s = e.doc.resolve(t)
      , o = e.doc.resolve(n);
    if (fU(s, o, r))
        return e.step(new ur(t,n,r));
    let i = mU(s, e.doc.resolve(n));
    i[i.length - 1] == 0 && i.pop();
    let a = -(s.depth + 1);
    i.unshift(a);
    for (let f = s.depth, p = s.pos - 1; f > 0; f--,
    p--) {
        let m = s.node(f).type.spec;
        if (m.defining || m.definingAsContext || m.isolating)
            break;
        i.indexOf(f) > -1 ? a = f : s.before(f) == p && i.splice(1, 0, -f)
    }
    let l = i.indexOf(a)
      , c = []
      , u = r.openStart;
    for (let f = r.content, p = 0; ; p++) {
        let m = f.firstChild;
        if (c.push(m),
        p == r.openStart)
            break;
        f = m.content
    }
    for (let f = u - 1; f >= 0; f--) {
        let p = c[f]
          , m = Fce(p.type);
        if (m && !p.sameMarkup(s.node(Math.abs(a) - 1)))
            u = f;
        else if (m || !p.type.isTextblock)
            break
    }
    for (let f = r.openStart; f >= 0; f--) {
        let p = (f + u + 1) % (r.openStart + 1)
          , m = c[p];
        if (m)
            for (let v = 0; v < i.length; v++) {
                let _ = i[(v + l) % i.length]
                  , y = !0;
                _ < 0 && (y = !1,
                _ = -_);
                let b = s.node(_ - 1)
                  , S = s.index(_ - 1);
                if (b.canReplaceWith(S, S, m.type, m.marks))
                    return e.replace(s.before(_), y ? o.after(_) : n, new Me(pU(r.content, 0, r.openStart, p),p,r.openEnd))
            }
    }
    let d = e.steps.length;
    for (let f = i.length - 1; f >= 0 && (e.replace(t, n, r),
    !(e.steps.length > d)); f--) {
        let p = i[f];
        p < 0 || (t = s.before(p),
        n = o.after(p))
    }
}
function pU(e, t, n, r, s) {
    if (t < n) {
        let o = e.firstChild;
        e = e.replaceChild(0, o.copy(pU(o.content, t + 1, n, r, o)))
    }
    if (t > r) {
        let o = s.contentMatchAt(0)
          , i = o.fillBefore(e).append(e);
        e = i.append(o.matchFragment(i).fillBefore(pe.empty, !0))
    }
    return e
}
function Uce(e, t, n, r) {
    if (!r.isInline && t == n && e.doc.resolve(t).parent.content.size) {
        let s = Nce(e.doc, t, r.type);
        s != null && (t = n = s)
    }
    e.replaceRange(t, n, new Me(pe.from(r),0,0))
}
function Bce(e, t, n) {
    let r = e.doc.resolve(t)
      , s = e.doc.resolve(n)
      , o = mU(r, s);
    for (let i = 0; i < o.length; i++) {
        let a = o[i]
          , l = i == o.length - 1;
        if (l && a == 0 || r.node(a).type.contentMatch.validEnd)
            return e.delete(r.start(a), s.end(a));
        if (a > 0 && (l || r.node(a - 1).canReplace(r.index(a - 1), s.indexAfter(a - 1))))
            return e.delete(r.before(a), s.after(a))
    }
    for (let i = 1; i <= r.depth && i <= s.depth; i++)
        if (t - r.start(i) == r.depth - i && n > r.end(i) && s.end(i) - n != s.depth - i)
            return e.delete(r.before(i), n);
    e.delete(t, n)
}
function mU(e, t) {
    let n = []
      , r = Math.min(e.depth, t.depth);
    for (let s = r; s >= 0; s--) {
        let o = e.start(s);
        if (o < e.pos - (e.depth - s) || t.end(s) > t.pos + (t.depth - s) || e.node(s).type.spec.isolating || t.node(s).type.spec.isolating)
            break;
        (o == t.start(s) || s == e.depth && s == t.depth && e.parent.inlineContent && t.parent.inlineContent && s && t.start(s - 1) == o - 1) && n.push(s)
    }
    return n
}
class hu extends gr {
    constructor(t, n, r) {
        super(),
        this.pos = t,
        this.attr = n,
        this.value = r
    }
    apply(t) {
        let n = t.nodeAt(this.pos);
        if (!n)
            return wn.fail("No node at attribute step's position");
        let r = Object.create(null);
        for (let o in n.attrs)
            r[o] = n.attrs[o];
        r[this.attr] = this.value;
        let s = n.type.create(r, null, n.marks);
        return wn.fromReplace(t, this.pos, this.pos + 1, new Me(pe.from(s),0,n.isLeaf ? 0 : 1))
    }
    getMap() {
        return Xr.empty
    }
    invert(t) {
        return new hu(this.pos,this.attr,t.nodeAt(this.pos).attrs[this.attr])
    }
    map(t) {
        let n = t.mapResult(this.pos, 1);
        return n.deletedAfter ? null : new hu(n.pos,this.attr,this.value)
    }
    toJSON() {
        return {
            stepType: "attr",
            pos: this.pos,
            attr: this.attr,
            value: this.value
        }
    }
    static fromJSON(t, n) {
        if (typeof n.pos != "number" || typeof n.attr != "string")
            throw new RangeError("Invalid input for AttrStep.fromJSON");
        return new hu(n.pos,n.attr,n.value)
    }
}
gr.jsonID("attr", hu);
class Of extends gr {
    constructor(t, n) {
        super(),
        this.attr = t,
        this.value = n
    }
    apply(t) {
        let n = Object.create(null);
        for (let s in t.attrs)
            n[s] = t.attrs[s];
        n[this.attr] = this.value;
        let r = t.type.create(n, t.content, t.marks);
        return wn.ok(r)
    }
    getMap() {
        return Xr.empty
    }
    invert(t) {
        return new Of(this.attr,t.attrs[this.attr])
    }
    map(t) {
        return this
    }
    toJSON() {
        return {
            stepType: "docAttr",
            attr: this.attr,
            value: this.value
        }
    }
    static fromJSON(t, n) {
        if (typeof n.attr != "string")
            throw new RangeError("Invalid input for DocAttrStep.fromJSON");
        return new Of(n.attr,n.value)
    }
}
gr.jsonID("docAttr", Of);
let Fu = class extends Error {
}
;
Fu = function e(t) {
    let n = Error.call(this, t);
    return n.__proto__ = e.prototype,
    n
}
;
Fu.prototype = Object.create(Error.prototype);
Fu.prototype.constructor = Fu;
Fu.prototype.name = "TransformError";
class qce {
    constructor(t) {
        this.doc = t,
        this.steps = [],
        this.docs = [],
        this.mapping = new fu
    }
    get before() {
        return this.docs.length ? this.docs[0] : this.doc
    }
    step(t) {
        let n = this.maybeStep(t);
        if (n.failed)
            throw new Fu(n.failed);
        return this
    }
    maybeStep(t) {
        let n = t.apply(this.doc);
        return n.failed || this.addStep(t, n.doc),
        n
    }
    get docChanged() {
        return this.steps.length > 0
    }
    addStep(t, n) {
        this.docs.push(this.doc),
        this.steps.push(t),
        this.mapping.appendMap(t.getMap()),
        this.doc = n
    }
    replace(t, n=t, r=Me.empty) {
        let s = Bw(this.doc, t, n, r);
        return s && this.step(s),
        this
    }
    replaceWith(t, n, r) {
        return this.replace(t, n, new Me(pe.from(r),0,0))
    }
    delete(t, n) {
        return this.replace(t, n, Me.empty)
    }
    insert(t, n) {
        return this.replaceWith(t, t, n)
    }
    replaceRange(t, n, r) {
        return jce(this, t, n, r),
        this
    }
    replaceRangeWith(t, n, r) {
        return Uce(this, t, n, r),
        this
    }
    deleteRange(t, n) {
        return Bce(this, t, n),
        this
    }
    lift(t, n) {
        return bce(this, t, n),
        this
    }
    join(t, n=1) {
        return Rce(this, t, n),
        this
    }
    wrap(t, n) {
        return Ece(this, t, n),
        this
    }
    setBlockType(t, n=t, r, s=null) {
        return xce(this, t, n, r, s),
        this
    }
    setNodeMarkup(t, n, r=null, s) {
        return Ace(this, t, n, r, s),
        this
    }
    setNodeAttribute(t, n, r) {
        return this.step(new hu(t,n,r)),
        this
    }
    setDocAttribute(t, n) {
        return this.step(new Of(t,n)),
        this
    }
    addNodeMark(t, n) {
        return this.step(new oa(t,n)),
        this
    }
    removeNodeMark(t, n) {
        if (!(n instanceof Lt)) {
            let r = this.doc.nodeAt(t);
            if (!r)
                throw new RangeError("No node at position " + t);
            if (n = n.isInSet(r.marks),
            !n)
                return this
        }
        return this.step(new Lu(t,n)),
        this
    }
    split(t, n=1, r) {
        return Mce(this, t, n, r),
        this
    }
    addMark(t, n, r) {
        return vce(this, t, n, r),
        this
    }
    removeMark(t, n, r) {
        return _ce(this, t, n, r),
        this
    }
    clearIncompatible(t, n, r) {
        return uU(this, t, n, r),
        this
    }
}
const by = Object.create(null);
class Et {
    constructor(t, n, r) {
        this.$anchor = t,
        this.$head = n,
        this.ranges = r || [new Gce(t.min(n),t.max(n))]
    }
    get anchor() {
        return this.$anchor.pos
    }
    get head() {
        return this.$head.pos
    }
    get from() {
        return this.$from.pos
    }
    get to() {
        return this.$to.pos
    }
    get $from() {
        return this.ranges[0].$from
    }
    get $to() {
        return this.ranges[0].$to
    }
    get empty() {
        let t = this.ranges;
        for (let n = 0; n < t.length; n++)
            if (t[n].$from.pos != t[n].$to.pos)
                return !1;
        return !0
    }
    content() {
        return this.$from.doc.slice(this.from, this.to, !0)
    }
    replace(t, n=Me.empty) {
        let r = n.content.lastChild
          , s = null;
        for (let a = 0; a < n.openEnd; a++)
            s = r,
            r = r.lastChild;
        let o = t.steps.length
          , i = this.ranges;
        for (let a = 0; a < i.length; a++) {
            let {$from: l, $to: c} = i[a]
              , u = t.mapping.slice(o);
            t.replaceRange(u.map(l.pos), u.map(c.pos), a ? Me.empty : n),
            a == 0 && IT(t, o, (r ? r.isInline : s && s.isTextblock) ? -1 : 1)
        }
    }
    replaceWith(t, n) {
        let r = t.steps.length
          , s = this.ranges;
        for (let o = 0; o < s.length; o++) {
            let {$from: i, $to: a} = s[o]
              , l = t.mapping.slice(r)
              , c = l.map(i.pos)
              , u = l.map(a.pos);
            o ? t.deleteRange(c, u) : (t.replaceRangeWith(c, u, n),
            IT(t, r, n.isInline ? -1 : 1))
        }
    }
    static findFrom(t, n, r=!1) {
        let s = t.parent.inlineContent ? new Rt(t) : zc(t.node(0), t.parent, t.pos, t.index(), n, r);
        if (s)
            return s;
        for (let o = t.depth - 1; o >= 0; o--) {
            let i = n < 0 ? zc(t.node(0), t.node(o), t.before(o + 1), t.index(o), n, r) : zc(t.node(0), t.node(o), t.after(o + 1), t.index(o) + 1, n, r);
            if (i)
                return i
        }
        return null
    }
    static near(t, n=1) {
        return this.findFrom(t, n) || this.findFrom(t, -n) || new rs(t.node(0))
    }
    static atStart(t) {
        return zc(t, t, 0, 0, 1) || new rs(t)
    }
    static atEnd(t) {
        return zc(t, t, t.content.size, t.childCount, -1) || new rs(t)
    }
    static fromJSON(t, n) {
        if (!n || !n.type)
            throw new RangeError("Invalid input for Selection.fromJSON");
        let r = by[n.type];
        if (!r)
            throw new RangeError(`No selection type ${n.type} defined`);
        return r.fromJSON(t, n)
    }
    static jsonID(t, n) {
        if (t in by)
            throw new RangeError("Duplicate use of selection JSON ID " + t);
        return by[t] = n,
        n.prototype.jsonID = t,
        n
    }
    getBookmark() {
        return Rt.between(this.$anchor, this.$head).getBookmark()
    }
}
Et.prototype.visible = !0;
class Gce {
    constructor(t, n) {
        this.$from = t,
        this.$to = n
    }
}
let AT = !1;
function MT(e) {
    !AT && !e.parent.inlineContent && (AT = !0,
    console.warn("TextSelection endpoint not pointing into a node with inline content (" + e.parent.type.name + ")"))
}
class Rt extends Et {
    constructor(t, n=t) {
        MT(t),
        MT(n),
        super(t, n)
    }
    get $cursor() {
        return this.$anchor.pos == this.$head.pos ? this.$head : null
    }
    map(t, n) {
        let r = t.resolve(n.map(this.head));
        if (!r.parent.inlineContent)
            return Et.near(r);
        let s = t.resolve(n.map(this.anchor));
        return new Rt(s.parent.inlineContent ? s : r,r)
    }
    replace(t, n=Me.empty) {
        if (super.replace(t, n),
        n == Me.empty) {
            let r = this.$from.marksAcross(this.$to);
            r && t.ensureMarks(r)
        }
    }
    eq(t) {
        return t instanceof Rt && t.anchor == this.anchor && t.head == this.head
    }
    getBookmark() {
        return new I1(this.anchor,this.head)
    }
    toJSON() {
        return {
            type: "text",
            anchor: this.anchor,
            head: this.head
        }
    }
    static fromJSON(t, n) {
        if (typeof n.anchor != "number" || typeof n.head != "number")
            throw new RangeError("Invalid input for TextSelection.fromJSON");
        return new Rt(t.resolve(n.anchor),t.resolve(n.head))
    }
    static create(t, n, r=n) {
        let s = t.resolve(n);
        return new this(s,r == n ? s : t.resolve(r))
    }
    static between(t, n, r) {
        let s = t.pos - n.pos;
        if ((!r || s) && (r = s >= 0 ? 1 : -1),
        !n.parent.inlineContent) {
            let o = Et.findFrom(n, r, !0) || Et.findFrom(n, -r, !0);
            if (o)
                n = o.$head;
            else
                return Et.near(n, r)
        }
        return t.parent.inlineContent || (s == 0 ? t = n : (t = (Et.findFrom(t, -r, !0) || Et.findFrom(t, r, !0)).$anchor,
        t.pos < n.pos != s < 0 && (t = n))),
        new Rt(t,n)
    }
}
Et.jsonID("text", Rt);
class I1 {
    constructor(t, n) {
        this.anchor = t,
        this.head = n
    }
    map(t) {
        return new I1(t.map(this.anchor),t.map(this.head))
    }
    resolve(t) {
        return Rt.between(t.resolve(this.anchor), t.resolve(this.head))
    }
}
class st extends Et {
    constructor(t) {
        let n = t.nodeAfter
          , r = t.node(0).resolve(t.pos + n.nodeSize);
        super(t, r),
        this.node = n
    }
    map(t, n) {
        let {deleted: r, pos: s} = n.mapResult(this.anchor)
          , o = t.resolve(s);
        return r ? Et.near(o) : new st(o)
    }
    content() {
        return new Me(pe.from(this.node),0,0)
    }
    eq(t) {
        return t instanceof st && t.anchor == this.anchor
    }
    toJSON() {
        return {
            type: "node",
            anchor: this.anchor
        }
    }
    getBookmark() {
        return new qw(this.anchor)
    }
    static fromJSON(t, n) {
        if (typeof n.anchor != "number")
            throw new RangeError("Invalid input for NodeSelection.fromJSON");
        return new st(t.resolve(n.anchor))
    }
    static create(t, n) {
        return new st(t.resolve(n))
    }
    static isSelectable(t) {
        return !t.isText && t.type.spec.selectable !== !1
    }
}
st.prototype.visible = !1;
Et.jsonID("node", st);
class qw {
    constructor(t) {
        this.anchor = t
    }
    map(t) {
        let {deleted: n, pos: r} = t.mapResult(this.anchor);
        return n ? new I1(r,r) : new qw(r)
    }
    resolve(t) {
        let n = t.resolve(this.anchor)
          , r = n.nodeAfter;
        return r && st.isSelectable(r) ? new st(n) : Et.near(n)
    }
}
class rs extends Et {
    constructor(t) {
        super(t.resolve(0), t.resolve(t.content.size))
    }
    replace(t, n=Me.empty) {
        if (n == Me.empty) {
            t.delete(0, t.doc.content.size);
            let r = Et.atStart(t.doc);
            r.eq(t.selection) || t.setSelection(r)
        } else
            super.replace(t, n)
    }
    toJSON() {
        return {
            type: "all"
        }
    }
    static fromJSON(t) {
        return new rs(t)
    }
    map(t) {
        return new rs(t)
    }
    eq(t) {
        return t instanceof rs
    }
    getBookmark() {
        return Vce
    }
}
Et.jsonID("all", rs);
const Vce = {
    map() {
        return this
    },
    resolve(e) {
        return new rs(e)
    }
};
function zc(e, t, n, r, s, o=!1) {
    if (t.inlineContent)
        return Rt.create(e, n);
    for (let i = r - (s > 0 ? 0 : 1); s > 0 ? i < t.childCount : i >= 0; i += s) {
        let a = t.child(i);
        if (a.isAtom) {
            if (!o && st.isSelectable(a))
                return st.create(e, n - (s < 0 ? a.nodeSize : 0))
        } else {
            let l = zc(e, a, n + s, s < 0 ? a.childCount : 0, s, o);
            if (l)
                return l
        }
        n += a.nodeSize * s
    }
    return null
}
function IT(e, t, n) {
    let r = e.steps.length - 1;
    if (r < t)
        return;
    let s = e.steps[r];
    if (!(s instanceof ur || s instanceof ns))
        return;
    let o = e.mapping.maps[r], i;
    o.forEach( (a, l, c, u) => {
        i == null && (i = u)
    }
    ),
    e.setSelection(Et.near(e.doc.resolve(i), n))
}
const RT = 1
  , NT = 2
  , PT = 4;
class Hce extends qce {
    constructor(t) {
        super(t.doc),
        this.curSelectionFor = 0,
        this.updated = 0,
        this.meta = Object.create(null),
        this.time = Date.now(),
        this.curSelection = t.selection,
        this.storedMarks = t.storedMarks
    }
    get selection() {
        return this.curSelectionFor < this.steps.length && (this.curSelection = this.curSelection.map(this.doc, this.mapping.slice(this.curSelectionFor)),
        this.curSelectionFor = this.steps.length),
        this.curSelection
    }
    setSelection(t) {
        if (t.$from.doc != this.doc)
            throw new RangeError("Selection passed to setSelection must point at the current document");
        return this.curSelection = t,
        this.curSelectionFor = this.steps.length,
        this.updated = (this.updated | RT) & -3,
        this.storedMarks = null,
        this
    }
    get selectionSet() {
        return (this.updated & RT) > 0
    }
    setStoredMarks(t) {
        return this.storedMarks = t,
        this.updated |= NT,
        this
    }
    ensureMarks(t) {
        return Lt.sameSet(this.storedMarks || this.selection.$from.marks(), t) || this.setStoredMarks(t),
        this
    }
    addStoredMark(t) {
        return this.ensureMarks(t.addToSet(this.storedMarks || this.selection.$head.marks()))
    }
    removeStoredMark(t) {
        return this.ensureMarks(t.removeFromSet(this.storedMarks || this.selection.$head.marks()))
    }
    get storedMarksSet() {
        return (this.updated & NT) > 0
    }
    addStep(t, n) {
        super.addStep(t, n),
        this.updated = this.updated & -3,
        this.storedMarks = null
    }
    setTime(t) {
        return this.time = t,
        this
    }
    replaceSelection(t) {
        return this.selection.replace(this, t),
        this
    }
    replaceSelectionWith(t, n=!0) {
        let r = this.selection;
        return n && (t = t.mark(this.storedMarks || (r.empty ? r.$from.marks() : r.$from.marksAcross(r.$to) || Lt.none))),
        r.replaceWith(this, t),
        this
    }
    deleteSelection() {
        return this.selection.replace(this),
        this
    }
    insertText(t, n, r) {
        let s = this.doc.type.schema;
        if (n == null)
            return t ? this.replaceSelectionWith(s.text(t), !0) : this.deleteSelection();
        {
            if (r == null && (r = n),
            r = r ?? n,
            !t)
                return this.deleteRange(n, r);
            let o = this.storedMarks;
            if (!o) {
                let i = this.doc.resolve(n);
                o = r == n ? i.marks() : i.marksAcross(this.doc.resolve(r))
            }
            return this.replaceRangeWith(n, r, s.text(t, o)),
            this.selection.empty || this.setSelection(Et.near(this.selection.$to)),
            this
        }
    }
    setMeta(t, n) {
        return this.meta[typeof t == "string" ? t : t.key] = n,
        this
    }
    getMeta(t) {
        return this.meta[typeof t == "string" ? t : t.key]
    }
    get isGeneric() {
        for (let t in this.meta)
            return !1;
        return !0
    }
    scrollIntoView() {
        return this.updated |= PT,
        this
    }
    get scrolledIntoView() {
        return (this.updated & PT) > 0
    }
}
function DT(e, t) {
    return !t || !e ? e : e.bind(t)
}
class qd {
    constructor(t, n, r) {
        this.name = t,
        this.init = DT(n.init, r),
        this.apply = DT(n.apply, r)
    }
}
const zce = [new qd("doc",{
    init(e) {
        return e.doc || e.schema.topNodeType.createAndFill()
    },
    apply(e) {
        return e.doc
    }
}), new qd("selection",{
    init(e, t) {
        return e.selection || Et.atStart(t.doc)
    },
    apply(e) {
        return e.selection
    }
}), new qd("storedMarks",{
    init(e) {
        return e.storedMarks || null
    },
    apply(e, t, n, r) {
        return r.selection.$cursor ? e.storedMarks : null
    }
}), new qd("scrollToSelection",{
    init() {
        return 0
    },
    apply(e, t) {
        return e.scrolledIntoView ? t + 1 : t
    }
})];
class Cy {
    constructor(t, n) {
        this.schema = t,
        this.plugins = [],
        this.pluginsByKey = Object.create(null),
        this.fields = zce.slice(),
        n && n.forEach(r => {
            if (this.pluginsByKey[r.key])
                throw new RangeError("Adding different instances of a keyed plugin (" + r.key + ")");
            this.plugins.push(r),
            this.pluginsByKey[r.key] = r,
            r.spec.state && this.fields.push(new qd(r.key,r.spec.state,r))
        }
        )
    }
}
class ru {
    constructor(t) {
        this.config = t
    }
    get schema() {
        return this.config.schema
    }
    get plugins() {
        return this.config.plugins
    }
    apply(t) {
        return this.applyTransaction(t).state
    }
    filterTransaction(t, n=-1) {
        for (let r = 0; r < this.config.plugins.length; r++)
            if (r != n) {
                let s = this.config.plugins[r];
                if (s.spec.filterTransaction && !s.spec.filterTransaction.call(s, t, this))
                    return !1
            }
        return !0
    }
    applyTransaction(t) {
        if (!this.filterTransaction(t))
            return {
                state: this,
                transactions: []
            };
        let n = [t]
          , r = this.applyInner(t)
          , s = null;
        for (; ; ) {
            let o = !1;
            for (let i = 0; i < this.config.plugins.length; i++) {
                let a = this.config.plugins[i];
                if (a.spec.appendTransaction) {
                    let l = s ? s[i].n : 0
                      , c = s ? s[i].state : this
                      , u = l < n.length && a.spec.appendTransaction.call(a, l ? n.slice(l) : n, c, r);
                    if (u && r.filterTransaction(u, i)) {
                        if (u.setMeta("appendedTransaction", t),
                        !s) {
                            s = [];
                            for (let d = 0; d < this.config.plugins.length; d++)
                                s.push(d < i ? {
                                    state: r,
                                    n: n.length
                                } : {
                                    state: this,
                                    n: 0
                                })
                        }
                        n.push(u),
                        r = r.applyInner(u),
                        o = !0
                    }
                    s && (s[i] = {
                        state: r,
                        n: n.length
                    })
                }
            }
            if (!o)
                return {
                    state: r,
                    transactions: n
                }
        }
    }
    applyInner(t) {
        if (!t.before.eq(this.doc))
            throw new RangeError("Applying a mismatched transaction");
        let n = new ru(this.config)
          , r = this.config.fields;
        for (let s = 0; s < r.length; s++) {
            let o = r[s];
            n[o.name] = o.apply(t, this[o.name], this, n)
        }
        return n
    }
    get tr() {
        return new Hce(this)
    }
    static create(t) {
        let n = new Cy(t.doc ? t.doc.type.schema : t.schema,t.plugins)
          , r = new ru(n);
        for (let s = 0; s < n.fields.length; s++)
            r[n.fields[s].name] = n.fields[s].init(t, r);
        return r
    }
    reconfigure(t) {
        let n = new Cy(this.schema,t.plugins)
          , r = n.fields
          , s = new ru(n);
        for (let o = 0; o < r.length; o++) {
            let i = r[o].name;
            s[i] = this.hasOwnProperty(i) ? this[i] : r[o].init(t, s)
        }
        return s
    }
    toJSON(t) {
        let n = {
            doc: this.doc.toJSON(),
            selection: this.selection.toJSON()
        };
        if (this.storedMarks && (n.storedMarks = this.storedMarks.map(r => r.toJSON())),
        t && typeof t == "object")
            for (let r in t) {
                if (r == "doc" || r == "selection")
                    throw new RangeError("The JSON fields `doc` and `selection` are reserved");
                let s = t[r]
                  , o = s.spec.state;
                o && o.toJSON && (n[r] = o.toJSON.call(s, this[s.key]))
            }
        return n
    }
    static fromJSON(t, n, r) {
        if (!n)
            throw new RangeError("Invalid input for EditorState.fromJSON");
        if (!t.schema)
            throw new RangeError("Required config field 'schema' missing");
        let s = new Cy(t.schema,t.plugins)
          , o = new ru(s);
        return s.fields.forEach(i => {
            if (i.name == "doc")
                o.doc = wl.fromJSON(t.schema, n.doc);
            else if (i.name == "selection")
                o.selection = Et.fromJSON(o.doc, n.selection);
            else if (i.name == "storedMarks")
                n.storedMarks && (o.storedMarks = n.storedMarks.map(t.schema.markFromJSON));
            else {
                if (r)
                    for (let a in r) {
                        let l = r[a]
                          , c = l.spec.state;
                        if (l.key == i.name && c && c.fromJSON && Object.prototype.hasOwnProperty.call(n, a)) {
                            o[i.name] = c.fromJSON.call(l, t, n[a], o);
                            return
                        }
                    }
                o[i.name] = i.init(t, o)
            }
        }
        ),
        o
    }
}
function gU(e, t, n) {
    for (let r in e) {
        let s = e[r];
        s instanceof Function ? s = s.bind(t) : r == "handleDOMEvents" && (s = gU(s, t, {})),
        n[r] = s
    }
    return n
}
class ho {
    constructor(t) {
        this.spec = t,
        this.props = {},
        t.props && gU(t.props, this, this.props),
        this.key = t.key ? t.key.key : vU("plugin")
    }
    getState(t) {
        return t[this.key]
    }
}
const Sy = Object.create(null);
function vU(e) {
    return e in Sy ? e + "$" + ++Sy[e] : (Sy[e] = 0,
    e + "$")
}
class Go {
    constructor(t="key") {
        this.key = vU(t)
    }
    get(t) {
        return t.config.pluginsByKey[this.key]
    }
    getState(t) {
        return t[this.key]
    }
}
const _U = new Go("transactionEventPlugin")
  , P5 = "prosemirrorDispatchTransaction";
function Gw(e, t) {
    const {eventTarget: n} = _U.getState(e.state);
    return n.addEventListener(P5, t),
    () => {
        n.removeEventListener(P5, t)
    }
}
function $ce(e) {
    return new ho({
        key: _U,
        state: {
            init() {
                return {
                    eventTarget: e
                }
            },
            apply(t, n) {
                return n
            }
        }
    })
}
class yU {
}
class bU extends yU {
    constructor(t) {
        super(),
        this.view = t
    }
    subscribe(t, n) {
        if (t === "change") {
            const r = () => {
                n(void 0)
            }
            ;
            return Gw(this.view, r)
        }
        return this.view.dom?.addEventListener(t, n, {
            capture: !0
        }),
        () => {
            this.view.dom?.removeEventListener(t, n, {
                capture: !0
            })
        }
    }
}
class ZTe extends yU {
    subscribe() {
        return () => {}
    }
}
const nm = new Go("contextConnectorPaste");
function Wce() {
    return new ho({
        key: nm,
        state: {
            init: () => ({}),
            apply(e, t) {
                return e.getMeta(nm) ?? t
            }
        },
        props: {
            transformPasted(e, t) {
                const n = nm.getState(t.state)?.transformPasted;
                return n ? n(e, t) : e
            }
        }
    })
}
function JTe(e, t) {
    e.dispatch(e.state.tr.setMeta(nm, t))
}
const CU = {
    shift: !1,
    ctrl: !1,
    meta: !1
}
  , D5 = dn( () => CU)
  , Kce = D5.getState;
function Yce(e) {
    return bn(e) ? qf(e, "4147197039") : null
}
const Zce = 5e3;
function Jce(e, t) {
    const n = Yce(e);
    if (Kce().shift || !t || t.length < Zce)
        return !1;
    const s = n?.get("paste_threshold", 0) ?? 0;
    return s > 0 ? t.length >= s : !1
}
async function XTe(e) {
    const t = await he( () => import("./kw1dn4ciyc11dkpx.js"), __vite__mapDeps([4, 1, 5]));
    await new Promise(r => setTimeout(r, 0));
    const n = t.getFileTypeGuess(e);
    return await new Promise(r => setTimeout(r, 0)),
    n
}
const SU = (e, t) => e.selection.empty ? !1 : (t && t(e.tr.deleteSelection().scrollIntoView()),
!0);
function Xce(e, t) {
    let {$cursor: n} = e.selection;
    return !n || (t ? !t.endOfTextblock("backward", e) : n.parentOffset > 0) ? null : n
}
const Vw = (e, t, n) => {
    let r = Xce(e, n);
    if (!r)
        return !1;
    let s = wU(r);
    if (!s) {
        let i = r.blockRange()
          , a = i && Uw(i);
        return a == null ? !1 : (t && t(e.tr.lift(i, a).scrollIntoView()),
        !0)
    }
    let o = s.nodeBefore;
    if (!o.type.spec.isolating && OU(e, s, t))
        return !0;
    if (r.parent.content.size == 0 && (ju(o, "end") || st.isSelectable(o))) {
        let i = Bw(e.doc, r.before(), r.after(), Me.empty);
        if (i && i.slice.size < i.to - i.from) {
            if (t) {
                let a = e.tr.step(i);
                a.setSelection(ju(o, "end") ? Et.findFrom(a.doc.resolve(a.mapping.map(s.pos, -1)), -1) : st.create(a.doc, s.pos - o.nodeSize)),
                t(a.scrollIntoView())
            }
            return !0
        }
    }
    return o.isAtom && s.depth == r.depth - 1 ? (t && t(e.tr.delete(s.pos - o.nodeSize, s.pos).scrollIntoView()),
    !0) : !1
}
;
function ju(e, t, n=!1) {
    for (let r = e; r; r = t == "start" ? r.firstChild : r.lastChild) {
        if (r.isTextblock)
            return !0;
        if (n && r.childCount != 1)
            return !1
    }
    return !1
}
const Qce = (e, t, n) => {
    let {$head: r, empty: s} = e.selection
      , o = r;
    if (!s)
        return !1;
    if (r.parent.isTextblock) {
        if (n ? !n.endOfTextblock("backward", e) : r.parentOffset > 0)
            return !1;
        o = wU(r)
    }
    let i = o && o.nodeBefore;
    return !i || !st.isSelectable(i) ? !1 : (t && t(e.tr.setSelection(st.create(e.doc, o.pos - i.nodeSize)).scrollIntoView()),
    !0)
}
;
function wU(e) {
    if (!e.parent.type.spec.isolating)
        for (let t = e.depth - 1; t >= 0; t--) {
            if (e.index(t) > 0)
                return e.doc.resolve(e.before(t + 1));
            if (e.node(t).type.spec.isolating)
                break
        }
    return null
}
function eue(e, t) {
    let {$cursor: n} = e.selection;
    return !n || (t ? !t.endOfTextblock("forward", e) : n.parentOffset < n.parent.content.size) ? null : n
}
const tue = (e, t, n) => {
    let r = eue(e, n);
    if (!r)
        return !1;
    let s = EU(r);
    if (!s)
        return !1;
    let o = s.nodeAfter;
    if (OU(e, s, t))
        return !0;
    if (r.parent.content.size == 0 && (ju(o, "start") || st.isSelectable(o))) {
        let i = Bw(e.doc, r.before(), r.after(), Me.empty);
        if (i && i.slice.size < i.to - i.from) {
            if (t) {
                let a = e.tr.step(i);
                a.setSelection(ju(o, "start") ? Et.findFrom(a.doc.resolve(a.mapping.map(s.pos)), 1) : st.create(a.doc, a.mapping.map(s.pos))),
                t(a.scrollIntoView())
            }
            return !0
        }
    }
    return o.isAtom && s.depth == r.depth - 1 ? (t && t(e.tr.delete(s.pos, s.pos + o.nodeSize).scrollIntoView()),
    !0) : !1
}
  , nue = (e, t, n) => {
    let {$head: r, empty: s} = e.selection
      , o = r;
    if (!s)
        return !1;
    if (r.parent.isTextblock) {
        if (n ? !n.endOfTextblock("forward", e) : r.parentOffset < r.parent.content.size)
            return !1;
        o = EU(r)
    }
    let i = o && o.nodeAfter;
    return !i || !st.isSelectable(i) ? !1 : (t && t(e.tr.setSelection(st.create(e.doc, o.pos)).scrollIntoView()),
    !0)
}
;
function EU(e) {
    if (!e.parent.type.spec.isolating)
        for (let t = e.depth - 1; t >= 0; t--) {
            let n = e.node(t);
            if (e.index(t) + 1 < n.childCount)
                return e.doc.resolve(e.after(t + 1));
            if (n.type.spec.isolating)
                break
        }
    return null
}
const rue = (e, t) => {
    let {$head: n, $anchor: r} = e.selection;
    return !n.parent.type.spec.code || !n.sameParent(r) ? !1 : (t && t(e.tr.insertText(`
`).scrollIntoView()),
    !0)
}
;
function Hw(e) {
    for (let t = 0; t < e.edgeCount; t++) {
        let {type: n} = e.edge(t);
        if (n.isTextblock && !n.hasRequiredAttrs())
            return n
    }
    return null
}
const sue = (e, t) => {
    let {$head: n, $anchor: r} = e.selection;
    if (!n.parent.type.spec.code || !n.sameParent(r))
        return !1;
    let s = n.node(-1)
      , o = n.indexAfter(-1)
      , i = Hw(s.contentMatchAt(o));
    if (!i || !s.canReplaceWith(o, o, i))
        return !1;
    if (t) {
        let a = n.after()
          , l = e.tr.replaceWith(a, a, i.createAndFill());
        l.setSelection(Et.near(l.doc.resolve(a), 1)),
        t(l.scrollIntoView())
    }
    return !0
}
  , xU = (e, t) => {
    let n = e.selection
      , {$from: r, $to: s} = n;
    if (n instanceof rs || r.parent.inlineContent || s.parent.inlineContent)
        return !1;
    let o = Hw(s.parent.contentMatchAt(s.indexAfter()));
    if (!o || !o.isTextblock)
        return !1;
    if (t) {
        let i = (!r.parentOffset && s.index() < s.parent.childCount ? r : s).pos
          , a = e.tr.insert(i, o.createAndFill());
        a.setSelection(Rt.create(a.doc, i + 1)),
        t(a.scrollIntoView())
    }
    return !0
}
  , TU = (e, t) => {
    let {$cursor: n} = e.selection;
    if (!n || n.parent.content.size)
        return !1;
    if (n.depth > 1 && n.after() != n.end(-1)) {
        let o = n.before();
        if (tm(e.doc, o))
            return t && t(e.tr.split(o).scrollIntoView()),
            !0
    }
    let r = n.blockRange()
      , s = r && Uw(r);
    return s == null ? !1 : (t && t(e.tr.lift(r, s).scrollIntoView()),
    !0)
}
;
function oue(e) {
    return (t, n) => {
        let {$from: r, $to: s} = t.selection;
        if (t.selection instanceof st && t.selection.node.isBlock)
            return !r.parentOffset || !tm(t.doc, r.pos) ? !1 : (n && n(t.tr.split(r.pos).scrollIntoView()),
            !0);
        if (!r.parent.isBlock)
            return !1;
        if (n) {
            let o = s.parentOffset == s.parent.content.size
              , i = t.tr;
            (t.selection instanceof Rt || t.selection instanceof rs) && i.deleteSelection();
            let a = r.depth == 0 ? null : Hw(r.node(-1).contentMatchAt(r.indexAfter(-1)))
              , l = o && a ? [{
                type: a
            }] : void 0
              , c = tm(i.doc, i.mapping.map(r.pos), 1, l);
            if (!l && !c && tm(i.doc, i.mapping.map(r.pos), 1, a ? [{
                type: a
            }] : void 0) && (a && (l = [{
                type: a
            }]),
            c = !0),
            c && (i.split(i.mapping.map(r.pos), 1, l),
            !o && !r.parentOffset && r.parent.type != a)) {
                let u = i.mapping.map(r.before())
                  , d = i.doc.resolve(u);
                a && r.node(-1).canReplaceWith(d.index(), d.index() + 1, a) && i.setNodeMarkup(i.mapping.map(r.before()), a)
            }
            n(i.scrollIntoView())
        }
        return !0
    }
}
const kU = oue()
  , iue = (e, t) => (t && t(e.tr.setSelection(new rs(e.doc))),
!0);
function aue(e, t, n) {
    let r = t.nodeBefore
      , s = t.nodeAfter
      , o = t.index();
    return !r || !s || !r.type.compatibleContent(s.type) ? !1 : !r.content.size && t.parent.canReplace(o - 1, o) ? (n && n(e.tr.delete(t.pos - r.nodeSize, t.pos).scrollIntoView()),
    !0) : !t.parent.canReplace(o, o + 1) || !(s.isTextblock || dU(e.doc, t.pos)) ? !1 : (n && n(e.tr.clearIncompatible(t.pos, r.type, r.contentMatchAt(r.childCount)).join(t.pos).scrollIntoView()),
    !0)
}
function OU(e, t, n) {
    let r = t.nodeBefore, s = t.nodeAfter, o, i;
    if (r.type.spec.isolating || s.type.spec.isolating)
        return !1;
    if (aue(e, t, n))
        return !0;
    let a = t.parent.canReplace(t.index(), t.index() + 1);
    if (a && (o = (i = r.contentMatchAt(r.childCount)).findWrapping(s.type)) && i.matchType(o[0] || s.type).validEnd) {
        if (n) {
            let d = t.pos + s.nodeSize
              , f = pe.empty;
            for (let v = o.length - 1; v >= 0; v--)
                f = pe.from(o[v].create(null, f));
            f = pe.from(r.copy(f));
            let p = e.tr.step(new ns(t.pos - 1,d,t.pos,d,new Me(f,1,0),o.length,!0))
              , m = d + 2 * o.length;
            dU(p.doc, m) && p.join(m),
            n(p.scrollIntoView())
        }
        return !0
    }
    let l = Et.findFrom(t, 1)
      , c = l && l.$from.blockRange(l.$to)
      , u = c && Uw(c);
    if (u != null && u >= t.depth)
        return n && n(e.tr.lift(c, u).scrollIntoView()),
        !0;
    if (a && ju(s, "start", !0) && ju(r, "end")) {
        let d = r
          , f = [];
        for (; f.push(d),
        !d.isTextblock; )
            d = d.lastChild;
        let p = s
          , m = 1;
        for (; !p.isTextblock; p = p.firstChild)
            m++;
        if (d.canReplace(d.childCount, d.childCount, p.content)) {
            if (n) {
                let v = pe.empty;
                for (let y = f.length - 1; y >= 0; y--)
                    v = pe.from(f[y].copy(v));
                let _ = e.tr.step(new ns(t.pos - f.length,t.pos + s.nodeSize,t.pos + m,t.pos + s.nodeSize - m,new Me(v,f.length,0),0,!0));
                n(_.scrollIntoView())
            }
            return !0
        }
    }
    return !1
}
function AU(e) {
    return function(t, n) {
        let r = t.selection
          , s = e < 0 ? r.$from : r.$to
          , o = s.depth;
        for (; s.node(o).isInline; ) {
            if (!o)
                return !1;
            o--
        }
        return s.node(o).isTextblock ? (n && n(t.tr.setSelection(Rt.create(t.doc, e < 0 ? s.start(o) : s.end(o)))),
        !0) : !1
    }
}
const lue = AU(-1)
  , cue = AU(1);
function QTe(e, t=null) {
    return function(n, r) {
        let {$from: s, $to: o} = n.selection
          , i = s.blockRange(o)
          , a = i && Cce(i, e, t);
        return a ? (r && r(n.tr.wrap(i, a).scrollIntoView()),
        !0) : !1
    }
}
function eke(e, t=null) {
    return function(n, r) {
        let s = !1;
        for (let o = 0; o < n.selection.ranges.length && !s; o++) {
            let {$from: {pos: i}, $to: {pos: a}} = n.selection.ranges[o];
            n.doc.nodesBetween(i, a, (l, c) => {
                if (s)
                    return !1;
                if (!(!l.isTextblock || l.hasMarkup(e, t)))
                    if (l.type == e)
                        s = !0;
                    else {
                        let u = n.doc.resolve(c)
                          , d = u.index();
                        s = u.parent.canReplaceWith(d, d + 1, e)
                    }
            }
            )
        }
        if (!s)
            return !1;
        if (r) {
            let o = n.tr;
            for (let i = 0; i < n.selection.ranges.length; i++) {
                let {$from: {pos: a}, $to: {pos: l}} = n.selection.ranges[i];
                o.setBlockType(a, l, e, t)
            }
            r(o.scrollIntoView())
        }
        return !0
    }
}
function uue(e, t, n) {
    for (let r = 0; r < t.length; r++) {
        let {$from: s, $to: o} = t[r]
          , i = s.depth == 0 ? e.inlineContent && e.type.allowsMarkType(n) : !1;
        if (e.nodesBetween(s.pos, o.pos, a => {
            if (i)
                return !1;
            i = a.inlineContent && a.type.allowsMarkType(n)
        }
        ),
        i)
            return !0
    }
    return !1
}
function tke(e, t=null) {
    return function(n, r) {
        let {empty: s, $cursor: o, ranges: i} = n.selection;
        if (s && !o || !uue(n.doc, i, e))
            return !1;
        if (r)
            if (o)
                e.isInSet(n.storedMarks || o.marks()) ? r(n.tr.removeStoredMark(e)) : r(n.tr.addStoredMark(e.create(t)));
            else {
                let a = !1
                  , l = n.tr;
                for (let c = 0; !a && c < i.length; c++) {
                    let {$from: u, $to: d} = i[c];
                    a = n.doc.rangeHasMark(u.pos, d.pos, e)
                }
                for (let c = 0; c < i.length; c++) {
                    let {$from: u, $to: d} = i[c];
                    if (a)
                        l.removeMark(u.pos, d.pos, e);
                    else {
                        let f = u.pos
                          , p = d.pos
                          , m = u.nodeAfter
                          , v = d.nodeBefore
                          , _ = m && m.isText ? /^\s*/.exec(m.text)[0].length : 0
                          , y = v && v.isText ? /\s*$/.exec(v.text)[0].length : 0;
                        f + _ < p && (f += _,
                        p -= y),
                        l.addMark(f, p, e.create(t))
                    }
                }
                r(l.scrollIntoView())
            }
        return !0
    }
}
function R1(...e) {
    return function(t, n, r) {
        for (let s = 0; s < e.length; s++)
            if (e[s](t, n, r))
                return !0;
        return !1
    }
}
let wy = R1(SU, Vw, Qce)
  , LT = R1(SU, tue, nue);
const si = {
    Enter: R1(rue, xU, TU, kU),
    "Mod-Enter": sue,
    Backspace: wy,
    "Mod-Backspace": wy,
    "Shift-Backspace": wy,
    Delete: LT,
    "Mod-Delete": LT,
    "Mod-a": iue
}
  , MU = {
    "Ctrl-h": si.Backspace,
    "Alt-Backspace": si["Mod-Backspace"],
    "Ctrl-d": si.Delete,
    "Ctrl-Alt-Backspace": si["Mod-Delete"],
    "Alt-Delete": si["Mod-Delete"],
    "Alt-d": si["Mod-Delete"],
    "Ctrl-a": lue,
    "Ctrl-e": cue
};
for (let e in si)
    MU[e] = si[e];
const due = typeof navigator < "u" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : typeof os < "u" && os.platform ? os.platform() == "darwin" : !1
  , FT = due ? MU : si;
var Ta = {
    8: "Backspace",
    9: "Tab",
    10: "Enter",
    12: "NumLock",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    44: "PrintScreen",
    45: "Insert",
    46: "Delete",
    59: ";",
    61: "=",
    91: "Meta",
    92: "Meta",
    106: "*",
    107: "+",
    108: ",",
    109: "-",
    110: ".",
    111: "/",
    144: "NumLock",
    145: "ScrollLock",
    160: "Shift",
    161: "Shift",
    162: "Control",
    163: "Control",
    164: "Alt",
    165: "Alt",
    173: "-",
    186: ";",
    187: "=",
    188: ",",
    189: "-",
    190: ".",
    191: "/",
    192: "`",
    219: "[",
    220: "\\",
    221: "]",
    222: "'"
}
  , Jm = {
    48: ")",
    49: "!",
    50: "@",
    51: "#",
    52: "$",
    53: "%",
    54: "^",
    55: "&",
    56: "*",
    57: "(",
    59: ":",
    61: "+",
    173: "_",
    186: ":",
    187: "+",
    188: "<",
    189: "_",
    190: ">",
    191: "?",
    192: "~",
    219: "{",
    220: "|",
    221: "}",
    222: '"'
}
  , fue = typeof navigator < "u" && /Mac/.test(navigator.platform)
  , hue = typeof navigator < "u" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
for (var Xn = 0; Xn < 10; Xn++)
    Ta[48 + Xn] = Ta[96 + Xn] = String(Xn);
for (var Xn = 1; Xn <= 24; Xn++)
    Ta[Xn + 111] = "F" + Xn;
for (var Xn = 65; Xn <= 90; Xn++)
    Ta[Xn] = String.fromCharCode(Xn + 32),
    Jm[Xn] = String.fromCharCode(Xn);
for (var Ey in Ta)
    Jm.hasOwnProperty(Ey) || (Jm[Ey] = Ta[Ey]);
function pue(e) {
    var t = fue && e.metaKey && e.shiftKey && !e.ctrlKey && !e.altKey || hue && e.shiftKey && e.key && e.key.length == 1 || e.key == "Unidentified"
      , n = !t && e.key || (e.shiftKey ? Jm : Ta)[e.keyCode] || e.key || "Unidentified";
    return n == "Esc" && (n = "Escape"),
    n == "Del" && (n = "Delete"),
    n == "Left" && (n = "ArrowLeft"),
    n == "Up" && (n = "ArrowUp"),
    n == "Right" && (n = "ArrowRight"),
    n == "Down" && (n = "ArrowDown"),
    n
}
const mue = typeof navigator < "u" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : !1;
function gue(e) {
    let t = e.split(/-(?!$)/)
      , n = t[t.length - 1];
    n == "Space" && (n = " ");
    let r, s, o, i;
    for (let a = 0; a < t.length - 1; a++) {
        let l = t[a];
        if (/^(cmd|meta|m)$/i.test(l))
            i = !0;
        else if (/^a(lt)?$/i.test(l))
            r = !0;
        else if (/^(c|ctrl|control)$/i.test(l))
            s = !0;
        else if (/^s(hift)?$/i.test(l))
            o = !0;
        else if (/^mod$/i.test(l))
            mue ? i = !0 : s = !0;
        else
            throw new Error("Unrecognized modifier name: " + l)
    }
    return r && (n = "Alt-" + n),
    s && (n = "Ctrl-" + n),
    i && (n = "Meta-" + n),
    o && (n = "Shift-" + n),
    n
}
function vue(e) {
    let t = Object.create(null);
    for (let n in e)
        t[gue(n)] = e[n];
    return t
}
function xy(e, t, n=!0) {
    return t.altKey && (e = "Alt-" + e),
    t.ctrlKey && (e = "Ctrl-" + e),
    t.metaKey && (e = "Meta-" + e),
    n && t.shiftKey && (e = "Shift-" + e),
    e
}
function _ue(e) {
    return new ho({
        props: {
            handleKeyDown: IU(e)
        }
    })
}
function IU(e) {
    let t = vue(e);
    return function(n, r) {
        let s = pue(r), o, i = t[xy(s, r)];
        if (i && i(n.state, n.dispatch, n))
            return !0;
        if (s.length == 1 && s != " ") {
            if (r.shiftKey) {
                let a = t[xy(s, r, !1)];
                if (a && a(n.state, n.dispatch, n))
                    return !0
            }
            if ((r.shiftKey || r.altKey || r.metaKey || s.charCodeAt(0) > 127) && (o = Ta[r.keyCode]) && o != s) {
                let a = t[xy(o, r)];
                if (a && a(n.state, n.dispatch, n))
                    return !0
            }
        }
        return !1
    }
}
const Qn = function(e) {
    for (var t = 0; ; t++)
        if (e = e.previousSibling,
        !e)
            return t
}
  , Af = function(e) {
    let t = e.assignedSlot || e.parentNode;
    return t && t.nodeType == 11 ? t.host : t
};
let L5 = null;
const ti = function(e, t, n) {
    let r = L5 || (L5 = document.createRange());
    return r.setEnd(e, n ?? e.nodeValue.length),
    r.setStart(e, t || 0),
    r
}
  , yue = function() {
    L5 = null
}
  , ql = function(e, t, n, r) {
    return n && (jT(e, t, n, r, -1) || jT(e, t, n, r, 1))
}
  , bue = /^(img|br|input|textarea|hr)$/i;
function jT(e, t, n, r, s) {
    for (; ; ) {
        if (e == n && t == r)
            return !0;
        if (t == (s < 0 ? 0 : xo(e))) {
            let o = e.parentNode;
            if (!o || o.nodeType != 1 || mh(e) || bue.test(e.nodeName) || e.contentEditable == "false")
                return !1;
            t = Qn(e) + (s < 0 ? 0 : 1),
            e = o
        } else if (e.nodeType == 1) {
            if (e = e.childNodes[t + (s < 0 ? -1 : 0)],
            e.contentEditable == "false")
                return !1;
            t = s < 0 ? xo(e) : 0
        } else
            return !1
    }
}
function xo(e) {
    return e.nodeType == 3 ? e.nodeValue.length : e.childNodes.length
}
function Cue(e, t) {
    for (; ; ) {
        if (e.nodeType == 3 && t)
            return e;
        if (e.nodeType == 1 && t > 0) {
            if (e.contentEditable == "false")
                return null;
            e = e.childNodes[t - 1],
            t = xo(e)
        } else if (e.parentNode && !mh(e))
            t = Qn(e),
            e = e.parentNode;
        else
            return null
    }
}
function Sue(e, t) {
    for (; ; ) {
        if (e.nodeType == 3 && t < e.nodeValue.length)
            return e;
        if (e.nodeType == 1 && t < e.childNodes.length) {
            if (e.contentEditable == "false")
                return null;
            e = e.childNodes[t],
            t = 0
        } else if (e.parentNode && !mh(e))
            t = Qn(e) + 1,
            e = e.parentNode;
        else
            return null
    }
}
function wue(e, t, n) {
    for (let r = t == 0, s = t == xo(e); r || s; ) {
        if (e == n)
            return !0;
        let o = Qn(e);
        if (e = e.parentNode,
        !e)
            return !1;
        r = r && o == 0,
        s = s && o == xo(e)
    }
}
function mh(e) {
    let t;
    for (let n = e; n && !(t = n.pmViewDesc); n = n.parentNode)
        ;
    return t && t.node && t.node.isBlock && (t.dom == e || t.contentDOM == e)
}
const N1 = function(e) {
    return e.focusNode && ql(e.focusNode, e.focusOffset, e.anchorNode, e.anchorOffset)
};
function ul(e, t) {
    let n = document.createEvent("Event");
    return n.initEvent("keydown", !0, !0),
    n.keyCode = e,
    n.key = n.code = t,
    n
}
function Eue(e) {
    let t = e.activeElement;
    for (; t && t.shadowRoot; )
        t = t.shadowRoot.activeElement;
    return t
}
function xue(e, t, n) {
    if (e.caretPositionFromPoint)
        try {
            let r = e.caretPositionFromPoint(t, n);
            if (r)
                return {
                    node: r.offsetNode,
                    offset: r.offset
                }
        } catch {}
    if (e.caretRangeFromPoint) {
        let r = e.caretRangeFromPoint(t, n);
        if (r)
            return {
                node: r.startContainer,
                offset: r.startOffset
            }
    }
}
const Fo = typeof navigator < "u" ? navigator : null
  , UT = typeof document < "u" ? document : null
  , Ua = Fo && Fo.userAgent || ""
  , F5 = /Edge\/(\d+)/.exec(Ua)
  , RU = /MSIE \d/.exec(Ua)
  , j5 = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(Ua)
  , Pr = !!(RU || j5 || F5)
  , fa = RU ? document.documentMode : j5 ? +j5[1] : F5 ? +F5[1] : 0
  , no = !Pr && /gecko\/(\d+)/i.test(Ua);
no && +(/Firefox\/(\d+)/.exec(Ua) || [0, 0])[1];
const U5 = !Pr && /Chrome\/(\d+)/.exec(Ua)
  , hr = !!U5
  , NU = U5 ? +U5[1] : 0
  , Cr = !Pr && !!Fo && /Apple Computer/.test(Fo.vendor)
  , Uu = Cr && (/Mobile\/\w+/.test(Ua) || !!Fo && Fo.maxTouchPoints > 2)
  , vs = Uu || (Fo ? /Mac/.test(Fo.platform) : !1)
  , Tue = Fo ? /Win/.test(Fo.platform) : !1
  , Gs = /Android \d/.test(Ua)
  , gh = !!UT && "webkitFontSmoothing"in UT.documentElement.style
  , kue = gh ? +(/\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0;
function Oue(e) {
    let t = e.defaultView && e.defaultView.visualViewport;
    return t ? {
        left: 0,
        right: t.width,
        top: 0,
        bottom: t.height
    } : {
        left: 0,
        right: e.documentElement.clientWidth,
        top: 0,
        bottom: e.documentElement.clientHeight
    }
}
function Jo(e, t) {
    return typeof e == "number" ? e : e[t]
}
function Aue(e) {
    let t = e.getBoundingClientRect()
      , n = t.width / e.offsetWidth || 1
      , r = t.height / e.offsetHeight || 1;
    return {
        left: t.left,
        right: t.left + e.clientWidth * n,
        top: t.top,
        bottom: t.top + e.clientHeight * r
    }
}
function BT(e, t, n) {
    let r = e.someProp("scrollThreshold") || 0
      , s = e.someProp("scrollMargin") || 5
      , o = e.dom.ownerDocument;
    for (let i = n || e.dom; i; i = Af(i)) {
        if (i.nodeType != 1)
            continue;
        let a = i
          , l = a == o.body
          , c = l ? Oue(o) : Aue(a)
          , u = 0
          , d = 0;
        if (t.top < c.top + Jo(r, "top") ? d = -(c.top - t.top + Jo(s, "top")) : t.bottom > c.bottom - Jo(r, "bottom") && (d = t.bottom - t.top > c.bottom - c.top ? t.top + Jo(s, "top") - c.top : t.bottom - c.bottom + Jo(s, "bottom")),
        t.left < c.left + Jo(r, "left") ? u = -(c.left - t.left + Jo(s, "left")) : t.right > c.right - Jo(r, "right") && (u = t.right - c.right + Jo(s, "right")),
        u || d)
            if (l)
                o.defaultView.scrollBy(u, d);
            else {
                let f = a.scrollLeft
                  , p = a.scrollTop;
                d && (a.scrollTop += d),
                u && (a.scrollLeft += u);
                let m = a.scrollLeft - f
                  , v = a.scrollTop - p;
                t = {
                    left: t.left - m,
                    top: t.top - v,
                    right: t.right - m,
                    bottom: t.bottom - v
                }
            }
        if (l || /^(fixed|sticky)$/.test(getComputedStyle(i).position))
            break
    }
}
function Mue(e) {
    let t = e.dom.getBoundingClientRect(), n = Math.max(0, t.top), r, s;
    for (let o = (t.left + t.right) / 2, i = n + 1; i < Math.min(innerHeight, t.bottom); i += 5) {
        let a = e.root.elementFromPoint(o, i);
        if (!a || a == e.dom || !e.dom.contains(a))
            continue;
        let l = a.getBoundingClientRect();
        if (l.top >= n - 20) {
            r = a,
            s = l.top;
            break
        }
    }
    return {
        refDOM: r,
        refTop: s,
        stack: PU(e.dom)
    }
}
function PU(e) {
    let t = []
      , n = e.ownerDocument;
    for (let r = e; r && (t.push({
        dom: r,
        top: r.scrollTop,
        left: r.scrollLeft
    }),
    e != n); r = Af(r))
        ;
    return t
}
function Iue({refDOM: e, refTop: t, stack: n}) {
    let r = e ? e.getBoundingClientRect().top : 0;
    DU(n, r == 0 ? 0 : r - t)
}
function DU(e, t) {
    for (let n = 0; n < e.length; n++) {
        let {dom: r, top: s, left: o} = e[n];
        r.scrollTop != s + t && (r.scrollTop = s + t),
        r.scrollLeft != o && (r.scrollLeft = o)
    }
}
let Ic = null;
function Rue(e) {
    if (e.setActive)
        return e.setActive();
    if (Ic)
        return e.focus(Ic);
    let t = PU(e);
    e.focus(Ic == null ? {
        get preventScroll() {
            return Ic = {
                preventScroll: !0
            },
            !0
        }
    } : void 0),
    Ic || (Ic = !1,
    DU(t, 0))
}
function LU(e, t) {
    let n, r = 2e8, s, o = 0, i = t.top, a = t.top, l, c;
    for (let u = e.firstChild, d = 0; u; u = u.nextSibling,
    d++) {
        let f;
        if (u.nodeType == 1)
            f = u.getClientRects();
        else if (u.nodeType == 3)
            f = ti(u).getClientRects();
        else
            continue;
        for (let p = 0; p < f.length; p++) {
            let m = f[p];
            if (m.top <= i && m.bottom >= a) {
                i = Math.max(m.bottom, i),
                a = Math.min(m.top, a);
                let v = m.left > t.left ? m.left - t.left : m.right < t.left ? t.left - m.right : 0;
                if (v < r) {
                    n = u,
                    r = v,
                    s = v && n.nodeType == 3 ? {
                        left: m.right < t.left ? m.right : m.left,
                        top: t.top
                    } : t,
                    u.nodeType == 1 && v && (o = d + (t.left >= (m.left + m.right) / 2 ? 1 : 0));
                    continue
                }
            } else
                m.top > t.top && !l && m.left <= t.left && m.right >= t.left && (l = u,
                c = {
                    left: Math.max(m.left, Math.min(m.right, t.left)),
                    top: m.top
                });
            !n && (t.left >= m.right && t.top >= m.top || t.left >= m.left && t.top >= m.bottom) && (o = d + 1)
        }
    }
    return !n && l && (n = l,
    s = c,
    r = 0),
    n && n.nodeType == 3 ? Nue(n, s) : !n || r && n.nodeType == 1 ? {
        node: e,
        offset: o
    } : LU(n, s)
}
function Nue(e, t) {
    let n = e.nodeValue.length
      , r = document.createRange();
    for (let s = 0; s < n; s++) {
        r.setEnd(e, s + 1),
        r.setStart(e, s);
        let o = Yi(r, 1);
        if (o.top != o.bottom && zw(t, o))
            return {
                node: e,
                offset: s + (t.left >= (o.left + o.right) / 2 ? 1 : 0)
            }
    }
    return {
        node: e,
        offset: 0
    }
}
function zw(e, t) {
    return e.left >= t.left - 1 && e.left <= t.right + 1 && e.top >= t.top - 1 && e.top <= t.bottom + 1
}
function Pue(e, t) {
    let n = e.parentNode;
    return n && /^li$/i.test(n.nodeName) && t.left < e.getBoundingClientRect().left ? n : e
}
function Due(e, t, n) {
    let {node: r, offset: s} = LU(t, n)
      , o = -1;
    if (r.nodeType == 1 && !r.firstChild) {
        let i = r.getBoundingClientRect();
        o = i.left != i.right && n.left > (i.left + i.right) / 2 ? 1 : -1
    }
    return e.docView.posFromDOM(r, s, o)
}
function Lue(e, t, n, r) {
    let s = -1;
    for (let o = t, i = !1; o != e.dom; ) {
        let a = e.docView.nearestDesc(o, !0);
        if (!a)
            return null;
        if (a.dom.nodeType == 1 && (a.node.isBlock && a.parent || !a.contentDOM)) {
            let l = a.dom.getBoundingClientRect();
            if (a.node.isBlock && a.parent && (!i && l.left > r.left || l.top > r.top ? s = a.posBefore : (!i && l.right < r.left || l.bottom < r.top) && (s = a.posAfter),
            i = !0),
            !a.contentDOM && s < 0 && !a.node.isText)
                return (a.node.isBlock ? r.top < (l.top + l.bottom) / 2 : r.left < (l.left + l.right) / 2) ? a.posBefore : a.posAfter
        }
        o = a.dom.parentNode
    }
    return s > -1 ? s : e.docView.posFromDOM(t, n, -1)
}
function FU(e, t, n) {
    let r = e.childNodes.length;
    if (r && n.top < n.bottom)
        for (let s = Math.max(0, Math.min(r - 1, Math.floor(r * (t.top - n.top) / (n.bottom - n.top)) - 2)), o = s; ; ) {
            let i = e.childNodes[o];
            if (i.nodeType == 1) {
                let a = i.getClientRects();
                for (let l = 0; l < a.length; l++) {
                    let c = a[l];
                    if (zw(t, c))
                        return FU(i, t, c)
                }
            }
            if ((o = (o + 1) % r) == s)
                break
        }
    return e
}
function Fue(e, t) {
    let n = e.dom.ownerDocument, r, s = 0, o = xue(n, t.left, t.top);
    o && ({node: r, offset: s} = o);
    let i = (e.root.elementFromPoint ? e.root : n).elementFromPoint(t.left, t.top), a;
    if (!i || !e.dom.contains(i.nodeType != 1 ? i.parentNode : i)) {
        let c = e.dom.getBoundingClientRect();
        if (!zw(t, c) || (i = FU(e.dom, t, c),
        !i))
            return null
    }
    if (Cr)
        for (let c = i; r && c; c = Af(c))
            c.draggable && (r = void 0);
    if (i = Pue(i, t),
    r) {
        if (no && r.nodeType == 1 && (s = Math.min(s, r.childNodes.length),
        s < r.childNodes.length)) {
            let u = r.childNodes[s], d;
            u.nodeName == "IMG" && (d = u.getBoundingClientRect()).right <= t.left && d.bottom > t.top && s++
        }
        let c;
        gh && s && r.nodeType == 1 && (c = r.childNodes[s - 1]).nodeType == 1 && c.contentEditable == "false" && c.getBoundingClientRect().top >= t.top && s--,
        r == e.dom && s == r.childNodes.length - 1 && r.lastChild.nodeType == 1 && t.top > r.lastChild.getBoundingClientRect().bottom ? a = e.state.doc.content.size : (s == 0 || r.nodeType != 1 || r.childNodes[s - 1].nodeName != "BR") && (a = Lue(e, r, s, t))
    }
    a == null && (a = Due(e, i, t));
    let l = e.docView.nearestDesc(i, !0);
    return {
        pos: a,
        inside: l ? l.posAtStart - l.border : -1
    }
}
function qT(e) {
    return e.top < e.bottom || e.left < e.right
}
function Yi(e, t) {
    let n = e.getClientRects();
    if (n.length) {
        let r = n[t < 0 ? 0 : n.length - 1];
        if (qT(r))
            return r
    }
    return Array.prototype.find.call(n, qT) || e.getBoundingClientRect()
}
const jue = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
function jU(e, t, n) {
    let {node: r, offset: s, atom: o} = e.docView.domFromPos(t, n < 0 ? -1 : 1)
      , i = gh || no;
    if (r.nodeType == 3)
        if (i && (jue.test(r.nodeValue) || (n < 0 ? !s : s == r.nodeValue.length))) {
            let l = Yi(ti(r, s, s), n);
            if (no && s && /\s/.test(r.nodeValue[s - 1]) && s < r.nodeValue.length) {
                let c = Yi(ti(r, s - 1, s - 1), -1);
                if (c.top == l.top) {
                    let u = Yi(ti(r, s, s + 1), -1);
                    if (u.top != l.top)
                        return Sd(u, u.left < c.left)
                }
            }
            return l
        } else {
            let l = s
              , c = s
              , u = n < 0 ? 1 : -1;
            return n < 0 && !s ? (c++,
            u = -1) : n >= 0 && s == r.nodeValue.length ? (l--,
            u = 1) : n < 0 ? l-- : c++,
            Sd(Yi(ti(r, l, c), u), u < 0)
        }
    if (!e.state.doc.resolve(t - (o || 0)).parent.inlineContent) {
        if (o == null && s && (n < 0 || s == xo(r))) {
            let l = r.childNodes[s - 1];
            if (l.nodeType == 1)
                return Ty(l.getBoundingClientRect(), !1)
        }
        if (o == null && s < xo(r)) {
            let l = r.childNodes[s];
            if (l.nodeType == 1)
                return Ty(l.getBoundingClientRect(), !0)
        }
        return Ty(r.getBoundingClientRect(), n >= 0)
    }
    if (o == null && s && (n < 0 || s == xo(r))) {
        let l = r.childNodes[s - 1]
          , c = l.nodeType == 3 ? ti(l, xo(l) - (i ? 0 : 1)) : l.nodeType == 1 && (l.nodeName != "BR" || !l.nextSibling) ? l : null;
        if (c)
            return Sd(Yi(c, 1), !1)
    }
    if (o == null && s < xo(r)) {
        let l = r.childNodes[s];
        for (; l.pmViewDesc && l.pmViewDesc.ignoreForCoords; )
            l = l.nextSibling;
        let c = l ? l.nodeType == 3 ? ti(l, 0, i ? 0 : 1) : l.nodeType == 1 ? l : null : null;
        if (c)
            return Sd(Yi(c, -1), !0)
    }
    return Sd(Yi(r.nodeType == 3 ? ti(r) : r, -n), n >= 0)
}
function Sd(e, t) {
    if (e.width == 0)
        return e;
    let n = t ? e.left : e.right;
    return {
        top: e.top,
        bottom: e.bottom,
        left: n,
        right: n
    }
}
function Ty(e, t) {
    if (e.height == 0)
        return e;
    let n = t ? e.top : e.bottom;
    return {
        top: n,
        bottom: n,
        left: e.left,
        right: e.right
    }
}
function UU(e, t, n) {
    let r = e.state
      , s = e.root.activeElement;
    r != t && e.updateState(t),
    s != e.dom && e.focus();
    try {
        return n()
    } finally {
        r != t && e.updateState(r),
        s != e.dom && s && s.focus()
    }
}
function Uue(e, t, n) {
    let r = t.selection
      , s = n == "up" ? r.$from : r.$to;
    return UU(e, t, () => {
        let {node: o} = e.docView.domFromPos(s.pos, n == "up" ? -1 : 1);
        for (; ; ) {
            let a = e.docView.nearestDesc(o, !0);
            if (!a)
                break;
            if (a.node.isBlock) {
                o = a.contentDOM || a.dom;
                break
            }
            o = a.dom.parentNode
        }
        let i = jU(e, s.pos, 1);
        for (let a = o.firstChild; a; a = a.nextSibling) {
            let l;
            if (a.nodeType == 1)
                l = a.getClientRects();
            else if (a.nodeType == 3)
                l = ti(a, 0, a.nodeValue.length).getClientRects();
            else
                continue;
            for (let c = 0; c < l.length; c++) {
                let u = l[c];
                if (u.bottom > u.top + 1 && (n == "up" ? i.top - u.top > (u.bottom - i.top) * 2 : u.bottom - i.bottom > (i.bottom - u.top) * 2))
                    return !1
            }
        }
        return !0
    }
    )
}
const Bue = /[\u0590-\u08ac]/;
function que(e, t, n) {
    let {$head: r} = t.selection;
    if (!r.parent.isTextblock)
        return !1;
    let s = r.parentOffset
      , o = !s
      , i = s == r.parent.content.size
      , a = e.domSelection();
    return !Bue.test(r.parent.textContent) || !a.modify ? n == "left" || n == "backward" ? o : i : UU(e, t, () => {
        let {focusNode: l, focusOffset: c, anchorNode: u, anchorOffset: d} = e.domSelectionRange()
          , f = a.caretBidiLevel;
        a.modify("move", n, "character");
        let p = r.depth ? e.docView.domAfterPos(r.before()) : e.dom
          , {focusNode: m, focusOffset: v} = e.domSelectionRange()
          , _ = m && !p.contains(m.nodeType == 1 ? m : m.parentNode) || l == m && c == v;
        try {
            a.collapse(u, d),
            l && (l != u || c != d) && a.extend && a.extend(l, c)
        } catch {}
        return f != null && (a.caretBidiLevel = f),
        _
    }
    )
}
let GT = null
  , VT = null
  , HT = !1;
function Gue(e, t, n) {
    return GT == t && VT == n ? HT : (GT = t,
    VT = n,
    HT = n == "up" || n == "down" ? Uue(e, t, n) : que(e, t, n))
}
const Ss = 0
  , zT = 1
  , ml = 2
  , jo = 3;
class vh {
    constructor(t, n, r, s) {
        this.parent = t,
        this.children = n,
        this.dom = r,
        this.contentDOM = s,
        this.dirty = Ss,
        r.pmViewDesc = this
    }
    matchesWidget(t) {
        return !1
    }
    matchesMark(t) {
        return !1
    }
    matchesNode(t, n, r) {
        return !1
    }
    matchesHack(t) {
        return !1
    }
    parseRule() {
        return null
    }
    stopEvent(t) {
        return !1
    }
    get size() {
        let t = 0;
        for (let n = 0; n < this.children.length; n++)
            t += this.children[n].size;
        return t
    }
    get border() {
        return 0
    }
    destroy() {
        this.parent = void 0,
        this.dom.pmViewDesc == this && (this.dom.pmViewDesc = void 0);
        for (let t = 0; t < this.children.length; t++)
            this.children[t].destroy()
    }
    posBeforeChild(t) {
        for (let n = 0, r = this.posAtStart; ; n++) {
            let s = this.children[n];
            if (s == t)
                return r;
            r += s.size
        }
    }
    get posBefore() {
        return this.parent.posBeforeChild(this)
    }
    get posAtStart() {
        return this.parent ? this.parent.posBeforeChild(this) + this.border : 0
    }
    get posAfter() {
        return this.posBefore + this.size
    }
    get posAtEnd() {
        return this.posAtStart + this.size - 2 * this.border
    }
    localPosFromDOM(t, n, r) {
        if (this.contentDOM && this.contentDOM.contains(t.nodeType == 1 ? t : t.parentNode))
            if (r < 0) {
                let o, i;
                if (t == this.contentDOM)
                    o = t.childNodes[n - 1];
                else {
                    for (; t.parentNode != this.contentDOM; )
                        t = t.parentNode;
                    o = t.previousSibling
                }
                for (; o && !((i = o.pmViewDesc) && i.parent == this); )
                    o = o.previousSibling;
                return o ? this.posBeforeChild(i) + i.size : this.posAtStart
            } else {
                let o, i;
                if (t == this.contentDOM)
                    o = t.childNodes[n];
                else {
                    for (; t.parentNode != this.contentDOM; )
                        t = t.parentNode;
                    o = t.nextSibling
                }
                for (; o && !((i = o.pmViewDesc) && i.parent == this); )
                    o = o.nextSibling;
                return o ? this.posBeforeChild(i) : this.posAtEnd
            }
        let s;
        if (t == this.dom && this.contentDOM)
            s = n > Qn(this.contentDOM);
        else if (this.contentDOM && this.contentDOM != this.dom && this.dom.contains(this.contentDOM))
            s = t.compareDocumentPosition(this.contentDOM) & 2;
        else if (this.dom.firstChild) {
            if (n == 0)
                for (let o = t; ; o = o.parentNode) {
                    if (o == this.dom) {
                        s = !1;
                        break
                    }
                    if (o.previousSibling)
                        break
                }
            if (s == null && n == t.childNodes.length)
                for (let o = t; ; o = o.parentNode) {
                    if (o == this.dom) {
                        s = !0;
                        break
                    }
                    if (o.nextSibling)
                        break
                }
        }
        return s ?? r > 0 ? this.posAtEnd : this.posAtStart
    }
    nearestDesc(t, n=!1) {
        for (let r = !0, s = t; s; s = s.parentNode) {
            let o = this.getDesc(s), i;
            if (o && (!n || o.node))
                if (r && (i = o.nodeDOM) && !(i.nodeType == 1 ? i.contains(t.nodeType == 1 ? t : t.parentNode) : i == t))
                    r = !1;
                else
                    return o
        }
    }
    getDesc(t) {
        let n = t.pmViewDesc;
        for (let r = n; r; r = r.parent)
            if (r == this)
                return n
    }
    posFromDOM(t, n, r) {
        for (let s = t; s; s = s.parentNode) {
            let o = this.getDesc(s);
            if (o)
                return o.localPosFromDOM(t, n, r)
        }
        return -1
    }
    descAt(t) {
        for (let n = 0, r = 0; n < this.children.length; n++) {
            let s = this.children[n]
              , o = r + s.size;
            if (r == t && o != r) {
                for (; !s.border && s.children.length; )
                    s = s.children[0];
                return s
            }
            if (t < o)
                return s.descAt(t - r - s.border);
            r = o
        }
    }
    domFromPos(t, n) {
        if (!this.contentDOM)
            return {
                node: this.dom,
                offset: 0,
                atom: t + 1
            };
        let r = 0
          , s = 0;
        for (let o = 0; r < this.children.length; r++) {
            let i = this.children[r]
              , a = o + i.size;
            if (a > t || i instanceof qU) {
                s = t - o;
                break
            }
            o = a
        }
        if (s)
            return this.children[r].domFromPos(s - this.children[r].border, n);
        for (let o; r && !(o = this.children[r - 1]).size && o instanceof BU && o.side >= 0; r--)
            ;
        if (n <= 0) {
            let o, i = !0;
            for (; o = r ? this.children[r - 1] : null,
            !(!o || o.dom.parentNode == this.contentDOM); r--,
            i = !1)
                ;
            return o && n && i && !o.border && !o.domAtom ? o.domFromPos(o.size, n) : {
                node: this.contentDOM,
                offset: o ? Qn(o.dom) + 1 : 0
            }
        } else {
            let o, i = !0;
            for (; o = r < this.children.length ? this.children[r] : null,
            !(!o || o.dom.parentNode == this.contentDOM); r++,
            i = !1)
                ;
            return o && i && !o.border && !o.domAtom ? o.domFromPos(0, n) : {
                node: this.contentDOM,
                offset: o ? Qn(o.dom) : this.contentDOM.childNodes.length
            }
        }
    }
    parseRange(t, n, r=0) {
        if (this.children.length == 0)
            return {
                node: this.contentDOM,
                from: t,
                to: n,
                fromOffset: 0,
                toOffset: this.contentDOM.childNodes.length
            };
        let s = -1
          , o = -1;
        for (let i = r, a = 0; ; a++) {
            let l = this.children[a]
              , c = i + l.size;
            if (s == -1 && t <= c) {
                let u = i + l.border;
                if (t >= u && n <= c - l.border && l.node && l.contentDOM && this.contentDOM.contains(l.contentDOM))
                    return l.parseRange(t, n, u);
                t = i;
                for (let d = a; d > 0; d--) {
                    let f = this.children[d - 1];
                    if (f.size && f.dom.parentNode == this.contentDOM && !f.emptyChildAt(1)) {
                        s = Qn(f.dom) + 1;
                        break
                    }
                    t -= f.size
                }
                s == -1 && (s = 0)
            }
            if (s > -1 && (c > n || a == this.children.length - 1)) {
                n = c;
                for (let u = a + 1; u < this.children.length; u++) {
                    let d = this.children[u];
                    if (d.size && d.dom.parentNode == this.contentDOM && !d.emptyChildAt(-1)) {
                        o = Qn(d.dom);
                        break
                    }
                    n += d.size
                }
                o == -1 && (o = this.contentDOM.childNodes.length);
                break
            }
            i = c
        }
        return {
            node: this.contentDOM,
            from: t,
            to: n,
            fromOffset: s,
            toOffset: o
        }
    }
    emptyChildAt(t) {
        if (this.border || !this.contentDOM || !this.children.length)
            return !1;
        let n = this.children[t < 0 ? 0 : this.children.length - 1];
        return n.size == 0 || n.emptyChildAt(t)
    }
    domAfterPos(t) {
        let {node: n, offset: r} = this.domFromPos(t, 0);
        if (n.nodeType != 1 || r == n.childNodes.length)
            throw new RangeError("No node after pos " + t);
        return n.childNodes[r]
    }
    setSelection(t, n, r, s=!1) {
        let o = Math.min(t, n)
          , i = Math.max(t, n);
        for (let f = 0, p = 0; f < this.children.length; f++) {
            let m = this.children[f]
              , v = p + m.size;
            if (o > p && i < v)
                return m.setSelection(t - p - m.border, n - p - m.border, r, s);
            p = v
        }
        let a = this.domFromPos(t, t ? -1 : 1)
          , l = n == t ? a : this.domFromPos(n, n ? -1 : 1)
          , c = r.getSelection()
          , u = !1;
        if ((no || Cr) && t == n) {
            let {node: f, offset: p} = a;
            if (f.nodeType == 3) {
                if (u = !!(p && f.nodeValue[p - 1] == `
`),
                u && p == f.nodeValue.length)
                    for (let m = f, v; m; m = m.parentNode) {
                        if (v = m.nextSibling) {
                            v.nodeName == "BR" && (a = l = {
                                node: v.parentNode,
                                offset: Qn(v) + 1
                            });
                            break
                        }
                        let _ = m.pmViewDesc;
                        if (_ && _.node && _.node.isBlock)
                            break
                    }
            } else {
                let m = f.childNodes[p - 1];
                u = m && (m.nodeName == "BR" || m.contentEditable == "false")
            }
        }
        if (no && c.focusNode && c.focusNode != l.node && c.focusNode.nodeType == 1) {
            let f = c.focusNode.childNodes[c.focusOffset];
            f && f.contentEditable == "false" && (s = !0)
        }
        if (!(s || u && Cr) && ql(a.node, a.offset, c.anchorNode, c.anchorOffset) && ql(l.node, l.offset, c.focusNode, c.focusOffset))
            return;
        let d = !1;
        if ((c.extend || t == n) && !u) {
            c.collapse(a.node, a.offset);
            try {
                t != n && c.extend(l.node, l.offset),
                d = !0
            } catch {}
        }
        if (!d) {
            if (t > n) {
                let p = a;
                a = l,
                l = p
            }
            let f = document.createRange();
            f.setEnd(l.node, l.offset),
            f.setStart(a.node, a.offset),
            c.removeAllRanges(),
            c.addRange(f)
        }
    }
    ignoreMutation(t) {
        return !this.contentDOM && t.type != "selection"
    }
    get contentLost() {
        return this.contentDOM && this.contentDOM != this.dom && !this.dom.contains(this.contentDOM)
    }
    markDirty(t, n) {
        for (let r = 0, s = 0; s < this.children.length; s++) {
            let o = this.children[s]
              , i = r + o.size;
            if (r == i ? t <= i && n >= r : t < i && n > r) {
                let a = r + o.border
                  , l = i - o.border;
                if (t >= a && n <= l) {
                    this.dirty = t == r || n == i ? ml : zT,
                    t == a && n == l && (o.contentLost || o.dom.parentNode != this.contentDOM) ? o.dirty = jo : o.markDirty(t - a, n - a);
                    return
                } else
                    o.dirty = o.dom == o.contentDOM && o.dom.parentNode == this.contentDOM && !o.children.length ? ml : jo
            }
            r = i
        }
        this.dirty = ml
    }
    markParentsDirty() {
        let t = 1;
        for (let n = this.parent; n; n = n.parent,
        t++) {
            let r = t == 1 ? ml : zT;
            n.dirty < r && (n.dirty = r)
        }
    }
    get domAtom() {
        return !1
    }
    get ignoreForCoords() {
        return !1
    }
    isText(t) {
        return !1
    }
}
class BU extends vh {
    constructor(t, n, r, s) {
        let o, i = n.type.toDOM;
        if (typeof i == "function" && (i = i(r, () => {
            if (!o)
                return s;
            if (o.parent)
                return o.parent.posBeforeChild(o)
        }
        )),
        !n.type.spec.raw) {
            if (i.nodeType != 1) {
                let a = document.createElement("span");
                a.appendChild(i),
                i = a
            }
            i.contentEditable = "false",
            i.classList.add("ProseMirror-widget")
        }
        super(t, [], i, null),
        this.widget = n,
        this.widget = n,
        o = this
    }
    matchesWidget(t) {
        return this.dirty == Ss && t.type.eq(this.widget.type)
    }
    parseRule() {
        return {
            ignore: !0
        }
    }
    stopEvent(t) {
        let n = this.widget.spec.stopEvent;
        return n ? n(t) : !1
    }
    ignoreMutation(t) {
        return t.type != "selection" || this.widget.spec.ignoreSelection
    }
    destroy() {
        this.widget.type.destroy(this.dom),
        super.destroy()
    }
    get domAtom() {
        return !0
    }
    get side() {
        return this.widget.type.side
    }
}
class Vue extends vh {
    constructor(t, n, r, s) {
        super(t, [], n, null),
        this.textDOM = r,
        this.text = s
    }
    get size() {
        return this.text.length
    }
    localPosFromDOM(t, n) {
        return t != this.textDOM ? this.posAtStart + (n ? this.size : 0) : this.posAtStart + n
    }
    domFromPos(t) {
        return {
            node: this.textDOM,
            offset: t
        }
    }
    ignoreMutation(t) {
        return t.type === "characterData" && t.target.nodeValue == t.oldValue
    }
}
class Gl extends vh {
    constructor(t, n, r, s) {
        super(t, [], r, s),
        this.mark = n
    }
    static create(t, n, r, s) {
        let o = s.nodeViews[n.type.name]
          , i = o && o(n, s, r);
        return (!i || !i.dom) && (i = Qu.renderSpec(document, n.type.spec.toDOM(n, r), null, n.attrs)),
        new Gl(t,n,i.dom,i.contentDOM || i.dom)
    }
    parseRule() {
        return this.dirty & jo || this.mark.type.spec.reparseInView ? null : {
            mark: this.mark.type.name,
            attrs: this.mark.attrs,
            contentElement: this.contentDOM
        }
    }
    matchesMark(t) {
        return this.dirty != jo && this.mark.eq(t)
    }
    markDirty(t, n) {
        if (super.markDirty(t, n),
        this.dirty != Ss) {
            let r = this.parent;
            for (; !r.node; )
                r = r.parent;
            r.dirty < this.dirty && (r.dirty = this.dirty),
            this.dirty = Ss
        }
    }
    slice(t, n, r) {
        let s = Gl.create(this.parent, this.mark, !0, r)
          , o = this.children
          , i = this.size;
        n < i && (o = G5(o, n, i, r)),
        t > 0 && (o = G5(o, 0, t, r));
        for (let a = 0; a < o.length; a++)
            o[a].parent = s;
        return s.children = o,
        s
    }
}
class ha extends vh {
    constructor(t, n, r, s, o, i, a, l, c) {
        super(t, [], o, i),
        this.node = n,
        this.outerDeco = r,
        this.innerDeco = s,
        this.nodeDOM = a
    }
    static create(t, n, r, s, o, i) {
        let a = o.nodeViews[n.type.name], l, c = a && a(n, o, () => {
            if (!l)
                return i;
            if (l.parent)
                return l.parent.posBeforeChild(l)
        }
        , r, s), u = c && c.dom, d = c && c.contentDOM;
        if (n.isText) {
            if (!u)
                u = document.createTextNode(n.text);
            else if (u.nodeType != 3)
                throw new RangeError("Text must be rendered as a DOM text node")
        } else
            u || ({dom: u, contentDOM: d} = Qu.renderSpec(document, n.type.spec.toDOM(n), null, n.attrs));
        !d && !n.isText && u.nodeName != "BR" && (u.hasAttribute("contenteditable") || (u.contentEditable = "false"),
        n.type.spec.draggable && (u.draggable = !0));
        let f = u;
        return u = HU(u, r, n),
        c ? l = new Hue(t,n,r,s,u,d || null,f,c,o,i + 1) : n.isText ? new P1(t,n,r,s,u,f,o) : new ha(t,n,r,s,u,d || null,f,o,i + 1)
    }
    parseRule() {
        if (this.node.type.spec.reparseInView)
            return null;
        let t = {
            node: this.node.type.name,
            attrs: this.node.attrs
        };
        if (this.node.type.whitespace == "pre" && (t.preserveWhitespace = "full"),
        !this.contentDOM)
            t.getContent = () => this.node.content;
        else if (!this.contentLost)
            t.contentElement = this.contentDOM;
        else {
            for (let n = this.children.length - 1; n >= 0; n--) {
                let r = this.children[n];
                if (this.dom.contains(r.dom.parentNode)) {
                    t.contentElement = r.dom.parentNode;
                    break
                }
            }
            t.contentElement || (t.getContent = () => pe.empty)
        }
        return t
    }
    matchesNode(t, n, r) {
        return this.dirty == Ss && t.eq(this.node) && q5(n, this.outerDeco) && r.eq(this.innerDeco)
    }
    get size() {
        return this.node.nodeSize
    }
    get border() {
        return this.node.isLeaf ? 0 : 1
    }
    updateChildren(t, n) {
        let r = this.node.inlineContent
          , s = n
          , o = t.composing ? this.localCompositionInfo(t, n) : null
          , i = o && o.pos > -1 ? o : null
          , a = o && o.pos < 0
          , l = new $ue(this,i && i.node,t);
        Yue(this.node, this.innerDeco, (c, u, d) => {
            c.spec.marks ? l.syncToMarks(c.spec.marks, r, t) : c.type.side >= 0 && !d && l.syncToMarks(u == this.node.childCount ? Lt.none : this.node.child(u).marks, r, t),
            l.placeWidget(c, t, s)
        }
        , (c, u, d, f) => {
            l.syncToMarks(c.marks, r, t);
            let p;
            l.findNodeMatch(c, u, d, f) || a && t.state.selection.from > s && t.state.selection.to < s + c.nodeSize && (p = l.findIndexWithChild(o.node)) > -1 && l.updateNodeAt(c, u, d, p, t) || l.updateNextNode(c, u, d, t, f, s) || l.addNode(c, u, d, t, s),
            s += c.nodeSize
        }
        ),
        l.syncToMarks([], r, t),
        this.node.isTextblock && l.addTextblockHacks(),
        l.destroyRest(),
        (l.changed || this.dirty == ml) && (i && this.protectLocalComposition(t, i),
        GU(this.contentDOM, this.children, t),
        Uu && Zue(this.dom))
    }
    localCompositionInfo(t, n) {
        let {from: r, to: s} = t.state.selection;
        if (!(t.state.selection instanceof Rt) || r < n || s > n + this.node.content.size)
            return null;
        let o = t.input.compositionNode;
        if (!o || !this.dom.contains(o.parentNode))
            return null;
        if (this.node.inlineContent) {
            let i = o.nodeValue
              , a = Jue(this.node.content, i, r - n, s - n);
            return a < 0 ? null : {
                node: o,
                pos: a,
                text: i
            }
        } else
            return {
                node: o,
                pos: -1,
                text: ""
            }
    }
    protectLocalComposition(t, {node: n, pos: r, text: s}) {
        if (this.getDesc(n))
            return;
        let o = n;
        for (; o.parentNode != this.contentDOM; o = o.parentNode) {
            for (; o.previousSibling; )
                o.parentNode.removeChild(o.previousSibling);
            for (; o.nextSibling; )
                o.parentNode.removeChild(o.nextSibling);
            o.pmViewDesc && (o.pmViewDesc = void 0)
        }
        let i = new Vue(this,o,n,s);
        t.input.compositionNodes.push(i),
        this.children = G5(this.children, r, r + s.length, t, i)
    }
    update(t, n, r, s) {
        return this.dirty == jo || !t.sameMarkup(this.node) ? !1 : (this.updateInner(t, n, r, s),
        !0)
    }
    updateInner(t, n, r, s) {
        this.updateOuterDeco(n),
        this.node = t,
        this.innerDeco = r,
        this.contentDOM && this.updateChildren(s, this.posAtStart),
        this.dirty = Ss
    }
    updateOuterDeco(t) {
        if (q5(t, this.outerDeco))
            return;
        let n = this.nodeDOM.nodeType != 1
          , r = this.dom;
        this.dom = VU(this.dom, this.nodeDOM, B5(this.outerDeco, this.node, n), B5(t, this.node, n)),
        this.dom != r && (r.pmViewDesc = void 0,
        this.dom.pmViewDesc = this),
        this.outerDeco = t
    }
    selectNode() {
        this.nodeDOM.nodeType == 1 && this.nodeDOM.classList.add("ProseMirror-selectednode"),
        (this.contentDOM || !this.node.type.spec.draggable) && (this.dom.draggable = !0)
    }
    deselectNode() {
        this.nodeDOM.nodeType == 1 && (this.nodeDOM.classList.remove("ProseMirror-selectednode"),
        (this.contentDOM || !this.node.type.spec.draggable) && this.dom.removeAttribute("draggable"))
    }
    get domAtom() {
        return this.node.isAtom
    }
}
function $T(e, t, n, r, s) {
    HU(r, t, e);
    let o = new ha(void 0,e,t,n,r,r,r,s,0);
    return o.contentDOM && o.updateChildren(s, 0),
    o
}
class P1 extends ha {
    constructor(t, n, r, s, o, i, a) {
        super(t, n, r, s, o, null, i, a, 0)
    }
    parseRule() {
        let t = this.nodeDOM.parentNode;
        for (; t && t != this.dom && !t.pmIsDeco; )
            t = t.parentNode;
        return {
            skip: t || !0
        }
    }
    update(t, n, r, s) {
        return this.dirty == jo || this.dirty != Ss && !this.inParent() || !t.sameMarkup(this.node) ? !1 : (this.updateOuterDeco(n),
        (this.dirty != Ss || t.text != this.node.text) && t.text != this.nodeDOM.nodeValue && (this.nodeDOM.nodeValue = t.text,
        s.trackWrites == this.nodeDOM && (s.trackWrites = null)),
        this.node = t,
        this.dirty = Ss,
        !0)
    }
    inParent() {
        let t = this.parent.contentDOM;
        for (let n = this.nodeDOM; n; n = n.parentNode)
            if (n == t)
                return !0;
        return !1
    }
    domFromPos(t) {
        return {
            node: this.nodeDOM,
            offset: t
        }
    }
    localPosFromDOM(t, n, r) {
        return t == this.nodeDOM ? this.posAtStart + Math.min(n, this.node.text.length) : super.localPosFromDOM(t, n, r)
    }
    ignoreMutation(t) {
        return t.type != "characterData" && t.type != "selection"
    }
    slice(t, n, r) {
        let s = this.node.cut(t, n)
          , o = document.createTextNode(s.text);
        return new P1(this.parent,s,this.outerDeco,this.innerDeco,o,o,r)
    }
    markDirty(t, n) {
        super.markDirty(t, n),
        this.dom != this.nodeDOM && (t == 0 || n == this.nodeDOM.nodeValue.length) && (this.dirty = jo)
    }
    get domAtom() {
        return !1
    }
    isText(t) {
        return this.node.text == t
    }
}
class qU extends vh {
    parseRule() {
        return {
            ignore: !0
        }
    }
    matchesHack(t) {
        return this.dirty == Ss && this.dom.nodeName == t
    }
    get domAtom() {
        return !0
    }
    get ignoreForCoords() {
        return this.dom.nodeName == "IMG"
    }
}
class Hue extends ha {
    constructor(t, n, r, s, o, i, a, l, c, u) {
        super(t, n, r, s, o, i, a, c, u),
        this.spec = l
    }
    update(t, n, r, s) {
        if (this.dirty == jo)
            return !1;
        if (this.spec.update) {
            let o = this.spec.update(t, n, r);
            return o && this.updateInner(t, n, r, s),
            o
        } else
            return !this.contentDOM && !t.isLeaf ? !1 : super.update(t, n, r, s)
    }
    selectNode() {
        this.spec.selectNode ? this.spec.selectNode() : super.selectNode()
    }
    deselectNode() {
        this.spec.deselectNode ? this.spec.deselectNode() : super.deselectNode()
    }
    setSelection(t, n, r, s) {
        this.spec.setSelection ? this.spec.setSelection(t, n, r) : super.setSelection(t, n, r, s)
    }
    destroy() {
        this.spec.destroy && this.spec.destroy(),
        super.destroy()
    }
    stopEvent(t) {
        return this.spec.stopEvent ? this.spec.stopEvent(t) : !1
    }
    ignoreMutation(t) {
        return this.spec.ignoreMutation ? this.spec.ignoreMutation(t) : super.ignoreMutation(t)
    }
}
function GU(e, t, n) {
    let r = e.firstChild
      , s = !1;
    for (let o = 0; o < t.length; o++) {
        let i = t[o]
          , a = i.dom;
        if (a.parentNode == e) {
            for (; a != r; )
                r = WT(r),
                s = !0;
            r = r.nextSibling
        } else
            s = !0,
            e.insertBefore(a, r);
        if (i instanceof Gl) {
            let l = r ? r.previousSibling : e.lastChild;
            GU(i.contentDOM, i.children, n),
            r = l ? l.nextSibling : e.firstChild
        }
    }
    for (; r; )
        r = WT(r),
        s = !0;
    s && n.trackWrites == e && (n.trackWrites = null)
}
const tf = function(e) {
    e && (this.nodeName = e)
};
tf.prototype = Object.create(null);
const gl = [new tf];
function B5(e, t, n) {
    if (e.length == 0)
        return gl;
    let r = n ? gl[0] : new tf
      , s = [r];
    for (let o = 0; o < e.length; o++) {
        let i = e[o].type.attrs;
        if (i) {
            i.nodeName && s.push(r = new tf(i.nodeName));
            for (let a in i) {
                let l = i[a];
                l != null && (n && s.length == 1 && s.push(r = new tf(t.isInline ? "span" : "div")),
                a == "class" ? r.class = (r.class ? r.class + " " : "") + l : a == "style" ? r.style = (r.style ? r.style + ";" : "") + l : a != "nodeName" && (r[a] = l))
            }
        }
    }
    return s
}
function VU(e, t, n, r) {
    if (n == gl && r == gl)
        return t;
    let s = t;
    for (let o = 0; o < r.length; o++) {
        let i = r[o]
          , a = n[o];
        if (o) {
            let l;
            a && a.nodeName == i.nodeName && s != e && (l = s.parentNode) && l.nodeName.toLowerCase() == i.nodeName || (l = document.createElement(i.nodeName),
            l.pmIsDeco = !0,
            l.appendChild(s),
            a = gl[0]),
            s = l
        }
        zue(s, a || gl[0], i)
    }
    return s
}
function zue(e, t, n) {
    for (let r in t)
        r != "class" && r != "style" && r != "nodeName" && !(r in n) && e.removeAttribute(r);
    for (let r in n)
        r != "class" && r != "style" && r != "nodeName" && n[r] != t[r] && e.setAttribute(r, n[r]);
    if (t.class != n.class) {
        let r = t.class ? t.class.split(" ").filter(Boolean) : []
          , s = n.class ? n.class.split(" ").filter(Boolean) : [];
        for (let o = 0; o < r.length; o++)
            s.indexOf(r[o]) == -1 && e.classList.remove(r[o]);
        for (let o = 0; o < s.length; o++)
            r.indexOf(s[o]) == -1 && e.classList.add(s[o]);
        e.classList.length == 0 && e.removeAttribute("class")
    }
    if (t.style != n.style) {
        if (t.style) {
            let r = /\s*([\w\-\xa1-\uffff]+)\s*:(?:"(?:\\.|[^"])*"|'(?:\\.|[^'])*'|\(.*?\)|[^;])*/g, s;
            for (; s = r.exec(t.style); )
                e.style.removeProperty(s[1])
        }
        n.style && (e.style.cssText += n.style)
    }
}
function HU(e, t, n) {
    return VU(e, e, gl, B5(t, n, e.nodeType != 1))
}
function q5(e, t) {
    if (e.length != t.length)
        return !1;
    for (let n = 0; n < e.length; n++)
        if (!e[n].type.eq(t[n].type))
            return !1;
    return !0
}
function WT(e) {
    let t = e.nextSibling;
    return e.parentNode.removeChild(e),
    t
}
class $ue {
    constructor(t, n, r) {
        this.lock = n,
        this.view = r,
        this.index = 0,
        this.stack = [],
        this.changed = !1,
        this.top = t,
        this.preMatch = Wue(t.node.content, t)
    }
    destroyBetween(t, n) {
        if (t != n) {
            for (let r = t; r < n; r++)
                this.top.children[r].destroy();
            this.top.children.splice(t, n - t),
            this.changed = !0
        }
    }
    destroyRest() {
        this.destroyBetween(this.index, this.top.children.length)
    }
    syncToMarks(t, n, r) {
        let s = 0
          , o = this.stack.length >> 1
          , i = Math.min(o, t.length);
        for (; s < i && (s == o - 1 ? this.top : this.stack[s + 1 << 1]).matchesMark(t[s]) && t[s].type.spec.spanning !== !1; )
            s++;
        for (; s < o; )
            this.destroyRest(),
            this.top.dirty = Ss,
            this.index = this.stack.pop(),
            this.top = this.stack.pop(),
            o--;
        for (; o < t.length; ) {
            this.stack.push(this.top, this.index + 1);
            let a = -1;
            for (let l = this.index; l < Math.min(this.index + 3, this.top.children.length); l++) {
                let c = this.top.children[l];
                if (c.matchesMark(t[o]) && !this.isLocked(c.dom)) {
                    a = l;
                    break
                }
            }
            if (a > -1)
                a > this.index && (this.changed = !0,
                this.destroyBetween(this.index, a)),
                this.top = this.top.children[this.index];
            else {
                let l = Gl.create(this.top, t[o], n, r);
                this.top.children.splice(this.index, 0, l),
                this.top = l,
                this.changed = !0
            }
            this.index = 0,
            o++
        }
    }
    findNodeMatch(t, n, r, s) {
        let o = -1, i;
        if (s >= this.preMatch.index && (i = this.preMatch.matches[s - this.preMatch.index]).parent == this.top && i.matchesNode(t, n, r))
            o = this.top.children.indexOf(i, this.index);
        else
            for (let a = this.index, l = Math.min(this.top.children.length, a + 5); a < l; a++) {
                let c = this.top.children[a];
                if (c.matchesNode(t, n, r) && !this.preMatch.matched.has(c)) {
                    o = a;
                    break
                }
            }
        return o < 0 ? !1 : (this.destroyBetween(this.index, o),
        this.index++,
        !0)
    }
    updateNodeAt(t, n, r, s, o) {
        let i = this.top.children[s];
        return i.dirty == jo && i.dom == i.contentDOM && (i.dirty = ml),
        i.update(t, n, r, o) ? (this.destroyBetween(this.index, s),
        this.index++,
        !0) : !1
    }
    findIndexWithChild(t) {
        for (; ; ) {
            let n = t.parentNode;
            if (!n)
                return -1;
            if (n == this.top.contentDOM) {
                let r = t.pmViewDesc;
                if (r) {
                    for (let s = this.index; s < this.top.children.length; s++)
                        if (this.top.children[s] == r)
                            return s
                }
                return -1
            }
            t = n
        }
    }
    updateNextNode(t, n, r, s, o, i) {
        for (let a = this.index; a < this.top.children.length; a++) {
            let l = this.top.children[a];
            if (l instanceof ha) {
                let c = this.preMatch.matched.get(l);
                if (c != null && c != o)
                    return !1;
                let u = l.dom, d, f = this.isLocked(u) && !(t.isText && l.node && l.node.isText && l.nodeDOM.nodeValue == t.text && l.dirty != jo && q5(n, l.outerDeco));
                if (!f && l.update(t, n, r, s))
                    return this.destroyBetween(this.index, a),
                    l.dom != u && (this.changed = !0),
                    this.index++,
                    !0;
                if (!f && (d = this.recreateWrapper(l, t, n, r, s, i)))
                    return this.top.children[this.index] = d,
                    d.contentDOM && (d.dirty = ml,
                    d.updateChildren(s, i + 1),
                    d.dirty = Ss),
                    this.changed = !0,
                    this.index++,
                    !0;
                break
            }
        }
        return !1
    }
    recreateWrapper(t, n, r, s, o, i) {
        if (t.dirty || n.isAtom || !t.children.length || !t.node.content.eq(n.content))
            return null;
        let a = ha.create(this.top, n, r, s, o, i);
        if (a.contentDOM) {
            a.children = t.children,
            t.children = [];
            for (let l of a.children)
                l.parent = a
        }
        return t.destroy(),
        a
    }
    addNode(t, n, r, s, o) {
        let i = ha.create(this.top, t, n, r, s, o);
        i.contentDOM && i.updateChildren(s, o + 1),
        this.top.children.splice(this.index++, 0, i),
        this.changed = !0
    }
    placeWidget(t, n, r) {
        let s = this.index < this.top.children.length ? this.top.children[this.index] : null;
        if (s && s.matchesWidget(t) && (t == s.widget || !s.widget.type.toDOM.parentNode))
            this.index++;
        else {
            let o = new BU(this.top,t,n,r);
            this.top.children.splice(this.index++, 0, o),
            this.changed = !0
        }
    }
    addTextblockHacks() {
        let t = this.top.children[this.index - 1]
          , n = this.top;
        for (; t instanceof Gl; )
            n = t,
            t = n.children[n.children.length - 1];
        (!t || !(t instanceof P1) || /\n$/.test(t.node.text) || this.view.requiresGeckoHackNode && /\s$/.test(t.node.text)) && ((Cr || hr) && t && t.dom.contentEditable == "false" && this.addHackNode("IMG", n),
        this.addHackNode("BR", this.top))
    }
    addHackNode(t, n) {
        if (n == this.top && this.index < n.children.length && n.children[this.index].matchesHack(t))
            this.index++;
        else {
            let r = document.createElement(t);
            t == "IMG" && (r.className = "ProseMirror-separator",
            r.alt = ""),
            t == "BR" && (r.className = "ProseMirror-trailingBreak");
            let s = new qU(this.top,[],r,null);
            n != this.top ? n.children.push(s) : n.children.splice(this.index++, 0, s),
            this.changed = !0
        }
    }
    isLocked(t) {
        return this.lock && (t == this.lock || t.nodeType == 1 && t.contains(this.lock.parentNode))
    }
}
function Wue(e, t) {
    let n = t
      , r = n.children.length
      , s = e.childCount
      , o = new Map
      , i = [];
    e: for (; s > 0; ) {
        let a;
        for (; ; )
            if (r) {
                let c = n.children[r - 1];
                if (c instanceof Gl)
                    n = c,
                    r = c.children.length;
                else {
                    a = c,
                    r--;
                    break
                }
            } else {
                if (n == t)
                    break e;
                r = n.parent.children.indexOf(n),
                n = n.parent
            }
        let l = a.node;
        if (l) {
            if (l != e.child(s - 1))
                break;
            --s,
            o.set(a, s),
            i.push(a)
        }
    }
    return {
        index: s,
        matched: o,
        matches: i.reverse()
    }
}
function Kue(e, t) {
    return e.type.side - t.type.side
}
function Yue(e, t, n, r) {
    let s = t.locals(e)
      , o = 0;
    if (s.length == 0) {
        for (let c = 0; c < e.childCount; c++) {
            let u = e.child(c);
            r(u, s, t.forChild(o, u), c),
            o += u.nodeSize
        }
        return
    }
    let i = 0
      , a = []
      , l = null;
    for (let c = 0; ; ) {
        let u, d;
        for (; i < s.length && s[i].to == o; ) {
            let _ = s[i++];
            _.widget && (u ? (d || (d = [u])).push(_) : u = _)
        }
        if (u)
            if (d) {
                d.sort(Kue);
                for (let _ = 0; _ < d.length; _++)
                    n(d[_], c, !!l)
            } else
                n(u, c, !!l);
        let f, p;
        if (l)
            p = -1,
            f = l,
            l = null;
        else if (c < e.childCount)
            p = c,
            f = e.child(c++);
        else
            break;
        for (let _ = 0; _ < a.length; _++)
            a[_].to <= o && a.splice(_--, 1);
        for (; i < s.length && s[i].from <= o && s[i].to > o; )
            a.push(s[i++]);
        let m = o + f.nodeSize;
        if (f.isText) {
            let _ = m;
            i < s.length && s[i].from < _ && (_ = s[i].from);
            for (let y = 0; y < a.length; y++)
                a[y].to < _ && (_ = a[y].to);
            _ < m && (l = f.cut(_ - o),
            f = f.cut(0, _ - o),
            m = _,
            p = -1)
        } else
            for (; i < s.length && s[i].to < m; )
                i++;
        let v = f.isInline && !f.isLeaf ? a.filter(_ => !_.inline) : a.slice();
        r(f, v, t.forChild(o, f), p),
        o = m
    }
}
function Zue(e) {
    if (e.nodeName == "UL" || e.nodeName == "OL") {
        let t = e.style.cssText;
        e.style.cssText = t + "; list-style: square !important",
        window.getComputedStyle(e).listStyle,
        e.style.cssText = t
    }
}
function Jue(e, t, n, r) {
    for (let s = 0, o = 0; s < e.childCount && o <= r; ) {
        let i = e.child(s++)
          , a = o;
        if (o += i.nodeSize,
        !i.isText)
            continue;
        let l = i.text;
        for (; s < e.childCount; ) {
            let c = e.child(s++);
            if (o += c.nodeSize,
            !c.isText)
                break;
            l += c.text
        }
        if (o >= n) {
            if (o >= r && l.slice(r - t.length - a, r - a) == t)
                return r - t.length;
            let c = a < r ? l.lastIndexOf(t, r - a - 1) : -1;
            if (c >= 0 && c + t.length + a >= n)
                return a + c;
            if (n == r && l.length >= r + t.length - a && l.slice(r - a, r - a + t.length) == t)
                return r
        }
    }
    return -1
}
function G5(e, t, n, r, s) {
    let o = [];
    for (let i = 0, a = 0; i < e.length; i++) {
        let l = e[i]
          , c = a
          , u = a += l.size;
        c >= n || u <= t ? o.push(l) : (c < t && o.push(l.slice(0, t - c, r)),
        s && (o.push(s),
        s = void 0),
        u > n && o.push(l.slice(n - c, l.size, r)))
    }
    return o
}
function $w(e, t=null) {
    let n = e.domSelectionRange()
      , r = e.state.doc;
    if (!n.focusNode)
        return null;
    let s = e.docView.nearestDesc(n.focusNode)
      , o = s && s.size == 0
      , i = e.docView.posFromDOM(n.focusNode, n.focusOffset, 1);
    if (i < 0)
        return null;
    let a = r.resolve(i), l, c;
    if (N1(n)) {
        for (l = a; s && !s.node; )
            s = s.parent;
        let u = s.node;
        if (s && u.isAtom && st.isSelectable(u) && s.parent && !(u.isInline && wue(n.focusNode, n.focusOffset, s.dom))) {
            let d = s.posBefore;
            c = new st(i == d ? a : r.resolve(d))
        }
    } else {
        let u = e.docView.posFromDOM(n.anchorNode, n.anchorOffset, 1);
        if (u < 0)
            return null;
        l = r.resolve(u)
    }
    if (!c) {
        let u = t == "pointer" || e.state.selection.head < a.pos && !o ? 1 : -1;
        c = Ww(e, l, a, u)
    }
    return c
}
function zU(e) {
    return e.editable ? e.hasFocus() : WU(e) && document.activeElement && document.activeElement.contains(e.dom)
}
function hi(e, t=!1) {
    let n = e.state.selection;
    if ($U(e, n),
    !!zU(e)) {
        if (!t && e.input.mouseDown && e.input.mouseDown.allowDefault && hr) {
            let r = e.domSelectionRange()
              , s = e.domObserver.currentSelection;
            if (r.anchorNode && s.anchorNode && ql(r.anchorNode, r.anchorOffset, s.anchorNode, s.anchorOffset)) {
                e.input.mouseDown.delayedSelectionSync = !0,
                e.domObserver.setCurSelection();
                return
            }
        }
        if (e.domObserver.disconnectSelection(),
        e.cursorWrapper)
            Que(e);
        else {
            let {anchor: r, head: s} = n, o, i;
            KT && !(n instanceof Rt) && (n.$from.parent.inlineContent || (o = YT(e, n.from)),
            !n.empty && !n.$from.parent.inlineContent && (i = YT(e, n.to))),
            e.docView.setSelection(r, s, e.root, t),
            KT && (o && ZT(o),
            i && ZT(i)),
            n.visible ? e.dom.classList.remove("ProseMirror-hideselection") : (e.dom.classList.add("ProseMirror-hideselection"),
            "onselectionchange"in document && Xue(e))
        }
        e.domObserver.setCurSelection(),
        e.domObserver.connectSelection()
    }
}
const KT = Cr || hr && NU < 63;
function YT(e, t) {
    let {node: n, offset: r} = e.docView.domFromPos(t, 0)
      , s = r < n.childNodes.length ? n.childNodes[r] : null
      , o = r ? n.childNodes[r - 1] : null;
    if (Cr && s && s.contentEditable == "false")
        return ky(s);
    if ((!s || s.contentEditable == "false") && (!o || o.contentEditable == "false")) {
        if (s)
            return ky(s);
        if (o)
            return ky(o)
    }
}
function ky(e) {
    return e.contentEditable = "true",
    Cr && e.draggable && (e.draggable = !1,
    e.wasDraggable = !0),
    e
}
function ZT(e) {
    e.contentEditable = "false",
    e.wasDraggable && (e.draggable = !0,
    e.wasDraggable = null)
}
function Xue(e) {
    let t = e.dom.ownerDocument;
    t.removeEventListener("selectionchange", e.input.hideSelectionGuard);
    let n = e.domSelectionRange()
      , r = n.anchorNode
      , s = n.anchorOffset;
    t.addEventListener("selectionchange", e.input.hideSelectionGuard = () => {
        (n.anchorNode != r || n.anchorOffset != s) && (t.removeEventListener("selectionchange", e.input.hideSelectionGuard),
        setTimeout( () => {
            (!zU(e) || e.state.selection.visible) && e.dom.classList.remove("ProseMirror-hideselection")
        }
        , 20))
    }
    )
}
function Que(e) {
    let t = e.domSelection()
      , n = document.createRange()
      , r = e.cursorWrapper.dom
      , s = r.nodeName == "IMG";
    s ? n.setEnd(r.parentNode, Qn(r) + 1) : n.setEnd(r, 0),
    n.collapse(!1),
    t.removeAllRanges(),
    t.addRange(n),
    !s && !e.state.selection.visible && Pr && fa <= 11 && (r.disabled = !0,
    r.disabled = !1)
}
function $U(e, t) {
    if (t instanceof st) {
        let n = e.docView.descAt(t.from);
        n != e.lastSelectedViewDesc && (JT(e),
        n && n.selectNode(),
        e.lastSelectedViewDesc = n)
    } else
        JT(e)
}
function JT(e) {
    e.lastSelectedViewDesc && (e.lastSelectedViewDesc.parent && e.lastSelectedViewDesc.deselectNode(),
    e.lastSelectedViewDesc = void 0)
}
function Ww(e, t, n, r) {
    return e.someProp("createSelectionBetween", s => s(e, t, n)) || Rt.between(t, n, r)
}
function XT(e) {
    return e.editable && !e.hasFocus() ? !1 : WU(e)
}
function WU(e) {
    let t = e.domSelectionRange();
    if (!t.anchorNode)
        return !1;
    try {
        return e.dom.contains(t.anchorNode.nodeType == 3 ? t.anchorNode.parentNode : t.anchorNode) && (e.editable || e.dom.contains(t.focusNode.nodeType == 3 ? t.focusNode.parentNode : t.focusNode))
    } catch {
        return !1
    }
}
function ede(e) {
    let t = e.docView.domFromPos(e.state.selection.anchor, 0)
      , n = e.domSelectionRange();
    return ql(t.node, t.offset, n.anchorNode, n.anchorOffset)
}
function V5(e, t) {
    let {$anchor: n, $head: r} = e.selection
      , s = t > 0 ? n.max(r) : n.min(r)
      , o = s.parent.inlineContent ? s.depth ? e.doc.resolve(t > 0 ? s.after() : s.before()) : null : s;
    return o && Et.findFrom(o, t)
}
function Zi(e, t) {
    return e.dispatch(e.state.tr.setSelection(t).scrollIntoView()),
    !0
}
function QT(e, t, n) {
    let r = e.state.selection;
    if (r instanceof Rt)
        if (n.indexOf("s") > -1) {
            let {$head: s} = r
              , o = s.textOffset ? null : t < 0 ? s.nodeBefore : s.nodeAfter;
            if (!o || o.isText || !o.isLeaf)
                return !1;
            let i = e.state.doc.resolve(s.pos + o.nodeSize * (t < 0 ? -1 : 1));
            return Zi(e, new Rt(r.$anchor,i))
        } else if (r.empty) {
            if (e.endOfTextblock(t > 0 ? "forward" : "backward")) {
                let s = V5(e.state, t);
                return s && s instanceof st ? Zi(e, s) : !1
            } else if (!(vs && n.indexOf("m") > -1)) {
                let s = r.$head, o = s.textOffset ? null : t < 0 ? s.nodeBefore : s.nodeAfter, i;
                if (!o || o.isText)
                    return !1;
                let a = t < 0 ? s.pos - o.nodeSize : s.pos;
                return o.isAtom || (i = e.docView.descAt(a)) && !i.contentDOM ? st.isSelectable(o) ? Zi(e, new st(t < 0 ? e.state.doc.resolve(s.pos - o.nodeSize) : s)) : gh ? Zi(e, new Rt(e.state.doc.resolve(t < 0 ? a : a + o.nodeSize))) : !1 : !1
            }
        } else
            return !1;
    else {
        if (r instanceof st && r.node.isInline)
            return Zi(e, new Rt(t > 0 ? r.$to : r.$from));
        {
            let s = V5(e.state, t);
            return s ? Zi(e, s) : !1
        }
    }
}
function Xm(e) {
    return e.nodeType == 3 ? e.nodeValue.length : e.childNodes.length
}
function nf(e, t) {
    let n = e.pmViewDesc;
    return n && n.size == 0 && (t < 0 || e.nextSibling || e.nodeName != "BR")
}
function Rc(e, t) {
    return t < 0 ? tde(e) : nde(e)
}
function tde(e) {
    let t = e.domSelectionRange()
      , n = t.focusNode
      , r = t.focusOffset;
    if (!n)
        return;
    let s, o, i = !1;
    for (no && n.nodeType == 1 && r < Xm(n) && nf(n.childNodes[r], -1) && (i = !0); ; )
        if (r > 0) {
            if (n.nodeType != 1)
                break;
            {
                let a = n.childNodes[r - 1];
                if (nf(a, -1))
                    s = n,
                    o = --r;
                else if (a.nodeType == 3)
                    n = a,
                    r = n.nodeValue.length;
                else
                    break
            }
        } else {
            if (KU(n))
                break;
            {
                let a = n.previousSibling;
                for (; a && nf(a, -1); )
                    s = n.parentNode,
                    o = Qn(a),
                    a = a.previousSibling;
                if (a)
                    n = a,
                    r = Xm(n);
                else {
                    if (n = n.parentNode,
                    n == e.dom)
                        break;
                    r = 0
                }
            }
        }
    i ? H5(e, n, r) : s && H5(e, s, o)
}
function nde(e) {
    let t = e.domSelectionRange()
      , n = t.focusNode
      , r = t.focusOffset;
    if (!n)
        return;
    let s = Xm(n), o, i;
    for (; ; )
        if (r < s) {
            if (n.nodeType != 1)
                break;
            let a = n.childNodes[r];
            if (nf(a, 1))
                o = n,
                i = ++r;
            else
                break
        } else {
            if (KU(n))
                break;
            {
                let a = n.nextSibling;
                for (; a && nf(a, 1); )
                    o = a.parentNode,
                    i = Qn(a) + 1,
                    a = a.nextSibling;
                if (a)
                    n = a,
                    r = 0,
                    s = Xm(n);
                else {
                    if (n = n.parentNode,
                    n == e.dom)
                        break;
                    r = s = 0
                }
            }
        }
    o && H5(e, o, i)
}
function KU(e) {
    let t = e.pmViewDesc;
    return t && t.node && t.node.isBlock
}
function rde(e, t) {
    for (; e && t == e.childNodes.length && !mh(e); )
        t = Qn(e) + 1,
        e = e.parentNode;
    for (; e && t < e.childNodes.length; ) {
        let n = e.childNodes[t];
        if (n.nodeType == 3)
            return n;
        if (n.nodeType == 1 && n.contentEditable == "false")
            break;
        e = n,
        t = 0
    }
}
function sde(e, t) {
    for (; e && !t && !mh(e); )
        t = Qn(e),
        e = e.parentNode;
    for (; e && t; ) {
        let n = e.childNodes[t - 1];
        if (n.nodeType == 3)
            return n;
        if (n.nodeType == 1 && n.contentEditable == "false")
            break;
        e = n,
        t = e.childNodes.length
    }
}
function H5(e, t, n) {
    if (t.nodeType != 3) {
        let o, i;
        (i = rde(t, n)) ? (t = i,
        n = 0) : (o = sde(t, n)) && (t = o,
        n = o.nodeValue.length)
    }
    let r = e.domSelection();
    if (N1(r)) {
        let o = document.createRange();
        o.setEnd(t, n),
        o.setStart(t, n),
        r.removeAllRanges(),
        r.addRange(o)
    } else
        r.extend && r.extend(t, n);
    e.domObserver.setCurSelection();
    let {state: s} = e;
    setTimeout( () => {
        e.state == s && hi(e)
    }
    , 50)
}
function ek(e, t) {
    let n = e.state.doc.resolve(t);
    if (!(hr || Tue) && n.parent.inlineContent) {
        let s = e.coordsAtPos(t);
        if (t > n.start()) {
            let o = e.coordsAtPos(t - 1)
              , i = (o.top + o.bottom) / 2;
            if (i > s.top && i < s.bottom && Math.abs(o.left - s.left) > 1)
                return o.left < s.left ? "ltr" : "rtl"
        }
        if (t < n.end()) {
            let o = e.coordsAtPos(t + 1)
              , i = (o.top + o.bottom) / 2;
            if (i > s.top && i < s.bottom && Math.abs(o.left - s.left) > 1)
                return o.left > s.left ? "ltr" : "rtl"
        }
    }
    return getComputedStyle(e.dom).direction == "rtl" ? "rtl" : "ltr"
}
function tk(e, t, n) {
    let r = e.state.selection;
    if (r instanceof Rt && !r.empty || n.indexOf("s") > -1 || vs && n.indexOf("m") > -1)
        return !1;
    let {$from: s, $to: o} = r;
    if (!s.parent.inlineContent || e.endOfTextblock(t < 0 ? "up" : "down")) {
        let i = V5(e.state, t);
        if (i && i instanceof st)
            return Zi(e, i)
    }
    if (!s.parent.inlineContent) {
        let i = t < 0 ? s : o
          , a = r instanceof rs ? Et.near(i, t) : Et.findFrom(i, t);
        return a ? Zi(e, a) : !1
    }
    return !1
}
function nk(e, t) {
    if (!(e.state.selection instanceof Rt))
        return !0;
    let {$head: n, $anchor: r, empty: s} = e.state.selection;
    if (!n.sameParent(r))
        return !0;
    if (!s)
        return !1;
    if (e.endOfTextblock(t > 0 ? "forward" : "backward"))
        return !0;
    let o = !n.textOffset && (t < 0 ? n.nodeBefore : n.nodeAfter);
    if (o && !o.isText) {
        let i = e.state.tr;
        return t < 0 ? i.delete(n.pos - o.nodeSize, n.pos) : i.delete(n.pos, n.pos + o.nodeSize),
        e.dispatch(i),
        !0
    }
    return !1
}
function rk(e, t, n) {
    e.domObserver.stop(),
    t.contentEditable = n,
    e.domObserver.start()
}
function ode(e) {
    if (!Cr || e.state.selection.$head.parentOffset > 0)
        return !1;
    let {focusNode: t, focusOffset: n} = e.domSelectionRange();
    if (t && t.nodeType == 1 && n == 0 && t.firstChild && t.firstChild.contentEditable == "false") {
        let r = t.firstChild;
        rk(e, r, "true"),
        setTimeout( () => rk(e, r, "false"), 20)
    }
    return !1
}
function ide(e) {
    let t = "";
    return e.ctrlKey && (t += "c"),
    e.metaKey && (t += "m"),
    e.altKey && (t += "a"),
    e.shiftKey && (t += "s"),
    t
}
function ade(e, t) {
    let n = t.keyCode
      , r = ide(t);
    if (n == 8 || vs && n == 72 && r == "c")
        return nk(e, -1) || Rc(e, -1);
    if (n == 46 && !t.shiftKey || vs && n == 68 && r == "c")
        return nk(e, 1) || Rc(e, 1);
    if (n == 13 || n == 27)
        return !0;
    if (n == 37 || vs && n == 66 && r == "c") {
        let s = n == 37 ? ek(e, e.state.selection.from) == "ltr" ? -1 : 1 : -1;
        return QT(e, s, r) || Rc(e, s)
    } else if (n == 39 || vs && n == 70 && r == "c") {
        let s = n == 39 ? ek(e, e.state.selection.from) == "ltr" ? 1 : -1 : 1;
        return QT(e, s, r) || Rc(e, s)
    } else {
        if (n == 38 || vs && n == 80 && r == "c")
            return tk(e, -1, r) || Rc(e, -1);
        if (n == 40 || vs && n == 78 && r == "c")
            return ode(e) || tk(e, 1, r) || Rc(e, 1);
        if (r == (vs ? "m" : "c") && (n == 66 || n == 73 || n == 89 || n == 90))
            return !0
    }
    return !1
}
function YU(e, t) {
    e.someProp("transformCopied", p => {
        t = p(t, e)
    }
    );
    let n = []
      , {content: r, openStart: s, openEnd: o} = t;
    for (; s > 1 && o > 1 && r.childCount == 1 && r.firstChild.childCount == 1; ) {
        s--,
        o--;
        let p = r.firstChild;
        n.push(p.type.name, p.attrs != p.type.defaultAttrs ? p.attrs : null),
        r = p.content
    }
    let i = e.someProp("clipboardSerializer") || Qu.fromSchema(e.state.schema)
      , a = tB()
      , l = a.createElement("div");
    l.appendChild(i.serializeFragment(r, {
        document: a
    }));
    let c = l.firstChild, u, d = 0;
    for (; c && c.nodeType == 1 && (u = eB[c.nodeName.toLowerCase()]); ) {
        for (let p = u.length - 1; p >= 0; p--) {
            let m = a.createElement(u[p]);
            for (; l.firstChild; )
                m.appendChild(l.firstChild);
            l.appendChild(m),
            d++
        }
        c = l.firstChild
    }
    c && c.nodeType == 1 && c.setAttribute("data-pm-slice", `${s} ${o}${d ? ` -${d}` : ""} ${JSON.stringify(n)}`);
    let f = e.someProp("clipboardTextSerializer", p => p(t, e)) || t.content.textBetween(0, t.content.size, `

`);
    return {
        dom: l,
        text: f,
        slice: t
    }
}
function ZU(e, t, n, r, s) {
    let o = s.parent.type.spec.code, i, a;
    if (!n && !t)
        return null;
    let l = t && (r || o || !n);
    if (l) {
        if (e.someProp("transformPastedText", f => {
            t = f(t, o || r, e)
        }
        ),
        o)
            return t ? new Me(pe.from(e.state.schema.text(t.replace(/\r\n?/g, `
`))),0,0) : Me.empty;
        let d = e.someProp("clipboardTextParser", f => f(t, s, r, e));
        if (d)
            a = d;
        else {
            let f = s.marks()
              , {schema: p} = e.state
              , m = Qu.fromSchema(p);
            i = document.createElement("div"),
            t.split(/(?:\r\n?|\n)+/).forEach(v => {
                let _ = i.appendChild(document.createElement("p"));
                v && _.appendChild(m.serializeNode(p.text(v, f)))
            }
            )
        }
    } else
        e.someProp("transformPastedHTML", d => {
            n = d(n, e)
        }
        ),
        i = ude(n),
        gh && dde(i);
    let c = i && i.querySelector("[data-pm-slice]")
      , u = c && /^(\d+) (\d+)(?: -(\d+))? (.*)/.exec(c.getAttribute("data-pm-slice") || "");
    if (u && u[3])
        for (let d = +u[3]; d > 0; d--) {
            let f = i.firstChild;
            for (; f && f.nodeType != 1; )
                f = f.nextSibling;
            if (!f)
                break;
            i = f
        }
    if (a || (a = (e.someProp("clipboardParser") || e.someProp("domParser") || kf.fromSchema(e.state.schema)).parseSlice(i, {
        preserveWhitespace: !!(l || u),
        context: s,
        ruleFromNode(f) {
            return f.nodeName == "BR" && !f.nextSibling && f.parentNode && !lde.test(f.parentNode.nodeName) ? {
                ignore: !0
            } : null
        }
    })),
    u)
        a = fde(sk(a, +u[1], +u[2]), u[4]);
    else if (a = Me.maxOpen(cde(a.content, s), !0),
    a.openStart || a.openEnd) {
        let d = 0
          , f = 0;
        for (let p = a.content.firstChild; d < a.openStart && !p.type.spec.isolating; d++,
        p = p.firstChild)
            ;
        for (let p = a.content.lastChild; f < a.openEnd && !p.type.spec.isolating; f++,
        p = p.lastChild)
            ;
        a = sk(a, d, f)
    }
    return e.someProp("transformPasted", d => {
        a = d(a, e)
    }
    ),
    a
}
const lde = /^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var)$/i;
function cde(e, t) {
    if (e.childCount < 2)
        return e;
    for (let n = t.depth; n >= 0; n--) {
        let s = t.node(n).contentMatchAt(t.index(n)), o, i = [];
        if (e.forEach(a => {
            if (!i)
                return;
            let l = s.findWrapping(a.type), c;
            if (!l)
                return i = null;
            if (c = i.length && o.length && XU(l, o, a, i[i.length - 1], 0))
                i[i.length - 1] = c;
            else {
                i.length && (i[i.length - 1] = QU(i[i.length - 1], o.length));
                let u = JU(a, l);
                i.push(u),
                s = s.matchType(u.type),
                o = l
            }
        }
        ),
        i)
            return pe.from(i)
    }
    return e
}
function JU(e, t, n=0) {
    for (let r = t.length - 1; r >= n; r--)
        e = t[r].create(null, pe.from(e));
    return e
}
function XU(e, t, n, r, s) {
    if (s < e.length && s < t.length && e[s] == t[s]) {
        let o = XU(e, t, n, r.lastChild, s + 1);
        if (o)
            return r.copy(r.content.replaceChild(r.childCount - 1, o));
        if (r.contentMatchAt(r.childCount).matchType(s == e.length - 1 ? n.type : e[s + 1]))
            return r.copy(r.content.append(pe.from(JU(n, e, s + 1))))
    }
}
function QU(e, t) {
    if (t == 0)
        return e;
    let n = e.content.replaceChild(e.childCount - 1, QU(e.lastChild, t - 1))
      , r = e.contentMatchAt(e.childCount).fillBefore(pe.empty, !0);
    return e.copy(n.append(r))
}
function z5(e, t, n, r, s, o) {
    let i = t < 0 ? e.firstChild : e.lastChild
      , a = i.content;
    return e.childCount > 1 && (o = 0),
    s < r - 1 && (a = z5(a, t, n, r, s + 1, o)),
    s >= n && (a = t < 0 ? i.contentMatchAt(0).fillBefore(a, o <= s).append(a) : a.append(i.contentMatchAt(i.childCount).fillBefore(pe.empty, !0))),
    e.replaceChild(t < 0 ? 0 : e.childCount - 1, i.copy(a))
}
function sk(e, t, n) {
    return t < e.openStart && (e = new Me(z5(e.content, -1, t, e.openStart, 0, e.openEnd),t,e.openEnd)),
    n < e.openEnd && (e = new Me(z5(e.content, 1, n, e.openEnd, 0, 0),e.openStart,n)),
    e
}
const eB = {
    thead: ["table"],
    tbody: ["table"],
    tfoot: ["table"],
    caption: ["table"],
    colgroup: ["table"],
    col: ["table", "colgroup"],
    tr: ["table", "tbody"],
    td: ["table", "tbody", "tr"],
    th: ["table", "tbody", "tr"]
};
let ok = null;
function tB() {
    return ok || (ok = document.implementation.createHTMLDocument("title"))
}
function ude(e) {
    let t = /^(\s*<meta [^>]*>)*/.exec(e);
    t && (e = e.slice(t[0].length));
    let n = tB().createElement("div"), r = /<([a-z][^>\s]+)/i.exec(e), s;
    if ((s = r && eB[r[1].toLowerCase()]) && (e = s.map(o => "<" + o + ">").join("") + e + s.map(o => "</" + o + ">").reverse().join("")),
    n.innerHTML = e,
    s)
        for (let o = 0; o < s.length; o++)
            n = n.querySelector(s[o]) || n;
    return n
}
function dde(e) {
    let t = e.querySelectorAll(hr ? "span:not([class]):not([style])" : "span.Apple-converted-space");
    for (let n = 0; n < t.length; n++) {
        let r = t[n];
        r.childNodes.length == 1 && r.textContent == "Â " && r.parentNode && r.parentNode.replaceChild(e.ownerDocument.createTextNode(" "), r)
    }
}
function fde(e, t) {
    if (!e.size)
        return e;
    let n = e.content.firstChild.type.schema, r;
    try {
        r = JSON.parse(t)
    } catch {
        return e
    }
    let {content: s, openStart: o, openEnd: i} = e;
    for (let a = r.length - 2; a >= 0; a -= 2) {
        let l = n.nodes[r[a]];
        if (!l || l.hasRequiredAttrs())
            break;
        s = pe.from(l.create(r[a + 1], s)),
        o++,
        i++
    }
    return new Me(s,o,i)
}
const Sr = {}
  , wr = {}
  , hde = {
    touchstart: !0,
    touchmove: !0
};
class pde {
    constructor() {
        this.shiftKey = !1,
        this.mouseDown = null,
        this.lastKeyCode = null,
        this.lastKeyCodeTime = 0,
        this.lastClick = {
            time: 0,
            x: 0,
            y: 0,
            type: ""
        },
        this.lastSelectionOrigin = null,
        this.lastSelectionTime = 0,
        this.lastIOSEnter = 0,
        this.lastIOSEnterFallbackTimeout = -1,
        this.lastFocus = 0,
        this.lastTouch = 0,
        this.lastAndroidDelete = 0,
        this.composing = !1,
        this.compositionNode = null,
        this.composingTimeout = -1,
        this.compositionNodes = [],
        this.compositionEndedAt = -2e8,
        this.compositionID = 1,
        this.compositionPendingChanges = 0,
        this.domChangeCount = 0,
        this.eventHandlers = Object.create(null),
        this.hideSelectionGuard = null
    }
}
function mde(e) {
    for (let t in Sr) {
        let n = Sr[t];
        e.dom.addEventListener(t, e.input.eventHandlers[t] = r => {
            vde(e, r) && !Kw(e, r) && (e.editable || !(r.type in wr)) && n(e, r)
        }
        , hde[t] ? {
            passive: !0
        } : void 0)
    }
    Cr && e.dom.addEventListener("input", () => null),
    $5(e)
}
function ia(e, t) {
    e.input.lastSelectionOrigin = t,
    e.input.lastSelectionTime = Date.now()
}
function gde(e) {
    e.domObserver.stop();
    for (let t in e.input.eventHandlers)
        e.dom.removeEventListener(t, e.input.eventHandlers[t]);
    clearTimeout(e.input.composingTimeout),
    clearTimeout(e.input.lastIOSEnterFallbackTimeout)
}
function $5(e) {
    e.someProp("handleDOMEvents", t => {
        for (let n in t)
            e.input.eventHandlers[n] || e.dom.addEventListener(n, e.input.eventHandlers[n] = r => Kw(e, r))
    }
    )
}
function Kw(e, t) {
    return e.someProp("handleDOMEvents", n => {
        let r = n[t.type];
        return r ? r(e, t) || t.defaultPrevented : !1
    }
    )
}
function vde(e, t) {
    if (!t.bubbles)
        return !0;
    if (t.defaultPrevented)
        return !1;
    for (let n = t.target; n != e.dom; n = n.parentNode)
        if (!n || n.nodeType == 11 || n.pmViewDesc && n.pmViewDesc.stopEvent(t))
            return !1;
    return !0
}
function _de(e, t) {
    !Kw(e, t) && Sr[t.type] && (e.editable || !(t.type in wr)) && Sr[t.type](e, t)
}
wr.keydown = (e, t) => {
    let n = t;
    if (e.input.shiftKey = n.keyCode == 16 || n.shiftKey,
    !rB(e, n) && (e.input.lastKeyCode = n.keyCode,
    e.input.lastKeyCodeTime = Date.now(),
    !(Gs && hr && n.keyCode == 13)))
        if (n.keyCode != 229 && e.domObserver.forceFlush(),
        Uu && n.keyCode == 13 && !n.ctrlKey && !n.altKey && !n.metaKey) {
            let r = Date.now();
            e.input.lastIOSEnter = r,
            e.input.lastIOSEnterFallbackTimeout = setTimeout( () => {
                e.input.lastIOSEnter == r && (e.someProp("handleKeyDown", s => s(e, ul(13, "Enter"))),
                e.input.lastIOSEnter = 0)
            }
            , 200)
        } else
            e.someProp("handleKeyDown", r => r(e, n)) || ade(e, n) ? n.preventDefault() : ia(e, "key")
}
;
wr.keyup = (e, t) => {
    t.keyCode == 16 && (e.input.shiftKey = !1)
}
;
wr.keypress = (e, t) => {
    let n = t;
    if (rB(e, n) || !n.charCode || n.ctrlKey && !n.altKey || vs && n.metaKey)
        return;
    if (e.someProp("handleKeyPress", s => s(e, n))) {
        n.preventDefault();
        return
    }
    let r = e.state.selection;
    if (!(r instanceof Rt) || !r.$from.sameParent(r.$to)) {
        let s = String.fromCharCode(n.charCode);
        !/[\r\n]/.test(s) && !e.someProp("handleTextInput", o => o(e, r.$from.pos, r.$to.pos, s)) && e.dispatch(e.state.tr.insertText(s).scrollIntoView()),
        n.preventDefault()
    }
}
;
function D1(e) {
    return {
        left: e.clientX,
        top: e.clientY
    }
}
function yde(e, t) {
    let n = t.x - e.clientX
      , r = t.y - e.clientY;
    return n * n + r * r < 100
}
function Yw(e, t, n, r, s) {
    if (r == -1)
        return !1;
    let o = e.state.doc.resolve(r);
    for (let i = o.depth + 1; i > 0; i--)
        if (e.someProp(t, a => i > o.depth ? a(e, n, o.nodeAfter, o.before(i), s, !0) : a(e, n, o.node(i), o.before(i), s, !1)))
            return !0;
    return !1
}
function pu(e, t, n) {
    e.focused || e.focus();
    let r = e.state.tr.setSelection(t);
    r.setMeta("pointer", !0),
    e.dispatch(r)
}
function bde(e, t) {
    if (t == -1)
        return !1;
    let n = e.state.doc.resolve(t)
      , r = n.nodeAfter;
    return r && r.isAtom && st.isSelectable(r) ? (pu(e, new st(n)),
    !0) : !1
}
function Cde(e, t) {
    if (t == -1)
        return !1;
    let n = e.state.selection, r, s;
    n instanceof st && (r = n.node);
    let o = e.state.doc.resolve(t);
    for (let i = o.depth + 1; i > 0; i--) {
        let a = i > o.depth ? o.nodeAfter : o.node(i);
        if (st.isSelectable(a)) {
            r && n.$from.depth > 0 && i >= n.$from.depth && o.before(n.$from.depth + 1) == n.$from.pos ? s = o.before(n.$from.depth) : s = o.before(i);
            break
        }
    }
    return s != null ? (pu(e, st.create(e.state.doc, s)),
    !0) : !1
}
function Sde(e, t, n, r, s) {
    return Yw(e, "handleClickOn", t, n, r) || e.someProp("handleClick", o => o(e, t, r)) || (s ? Cde(e, n) : bde(e, n))
}
function wde(e, t, n, r) {
    return Yw(e, "handleDoubleClickOn", t, n, r) || e.someProp("handleDoubleClick", s => s(e, t, r))
}
function Ede(e, t, n, r) {
    return Yw(e, "handleTripleClickOn", t, n, r) || e.someProp("handleTripleClick", s => s(e, t, r)) || xde(e, n, r)
}
function xde(e, t, n) {
    if (n.button != 0)
        return !1;
    let r = e.state.doc;
    if (t == -1)
        return r.inlineContent ? (pu(e, Rt.create(r, 0, r.content.size)),
        !0) : !1;
    let s = r.resolve(t);
    for (let o = s.depth + 1; o > 0; o--) {
        let i = o > s.depth ? s.nodeAfter : s.node(o)
          , a = s.before(o);
        if (i.inlineContent)
            pu(e, Rt.create(r, a + 1, a + 1 + i.content.size));
        else if (st.isSelectable(i))
            pu(e, st.create(r, a));
        else
            continue;
        return !0
    }
}
function Zw(e) {
    return Qm(e)
}
const nB = vs ? "metaKey" : "ctrlKey";
Sr.mousedown = (e, t) => {
    let n = t;
    e.input.shiftKey = n.shiftKey;
    let r = Zw(e)
      , s = Date.now()
      , o = "singleClick";
    s - e.input.lastClick.time < 500 && yde(n, e.input.lastClick) && !n[nB] && (e.input.lastClick.type == "singleClick" ? o = "doubleClick" : e.input.lastClick.type == "doubleClick" && (o = "tripleClick")),
    e.input.lastClick = {
        time: s,
        x: n.clientX,
        y: n.clientY,
        type: o
    };
    let i = e.posAtCoords(D1(n));
    i && (o == "singleClick" ? (e.input.mouseDown && e.input.mouseDown.done(),
    e.input.mouseDown = new Tde(e,i,n,!!r)) : (o == "doubleClick" ? wde : Ede)(e, i.pos, i.inside, n) ? n.preventDefault() : ia(e, "pointer"))
}
;
class Tde {
    constructor(t, n, r, s) {
        this.view = t,
        this.pos = n,
        this.event = r,
        this.flushed = s,
        this.delayedSelectionSync = !1,
        this.mightDrag = null,
        this.startDoc = t.state.doc,
        this.selectNode = !!r[nB],
        this.allowDefault = r.shiftKey;
        let o, i;
        if (n.inside > -1)
            o = t.state.doc.nodeAt(n.inside),
            i = n.inside;
        else {
            let u = t.state.doc.resolve(n.pos);
            o = u.parent,
            i = u.depth ? u.before() : 0
        }
        const a = s ? null : r.target
          , l = a ? t.docView.nearestDesc(a, !0) : null;
        this.target = l && l.dom.nodeType == 1 ? l.dom : null;
        let {selection: c} = t.state;
        (r.button == 0 && o.type.spec.draggable && o.type.spec.selectable !== !1 || c instanceof st && c.from <= i && c.to > i) && (this.mightDrag = {
            node: o,
            pos: i,
            addAttr: !!(this.target && !this.target.draggable),
            setUneditable: !!(this.target && no && !this.target.hasAttribute("contentEditable"))
        }),
        this.target && this.mightDrag && (this.mightDrag.addAttr || this.mightDrag.setUneditable) && (this.view.domObserver.stop(),
        this.mightDrag.addAttr && (this.target.draggable = !0),
        this.mightDrag.setUneditable && setTimeout( () => {
            this.view.input.mouseDown == this && this.target.setAttribute("contentEditable", "false")
        }
        , 20),
        this.view.domObserver.start()),
        t.root.addEventListener("mouseup", this.up = this.up.bind(this)),
        t.root.addEventListener("mousemove", this.move = this.move.bind(this)),
        ia(t, "pointer")
    }
    done() {
        this.view.root.removeEventListener("mouseup", this.up),
        this.view.root.removeEventListener("mousemove", this.move),
        this.mightDrag && this.target && (this.view.domObserver.stop(),
        this.mightDrag.addAttr && this.target.removeAttribute("draggable"),
        this.mightDrag.setUneditable && this.target.removeAttribute("contentEditable"),
        this.view.domObserver.start()),
        this.delayedSelectionSync && setTimeout( () => hi(this.view)),
        this.view.input.mouseDown = null
    }
    up(t) {
        if (this.done(),
        !this.view.dom.contains(t.target))
            return;
        let n = this.pos;
        this.view.state.doc != this.startDoc && (n = this.view.posAtCoords(D1(t))),
        this.updateAllowDefault(t),
        this.allowDefault || !n ? ia(this.view, "pointer") : Sde(this.view, n.pos, n.inside, t, this.selectNode) ? t.preventDefault() : t.button == 0 && (this.flushed || Cr && this.mightDrag && !this.mightDrag.node.isAtom || hr && !this.view.state.selection.visible && Math.min(Math.abs(n.pos - this.view.state.selection.from), Math.abs(n.pos - this.view.state.selection.to)) <= 2) ? (pu(this.view, Et.near(this.view.state.doc.resolve(n.pos))),
        t.preventDefault()) : ia(this.view, "pointer")
    }
    move(t) {
        this.updateAllowDefault(t),
        ia(this.view, "pointer"),
        t.buttons == 0 && this.done()
    }
    updateAllowDefault(t) {
        !this.allowDefault && (Math.abs(this.event.x - t.clientX) > 4 || Math.abs(this.event.y - t.clientY) > 4) && (this.allowDefault = !0)
    }
}
Sr.touchstart = e => {
    e.input.lastTouch = Date.now(),
    Zw(e),
    ia(e, "pointer")
}
;
Sr.touchmove = e => {
    e.input.lastTouch = Date.now(),
    ia(e, "pointer")
}
;
Sr.contextmenu = e => Zw(e);
function rB(e, t) {
    return e.composing ? !0 : Cr && Math.abs(t.timeStamp - e.input.compositionEndedAt) < 500 ? (e.input.compositionEndedAt = -2e8,
    !0) : !1
}
const kde = Gs ? 5e3 : -1;
wr.compositionstart = wr.compositionupdate = e => {
    if (!e.composing) {
        e.domObserver.flush();
        let {state: t} = e
          , n = t.selection.$from;
        if (t.selection.empty && (t.storedMarks || !n.textOffset && n.parentOffset && n.nodeBefore.marks.some(r => r.type.spec.inclusive === !1)))
            e.markCursor = e.state.storedMarks || n.marks(),
            Qm(e, !0),
            e.markCursor = null;
        else if (Qm(e),
        no && t.selection.empty && n.parentOffset && !n.textOffset && n.nodeBefore.marks.length) {
            let r = e.domSelectionRange();
            for (let s = r.focusNode, o = r.focusOffset; s && s.nodeType == 1 && o != 0; ) {
                let i = o < 0 ? s.lastChild : s.childNodes[o - 1];
                if (!i)
                    break;
                if (i.nodeType == 3) {
                    e.domSelection().collapse(i, i.nodeValue.length);
                    break
                } else
                    s = i,
                    o = -1
            }
        }
        e.input.composing = !0
    }
    sB(e, kde)
}
;
wr.compositionend = (e, t) => {
    e.composing && (e.input.composing = !1,
    e.input.compositionEndedAt = t.timeStamp,
    e.input.compositionPendingChanges = e.domObserver.pendingRecords().length ? e.input.compositionID : 0,
    e.input.compositionNode = null,
    e.input.compositionPendingChanges && Promise.resolve().then( () => e.domObserver.flush()),
    e.input.compositionID++,
    sB(e, 20))
}
;
function sB(e, t) {
    clearTimeout(e.input.composingTimeout),
    t > -1 && (e.input.composingTimeout = setTimeout( () => Qm(e), t))
}
function oB(e) {
    for (e.composing && (e.input.composing = !1,
    e.input.compositionEndedAt = Ade()); e.input.compositionNodes.length > 0; )
        e.input.compositionNodes.pop().markParentsDirty()
}
function Ode(e) {
    let t = e.domSelectionRange();
    if (!t.focusNode)
        return null;
    let n = Cue(t.focusNode, t.focusOffset)
      , r = Sue(t.focusNode, t.focusOffset);
    if (n && r && n != r) {
        let s = r.pmViewDesc
          , o = e.domObserver.lastChangedTextNode;
        if (n == o || r == o)
            return o;
        if (!s || !s.isText(r.nodeValue))
            return r;
        if (e.input.compositionNode == r) {
            let i = n.pmViewDesc;
            if (!(!i || !i.isText(n.nodeValue)))
                return r
        }
    }
    return n || r
}
function Ade() {
    let e = document.createEvent("Event");
    return e.initEvent("event", !0, !0),
    e.timeStamp
}
function Qm(e, t=!1) {
    if (!(Gs && e.domObserver.flushingSoon >= 0)) {
        if (e.domObserver.forceFlush(),
        oB(e),
        t || e.docView && e.docView.dirty) {
            let n = $w(e);
            return n && !n.eq(e.state.selection) ? e.dispatch(e.state.tr.setSelection(n)) : e.updateState(e.state),
            !0
        }
        return !1
    }
}
function Mde(e, t) {
    if (!e.dom.parentNode)
        return;
    let n = e.dom.parentNode.appendChild(document.createElement("div"));
    n.appendChild(t),
    n.style.cssText = "position: fixed; left: -10000px; top: 10px";
    let r = getSelection()
      , s = document.createRange();
    s.selectNodeContents(t),
    e.dom.blur(),
    r.removeAllRanges(),
    r.addRange(s),
    setTimeout( () => {
        n.parentNode && n.parentNode.removeChild(n),
        e.focus()
    }
    , 50)
}
const Mf = Pr && fa < 15 || Uu && kue < 604;
Sr.copy = wr.cut = (e, t) => {
    let n = t
      , r = e.state.selection
      , s = n.type == "cut";
    if (r.empty)
        return;
    let o = Mf ? null : n.clipboardData
      , i = r.content()
      , {dom: a, text: l} = YU(e, i);
    o ? (n.preventDefault(),
    o.clearData(),
    o.setData("text/html", a.innerHTML),
    o.setData("text/plain", l)) : Mde(e, a),
    s && e.dispatch(e.state.tr.deleteSelection().scrollIntoView().setMeta("uiEvent", "cut"))
}
;
function Ide(e) {
    return e.openStart == 0 && e.openEnd == 0 && e.content.childCount == 1 ? e.content.firstChild : null
}
function Rde(e, t) {
    if (!e.dom.parentNode)
        return;
    let n = e.input.shiftKey || e.state.selection.$from.parent.type.spec.code
      , r = e.dom.parentNode.appendChild(document.createElement(n ? "textarea" : "div"));
    n || (r.contentEditable = "true"),
    r.style.cssText = "position: fixed; left: -10000px; top: 10px",
    r.focus();
    let s = e.input.shiftKey && e.input.lastKeyCode != 45;
    setTimeout( () => {
        e.focus(),
        r.parentNode && r.parentNode.removeChild(r),
        n ? If(e, r.value, null, s, t) : If(e, r.textContent, r.innerHTML, s, t)
    }
    , 50)
}
function If(e, t, n, r, s) {
    let o = ZU(e, t, n, r, e.state.selection.$from);
    if (e.someProp("handlePaste", l => l(e, s, o || Me.empty)))
        return !0;
    if (!o)
        return !1;
    let i = Ide(o)
      , a = i ? e.state.tr.replaceSelectionWith(i, r) : e.state.tr.replaceSelection(o);
    return e.dispatch(a.scrollIntoView().setMeta("paste", !0).setMeta("uiEvent", "paste")),
    !0
}
function iB(e) {
    let t = e.getData("text/plain") || e.getData("Text");
    if (t)
        return t;
    let n = e.getData("text/uri-list");
    return n ? n.replace(/\r?\n/g, " ") : ""
}
wr.paste = (e, t) => {
    let n = t;
    if (e.composing && !Gs)
        return;
    let r = Mf ? null : n.clipboardData
      , s = e.input.shiftKey && e.input.lastKeyCode != 45;
    r && If(e, iB(r), r.getData("text/html"), s, n) ? n.preventDefault() : Rde(e, n)
}
;
class aB {
    constructor(t, n, r) {
        this.slice = t,
        this.move = n,
        this.node = r
    }
}
const lB = vs ? "altKey" : "ctrlKey";
Sr.dragstart = (e, t) => {
    let n = t
      , r = e.input.mouseDown;
    if (r && r.done(),
    !n.dataTransfer)
        return;
    let s = e.state.selection, o = s.empty ? null : e.posAtCoords(D1(n)), i;
    if (!(o && o.pos >= s.from && o.pos <= (s instanceof st ? s.to - 1 : s.to))) {
        if (r && r.mightDrag)
            i = st.create(e.state.doc, r.mightDrag.pos);
        else if (n.target && n.target.nodeType == 1) {
            let d = e.docView.nearestDesc(n.target, !0);
            d && d.node.type.spec.draggable && d != e.docView && (i = st.create(e.state.doc, d.posBefore))
        }
    }
    let a = (i || e.state.selection).content()
      , {dom: l, text: c, slice: u} = YU(e, a);
    (!n.dataTransfer.files.length || !hr || NU > 120) && n.dataTransfer.clearData(),
    n.dataTransfer.setData(Mf ? "Text" : "text/html", l.innerHTML),
    n.dataTransfer.effectAllowed = "copyMove",
    Mf || n.dataTransfer.setData("text/plain", c),
    e.dragging = new aB(u,!n[lB],i)
}
;
Sr.dragend = e => {
    let t = e.dragging;
    window.setTimeout( () => {
        e.dragging == t && (e.dragging = null)
    }
    , 50)
}
;
wr.dragover = wr.dragenter = (e, t) => t.preventDefault();
wr.drop = (e, t) => {
    let n = t
      , r = e.dragging;
    if (e.dragging = null,
    !n.dataTransfer)
        return;
    let s = e.posAtCoords(D1(n));
    if (!s)
        return;
    let o = e.state.doc.resolve(s.pos)
      , i = r && r.slice;
    i ? e.someProp("transformPasted", m => {
        i = m(i, e)
    }
    ) : i = ZU(e, iB(n.dataTransfer), Mf ? null : n.dataTransfer.getData("text/html"), !1, o);
    let a = !!(r && !n[lB]);
    if (e.someProp("handleDrop", m => m(e, n, i || Me.empty, a))) {
        n.preventDefault();
        return
    }
    if (!i)
        return;
    n.preventDefault();
    let l = i ? Pce(e.state.doc, o.pos, i) : o.pos;
    l == null && (l = o.pos);
    let c = e.state.tr;
    if (a) {
        let {node: m} = r;
        m ? m.replace(c) : c.deleteSelection()
    }
    let u = c.mapping.map(l)
      , d = i.openStart == 0 && i.openEnd == 0 && i.content.childCount == 1
      , f = c.doc;
    if (d ? c.replaceRangeWith(u, u, i.content.firstChild) : c.replaceRange(u, u, i),
    c.doc.eq(f))
        return;
    let p = c.doc.resolve(u);
    if (d && st.isSelectable(i.content.firstChild) && p.nodeAfter && p.nodeAfter.sameMarkup(i.content.firstChild))
        c.setSelection(new st(p));
    else {
        let m = c.mapping.map(l);
        c.mapping.maps[c.mapping.maps.length - 1].forEach( (v, _, y, b) => m = b),
        c.setSelection(Ww(e, p, c.doc.resolve(m)))
    }
    e.focus(),
    e.dispatch(c.setMeta("uiEvent", "drop"))
}
;
Sr.focus = e => {
    e.input.lastFocus = Date.now(),
    e.focused || (e.domObserver.stop(),
    e.dom.classList.add("ProseMirror-focused"),
    e.domObserver.start(),
    e.focused = !0,
    setTimeout( () => {
        e.docView && e.hasFocus() && !e.domObserver.currentSelection.eq(e.domSelectionRange()) && hi(e)
    }
    , 20))
}
;
Sr.blur = (e, t) => {
    let n = t;
    e.focused && (e.domObserver.stop(),
    e.dom.classList.remove("ProseMirror-focused"),
    e.domObserver.start(),
    n.relatedTarget && e.dom.contains(n.relatedTarget) && e.domObserver.currentSelection.clear(),
    e.focused = !1)
}
;
Sr.beforeinput = (e, t) => {
    if (hr && Gs && t.inputType == "deleteContentBackward") {
        e.domObserver.flushSoon();
        let {domChangeCount: r} = e.input;
        setTimeout( () => {
            if (e.input.domChangeCount != r || (e.dom.blur(),
            e.focus(),
            e.someProp("handleKeyDown", o => o(e, ul(8, "Backspace")))))
                return;
            let {$cursor: s} = e.state.selection;
            s && s.pos > 0 && e.dispatch(e.state.tr.delete(s.pos - 1, s.pos).scrollIntoView())
        }
        , 50)
    }
}
;
for (let e in wr)
    Sr[e] = wr[e];
function Rf(e, t) {
    if (e == t)
        return !0;
    for (let n in e)
        if (e[n] !== t[n])
            return !1;
    for (let n in t)
        if (!(n in e))
            return !1;
    return !0
}
class eg {
    constructor(t, n) {
        this.toDOM = t,
        this.spec = n || El,
        this.side = this.spec.side || 0
    }
    map(t, n, r, s) {
        let {pos: o, deleted: i} = t.mapResult(n.from + s, this.side < 0 ? -1 : 1);
        return i ? null : new Nr(o - r,o - r,this)
    }
    valid() {
        return !0
    }
    eq(t) {
        return this == t || t instanceof eg && (this.spec.key && this.spec.key == t.spec.key || this.toDOM == t.toDOM && Rf(this.spec, t.spec))
    }
    destroy(t) {
        this.spec.destroy && this.spec.destroy(t)
    }
}
class pa {
    constructor(t, n) {
        this.attrs = t,
        this.spec = n || El
    }
    map(t, n, r, s) {
        let o = t.map(n.from + s, this.spec.inclusiveStart ? -1 : 1) - r
          , i = t.map(n.to + s, this.spec.inclusiveEnd ? 1 : -1) - r;
        return o >= i ? null : new Nr(o,i,this)
    }
    valid(t, n) {
        return n.from < n.to
    }
    eq(t) {
        return this == t || t instanceof pa && Rf(this.attrs, t.attrs) && Rf(this.spec, t.spec)
    }
    static is(t) {
        return t.type instanceof pa
    }
    destroy() {}
}
class Jw {
    constructor(t, n) {
        this.attrs = t,
        this.spec = n || El
    }
    map(t, n, r, s) {
        let o = t.mapResult(n.from + s, 1);
        if (o.deleted)
            return null;
        let i = t.mapResult(n.to + s, -1);
        return i.deleted || i.pos <= o.pos ? null : new Nr(o.pos - r,i.pos - r,this)
    }
    valid(t, n) {
        let {index: r, offset: s} = t.content.findIndex(n.from), o;
        return s == n.from && !(o = t.child(r)).isText && s + o.nodeSize == n.to
    }
    eq(t) {
        return this == t || t instanceof Jw && Rf(this.attrs, t.attrs) && Rf(this.spec, t.spec)
    }
    destroy() {}
}
class Nr {
    constructor(t, n, r) {
        this.from = t,
        this.to = n,
        this.type = r
    }
    copy(t, n) {
        return new Nr(t,n,this.type)
    }
    eq(t, n=0) {
        return this.type.eq(t.type) && this.from + n == t.from && this.to + n == t.to
    }
    map(t, n, r) {
        return this.type.map(t, this, n, r)
    }
    static widget(t, n, r) {
        return new Nr(t,t,new eg(n,r))
    }
    static inline(t, n, r, s) {
        return new Nr(t,n,new pa(r,s))
    }
    static node(t, n, r, s) {
        return new Nr(t,n,new Jw(r,s))
    }
    get spec() {
        return this.type.spec
    }
    get inline() {
        return this.type instanceof pa
    }
    get widget() {
        return this.type instanceof eg
    }
}
const $c = []
  , El = {};
class rn {
    constructor(t, n) {
        this.local = t.length ? t : $c,
        this.children = n.length ? n : $c
    }
    static create(t, n) {
        return n.length ? tg(n, t, 0, El) : cr
    }
    find(t, n, r) {
        let s = [];
        return this.findInner(t ?? 0, n ?? 1e9, s, 0, r),
        s
    }
    findInner(t, n, r, s, o) {
        for (let i = 0; i < this.local.length; i++) {
            let a = this.local[i];
            a.from <= n && a.to >= t && (!o || o(a.spec)) && r.push(a.copy(a.from + s, a.to + s))
        }
        for (let i = 0; i < this.children.length; i += 3)
            if (this.children[i] < n && this.children[i + 1] > t) {
                let a = this.children[i] + 1;
                this.children[i + 2].findInner(t - a, n - a, r, s + a, o)
            }
    }
    map(t, n, r) {
        return this == cr || t.maps.length == 0 ? this : this.mapInner(t, n, 0, 0, r || El)
    }
    mapInner(t, n, r, s, o) {
        let i;
        for (let a = 0; a < this.local.length; a++) {
            let l = this.local[a].map(t, r, s);
            l && l.type.valid(n, l) ? (i || (i = [])).push(l) : o.onRemove && o.onRemove(this.local[a].spec)
        }
        return this.children.length ? Nde(this.children, i || [], t, n, r, s, o) : i ? new rn(i.sort(xl),$c) : cr
    }
    add(t, n) {
        return n.length ? this == cr ? rn.create(t, n) : this.addInner(t, n, 0) : this
    }
    addInner(t, n, r) {
        let s, o = 0;
        t.forEach( (a, l) => {
            let c = l + r, u;
            if (u = uB(n, a, c)) {
                for (s || (s = this.children.slice()); o < s.length && s[o] < l; )
                    o += 3;
                s[o] == l ? s[o + 2] = s[o + 2].addInner(a, u, c + 1) : s.splice(o, 0, l, l + a.nodeSize, tg(u, a, c + 1, El)),
                o += 3
            }
        }
        );
        let i = cB(o ? dB(n) : n, -r);
        for (let a = 0; a < i.length; a++)
            i[a].type.valid(t, i[a]) || i.splice(a--, 1);
        return new rn(i.length ? this.local.concat(i).sort(xl) : this.local,s || this.children)
    }
    remove(t) {
        return t.length == 0 || this == cr ? this : this.removeInner(t, 0)
    }
    removeInner(t, n) {
        let r = this.children
          , s = this.local;
        for (let o = 0; o < r.length; o += 3) {
            let i, a = r[o] + n, l = r[o + 1] + n;
            for (let u = 0, d; u < t.length; u++)
                (d = t[u]) && d.from > a && d.to < l && (t[u] = null,
                (i || (i = [])).push(d));
            if (!i)
                continue;
            r == this.children && (r = this.children.slice());
            let c = r[o + 2].removeInner(i, a + 1);
            c != cr ? r[o + 2] = c : (r.splice(o, 3),
            o -= 3)
        }
        if (s.length) {
            for (let o = 0, i; o < t.length; o++)
                if (i = t[o])
                    for (let a = 0; a < s.length; a++)
                        s[a].eq(i, n) && (s == this.local && (s = this.local.slice()),
                        s.splice(a--, 1))
        }
        return r == this.children && s == this.local ? this : s.length || r.length ? new rn(s,r) : cr
    }
    forChild(t, n) {
        if (this == cr)
            return this;
        if (n.isLeaf)
            return rn.empty;
        let r, s;
        for (let a = 0; a < this.children.length; a += 3)
            if (this.children[a] >= t) {
                this.children[a] == t && (r = this.children[a + 2]);
                break
            }
        let o = t + 1
          , i = o + n.content.size;
        for (let a = 0; a < this.local.length; a++) {
            let l = this.local[a];
            if (l.from < i && l.to > o && l.type instanceof pa) {
                let c = Math.max(o, l.from) - o
                  , u = Math.min(i, l.to) - o;
                c < u && (s || (s = [])).push(l.copy(c, u))
            }
        }
        if (s) {
            let a = new rn(s.sort(xl),$c);
            return r ? new ea([a, r]) : a
        }
        return r || cr
    }
    eq(t) {
        if (this == t)
            return !0;
        if (!(t instanceof rn) || this.local.length != t.local.length || this.children.length != t.children.length)
            return !1;
        for (let n = 0; n < this.local.length; n++)
            if (!this.local[n].eq(t.local[n]))
                return !1;
        for (let n = 0; n < this.children.length; n += 3)
            if (this.children[n] != t.children[n] || this.children[n + 1] != t.children[n + 1] || !this.children[n + 2].eq(t.children[n + 2]))
                return !1;
        return !0
    }
    locals(t) {
        return Xw(this.localsInner(t))
    }
    localsInner(t) {
        if (this == cr)
            return $c;
        if (t.inlineContent || !this.local.some(pa.is))
            return this.local;
        let n = [];
        for (let r = 0; r < this.local.length; r++)
            this.local[r].type instanceof pa || n.push(this.local[r]);
        return n
    }
}
rn.empty = new rn([],[]);
rn.removeOverlap = Xw;
const cr = rn.empty;
class ea {
    constructor(t) {
        this.members = t
    }
    map(t, n) {
        const r = this.members.map(s => s.map(t, n, El));
        return ea.from(r)
    }
    forChild(t, n) {
        if (n.isLeaf)
            return rn.empty;
        let r = [];
        for (let s = 0; s < this.members.length; s++) {
            let o = this.members[s].forChild(t, n);
            o != cr && (o instanceof ea ? r = r.concat(o.members) : r.push(o))
        }
        return ea.from(r)
    }
    eq(t) {
        if (!(t instanceof ea) || t.members.length != this.members.length)
            return !1;
        for (let n = 0; n < this.members.length; n++)
            if (!this.members[n].eq(t.members[n]))
                return !1;
        return !0
    }
    locals(t) {
        let n, r = !0;
        for (let s = 0; s < this.members.length; s++) {
            let o = this.members[s].localsInner(t);
            if (o.length)
                if (!n)
                    n = o;
                else {
                    r && (n = n.slice(),
                    r = !1);
                    for (let i = 0; i < o.length; i++)
                        n.push(o[i])
                }
        }
        return n ? Xw(r ? n : n.sort(xl)) : $c
    }
    static from(t) {
        switch (t.length) {
        case 0:
            return cr;
        case 1:
            return t[0];
        default:
            return new ea(t.every(n => n instanceof rn) ? t : t.reduce( (n, r) => n.concat(r instanceof rn ? r : r.members), []))
        }
    }
}
function Nde(e, t, n, r, s, o, i) {
    let a = e.slice();
    for (let c = 0, u = o; c < n.maps.length; c++) {
        let d = 0;
        n.maps[c].forEach( (f, p, m, v) => {
            let _ = v - m - (p - f);
            for (let y = 0; y < a.length; y += 3) {
                let b = a[y + 1];
                if (b < 0 || f > b + u - d)
                    continue;
                let S = a[y] + u - d;
                p >= S ? a[y + 1] = f <= S ? -2 : -1 : f >= u && _ && (a[y] += _,
                a[y + 1] += _)
            }
            d += _
        }
        ),
        u = n.maps[c].map(u, -1)
    }
    let l = !1;
    for (let c = 0; c < a.length; c += 3)
        if (a[c + 1] < 0) {
            if (a[c + 1] == -2) {
                l = !0,
                a[c + 1] = -1;
                continue
            }
            let u = n.map(e[c] + o)
              , d = u - s;
            if (d < 0 || d >= r.content.size) {
                l = !0;
                continue
            }
            let f = n.map(e[c + 1] + o, -1)
              , p = f - s
              , {index: m, offset: v} = r.content.findIndex(d)
              , _ = r.maybeChild(m);
            if (_ && v == d && v + _.nodeSize == p) {
                let y = a[c + 2].mapInner(n, _, u + 1, e[c] + o + 1, i);
                y != cr ? (a[c] = d,
                a[c + 1] = p,
                a[c + 2] = y) : (a[c + 1] = -2,
                l = !0)
            } else
                l = !0
        }
    if (l) {
        let c = Pde(a, e, t, n, s, o, i)
          , u = tg(c, r, 0, i);
        t = u.local;
        for (let d = 0; d < a.length; d += 3)
            a[d + 1] < 0 && (a.splice(d, 3),
            d -= 3);
        for (let d = 0, f = 0; d < u.children.length; d += 3) {
            let p = u.children[d];
            for (; f < a.length && a[f] < p; )
                f += 3;
            a.splice(f, 0, u.children[d], u.children[d + 1], u.children[d + 2])
        }
    }
    return new rn(t.sort(xl),a)
}
function cB(e, t) {
    if (!t || !e.length)
        return e;
    let n = [];
    for (let r = 0; r < e.length; r++) {
        let s = e[r];
        n.push(new Nr(s.from + t,s.to + t,s.type))
    }
    return n
}
function Pde(e, t, n, r, s, o, i) {
    function a(l, c) {
        for (let u = 0; u < l.local.length; u++) {
            let d = l.local[u].map(r, s, c);
            d ? n.push(d) : i.onRemove && i.onRemove(l.local[u].spec)
        }
        for (let u = 0; u < l.children.length; u += 3)
            a(l.children[u + 2], l.children[u] + c + 1)
    }
    for (let l = 0; l < e.length; l += 3)
        e[l + 1] == -1 && a(e[l + 2], t[l] + o + 1);
    return n
}
function uB(e, t, n) {
    if (t.isLeaf)
        return null;
    let r = n + t.nodeSize
      , s = null;
    for (let o = 0, i; o < e.length; o++)
        (i = e[o]) && i.from > n && i.to < r && ((s || (s = [])).push(i),
        e[o] = null);
    return s
}
function dB(e) {
    let t = [];
    for (let n = 0; n < e.length; n++)
        e[n] != null && t.push(e[n]);
    return t
}
function tg(e, t, n, r) {
    let s = []
      , o = !1;
    t.forEach( (a, l) => {
        let c = uB(e, a, l + n);
        if (c) {
            o = !0;
            let u = tg(c, a, n + l + 1, r);
            u != cr && s.push(l, l + a.nodeSize, u)
        }
    }
    );
    let i = cB(o ? dB(e) : e, -n).sort(xl);
    for (let a = 0; a < i.length; a++)
        i[a].type.valid(t, i[a]) || (r.onRemove && r.onRemove(i[a].spec),
        i.splice(a--, 1));
    return i.length || s.length ? new rn(i,s) : cr
}
function xl(e, t) {
    return e.from - t.from || e.to - t.to
}
function Xw(e) {
    let t = e;
    for (let n = 0; n < t.length - 1; n++) {
        let r = t[n];
        if (r.from != r.to)
            for (let s = n + 1; s < t.length; s++) {
                let o = t[s];
                if (o.from == r.from) {
                    o.to != r.to && (t == e && (t = e.slice()),
                    t[s] = o.copy(o.from, r.to),
                    ik(t, s + 1, o.copy(r.to, o.to)));
                    continue
                } else {
                    o.from < r.to && (t == e && (t = e.slice()),
                    t[n] = r.copy(r.from, o.from),
                    ik(t, s, r.copy(o.from, r.to)));
                    break
                }
            }
    }
    return t
}
function ik(e, t, n) {
    for (; t < e.length && xl(n, e[t]) > 0; )
        t++;
    e.splice(t, 0, n)
}
function Oy(e) {
    let t = [];
    return e.someProp("decorations", n => {
        let r = n(e.state);
        r && r != cr && t.push(r)
    }
    ),
    e.cursorWrapper && t.push(rn.create(e.state.doc, [e.cursorWrapper.deco])),
    ea.from(t)
}
const Dde = {
    childList: !0,
    characterData: !0,
    characterDataOldValue: !0,
    attributes: !0,
    attributeOldValue: !0,
    subtree: !0
}
  , Lde = Pr && fa <= 11;
class Fde {
    constructor() {
        this.anchorNode = null,
        this.anchorOffset = 0,
        this.focusNode = null,
        this.focusOffset = 0
    }
    set(t) {
        this.anchorNode = t.anchorNode,
        this.anchorOffset = t.anchorOffset,
        this.focusNode = t.focusNode,
        this.focusOffset = t.focusOffset
    }
    clear() {
        this.anchorNode = this.focusNode = null
    }
    eq(t) {
        return t.anchorNode == this.anchorNode && t.anchorOffset == this.anchorOffset && t.focusNode == this.focusNode && t.focusOffset == this.focusOffset
    }
}
class jde {
    constructor(t, n) {
        this.view = t,
        this.handleDOMChange = n,
        this.queue = [],
        this.flushingSoon = -1,
        this.observer = null,
        this.currentSelection = new Fde,
        this.onCharData = null,
        this.suppressingSelectionUpdates = !1,
        this.lastChangedTextNode = null,
        this.observer = window.MutationObserver && new window.MutationObserver(r => {
            for (let s = 0; s < r.length; s++)
                this.queue.push(r[s]);
            Pr && fa <= 11 && r.some(s => s.type == "childList" && s.removedNodes.length || s.type == "characterData" && s.oldValue.length > s.target.nodeValue.length) ? this.flushSoon() : this.flush()
        }
        ),
        Lde && (this.onCharData = r => {
            this.queue.push({
                target: r.target,
                type: "characterData",
                oldValue: r.prevValue
            }),
            this.flushSoon()
        }
        ),
        this.onSelectionChange = this.onSelectionChange.bind(this)
    }
    flushSoon() {
        this.flushingSoon < 0 && (this.flushingSoon = window.setTimeout( () => {
            this.flushingSoon = -1,
            this.flush()
        }
        , 20))
    }
    forceFlush() {
        this.flushingSoon > -1 && (window.clearTimeout(this.flushingSoon),
        this.flushingSoon = -1,
        this.flush())
    }
    start() {
        this.observer && (this.observer.takeRecords(),
        this.observer.observe(this.view.dom, Dde)),
        this.onCharData && this.view.dom.addEventListener("DOMCharacterDataModified", this.onCharData),
        this.connectSelection()
    }
    stop() {
        if (this.observer) {
            let t = this.observer.takeRecords();
            if (t.length) {
                for (let n = 0; n < t.length; n++)
                    this.queue.push(t[n]);
                window.setTimeout( () => this.flush(), 20)
            }
            this.observer.disconnect()
        }
        this.onCharData && this.view.dom.removeEventListener("DOMCharacterDataModified", this.onCharData),
        this.disconnectSelection()
    }
    connectSelection() {
        this.view.dom.ownerDocument.addEventListener("selectionchange", this.onSelectionChange)
    }
    disconnectSelection() {
        this.view.dom.ownerDocument.removeEventListener("selectionchange", this.onSelectionChange)
    }
    suppressSelectionUpdates() {
        this.suppressingSelectionUpdates = !0,
        setTimeout( () => this.suppressingSelectionUpdates = !1, 50)
    }
    onSelectionChange() {
        if (XT(this.view)) {
            if (this.suppressingSelectionUpdates)
                return hi(this.view);
            if (Pr && fa <= 11 && !this.view.state.selection.empty) {
                let t = this.view.domSelectionRange();
                if (t.focusNode && ql(t.focusNode, t.focusOffset, t.anchorNode, t.anchorOffset))
                    return this.flushSoon()
            }
            this.flush()
        }
    }
    setCurSelection() {
        this.currentSelection.set(this.view.domSelectionRange())
    }
    ignoreSelectionChange(t) {
        if (!t.focusNode)
            return !0;
        let n = new Set, r;
        for (let o = t.focusNode; o; o = Af(o))
            n.add(o);
        for (let o = t.anchorNode; o; o = Af(o))
            if (n.has(o)) {
                r = o;
                break
            }
        let s = r && this.view.docView.nearestDesc(r);
        if (s && s.ignoreMutation({
            type: "selection",
            target: r.nodeType == 3 ? r.parentNode : r
        }))
            return this.setCurSelection(),
            !0
    }
    pendingRecords() {
        if (this.observer)
            for (let t of this.observer.takeRecords())
                this.queue.push(t);
        return this.queue
    }
    flush() {
        let {view: t} = this;
        if (!t.docView || this.flushingSoon > -1)
            return;
        let n = this.pendingRecords();
        n.length && (this.queue = []);
        let r = t.domSelectionRange()
          , s = !this.suppressingSelectionUpdates && !this.currentSelection.eq(r) && XT(t) && !this.ignoreSelectionChange(r)
          , o = -1
          , i = -1
          , a = !1
          , l = [];
        if (t.editable)
            for (let u = 0; u < n.length; u++) {
                let d = this.registerMutation(n[u], l);
                d && (o = o < 0 ? d.from : Math.min(d.from, o),
                i = i < 0 ? d.to : Math.max(d.to, i),
                d.typeOver && (a = !0))
            }
        if (no && l.length) {
            let u = l.filter(d => d.nodeName == "BR");
            if (u.length == 2) {
                let[d,f] = u;
                d.parentNode && d.parentNode.parentNode == f.parentNode ? f.remove() : d.remove()
            } else {
                let {focusNode: d} = this.currentSelection;
                for (let f of u) {
                    let p = f.parentNode;
                    p && p.nodeName == "LI" && (!d || qde(t, d) != p) && f.remove()
                }
            }
        }
        let c = null;
        o < 0 && s && t.input.lastFocus > Date.now() - 200 && Math.max(t.input.lastTouch, t.input.lastClick.time) < Date.now() - 300 && N1(r) && (c = $w(t)) && c.eq(Et.near(t.state.doc.resolve(0), 1)) ? (t.input.lastFocus = 0,
        hi(t),
        this.currentSelection.set(r),
        t.scrollToSelection()) : (o > -1 || s) && (o > -1 && (t.docView.markDirty(o, i),
        Ude(t)),
        this.handleDOMChange(o, i, a, l),
        t.docView && t.docView.dirty ? t.updateState(t.state) : this.currentSelection.eq(r) || hi(t),
        this.currentSelection.set(r))
    }
    registerMutation(t, n) {
        if (n.indexOf(t.target) > -1)
            return null;
        let r = this.view.docView.nearestDesc(t.target);
        if (t.type == "attributes" && (r == this.view.docView || t.attributeName == "contenteditable" || t.attributeName == "style" && !t.oldValue && !t.target.getAttribute("style")) || !r || r.ignoreMutation(t))
            return null;
        if (t.type == "childList") {
            for (let u = 0; u < t.addedNodes.length; u++) {
                let d = t.addedNodes[u];
                n.push(d),
                d.nodeType == 3 && (this.lastChangedTextNode = d)
            }
            if (r.contentDOM && r.contentDOM != r.dom && !r.contentDOM.contains(t.target))
                return {
                    from: r.posBefore,
                    to: r.posAfter
                };
            let s = t.previousSibling
              , o = t.nextSibling;
            if (Pr && fa <= 11 && t.addedNodes.length)
                for (let u = 0; u < t.addedNodes.length; u++) {
                    let {previousSibling: d, nextSibling: f} = t.addedNodes[u];
                    (!d || Array.prototype.indexOf.call(t.addedNodes, d) < 0) && (s = d),
                    (!f || Array.prototype.indexOf.call(t.addedNodes, f) < 0) && (o = f)
                }
            let i = s && s.parentNode == t.target ? Qn(s) + 1 : 0
              , a = r.localPosFromDOM(t.target, i, -1)
              , l = o && o.parentNode == t.target ? Qn(o) : t.target.childNodes.length
              , c = r.localPosFromDOM(t.target, l, 1);
            return {
                from: a,
                to: c
            }
        } else
            return t.type == "attributes" ? {
                from: r.posAtStart - r.border,
                to: r.posAtEnd + r.border
            } : (this.lastChangedTextNode = t.target,
            {
                from: r.posAtStart,
                to: r.posAtEnd,
                typeOver: t.target.nodeValue == t.oldValue
            })
    }
}
let ak = new WeakMap
  , lk = !1;
function Ude(e) {
    if (!ak.has(e) && (ak.set(e, null),
    ["normal", "nowrap", "pre-line"].indexOf(getComputedStyle(e.dom).whiteSpace) !== -1)) {
        if (e.requiresGeckoHackNode = no,
        lk)
            return;
        console.warn("ProseMirror expects the CSS white-space property to be set, preferably to 'pre-wrap'. It is recommended to load style/prosemirror.css from the prosemirror-view package."),
        lk = !0
    }
}
function ck(e, t) {
    let n = t.startContainer
      , r = t.startOffset
      , s = t.endContainer
      , o = t.endOffset
      , i = e.domAtPos(e.state.selection.anchor);
    return ql(i.node, i.offset, s, o) && ([n,r,s,o] = [s, o, n, r]),
    {
        anchorNode: n,
        anchorOffset: r,
        focusNode: s,
        focusOffset: o
    }
}
function Bde(e, t) {
    if (t.getComposedRanges) {
        let s = t.getComposedRanges(e.root)[0];
        if (s)
            return ck(e, s)
    }
    let n;
    function r(s) {
        s.preventDefault(),
        s.stopImmediatePropagation(),
        n = s.getTargetRanges()[0]
    }
    return e.dom.addEventListener("beforeinput", r, !0),
    document.execCommand("indent"),
    e.dom.removeEventListener("beforeinput", r, !0),
    n ? ck(e, n) : null
}
function qde(e, t) {
    for (let n = t.parentNode; n && n != e.dom; n = n.parentNode) {
        let r = e.docView.nearestDesc(n, !0);
        if (r && r.node.isBlock)
            return n
    }
    return null
}
function Gde(e, t, n) {
    let {node: r, fromOffset: s, toOffset: o, from: i, to: a} = e.docView.parseRange(t, n), l = e.domSelectionRange(), c, u = l.anchorNode;
    if (u && e.dom.contains(u.nodeType == 1 ? u : u.parentNode) && (c = [{
        node: u,
        offset: l.anchorOffset
    }],
    N1(l) || c.push({
        node: l.focusNode,
        offset: l.focusOffset
    })),
    hr && e.input.lastKeyCode === 8)
        for (let _ = o; _ > s; _--) {
            let y = r.childNodes[_ - 1]
              , b = y.pmViewDesc;
            if (y.nodeName == "BR" && !b) {
                o = _;
                break
            }
            if (!b || b.size)
                break
        }
    let d = e.state.doc
      , f = e.someProp("domParser") || kf.fromSchema(e.state.schema)
      , p = d.resolve(i)
      , m = null
      , v = f.parse(r, {
        topNode: p.parent,
        topMatch: p.parent.contentMatchAt(p.index()),
        topOpen: !0,
        from: s,
        to: o,
        preserveWhitespace: p.parent.type.whitespace == "pre" ? "full" : !0,
        findPositions: c,
        ruleFromNode: Vde,
        context: p
    });
    if (c && c[0].pos != null) {
        let _ = c[0].pos
          , y = c[1] && c[1].pos;
        y == null && (y = _),
        m = {
            anchor: _ + i,
            head: y + i
        }
    }
    return {
        doc: v,
        sel: m,
        from: i,
        to: a
    }
}
function Vde(e) {
    let t = e.pmViewDesc;
    if (t)
        return t.parseRule();
    if (e.nodeName == "BR" && e.parentNode) {
        if (Cr && /^(ul|ol)$/i.test(e.parentNode.nodeName)) {
            let n = document.createElement("div");
            return n.appendChild(document.createElement("li")),
            {
                skip: n
            }
        } else if (e.parentNode.lastChild == e || Cr && /^(tr|table)$/i.test(e.parentNode.nodeName))
            return {
                ignore: !0
            }
    } else if (e.nodeName == "IMG" && e.getAttribute("mark-placeholder"))
        return {
            ignore: !0
        };
    return null
}
const Hde = /^(a|abbr|acronym|b|bd[io]|big|br|button|cite|code|data(list)?|del|dfn|em|i|ins|kbd|label|map|mark|meter|output|q|ruby|s|samp|small|span|strong|su[bp]|time|u|tt|var)$/i;
function zde(e, t, n, r, s) {
    let o = e.input.compositionPendingChanges || (e.composing ? e.input.compositionID : 0);
    if (e.input.compositionPendingChanges = 0,
    t < 0) {
        let k = e.input.lastSelectionTime > Date.now() - 50 ? e.input.lastSelectionOrigin : null
          , A = $w(e, k);
        if (A && !e.state.selection.eq(A)) {
            if (hr && Gs && e.input.lastKeyCode === 13 && Date.now() - 100 < e.input.lastKeyCodeTime && e.someProp("handleKeyDown", M => M(e, ul(13, "Enter"))))
                return;
            let O = e.state.tr.setSelection(A);
            k == "pointer" ? O.setMeta("pointer", !0) : k == "key" && O.scrollIntoView(),
            o && O.setMeta("composition", o),
            e.dispatch(O)
        }
        return
    }
    let i = e.state.doc.resolve(t)
      , a = i.sharedDepth(n);
    t = i.before(a + 1),
    n = e.state.doc.resolve(n).after(a + 1);
    let l = e.state.selection, c = Gde(e, t, n), u = e.state.doc, d = u.slice(c.from, c.to), f, p;
    e.input.lastKeyCode === 8 && Date.now() - 100 < e.input.lastKeyCodeTime ? (f = e.state.selection.to,
    p = "end") : (f = e.state.selection.from,
    p = "start"),
    e.input.lastKeyCode = null;
    let m = Kde(d.content, c.doc.content, c.from, f, p);
    if ((Uu && e.input.lastIOSEnter > Date.now() - 225 || Gs) && s.some(k => k.nodeType == 1 && !Hde.test(k.nodeName)) && (!m || m.endA >= m.endB) && e.someProp("handleKeyDown", k => k(e, ul(13, "Enter")))) {
        e.input.lastIOSEnter = 0;
        return
    }
    if (!m)
        if (r && l instanceof Rt && !l.empty && l.$head.sameParent(l.$anchor) && !e.composing && !(c.sel && c.sel.anchor != c.sel.head))
            m = {
                start: l.from,
                endA: l.to,
                endB: l.to
            };
        else {
            if (c.sel) {
                let k = uk(e, e.state.doc, c.sel);
                if (k && !k.eq(e.state.selection)) {
                    let A = e.state.tr.setSelection(k);
                    o && A.setMeta("composition", o),
                    e.dispatch(A)
                }
            }
            return
        }
    e.input.domChangeCount++,
    e.state.selection.from < e.state.selection.to && m.start == m.endB && e.state.selection instanceof Rt && (m.start > e.state.selection.from && m.start <= e.state.selection.from + 2 && e.state.selection.from >= c.from ? m.start = e.state.selection.from : m.endA < e.state.selection.to && m.endA >= e.state.selection.to - 2 && e.state.selection.to <= c.to && (m.endB += e.state.selection.to - m.endA,
    m.endA = e.state.selection.to)),
    Pr && fa <= 11 && m.endB == m.start + 1 && m.endA == m.start && m.start > c.from && c.doc.textBetween(m.start - c.from - 1, m.start - c.from + 1) == " Â " && (m.start--,
    m.endA--,
    m.endB--);
    let v = c.doc.resolveNoCache(m.start - c.from), _ = c.doc.resolveNoCache(m.endB - c.from), y = u.resolve(m.start), b = v.sameParent(_) && v.parent.inlineContent && y.end() >= m.endA, S;
    if ((Uu && e.input.lastIOSEnter > Date.now() - 225 && (!b || s.some(k => k.nodeName == "DIV" || k.nodeName == "P")) || !b && v.pos < c.doc.content.size && !v.sameParent(_) && (S = Et.findFrom(c.doc.resolve(v.pos + 1), 1, !0)) && S.head == _.pos) && e.someProp("handleKeyDown", k => k(e, ul(13, "Enter")))) {
        e.input.lastIOSEnter = 0;
        return
    }
    if (e.state.selection.anchor > m.start && Wde(u, m.start, m.endA, v, _) && e.someProp("handleKeyDown", k => k(e, ul(8, "Backspace")))) {
        Gs && hr && e.domObserver.suppressSelectionUpdates();
        return
    }
    hr && Gs && m.endB == m.start && (e.input.lastAndroidDelete = Date.now()),
    Gs && !b && v.start() != _.start() && _.parentOffset == 0 && v.depth == _.depth && c.sel && c.sel.anchor == c.sel.head && c.sel.head == m.endA && (m.endB -= 2,
    _ = c.doc.resolveNoCache(m.endB - c.from),
    setTimeout( () => {
        e.someProp("handleKeyDown", function(k) {
            return k(e, ul(13, "Enter"))
        })
    }
    , 20));
    let C = m.start, w = m.endA, x, E, T;
    if (b) {
        if (v.pos == _.pos)
            Pr && fa <= 11 && v.parentOffset == 0 && (e.domObserver.suppressSelectionUpdates(),
            setTimeout( () => hi(e), 20)),
            x = e.state.tr.delete(C, w),
            E = u.resolve(m.start).marksAcross(u.resolve(m.endA));
        else if (m.endA == m.endB && (T = $de(v.parent.content.cut(v.parentOffset, _.parentOffset), y.parent.content.cut(y.parentOffset, m.endA - y.start()))))
            x = e.state.tr,
            T.type == "add" ? x.addMark(C, w, T.mark) : x.removeMark(C, w, T.mark);
        else if (v.parent.child(v.index()).isText && v.index() == _.index() - (_.textOffset ? 0 : 1)) {
            let k = v.parent.textBetween(v.parentOffset, _.parentOffset);
            if (e.someProp("handleTextInput", A => A(e, C, w, k)))
                return;
            x = e.state.tr.insertText(k, C, w)
        }
    }
    if (x || (x = e.state.tr.replace(C, w, c.doc.slice(m.start - c.from, m.endB - c.from))),
    c.sel) {
        let k = uk(e, x.doc, c.sel);
        k && !(hr && Gs && e.composing && k.empty && (m.start != m.endB || e.input.lastAndroidDelete < Date.now() - 100) && (k.head == C || k.head == x.mapping.map(w) - 1) || Pr && k.empty && k.head == C) && x.setSelection(k)
    }
    E && x.ensureMarks(E),
    o && x.setMeta("composition", o),
    e.dispatch(x.scrollIntoView())
}
function uk(e, t, n) {
    return Math.max(n.anchor, n.head) > t.content.size ? null : Ww(e, t.resolve(n.anchor), t.resolve(n.head))
}
function $de(e, t) {
    let n = e.firstChild.marks, r = t.firstChild.marks, s = n, o = r, i, a, l;
    for (let u = 0; u < r.length; u++)
        s = r[u].removeFromSet(s);
    for (let u = 0; u < n.length; u++)
        o = n[u].removeFromSet(o);
    if (s.length == 1 && o.length == 0)
        a = s[0],
        i = "add",
        l = u => u.mark(a.addToSet(u.marks));
    else if (s.length == 0 && o.length == 1)
        a = o[0],
        i = "remove",
        l = u => u.mark(a.removeFromSet(u.marks));
    else
        return null;
    let c = [];
    for (let u = 0; u < t.childCount; u++)
        c.push(l(t.child(u)));
    if (pe.from(c).eq(e))
        return {
            mark: a,
            type: i
        }
}
function Wde(e, t, n, r, s) {
    if (n - t <= s.pos - r.pos || Ay(r, !0, !1) < s.pos)
        return !1;
    let o = e.resolve(t);
    if (!r.parent.isTextblock) {
        let a = o.nodeAfter;
        return a != null && n == t + a.nodeSize
    }
    if (o.parentOffset < o.parent.content.size || !o.parent.isTextblock)
        return !1;
    let i = e.resolve(Ay(o, !0, !0));
    return !i.parent.isTextblock || i.pos > n || Ay(i, !0, !1) < n ? !1 : r.parent.content.cut(r.parentOffset).eq(i.parent.content)
}
function Ay(e, t, n) {
    let r = e.depth
      , s = t ? e.end() : e.pos;
    for (; r > 0 && (t || e.indexAfter(r) == e.node(r).childCount); )
        r--,
        s++,
        t = !1;
    if (n) {
        let o = e.node(r).maybeChild(e.indexAfter(r));
        for (; o && !o.isLeaf; )
            o = o.firstChild,
            s++
    }
    return s
}
function Kde(e, t, n, r, s) {
    let o = e.findDiffStart(t, n);
    if (o == null)
        return null;
    let {a: i, b: a} = e.findDiffEnd(t, n + e.size, n + t.size);
    if (s == "end") {
        let l = Math.max(0, o - Math.min(i, a));
        r -= i + l - o
    }
    if (i < o && e.size < t.size) {
        let l = r <= o && r >= i ? o - r : 0;
        o -= l,
        o && o < t.size && dk(t.textBetween(o - 1, o + 1)) && (o += l ? 1 : -1),
        a = o + (a - i),
        i = o
    } else if (a < o) {
        let l = r <= o && r >= a ? o - r : 0;
        o -= l,
        o && o < e.size && dk(e.textBetween(o - 1, o + 1)) && (o += l ? 1 : -1),
        i = o + (i - a),
        a = o
    }
    return {
        start: o,
        endA: i,
        endB: a
    }
}
function dk(e) {
    if (e.length != 2)
        return !1;
    let t = e.charCodeAt(0)
      , n = e.charCodeAt(1);
    return t >= 56320 && t <= 57343 && n >= 55296 && n <= 56319
}
class Yde {
    constructor(t, n) {
        this._root = null,
        this.focused = !1,
        this.trackWrites = null,
        this.mounted = !1,
        this.markCursor = null,
        this.cursorWrapper = null,
        this.lastSelectedViewDesc = void 0,
        this.input = new pde,
        this.prevDirectPlugins = [],
        this.pluginViews = [],
        this.requiresGeckoHackNode = !1,
        this.dragging = null,
        this._props = n,
        this.state = n.state,
        this.directPlugins = n.plugins || [],
        this.directPlugins.forEach(gk),
        this.dispatch = this.dispatch.bind(this),
        this.dom = t && t.mount || document.createElement("div"),
        t && (t.appendChild ? t.appendChild(this.dom) : typeof t == "function" ? t(this.dom) : t.mount && (this.mounted = !0)),
        this.editable = pk(this),
        hk(this),
        this.nodeViews = mk(this),
        this.docView = $T(this.state.doc, fk(this), Oy(this), this.dom, this),
        this.domObserver = new jde(this, (r, s, o, i) => zde(this, r, s, o, i)),
        this.domObserver.start(),
        mde(this),
        this.updatePluginViews()
    }
    get composing() {
        return this.input.composing
    }
    get props() {
        if (this._props.state != this.state) {
            let t = this._props;
            this._props = {};
            for (let n in t)
                this._props[n] = t[n];
            this._props.state = this.state
        }
        return this._props
    }
    update(t) {
        t.handleDOMEvents != this._props.handleDOMEvents && $5(this);
        let n = this._props;
        this._props = t,
        t.plugins && (t.plugins.forEach(gk),
        this.directPlugins = t.plugins),
        this.updateStateInner(t.state, n)
    }
    setProps(t) {
        let n = {};
        for (let r in this._props)
            n[r] = this._props[r];
        n.state = this.state;
        for (let r in t)
            n[r] = t[r];
        this.update(n)
    }
    updateState(t) {
        this.updateStateInner(t, this._props)
    }
    updateStateInner(t, n) {
        var r;
        let s = this.state
          , o = !1
          , i = !1;
        t.storedMarks && this.composing && (oB(this),
        i = !0),
        this.state = t;
        let a = s.plugins != t.plugins || this._props.plugins != n.plugins;
        if (a || this._props.plugins != n.plugins || this._props.nodeViews != n.nodeViews) {
            let p = mk(this);
            Jde(p, this.nodeViews) && (this.nodeViews = p,
            o = !0)
        }
        (a || n.handleDOMEvents != this._props.handleDOMEvents) && $5(this),
        this.editable = pk(this),
        hk(this);
        let l = Oy(this)
          , c = fk(this)
          , u = s.plugins != t.plugins && !s.doc.eq(t.doc) ? "reset" : t.scrollToSelection > s.scrollToSelection ? "to selection" : "preserve"
          , d = o || !this.docView.matchesNode(t.doc, c, l);
        (d || !t.selection.eq(s.selection)) && (i = !0);
        let f = u == "preserve" && i && this.dom.style.overflowAnchor == null && Mue(this);
        if (i) {
            this.domObserver.stop();
            let p = d && (Pr || hr) && !this.composing && !s.selection.empty && !t.selection.empty && Zde(s.selection, t.selection);
            if (d) {
                let m = hr ? this.trackWrites = this.domSelectionRange().focusNode : null;
                this.composing && (this.input.compositionNode = Ode(this)),
                (o || !this.docView.update(t.doc, c, l, this)) && (this.docView.updateOuterDeco(c),
                this.docView.destroy(),
                this.docView = $T(t.doc, c, l, this.dom, this)),
                m && !this.trackWrites && (p = !0)
            }
            p || !(this.input.mouseDown && this.domObserver.currentSelection.eq(this.domSelectionRange()) && ede(this)) ? hi(this, p) : ($U(this, t.selection),
            this.domObserver.setCurSelection()),
            this.domObserver.start()
        }
        this.updatePluginViews(s),
        !((r = this.dragging) === null || r === void 0) && r.node && !s.doc.eq(t.doc) && this.updateDraggedNode(this.dragging, s),
        u == "reset" ? this.dom.scrollTop = 0 : u == "to selection" ? this.scrollToSelection() : f && Iue(f)
    }
    scrollToSelection() {
        let t = this.domSelectionRange().focusNode;
        if (!this.someProp("handleScrollToSelection", n => n(this)))
            if (this.state.selection instanceof st) {
                let n = this.docView.domAfterPos(this.state.selection.from);
                n.nodeType == 1 && BT(this, n.getBoundingClientRect(), t)
            } else
                BT(this, this.coordsAtPos(this.state.selection.head, 1), t)
    }
    destroyPluginViews() {
        let t;
        for (; t = this.pluginViews.pop(); )
            t.destroy && t.destroy()
    }
    updatePluginViews(t) {
        if (!t || t.plugins != this.state.plugins || this.directPlugins != this.prevDirectPlugins) {
            this.prevDirectPlugins = this.directPlugins,
            this.destroyPluginViews();
            for (let n = 0; n < this.directPlugins.length; n++) {
                let r = this.directPlugins[n];
                r.spec.view && this.pluginViews.push(r.spec.view(this))
            }
            for (let n = 0; n < this.state.plugins.length; n++) {
                let r = this.state.plugins[n];
                r.spec.view && this.pluginViews.push(r.spec.view(this))
            }
        } else
            for (let n = 0; n < this.pluginViews.length; n++) {
                let r = this.pluginViews[n];
                r.update && r.update(this, t)
            }
    }
    updateDraggedNode(t, n) {
        let r = t.node
          , s = -1;
        if (this.state.doc.nodeAt(r.from) == r.node)
            s = r.from;
        else {
            let o = r.from + (this.state.doc.content.size - n.doc.content.size);
            (o > 0 && this.state.doc.nodeAt(o)) == r.node && (s = o)
        }
        this.dragging = new aB(t.slice,t.move,s < 0 ? void 0 : st.create(this.state.doc, s))
    }
    someProp(t, n) {
        let r = this._props && this._props[t], s;
        if (r != null && (s = n ? n(r) : r))
            return s;
        for (let i = 0; i < this.directPlugins.length; i++) {
            let a = this.directPlugins[i].props[t];
            if (a != null && (s = n ? n(a) : a))
                return s
        }
        let o = this.state.plugins;
        if (o)
            for (let i = 0; i < o.length; i++) {
                let a = o[i].props[t];
                if (a != null && (s = n ? n(a) : a))
                    return s
            }
    }
    hasFocus() {
        if (Pr) {
            let t = this.root.activeElement;
            if (t == this.dom)
                return !0;
            if (!t || !this.dom.contains(t))
                return !1;
            for (; t && this.dom != t && this.dom.contains(t); ) {
                if (t.contentEditable == "false")
                    return !1;
                t = t.parentElement
            }
            return !0
        }
        return this.root.activeElement == this.dom
    }
    focus() {
        this.domObserver.stop(),
        this.editable && Rue(this.dom),
        hi(this),
        this.domObserver.start()
    }
    get root() {
        let t = this._root;
        if (t == null) {
            for (let n = this.dom.parentNode; n; n = n.parentNode)
                if (n.nodeType == 9 || n.nodeType == 11 && n.host)
                    return n.getSelection || (Object.getPrototypeOf(n).getSelection = () => n.ownerDocument.getSelection()),
                    this._root = n
        }
        return t || document
    }
    updateRoot() {
        this._root = null
    }
    posAtCoords(t) {
        return Fue(this, t)
    }
    coordsAtPos(t, n=1) {
        return jU(this, t, n)
    }
    domAtPos(t, n=0) {
        return this.docView.domFromPos(t, n)
    }
    nodeDOM(t) {
        let n = this.docView.descAt(t);
        return n ? n.nodeDOM : null
    }
    posAtDOM(t, n, r=-1) {
        let s = this.docView.posFromDOM(t, n, r);
        if (s == null)
            throw new RangeError("DOM position not inside the editor");
        return s
    }
    endOfTextblock(t, n) {
        return Gue(this, n || this.state, t)
    }
    pasteHTML(t, n) {
        return If(this, "", t, !1, n || new ClipboardEvent("paste"))
    }
    pasteText(t, n) {
        return If(this, t, null, !0, n || new ClipboardEvent("paste"))
    }
    destroy() {
        this.docView && (gde(this),
        this.destroyPluginViews(),
        this.mounted ? (this.docView.update(this.state.doc, [], Oy(this), this),
        this.dom.textContent = "") : this.dom.parentNode && this.dom.parentNode.removeChild(this.dom),
        this.docView.destroy(),
        this.docView = null,
        yue())
    }
    get isDestroyed() {
        return this.docView == null
    }
    dispatchEvent(t) {
        return _de(this, t)
    }
    dispatch(t) {
        let n = this._props.dispatchTransaction;
        n ? n.call(this, t) : this.updateState(this.state.apply(t))
    }
    domSelectionRange() {
        let t = this.domSelection();
        return Cr && this.root.nodeType === 11 && Eue(this.dom.ownerDocument) == this.dom && Bde(this, t) || t
    }
    domSelection() {
        return this.root.getSelection()
    }
}
function fk(e) {
    let t = Object.create(null);
    return t.class = "ProseMirror",
    t.contenteditable = String(e.editable),
    e.someProp("attributes", n => {
        if (typeof n == "function" && (n = n(e.state)),
        n)
            for (let r in n)
                r == "class" ? t.class += " " + n[r] : r == "style" ? t.style = (t.style ? t.style + ";" : "") + n[r] : !t[r] && r != "contenteditable" && r != "nodeName" && (t[r] = String(n[r]))
    }
    ),
    t.translate || (t.translate = "no"),
    [Nr.node(0, e.state.doc.content.size, t)]
}
function hk(e) {
    if (e.markCursor) {
        let t = document.createElement("img");
        t.className = "ProseMirror-separator",
        t.setAttribute("mark-placeholder", "true"),
        t.setAttribute("alt", ""),
        e.cursorWrapper = {
            dom: t,
            deco: Nr.widget(e.state.selection.head, t, {
                raw: !0,
                marks: e.markCursor
            })
        }
    } else
        e.cursorWrapper = null
}
function pk(e) {
    return !e.someProp("editable", t => t(e.state) === !1)
}
function Zde(e, t) {
    let n = Math.min(e.$anchor.sharedDepth(e.head), t.$anchor.sharedDepth(t.head));
    return e.$anchor.start(n) != t.$anchor.start(n)
}
function mk(e) {
    let t = Object.create(null);
    function n(r) {
        for (let s in r)
            Object.prototype.hasOwnProperty.call(t, s) || (t[s] = r[s])
    }
    return e.someProp("nodeViews", n),
    e.someProp("markViews", n),
    t
}
function Jde(e, t) {
    let n = 0
      , r = 0;
    for (let s in e) {
        if (e[s] != t[s])
            return !0;
        n++
    }
    for (let s in t)
        r++;
    return n != r
}
function gk(e) {
    if (e.spec.state || e.spec.filterTransaction || e.spec.appendTransaction)
        throw new RangeError("Plugins passed directly to the view must not have a state component")
}
class pn extends Et {
    constructor(t) {
        super(t, t)
    }
    map(t, n) {
        let r = t.resolve(n.map(this.head));
        return pn.valid(r) ? new pn(r) : Et.near(r)
    }
    content() {
        return Me.empty
    }
    eq(t) {
        return t instanceof pn && t.head == this.head
    }
    toJSON() {
        return {
            type: "gapcursor",
            pos: this.head
        }
    }
    static fromJSON(t, n) {
        if (typeof n.pos != "number")
            throw new RangeError("Invalid input for GapCursor.fromJSON");
        return new pn(t.resolve(n.pos))
    }
    getBookmark() {
        return new Qw(this.anchor)
    }
    static valid(t) {
        let n = t.parent;
        if (n.isTextblock || !Xde(t) || !Qde(t))
            return !1;
        let r = n.type.spec.allowGapCursor;
        if (r != null)
            return r;
        let s = n.contentMatchAt(t.index()).defaultType;
        return s && s.isTextblock
    }
    static findGapCursorFrom(t, n, r=!1) {
        e: for (; ; ) {
            if (!r && pn.valid(t))
                return t;
            let s = t.pos
              , o = null;
            for (let i = t.depth; ; i--) {
                let a = t.node(i);
                if (n > 0 ? t.indexAfter(i) < a.childCount : t.index(i) > 0) {
                    o = a.child(n > 0 ? t.indexAfter(i) : t.index(i) - 1);
                    break
                } else if (i == 0)
                    return null;
                s += n;
                let l = t.doc.resolve(s);
                if (pn.valid(l))
                    return l
            }
            for (; ; ) {
                let i = n > 0 ? o.firstChild : o.lastChild;
                if (!i) {
                    if (o.isAtom && !o.isText && !st.isSelectable(o)) {
                        t = t.doc.resolve(s + o.nodeSize * n),
                        r = !1;
                        continue e
                    }
                    break
                }
                o = i,
                s += n;
                let a = t.doc.resolve(s);
                if (pn.valid(a))
                    return a
            }
            return null
        }
    }
}
pn.prototype.visible = !1;
pn.findFrom = pn.findGapCursorFrom;
Et.jsonID("gapcursor", pn);
class Qw {
    constructor(t) {
        this.pos = t
    }
    map(t) {
        return new Qw(t.map(this.pos))
    }
    resolve(t) {
        let n = t.resolve(this.pos);
        return pn.valid(n) ? new pn(n) : Et.near(n)
    }
}
function Xde(e) {
    for (let t = e.depth; t >= 0; t--) {
        let n = e.index(t)
          , r = e.node(t);
        if (n == 0) {
            if (r.type.spec.isolating)
                return !0;
            continue
        }
        for (let s = r.child(n - 1); ; s = s.lastChild) {
            if (s.childCount == 0 && !s.inlineContent || s.isAtom || s.type.spec.isolating)
                return !0;
            if (s.inlineContent)
                return !1
        }
    }
    return !0
}
function Qde(e) {
    for (let t = e.depth; t >= 0; t--) {
        let n = e.indexAfter(t)
          , r = e.node(t);
        if (n == r.childCount) {
            if (r.type.spec.isolating)
                return !0;
            continue
        }
        for (let s = r.child(n); ; s = s.firstChild) {
            if (s.childCount == 0 && !s.inlineContent || s.isAtom || s.type.spec.isolating)
                return !0;
            if (s.inlineContent)
                return !1
        }
    }
    return !0
}
function efe() {
    return new ho({
        props: {
            decorations: sfe,
            createSelectionBetween(e, t, n) {
                return t.pos == n.pos && pn.valid(n) ? new pn(n) : null
            },
            handleClick: nfe,
            handleKeyDown: tfe,
            handleDOMEvents: {
                beforeinput: rfe
            }
        }
    })
}
const tfe = IU({
    ArrowLeft: yp("horiz", -1),
    ArrowRight: yp("horiz", 1),
    ArrowUp: yp("vert", -1),
    ArrowDown: yp("vert", 1)
});
function yp(e, t) {
    const n = e == "vert" ? t > 0 ? "down" : "up" : t > 0 ? "right" : "left";
    return function(r, s, o) {
        let i = r.selection
          , a = t > 0 ? i.$to : i.$from
          , l = i.empty;
        if (i instanceof Rt) {
            if (!o.endOfTextblock(n) || a.depth == 0)
                return !1;
            l = !1,
            a = r.doc.resolve(t > 0 ? a.after() : a.before())
        }
        let c = pn.findGapCursorFrom(a, t, l);
        return c ? (s && s(r.tr.setSelection(new pn(c))),
        !0) : !1
    }
}
function nfe(e, t, n) {
    if (!e || !e.editable)
        return !1;
    let r = e.state.doc.resolve(t);
    if (!pn.valid(r))
        return !1;
    let s = e.posAtCoords({
        left: n.clientX,
        top: n.clientY
    });
    return s && s.inside > -1 && st.isSelectable(e.state.doc.nodeAt(s.inside)) ? !1 : (e.dispatch(e.state.tr.setSelection(new pn(r))),
    !0)
}
function rfe(e, t) {
    if (t.inputType != "insertCompositionText" || !(e.state.selection instanceof pn))
        return !1;
    let {$from: n} = e.state.selection
      , r = n.parent.contentMatchAt(n.index()).findWrapping(e.state.schema.nodes.text);
    if (!r)
        return !1;
    let s = pe.empty;
    for (let i = r.length - 1; i >= 0; i--)
        s = pe.from(r[i].createAndFill(null, s));
    let o = e.state.tr.replace(n.pos, n.pos, new Me(s,0,0));
    return o.setSelection(Rt.near(o.doc.resolve(n.pos + 1))),
    e.dispatch(o),
    !1
}
function sfe(e) {
    if (!(e.selection instanceof pn))
        return null;
    let t = document.createElement("div");
    return t.className = "ProseMirror-gapcursor",
    rn.create(e.doc, [Nr.widget(e.selection.head, t, {
        key: "gapcursor"
    })])
}
var ng = 200
  , Gn = function() {};
Gn.prototype.append = function(t) {
    return t.length ? (t = Gn.from(t),
    !this.length && t || t.length < ng && this.leafAppend(t) || this.length < ng && t.leafPrepend(this) || this.appendInner(t)) : this
}
;
Gn.prototype.prepend = function(t) {
    return t.length ? Gn.from(t).append(this) : this
}
;
Gn.prototype.appendInner = function(t) {
    return new ofe(this,t)
}
;
Gn.prototype.slice = function(t, n) {
    return t === void 0 && (t = 0),
    n === void 0 && (n = this.length),
    t >= n ? Gn.empty : this.sliceInner(Math.max(0, t), Math.min(this.length, n))
}
;
Gn.prototype.get = function(t) {
    if (!(t < 0 || t >= this.length))
        return this.getInner(t)
}
;
Gn.prototype.forEach = function(t, n, r) {
    n === void 0 && (n = 0),
    r === void 0 && (r = this.length),
    n <= r ? this.forEachInner(t, n, r, 0) : this.forEachInvertedInner(t, n, r, 0)
}
;
Gn.prototype.map = function(t, n, r) {
    n === void 0 && (n = 0),
    r === void 0 && (r = this.length);
    var s = [];
    return this.forEach(function(o, i) {
        return s.push(t(o, i))
    }, n, r),
    s
}
;
Gn.from = function(t) {
    return t instanceof Gn ? t : t && t.length ? new fB(t) : Gn.empty
}
;
var fB = function(e) {
    function t(r) {
        e.call(this),
        this.values = r
    }
    e && (t.__proto__ = e),
    t.prototype = Object.create(e && e.prototype),
    t.prototype.constructor = t;
    var n = {
        length: {
            configurable: !0
        },
        depth: {
            configurable: !0
        }
    };
    return t.prototype.flatten = function() {
        return this.values
    }
    ,
    t.prototype.sliceInner = function(s, o) {
        return s == 0 && o == this.length ? this : new t(this.values.slice(s, o))
    }
    ,
    t.prototype.getInner = function(s) {
        return this.values[s]
    }
    ,
    t.prototype.forEachInner = function(s, o, i, a) {
        for (var l = o; l < i; l++)
            if (s(this.values[l], a + l) === !1)
                return !1
    }
    ,
    t.prototype.forEachInvertedInner = function(s, o, i, a) {
        for (var l = o - 1; l >= i; l--)
            if (s(this.values[l], a + l) === !1)
                return !1
    }
    ,
    t.prototype.leafAppend = function(s) {
        if (this.length + s.length <= ng)
            return new t(this.values.concat(s.flatten()))
    }
    ,
    t.prototype.leafPrepend = function(s) {
        if (this.length + s.length <= ng)
            return new t(s.flatten().concat(this.values))
    }
    ,
    n.length.get = function() {
        return this.values.length
    }
    ,
    n.depth.get = function() {
        return 0
    }
    ,
    Object.defineProperties(t.prototype, n),
    t
}(Gn);
Gn.empty = new fB([]);
var ofe = function(e) {
    function t(n, r) {
        e.call(this),
        this.left = n,
        this.right = r,
        this.length = n.length + r.length,
        this.depth = Math.max(n.depth, r.depth) + 1
    }
    return e && (t.__proto__ = e),
    t.prototype = Object.create(e && e.prototype),
    t.prototype.constructor = t,
    t.prototype.flatten = function() {
        return this.left.flatten().concat(this.right.flatten())
    }
    ,
    t.prototype.getInner = function(r) {
        return r < this.left.length ? this.left.get(r) : this.right.get(r - this.left.length)
    }
    ,
    t.prototype.forEachInner = function(r, s, o, i) {
        var a = this.left.length;
        if (s < a && this.left.forEachInner(r, s, Math.min(o, a), i) === !1 || o > a && this.right.forEachInner(r, Math.max(s - a, 0), Math.min(this.length, o) - a, i + a) === !1)
            return !1
    }
    ,
    t.prototype.forEachInvertedInner = function(r, s, o, i) {
        var a = this.left.length;
        if (s > a && this.right.forEachInvertedInner(r, s - a, Math.max(o, a) - a, i + a) === !1 || o < a && this.left.forEachInvertedInner(r, Math.min(s, a), o, i) === !1)
            return !1
    }
    ,
    t.prototype.sliceInner = function(r, s) {
        if (r == 0 && s == this.length)
            return this;
        var o = this.left.length;
        return s <= o ? this.left.slice(r, s) : r >= o ? this.right.slice(r - o, s - o) : this.left.slice(r, o).append(this.right.slice(0, s - o))
    }
    ,
    t.prototype.leafAppend = function(r) {
        var s = this.right.leafAppend(r);
        if (s)
            return new t(this.left,s)
    }
    ,
    t.prototype.leafPrepend = function(r) {
        var s = this.left.leafPrepend(r);
        if (s)
            return new t(s,this.right)
    }
    ,
    t.prototype.appendInner = function(r) {
        return this.left.depth >= Math.max(this.right.depth, r.depth) + 1 ? new t(this.left,new t(this.right,r)) : new t(this,r)
    }
    ,
    t
}(Gn);
const ife = 500;
class $s {
    constructor(t, n) {
        this.items = t,
        this.eventCount = n
    }
    popEvent(t, n) {
        if (this.eventCount == 0)
            return null;
        let r = this.items.length;
        for (; ; r--)
            if (this.items.get(r - 1).selection) {
                --r;
                break
            }
        let s, o;
        n && (s = this.remapping(r, this.items.length),
        o = s.maps.length);
        let i = t.tr, a, l, c = [], u = [];
        return this.items.forEach( (d, f) => {
            if (!d.step) {
                s || (s = this.remapping(r, f + 1),
                o = s.maps.length),
                o--,
                u.push(d);
                return
            }
            if (s) {
                u.push(new Co(d.map));
                let p = d.step.map(s.slice(o)), m;
                p && i.maybeStep(p).doc && (m = i.mapping.maps[i.mapping.maps.length - 1],
                c.push(new Co(m,void 0,void 0,c.length + u.length))),
                o--,
                m && s.appendMap(m, o)
            } else
                i.maybeStep(d.step);
            if (d.selection)
                return a = s ? d.selection.map(s.slice(o)) : d.selection,
                l = new $s(this.items.slice(0, r).append(u.reverse().concat(c)),this.eventCount - 1),
                !1
        }
        , this.items.length, 0),
        {
            remaining: l,
            transform: i,
            selection: a
        }
    }
    addTransform(t, n, r, s) {
        let o = []
          , i = this.eventCount
          , a = this.items
          , l = !s && a.length ? a.get(a.length - 1) : null;
        for (let u = 0; u < t.steps.length; u++) {
            let d = t.steps[u].invert(t.docs[u]), f = new Co(t.mapping.maps[u],d,n), p;
            (p = l && l.merge(f)) && (f = p,
            u ? o.pop() : a = a.slice(0, a.length - 1)),
            o.push(f),
            n && (i++,
            n = void 0),
            s || (l = f)
        }
        let c = i - r.depth;
        return c > lfe && (a = afe(a, c),
        i -= c),
        new $s(a.append(o),i)
    }
    remapping(t, n) {
        let r = new fu;
        return this.items.forEach( (s, o) => {
            let i = s.mirrorOffset != null && o - s.mirrorOffset >= t ? r.maps.length - s.mirrorOffset : void 0;
            r.appendMap(s.map, i)
        }
        , t, n),
        r
    }
    addMaps(t) {
        return this.eventCount == 0 ? this : new $s(this.items.append(t.map(n => new Co(n))),this.eventCount)
    }
    rebased(t, n) {
        if (!this.eventCount)
            return this;
        let r = []
          , s = Math.max(0, this.items.length - n)
          , o = t.mapping
          , i = t.steps.length
          , a = this.eventCount;
        this.items.forEach(f => {
            f.selection && a--
        }
        , s);
        let l = n;
        this.items.forEach(f => {
            let p = o.getMirror(--l);
            if (p == null)
                return;
            i = Math.min(i, p);
            let m = o.maps[p];
            if (f.step) {
                let v = t.steps[p].invert(t.docs[p])
                  , _ = f.selection && f.selection.map(o.slice(l + 1, p));
                _ && a++,
                r.push(new Co(m,v,_))
            } else
                r.push(new Co(m))
        }
        , s);
        let c = [];
        for (let f = n; f < i; f++)
            c.push(new Co(o.maps[f]));
        let u = this.items.slice(0, s).append(c).append(r)
          , d = new $s(u,a);
        return d.emptyItemCount() > ife && (d = d.compress(this.items.length - r.length)),
        d
    }
    emptyItemCount() {
        let t = 0;
        return this.items.forEach(n => {
            n.step || t++
        }
        ),
        t
    }
    compress(t=this.items.length) {
        let n = this.remapping(0, t)
          , r = n.maps.length
          , s = []
          , o = 0;
        return this.items.forEach( (i, a) => {
            if (a >= t)
                s.push(i),
                i.selection && o++;
            else if (i.step) {
                let l = i.step.map(n.slice(r))
                  , c = l && l.getMap();
                if (r--,
                c && n.appendMap(c, r),
                l) {
                    let u = i.selection && i.selection.map(n.slice(r));
                    u && o++;
                    let d = new Co(c.invert(),l,u), f, p = s.length - 1;
                    (f = s.length && s[p].merge(d)) ? s[p] = f : s.push(d)
                }
            } else
                i.map && r--
        }
        , this.items.length, 0),
        new $s(Gn.from(s.reverse()),o)
    }
}
$s.empty = new $s(Gn.empty,0);
function afe(e, t) {
    let n;
    return e.forEach( (r, s) => {
        if (r.selection && t-- == 0)
            return n = s,
            !1
    }
    ),
    e.slice(n)
}
class Co {
    constructor(t, n, r, s) {
        this.map = t,
        this.step = n,
        this.selection = r,
        this.mirrorOffset = s
    }
    merge(t) {
        if (this.step && t.step && !t.selection) {
            let n = t.step.merge(this.step);
            if (n)
                return new Co(n.getMap().invert(),n,this.selection)
        }
    }
}
class Ji {
    constructor(t, n, r, s, o) {
        this.done = t,
        this.undone = n,
        this.prevRanges = r,
        this.prevTime = s,
        this.prevComposition = o
    }
}
const lfe = 20;
function cfe(e, t, n, r) {
    let s = n.getMeta(Tl), o;
    if (s)
        return s.historyState;
    n.getMeta(ffe) && (e = new Ji(e.done,e.undone,null,0,-1));
    let i = n.getMeta("appendedTransaction");
    if (n.steps.length == 0)
        return e;
    if (i && i.getMeta(Tl))
        return i.getMeta(Tl).redo ? new Ji(e.done.addTransform(n, void 0, r, rm(t)),e.undone,vk(n.mapping.maps),e.prevTime,e.prevComposition) : new Ji(e.done,e.undone.addTransform(n, void 0, r, rm(t)),null,e.prevTime,e.prevComposition);
    if (n.getMeta("addToHistory") !== !1 && !(i && i.getMeta("addToHistory") === !1)) {
        let a = n.getMeta("composition")
          , l = e.prevTime == 0 || !i && e.prevComposition != a && (e.prevTime < (n.time || 0) - r.newGroupDelay || !ufe(n, e.prevRanges))
          , c = i ? My(e.prevRanges, n.mapping) : vk(n.mapping.maps);
        return new Ji(e.done.addTransform(n, l ? t.selection.getBookmark() : void 0, r, rm(t)),$s.empty,c,n.time,a ?? e.prevComposition)
    } else
        return (o = n.getMeta("rebased")) ? new Ji(e.done.rebased(n, o),e.undone.rebased(n, o),My(e.prevRanges, n.mapping),e.prevTime,e.prevComposition) : new Ji(e.done.addMaps(n.mapping.maps),e.undone.addMaps(n.mapping.maps),My(e.prevRanges, n.mapping),e.prevTime,e.prevComposition)
}
function ufe(e, t) {
    if (!t)
        return !1;
    if (!e.docChanged)
        return !0;
    let n = !1;
    return e.mapping.maps[0].forEach( (r, s) => {
        for (let o = 0; o < t.length; o += 2)
            r <= t[o + 1] && s >= t[o] && (n = !0)
    }
    ),
    n
}
function vk(e) {
    let t = [];
    for (let n = e.length - 1; n >= 0 && t.length == 0; n--)
        e[n].forEach( (r, s, o, i) => t.push(o, i));
    return t
}
function My(e, t) {
    if (!e)
        return null;
    let n = [];
    for (let r = 0; r < e.length; r += 2) {
        let s = t.map(e[r], 1)
          , o = t.map(e[r + 1], -1);
        s <= o && n.push(s, o)
    }
    return n
}
function dfe(e, t, n) {
    let r = rm(t)
      , s = Tl.get(t).spec.config
      , o = (n ? e.undone : e.done).popEvent(t, r);
    if (!o)
        return null;
    let i = o.selection.resolve(o.transform.doc)
      , a = (n ? e.done : e.undone).addTransform(o.transform, t.selection.getBookmark(), s, r)
      , l = new Ji(n ? a : o.remaining,n ? o.remaining : a,null,0,-1);
    return o.transform.setSelection(i).setMeta(Tl, {
        redo: n,
        historyState: l
    })
}
let Iy = !1
  , _k = null;
function rm(e) {
    let t = e.plugins;
    if (_k != t) {
        Iy = !1,
        _k = t;
        for (let n = 0; n < t.length; n++)
            if (t[n].spec.historyPreserveItems) {
                Iy = !0;
                break
            }
    }
    return Iy
}
const Tl = new Go("history")
  , ffe = new Go("closeHistory");
function hfe(e={}) {
    return e = {
        depth: e.depth || 100,
        newGroupDelay: e.newGroupDelay || 500
    },
    new ho({
        key: Tl,
        state: {
            init() {
                return new Ji($s.empty,$s.empty,null,0,-1)
            },
            apply(t, n, r) {
                return cfe(n, r, t, e)
            }
        },
        config: e,
        props: {
            handleDOMEvents: {
                beforeinput(t, n) {
                    let r = n.inputType
                      , s = r == "historyUndo" ? pB : r == "historyRedo" ? W5 : null;
                    return s ? (n.preventDefault(),
                    s(t.state, t.dispatch)) : !1
                }
            }
        }
    })
}
function hB(e, t) {
    return (n, r) => {
        let s = Tl.getState(n);
        if (!s || (e ? s.undone : s.done).eventCount == 0)
            return !1;
        if (r) {
            let o = dfe(s, n, e);
            o && r(t ? o.scrollIntoView() : o)
        }
        return !0
    }
}
const pB = hB(!1, !0)
  , W5 = hB(!0, !0)
  , mu = new Go("customKeymapPlugin");
function nke(e, t) {
    const {allHandlers: n=[]} = mu.getState(e.state) ?? {};
    return e.dispatch(e.state.tr.setMeta(mu, {
        allHandlers: [t, ...n]
    })),
    () => {
        e.dispatch(e.state.tr.setMeta(mu, {
            allHandlers: n.filter(r => r !== t)
        }))
    }
}
function pfe(e={
    allHandlers: []
}) {
    return new ho({
        key: mu,
        state: {
            init() {
                return {
                    ...e
                }
            },
            apply(t, n) {
                const r = t.getMeta(mu);
                return r ? {
                    ...n,
                    ...r
                } : n
            }
        },
        props: {
            handleKeyDown(t, n) {
                if (b1(n))
                    return !1;
                const {allHandlers: r=[]} = mu.getState(t.state) ?? {};
                for (const s of r) {
                    const o = s[n.key];
                    if (o && o(n))
                        return !0
                }
            }
        }
    })
}
const mfe = (e, t, n, r) => {
    if (e.value) {
        const s = t.marks.startend?.create(n) ?? null;
        return t.text(e.value, s ? [s, ...r ?? []] : r)
    }
    return null
}
  , mB = new Go("contentReference")
  , rke = e => {
    const t = p1(e).map( ({newContentReference: n}) => n);
    return new ho({
        key: mB,
        state: {
            init: (n, {doc: r}) => ({
                displayedContentReferences: t
            }),
            apply: (n, r) => r
        },
        props: {}
    })
}
;
function gB(e) {
    if (e.childCount === 0)
        return !0;
    if (e.childCount === 1 && e.firstChild?.isTextblock) {
        const t = e.firstChild.content;
        if (t.size === 0)
            return !0;
        if (t.childCount === 1 && t.firstChild?.isText)
            return /^\s*$/.test(t.firstChild.text ?? "")
    }
    return !1
}
function gfe(e) {
    let t = ""
      , n = !1;
    const r = [];
    function s(o) {
        if (n = !1,
        o.type.name === "paragraph")
            return o.descendants(i => s(i)),
            t += `
`,
            n = !0,
            !1;
        if (o.type.name === "command_token") {
            const i = vfe(o.textContent);
            return r.push({
                symbol: DD.SystemHint,
                startIndex: t.length,
                endIndex: t.length + i.length
            }),
            t += i,
            !1
        } else
            o.isText && o.text !== void 0 && (t += o.text)
    }
    return e.descendants(o => s(o)),
    n && t.endsWith(`
`) && (t = t.slice(0, -1)),
    {
        content: t,
        metadata: {
            custom_symbol_offsets: r
        }
    }
}
function vfe(e) {
    return e.replace(/[\u{E0000}-\u{E007F}]+/gu, "")
}
const e4 = R1(xU, TU, kU);
function ske(e, t) {
    const {schema: n} = e.state
      , r = t ? n.nodes.paragraph.create(null, n.text(t)) : n.nodes.paragraph.create();
    e.dispatch(e.state.tr.replaceWith(0, e.state.doc.content.size, r)),
    e.hasFocus() && e.dispatch(e.state.tr.setSelection(Rt.atEnd(e.state.doc)).scrollIntoView())
}
function oke(e) {
    e.hasFocus() ? e.dispatch(e.state.tr.scrollIntoView()) : (e.focus(),
    e.dispatch(e.state.tr.setSelection(Rt.atEnd(e.state.doc)).scrollIntoView()))
}
function ike(e) {
    return _fe(e, 0, e.state.doc.content.size)
}
function _fe(e, t, n) {
    e.dispatch(e.state.tr.delete(t, n))
}
function ake(e, t) {
    vB(e, t, !1, !1)
}
function lke(e, t) {
    e.dispatch(e.state.tr.setSelection(Rt.create(e.state.doc, 0))),
    e4(e.state, e.dispatch),
    e.dispatch(e.state.tr.insertText(t, 0))
}
function vB(e, t, n=!1, r=!0) {
    if (n) {
        bfe(e, t);
        return
    }
    const {schema: s} = e.state
      , o = t.split(`
`);
    if (r && e.dispatch(e.state.tr.deleteSelection()),
    e.dispatch(e.state.tr.insertText(o[0])),
    o.length > 1) {
        e4(e.state, e.dispatch);
        const i = o.slice(1)
          , a = pe.fromArray(i.map(c => s.nodes.paragraph.create(null, c === "" ? null : s.text(c))))
          , l = new Me(a,0,0);
        e.dispatch(e.state.tr.replaceSelection(l)),
        Vw(e.state, e.dispatch, e)
    }
}
const yfe = /oaicite:(\d+)/g;
function bfe(e, t) {
    const {schema: n} = e.state
      , r = t.split(`
`);
    e.dispatch(e.state.tr.deleteSelection());
    const {tr: s} = e.state
      , {$from: o} = s.selection;
    o.parent.isTextblock || (s.insert(o.pos, n.nodes.paragraph.create()),
    e.dispatch(s),
    e.focus());
    const {selection: i} = e.state
      , {$from: a} = i
      , l = r[0]
      , c = yk(l, n, e)
      , u = pe.fromArray(c);
    let d = u;
    a.parent.type.validContent(u) || (d = n.nodes.paragraph.create(null, u));
    const f = new Me(pe.from(d),0,0);
    if (e.dispatch(e.state.tr.replaceSelection(f)),
    r.length > 1) {
        e4(e.state, e.dispatch);
        const m = r.slice(1).map(y => {
            const b = yk(y, n, e);
            return n.nodes.paragraph.create(null, b)
        }
        )
          , v = pe.fromArray(m)
          , _ = new Me(v,0,0);
        e.dispatch(e.state.tr.replaceSelection(_)),
        Vw(e.state, e.dispatch, e)
    }
}
function yk(e, t, n) {
    const r = [];
    let s = 0, o;
    if (!!!mB.get(n.state))
        return [t.text(e)];
    for (; (o = yfe.exec(e)) != null; ) {
        if (o.index > s) {
            const c = e.slice(s, o.index);
            r.push(t.text(c))
        }
        const a = o[1]
          , l = Cfe(a, t);
        r.push(l),
        s = o.index + o[0].length
    }
    if (s < e.length) {
        const a = e.slice(s);
        r.push(t.text(a))
    }
    return r
}
function Cfe(e, t) {
    const n = mfe({
        value: "oaicite:" + e
    }, t);
    if (n == null)
        throw new Error("Failed to create text node for content reference");
    const r = {
        index: e,
        displayLayout: "inline"
    }
      , s = pe.fromArray([n]);
    return t.nodes.contentReference.create(r, s)
}
const cke = e => us(e).checkGate("223382091");
function uke(e, t) {
    const r = e.state.tr;
    let s = 0;
    return r.doc.descendants( (o, i) => {
        if (o.isText && o.text) {
            if (typeof t == "string" && o.text.startsWith(t))
                s = t.length;
            else if (t instanceof RegExp) {
                const a = o.text.match(t);
                a?.index === 0 && (s = a[0].length)
            }
            if (s) {
                const a = o.text.substring(s).trimStart();
                s = o.text.length - a.length,
                r.delete(i, i + s)
            }
        }
        return !o.isLeaf
    }
    ),
    s > 0 ? (e.dispatch(r),
    !0) : !1
}
function dke(e, t, n) {
    const s = e.state.tr
      , o = [];
    s.doc.descendants( (i, a) => {
        !i.isText || i.text === void 0 || o.push({
            node: i,
            pos: a
        })
    }
    ),
    o.reverse(),
    o.forEach( ({node: i, pos: a}) => {
        !i.isText || i.text === void 0 || i.text.includes(t) && s.insertText(i.text.replaceAll(t, n), a, a + i.text.length)
    }
    ),
    e.dispatch(s)
}
var Ry, bk;
function Sfe() {
    if (bk)
        return Ry;
    bk = 1;
    function e(t, n) {
        for (var r = -1, s = t == null ? 0 : t.length; ++r < s && n(t[r], r, t) !== !1; )
            ;
        return t
    }
    return Ry = e,
    Ry
}
var Ny, Ck;
function _B() {
    if (Ck)
        return Ny;
    Ck = 1;
    var e = ec()
      , t = function() {
        try {
            var n = e(Object, "defineProperty");
            return n({}, "", {}),
            n
        } catch {}
    }();
    return Ny = t,
    Ny
}
var Py, Sk;
function t4() {
    if (Sk)
        return Py;
    Sk = 1;
    var e = _B();
    function t(n, r, s) {
        r == "__proto__" && e ? e(n, r, {
            configurable: !0,
            enumerable: !0,
            value: s,
            writable: !0
        }) : n[r] = s
    }
    return Py = t,
    Py
}
var Dy, wk;
function n4() {
    if (wk)
        return Dy;
    wk = 1;
    var e = t4()
      , t = U6()
      , n = Object.prototype
      , r = n.hasOwnProperty;
    function s(o, i, a) {
        var l = o[i];
        (!(r.call(o, i) && t(l, a)) || a === void 0 && !(i in o)) && e(o, i, a)
    }
    return Dy = s,
    Dy
}
var Ly, Ek;
function L1() {
    if (Ek)
        return Ly;
    Ek = 1;
    var e = n4()
      , t = t4();
    function n(r, s, o, i) {
        var a = !o;
        o || (o = {});
        for (var l = -1, c = s.length; ++l < c; ) {
            var u = s[l]
              , d = i ? i(o[u], r[u], u, o, r) : void 0;
            d === void 0 && (d = r[u]),
            a ? t(o, u, d) : e(o, u, d)
        }
        return o
    }
    return Ly = n,
    Ly
}
var Fy, xk;
function wfe() {
    if (xk)
        return Fy;
    xk = 1;
    var e = L1()
      , t = Yu();
    function n(r, s) {
        return r && e(s, t(s), r)
    }
    return Fy = n,
    Fy
}
var jy, Tk;
function Efe() {
    if (Tk)
        return jy;
    Tk = 1;
    function e(t) {
        var n = [];
        if (t != null)
            for (var r in Object(t))
                n.push(r);
        return n
    }
    return jy = e,
    jy
}
var Uy, kk;
function xfe() {
    if (kk)
        return Uy;
    kk = 1;
    var e = Bo()
      , t = X6()
      , n = Efe()
      , r = Object.prototype
      , s = r.hasOwnProperty;
    function o(i) {
        if (!e(i))
            return n(i);
        var a = t(i)
          , l = [];
        for (var c in i)
            c == "constructor" && (a || !s.call(i, c)) || l.push(c);
        return l
    }
    return Uy = o,
    Uy
}
var By, Ok;
function r4() {
    if (Ok)
        return By;
    Ok = 1;
    var e = wL()
      , t = xfe()
      , n = l1();
    function r(s) {
        return n(s) ? e(s, !0) : t(s)
    }
    return By = r,
    By
}
var qy, Ak;
function Tfe() {
    if (Ak)
        return qy;
    Ak = 1;
    var e = L1()
      , t = r4();
    function n(r, s) {
        return r && e(s, t(s), r)
    }
    return qy = n,
    qy
}
var Gd = {
    exports: {}
};
Gd.exports;
var Mk;
function kfe() {
    return Mk || (Mk = 1,
    function(e, t) {
        var n = fo()
          , r = t && !t.nodeType && t
          , s = r && !0 && e && !e.nodeType && e
          , o = s && s.exports === r
          , i = o ? n.Buffer : void 0
          , a = i ? i.allocUnsafe : void 0;
        function l(c, u) {
            if (u)
                return c.slice();
            var d = c.length
              , f = a ? a(d) : new c.constructor(d);
            return c.copy(f),
            f
        }
        e.exports = l
    }(Gd, Gd.exports)),
    Gd.exports
}
var Gy, Ik;
function Ofe() {
    if (Ik)
        return Gy;
    Ik = 1;
    function e(t, n) {
        var r = -1
          , s = t.length;
        for (n || (n = Array(s)); ++r < s; )
            n[r] = t[r];
        return n
    }
    return Gy = e,
    Gy
}
var Vy, Rk;
function Afe() {
    if (Rk)
        return Vy;
    Rk = 1;
    var e = L1()
      , t = z6();
    function n(r, s) {
        return e(r, t(r), s)
    }
    return Vy = n,
    Vy
}
var Hy, Nk;
function yB() {
    if (Nk)
        return Hy;
    Nk = 1;
    var e = EL()
      , t = e(Object.getPrototypeOf, Object);
    return Hy = t,
    Hy
}
var zy, Pk;
function bB() {
    if (Pk)
        return zy;
    Pk = 1;
    var e = H6()
      , t = yB()
      , n = z6()
      , r = CL()
      , s = Object.getOwnPropertySymbols
      , o = s ? function(i) {
        for (var a = []; i; )
            e(a, n(i)),
            i = t(i);
        return a
    }
    : r;
    return zy = o,
    zy
}
var $y, Dk;
function Mfe() {
    if (Dk)
        return $y;
    Dk = 1;
    var e = L1()
      , t = bB();
    function n(r, s) {
        return e(r, t(r), s)
    }
    return $y = n,
    $y
}
var Wy, Lk;
function CB() {
    if (Lk)
        return Wy;
    Lk = 1;
    var e = bL()
      , t = bB()
      , n = r4();
    function r(s) {
        return e(s, n, t)
    }
    return Wy = r,
    Wy
}
var Ky, Fk;
function Ife() {
    if (Fk)
        return Ky;
    Fk = 1;
    var e = Object.prototype
      , t = e.hasOwnProperty;
    function n(r) {
        var s = r.length
          , o = new r.constructor(s);
        return s && typeof r[0] == "string" && t.call(r, "index") && (o.index = r.index,
        o.input = r.input),
        o
    }
    return Ky = n,
    Ky
}
var Yy, jk;
function s4() {
    if (jk)
        return Yy;
    jk = 1;
    var e = yL();
    function t(n) {
        var r = new n.constructor(n.byteLength);
        return new e(r).set(new e(n)),
        r
    }
    return Yy = t,
    Yy
}
var Zy, Uk;
function Rfe() {
    if (Uk)
        return Zy;
    Uk = 1;
    var e = s4();
    function t(n, r) {
        var s = r ? e(n.buffer) : n.buffer;
        return new n.constructor(s,n.byteOffset,n.byteLength)
    }
    return Zy = t,
    Zy
}
var Jy, Bk;
function Nfe() {
    if (Bk)
        return Jy;
    Bk = 1;
    var e = /\w*$/;
    function t(n) {
        var r = new n.constructor(n.source,e.exec(n));
        return r.lastIndex = n.lastIndex,
        r
    }
    return Jy = t,
    Jy
}
var Xy, qk;
function Pfe() {
    if (qk)
        return Xy;
    qk = 1;
    var e = Wu()
      , t = e ? e.prototype : void 0
      , n = t ? t.valueOf : void 0;
    function r(s) {
        return n ? Object(n.call(s)) : {}
    }
    return Xy = r,
    Xy
}
var Qy, Gk;
function Dfe() {
    if (Gk)
        return Qy;
    Gk = 1;
    var e = s4();
    function t(n, r) {
        var s = r ? e(n.buffer) : n.buffer;
        return new n.constructor(s,n.byteOffset,n.length)
    }
    return Qy = t,
    Qy
}
var eb, Vk;
function Lfe() {
    if (Vk)
        return eb;
    Vk = 1;
    var e = s4()
      , t = Rfe()
      , n = Nfe()
      , r = Pfe()
      , s = Dfe()
      , o = "[object Boolean]"
      , i = "[object Date]"
      , a = "[object Map]"
      , l = "[object Number]"
      , c = "[object RegExp]"
      , u = "[object Set]"
      , d = "[object String]"
      , f = "[object Symbol]"
      , p = "[object ArrayBuffer]"
      , m = "[object DataView]"
      , v = "[object Float32Array]"
      , _ = "[object Float64Array]"
      , y = "[object Int8Array]"
      , b = "[object Int16Array]"
      , S = "[object Int32Array]"
      , C = "[object Uint8Array]"
      , w = "[object Uint8ClampedArray]"
      , x = "[object Uint16Array]"
      , E = "[object Uint32Array]";
    function T(k, A, O) {
        var M = k.constructor;
        switch (A) {
        case p:
            return e(k);
        case o:
        case i:
            return new M(+k);
        case m:
            return t(k, O);
        case v:
        case _:
        case y:
        case b:
        case S:
        case C:
        case w:
        case x:
        case E:
            return s(k, O);
        case a:
            return new M;
        case l:
        case d:
            return new M(k);
        case c:
            return n(k);
        case u:
            return new M;
        case f:
            return r(k)
        }
    }
    return eb = T,
    eb
}
var tb, Hk;
function Ffe() {
    if (Hk)
        return tb;
    Hk = 1;
    var e = Bo()
      , t = Object.create
      , n = function() {
        function r() {}
        return function(s) {
            if (!e(s))
                return {};
            if (t)
                return t(s);
            r.prototype = s;
            var o = new r;
            return r.prototype = void 0,
            o
        }
    }();
    return tb = n,
    tb
}
var nb, zk;
function jfe() {
    if (zk)
        return nb;
    zk = 1;
    var e = Ffe()
      , t = yB()
      , n = X6();
    function r(s) {
        return typeof s.constructor == "function" && !n(s) ? e(t(s)) : {}
    }
    return nb = r,
    nb
}
var rb, $k;
function Ufe() {
    if ($k)
        return rb;
    $k = 1;
    var e = c1()
      , t = La()
      , n = "[object Map]";
    function r(s) {
        return t(s) && e(s) == n
    }
    return rb = r,
    rb
}
var sb, Wk;
function Bfe() {
    if (Wk)
        return sb;
    Wk = 1;
    var e = Ufe()
      , t = Z6()
      , n = J6()
      , r = n && n.isMap
      , s = r ? t(r) : e;
    return sb = s,
    sb
}
var ob, Kk;
function qfe() {
    if (Kk)
        return ob;
    Kk = 1;
    var e = c1()
      , t = La()
      , n = "[object Set]";
    function r(s) {
        return t(s) && e(s) == n
    }
    return ob = r,
    ob
}
var ib, Yk;
function Gfe() {
    if (Yk)
        return ib;
    Yk = 1;
    var e = qfe()
      , t = Z6()
      , n = J6()
      , r = n && n.isSet
      , s = r ? t(r) : e;
    return ib = s,
    ib
}
var ab, Zk;
function Vfe() {
    if (Zk)
        return ab;
    Zk = 1;
    var e = G6()
      , t = Sfe()
      , n = n4()
      , r = wfe()
      , s = Tfe()
      , o = kfe()
      , i = Ofe()
      , a = Afe()
      , l = Mfe()
      , c = xL()
      , u = CB()
      , d = c1()
      , f = Ife()
      , p = Lfe()
      , m = jfe()
      , v = ks()
      , _ = W6()
      , y = Bfe()
      , b = Bo()
      , S = Gfe()
      , C = Yu()
      , w = r4()
      , x = 1
      , E = 2
      , T = 4
      , k = "[object Arguments]"
      , A = "[object Array]"
      , O = "[object Boolean]"
      , M = "[object Date]"
      , I = "[object Error]"
      , R = "[object Function]"
      , D = "[object GeneratorFunction]"
      , P = "[object Map]"
      , L = "[object Number]"
      , N = "[object Object]"
      , B = "[object RegExp]"
      , H = "[object Set]"
      , ye = "[object String]"
      , Ie = "[object Symbol]"
      , be = "[object WeakMap]"
      , me = "[object ArrayBuffer]"
      , ge = "[object DataView]"
      , ce = "[object Float32Array]"
      , Z = "[object Float64Array]"
      , ne = "[object Int8Array]"
      , _e = "[object Int16Array]"
      , ee = "[object Int32Array]"
      , oe = "[object Uint8Array]"
      , te = "[object Uint8ClampedArray]"
      , ve = "[object Uint16Array]"
      , Ue = "[object Uint32Array]"
      , re = {};
    re[k] = re[A] = re[me] = re[ge] = re[O] = re[M] = re[ce] = re[Z] = re[ne] = re[_e] = re[ee] = re[P] = re[L] = re[N] = re[B] = re[H] = re[ye] = re[Ie] = re[oe] = re[te] = re[ve] = re[Ue] = !0,
    re[I] = re[R] = re[be] = !1;
    function W(X, Te, se, G, F, ke) {
        var Ee, Y = Te & x, le = Te & E, Oe = Te & T;
        if (se && (Ee = F ? se(X, G, F, ke) : se(X)),
        Ee !== void 0)
            return Ee;
        if (!b(X))
            return X;
        var ae = v(X);
        if (ae) {
            if (Ee = f(X),
            !Y)
                return i(X, Ee)
        } else {
            var je = d(X)
              , ot = je == R || je == D;
            if (_(X))
                return o(X, Y);
            if (je == N || je == k || ot && !F) {
                if (Ee = le || ot ? {} : m(X),
                !Y)
                    return le ? l(X, s(Ee, X)) : a(X, r(Ee, X))
            } else {
                if (!re[je])
                    return F ? X : {};
                Ee = p(X, je, Y)
            }
        }
        ke || (ke = new e);
        var St = ke.get(X);
        if (St)
            return St;
        ke.set(X, Ee),
        S(X) ? X.forEach(function(ut) {
            Ee.add(W(ut, Te, se, ut, X, ke))
        }) : y(X) && X.forEach(function(ut, Mt) {
            Ee.set(Mt, W(ut, Te, se, Mt, X, ke))
        });
        var Tt = Oe ? le ? u : c : le ? w : C
          , wt = ae ? void 0 : Tt(X);
        return t(wt || X, function(ut, Mt) {
            wt && (Mt = ut,
            ut = X[Mt]),
            n(Ee, Mt, W(ut, Te, se, Mt, X, ke))
        }),
        Ee
    }
    return ab = W,
    ab
}
var lb, Jk;
function Hfe() {
    if (Jk)
        return lb;
    Jk = 1;
    var e = Vfe()
      , t = 1
      , n = 4;
    function r(s) {
        return e(s, t | n)
    }
    return lb = r,
    lb
}
var zfe = Hfe();
const $fe = mn(zfe)
  , SB = e => {
    const t = Vn(e, "463092697")?.value
      , n = $fe(t);
    let r = n?.enabledConnectors ?? [];
    return Xe(e, "3881721129") || (r = r.filter(o => o !== U.GITHUB_CONNECTOR)),
    n && (n.enabledConnectors = r),
    n
}
  , o4 = () => {
    const e = ue();
    return h.useMemo( () => SB(e), [e])
}
  , Wfe = e => e ? {
    enabled: !!SB(e)?.softmentionEnabled
} : {
    enabled: !1
};
function Kfe() {
    return {
        trackingKeywordsRegex: void 0,
        decorations: rn.empty,
        highlightedKeywords: new Set,
        matchedKeywords: new Set
    }
}
const wB = ({tr: e, regex: t, prevHighlightedKeywords: n, prevMatchedKeywords: r}) => {
    const s = []
      , o = new Set
      , i = new Set;
    return t ? (e.doc.descendants( (a, l) => {
        if (!a.isText || !a.text)
            return;
        const c = a.text;
        for (const u of c.matchAll(t)) {
            if (o.add(u[1]),
            !n.has(u[1]) && r.has(u[1]))
                continue;
            i.add(u[1]);
            const d = l + u.index
              , f = d + u[0].length;
            s.push(Nr.inline(d, f, {
                class: "hint-pill"
            }, {
                keyword: u[1]
            }))
        }
    }
    ),
    {
        decorations: rn.create(e.doc, s),
        matchedKeywords: o,
        highlightedKeywords: i
    }) : {
        decorations: rn.empty,
        matchedKeywords: o,
        highlightedKeywords: i
    }
}
;
function fke(e) {
    return [...ma.getState(e)?.matchedKeywords ?? []]
}
const hke = (e, t) => {
    const {state: n, dispatch: r} = t
      , s = n.tr
      , o = ma.getState(n);
    if (o) {
        const i = e.length > 0 ? new RegExp(`\\b(${e.join("|")})\\b`,"gi") : void 0
          , {decorations: a, highlightedKeywords: l, matchedKeywords: c} = wB({
            tr: s,
            regex: i,
            prevHighlightedKeywords: o.highlightedKeywords,
            prevMatchedKeywords: o.matchedKeywords
        });
        s.setMeta(ma, {
            ...o,
            trackingKeywordsRegex: i,
            decorations: a,
            highlightedKeywords: l,
            matchedKeywords: c
        })
    }
    r(s)
}
  , pke = (e, t) => {
    if (e.length === 0)
        return;
    const {state: n, dispatch: r} = t
      , s = n.tr
      , o = ma.getState(n);
    if (o) {
        const i = o.decorations.remove(o.decorations.find(void 0, void 0, a => a.keyword && e.includes(a.keyword)));
        s.setMeta(ma, {
            ...o,
            decorations: i,
            highlightedKeywords: new Set([...o.highlightedKeywords].filter(a => !e.includes(a)))
        })
    }
    r(s)
}
  , ma = new Go("keywordPlugin");
function Yfe() {
    return new ho({
        key: ma,
        state: {
            init() {
                return Kfe()
            },
            apply(e, t) {
                if (e.getMeta(ma))
                    return {
                        ...t,
                        ...e.getMeta(ma)
                    };
                if (!e.docChanged)
                    return t;
                const {decorations: n, matchedKeywords: r, highlightedKeywords: s} = wB({
                    tr: e,
                    regex: t.trackingKeywordsRegex,
                    prevHighlightedKeywords: t.highlightedKeywords,
                    prevMatchedKeywords: t.matchedKeywords
                });
                return {
                    ...t,
                    decorations: n,
                    highlightedKeywords: s,
                    matchedKeywords: r
                }
            }
        },
        props: {
            decorations(e) {
                const t = this.getState(e);
                return t ? t.decorations : rn.empty
            }
        }
    })
}
function Zfe(e) {
    const t = new WeakMap;
    return n => {
        let r = t.get(n);
        return r === void 0 && (r = e(n),
        t.set(n, r)),
        r
    }
}
const vl = new Go("menuSelectorPlugin");
function Xk(e) {
    e.dispatch(e.state.tr.setMeta(vl, {
        active: !1,
        onMenuAction: void 0
    }))
}
function mke(e, t) {
    e.dispatch(e.state.tr.setMeta(vl, {
        active: !0,
        onMenuAction: t
    }))
}
const gke = Zfe(e => Pa(t => Gw(e, t), () => vl.getState(e.state)?.active ?? !1, {
    getServerFallback: () => !1
}));
function Jfe(e={
    submitKeys: ["Enter", "Tab"],
    cancelKeys: ["Escape"],
    checkStrictMatchKeys: [" "]
}) {
    return new ho({
        key: vl,
        state: {
            init() {
                return {
                    ...e,
                    active: !1
                }
            },
            apply(t, n) {
                const r = t.getMeta(vl);
                return r ? {
                    ...n,
                    ...r
                } : n
            }
        },
        props: {
            handleKeyDown(t, n) {
                const r = vl.getState(t.state);
                if (!r?.active)
                    return !1;
                if (!n.isComposing)
                    return r.submitKeys.includes(n.key) ? (n.preventDefault(),
                    n.stopPropagation(),
                    n.stopImmediatePropagation(),
                    Xk(t),
                    r.onMenuAction?.("submit") ?? !0) : r.cancelKeys.includes(n.key) ? (n.preventDefault(),
                    r.onMenuAction?.("cancel"),
                    Xk(t),
                    !0) : n.key === "ArrowUp" ? (n.preventDefault(),
                    r.onMenuAction?.("up"),
                    !0) : n.key === "ArrowDown" ? (n.preventDefault(),
                    r.onMenuAction?.("down"),
                    !0) : r.checkStrictMatchKeys.includes(n.key) && r.onMenuAction?.("checkMatch") ? (n.preventDefault(),
                    !0) : !1
            },
            handleDOMEvents: {
                blur: t => {
                    vl.getState(t.state)?.onMenuAction?.("cancel")
                }
            }
        }
    })
}
const Vd = new Go("placeholderPlugin");
function vke(e, t) {
    e.dispatch(e.state.tr.setMeta(Vd, {
        placeholder: t
    }))
}
function Xfe(e) {
    return new ho({
        key: Vd,
        state: {
            init() {
                return {
                    placeholder: e
                }
            },
            apply(t, n) {
                return t.getMeta(Vd) ? {
                    placeholder: t.getMeta(Vd).placeholder
                } : n
            }
        },
        props: {
            decorations(t) {
                const {doc: n} = t;
                if (n.childCount === 1 && n.firstChild?.isTextblock && n.firstChild.content.size === 0) {
                    const s = []
                      , {placeholder: o} = Vd.getState(t);
                    return t.doc.descendants( (i, a) => {
                        const l = Nr.node(a, a + i.nodeSize, {
                            class: "placeholder",
                            "data-placeholder": o
                        });
                        s.push(l)
                    }
                    ),
                    rn.create(n, s)
                }
            }
        }
    })
}
const Qfe = ["p", 0]
  , ehe = ["br"]
  , the = {
    paragraph: {
        content: "inline*",
        group: "block",
        parseDOM: [{
            tag: "p",
            preserveWhitespace: "full"
        }],
        toDOM() {
            return Qfe
        }
    },
    text: {
        group: "inline"
    },
    hard_break: {
        inline: !0,
        group: "inline",
        selectable: !1,
        parseDOM: [{
            tag: "br"
        }],
        toDOM() {
            return ehe
        }
    },
    doc: {
        content: "block+"
    }
}
  , nhe = new oce({
    nodes: the,
    marks: {}
});
let K5;
try {
    K5 = new RegExp("^(\\/|@)([\\p{L}\\p{N}\\p{M}.:_-]*)$|\\s(\\/|@)([\\p{L}\\p{N}\\p{M}.:_-]+)$","u")
} catch {
    K5 = /^(\/|@)([\w.:_-]*)$|\s(\/|@)([\w.:_-]+)$/
}
function rhe(e, t) {
    if (e.depth === 0)
        return;
    const n = e.nodeBefore?.text?.match(K5);
    if (n) {
        const r = n[1] ?? n[3]
          , s = n[2] ?? n[4]
          , o = e.pos - s.length - 1
          , i = e.pos;
        return s.length > 0 && t ? void 0 : {
            triggerSymbol: r,
            queryText: s,
            range: {
                from: o,
                to: i
            }
        }
    }
}
const Hd = new Go("systemHintPlugin");
function she(e, t) {
    return e.setMeta(Hd, t),
    e
}
function _ke(e) {
    e.dispatch(she(e.state.tr, {
        ...Y5(),
        isDismissed: !0
    }))
}
function Y5() {
    return {
        triggerSymbol: "",
        queryText: "",
        active: !1,
        range: void 0,
        isDismissed: !1
    }
}
function Qk(e) {
    const {active: t, range: n, triggerSymbol: r, queryText: s, onHintMatch: o} = e;
    if (o)
        return o(!t || !n ? void 0 : {
            triggerSymbol: r,
            text: s,
            range: n
        })
}
function ohe() {
    return new ho({
        key: Hd,
        state: {
            init() {
                return Y5()
            },
            apply(e, t, n, r) {
                const s = e.getMeta(Hd)
                  , o = {
                    ...Y5(),
                    ...t,
                    ...s
                }
                  , i = e.selection;
                if (i.from !== i.to || r.doc.eq(n.doc))
                    return Qk(o),
                    o;
                const a = i.$from
                  , l = rhe(a, t.isDismissed);
                return o.active = l != null,
                l && (o.triggerSymbol = l.triggerSymbol,
                o.queryText = l.queryText,
                o.range = l.range,
                o.isDismissed = !1),
                Qk(o),
                o
            }
        },
        view() {
            return {
                update(e, t) {
                    const n = Hd.getState(t)
                      , r = Hd.getState(e.state);
                    if (n.active === r.active && n.range?.from === r.range?.from && n.setReferencePosition === r.setReferencePosition)
                        return;
                    const s = r.range;
                    !r.active || !s ? r.setReferencePosition?.(null) : r.setReferencePosition?.({
                        getBoundingClientRect: () => ihe(e.coordsAtPos(s.from))
                    })
                }
            }
        }
    })
}
function ihe({left: e, right: t, top: n, bottom: r}) {
    return new DOMRect(e,n,t - e,r - n)
}
function ahe(e=null, t, n) {
    const r = new EventTarget
      , s = Wfe(t).enabled
      , o = new Yde(null,{
        state: ru.create({
            schema: nhe,
            plugins: [hfe(), Jfe(), ohe(), ...s ? [Yfe()] : [], pfe(), _ue({
                ...FT,
                "Shift-Enter": FT.Enter,
                "Mod-z": pB,
                "Mod-y": W5,
                "Mod-Shift-z": W5
            }), $ce(r), Xfe(""), efe(), Wce()]
        }),
        dispatchTransaction(i) {
            const a = o.state.apply(i);
            o.updateState(a),
            i.docChanged && r.dispatchEvent(new Event(P5))
        },
        handlePaste(i, a) {
            const l = a.clipboardData?.getData("text/plain");
            return l === void 0 ? !1 : (a.defaultPrevented || t && Jce(t, l) || vB(i, l),
            !0)
        },
        clipboardTextSerializer(i) {
            return gfe(i.content).content
        }
    });
    return e != null && gB(o.state.doc) && o.dispatch(o.state.tr.insertText(e)),
    o
}
const Z5 = h.createContext(null)
  , yke = e => {
    "use forget";
    const t = De.c(9)
      , {children: n, clientThreadId: r, ignoreParentComposerController: s, draftsEnabled: o} = e
      , i = s === void 0 ? !1 : s
      , a = o === void 0 ? !0 : o
      , l = h.useContext(Z5)
      , c = ue();
    let u, d;
    t[0] !== r || t[1] !== l || t[2] !== c || t[3] !== a || t[4] !== i ? (d = l && !i ? l : new bU(ahe(a && r ? eee(to(r))?.content ?? null : null, c)),
    t[0] = r,
    t[1] = l,
    t[2] = c,
    t[3] = a,
    t[4] = i,
    t[5] = d) : d = t[5],
    u = d;
    const f = u;
    let p;
    return t[6] !== n || t[7] !== f ? (p = g.jsx(Z5.Provider, {
        value: f,
        children: n
    }),
    t[6] = n,
    t[7] = f,
    t[8] = p) : p = t[8],
    p
}
  , lhe = () => {
    "use forget";
    const e = De.c(2)
      , t = h.useContext(Z5);
    let n;
    return e[0] !== t ? (n = io(t),
    e[0] = t,
    e[1] = n) : n = e[1],
    n
}
;
function che() {
    const e = ir();
    return e?.data.residencyRegion !== "" && e?.data.residencyRegion !== "no_constraint"
}
function uhe() {
    return ir()?.data.residencyRegion
}
function ed() {
    const e = che()
      , t = uhe()
      , n = ue()
      , r = Vn(n, "3131667714").get("regions", []);
    return e ? r.includes(t) : !0
}
function dhe(e) {
    if (!e)
        return !1;
    const n = ["gpt-4o-gdrive", "gpt-4o-gdrive-1007-mclick", "gpt-4o-gdrive-1124", "gpt-4o-gdrive-1124-citation", "gpt-4o-gdrive-0212", "gpt-4o-gdrive-0314", "o1_ca_0226", "o3_mini_ca_0226"].includes(e.id)
      , r = !!e.product_features.contextual_answers?.is_eligible_for_contextual_answers;
    return n || r
}
var i4 = (e => (e.DOGFOODING = "dogfooding",
e.ALPHA = "alpha",
e.SB_1B9A6CB4 = "sb_1b9a6cb4",
e))(i4 || {});
function nc() {
    const e = ue()
      , t = ed()
      , n = Vn(e, "1001765573");
    return t ? n.get("ca_enabled", !1) : !1
}
function fhe() {
    const e = ue();
    return Vn(e, "1001765573").get("onboarding_paused", !1)
}
function bke() {
    const e = ed()
      , t = ue()
      , n = Vn(t, "1001765573");
    return e ? {
        isEnabled: n.get("ca_enabled", !1),
        isComingSoon: n.get("ca_coming_soon", !1)
    } : {
        isEnabled: !1,
        isComingSoon: !1
    }
}
function Cke() {
    const e = ed()
      , t = ue()
      , n = Vn(t, "1001765573");
    return e ? n.get("ca_enabled", !1) && n.get("ca_sk_enabled", !1) : !1
}
function Ske() {
    const e = ed()
      , t = ue()
      , n = Vn(t, "1001765573");
    if (!e)
        return !1;
    const r = Xe(t, "3881721129");
    return n.get("ca_enabled", !1) && n.get("ca_github_sync_enabled", !1) && r
}
function wke() {
    const e = ed()
      , t = ue()
      , n = Vn(t, "1001765573");
    return e ? n.get("ca_enabled", !1) && n.get("ca_sharepoint_sync_enabled", !1) : !1
}
function Eke() {
    const e = ue();
    return Vn(e, "1001765573").get("github_onboarding_paused", !1)
}
function xke() {
    const e = ed()
      , t = ue()
      , n = Vn(t, "1001765573");
    return e ? n.get("ca_personal_enabled", !1) : !1
}
function hhe(e) {
    return nc() && dhe(e)
}
function Tke(e, t) {
    const n = hhe(e)
      , r = phe();
    return !n || !r ? !1 : r === i4.DOGFOODING ? !!t : !0
}
function phe() {
    const e = ue()
      , t = Vn(e, "1001765573");
    if (!t.get("ca_enabled", !1))
        return null;
    const r = t.get("feedback_format", null);
    return r && Object.values(i4).includes(r) ? r : null
}
const kke = e => Ai(e, t => Ce.getConversationTurns(t).some(n => n.messages.some(mhe)))
  , mhe = e => !!(e.author.role === Ke.Tool && e.author.name === "file_search" && e.metadata && e.metadata.command === FD.Spinner && e.metadata.retrieval_search_sources && e.metadata.retrieval_search_sources.some(t => t.product_type === "contextual_answers" || t.product_type === "slurm"))
  , Oke = () => {
    const e = ue();
    return Xe(e, "4147309512")
}
;
class ka {
    static async admin_list_knowledge_connectors(t) {
        return await ie.safeGet("/ca/v2/admin/list_knowledge_connectors", {
            parameters: {
                query: {
                    account_id: t
                }
            }
        })
    }
    static async admin_list_connection_instances(t) {
        return await ie.safeGet("/ca/v2/admin/list_connection_instances", {
            parameters: {
                query: {
                    account_id: t
                }
            }
        })
    }
    static async admin_get_connection_instance(t, n) {
        return await ie.safeGet("/ca/v2/admin/connection_instance/{connection_id}", {
            parameters: {
                query: {
                    account_id: t
                },
                path: {
                    connection_id: n
                }
            }
        })
    }
    static async admin_create_connection_instance(t, n, r) {
        return r === "" && (r = null),
        await ie.safePost("/ca/v2/admin/create_connection_instance", {
            requestBody: {
                connection_config: n,
                connection_name: r ?? null
            },
            parameters: {
                query: {
                    account_id: t
                }
            }
        })
    }
    static async admin_request_connect_quickstart(t, n, r) {
        return await ie.safeGet("/ca/v2/admin/request_connect_quickstart", {
            parameters: {
                query: {
                    account_id: t,
                    connection_id: n,
                    after_flow_redirect_to: r
                }
            }
        })
    }
    static async admin_connect_and_quickstart(t, n, r, s) {
        return await ie.safePost("/ca/v2/admin/connect_and_quickstart", {
            parameters: {
                query: {
                    account_id: t
                }
            },
            requestBody: {
                plugin_id: n,
                code: r,
                state: s
            }
        })
    }
    static async admin_edit_name_connection_instance(t, n, r) {
        return await ie.safePost("/ca/v2/admin/connection_instance/{connection_id}/update_name", {
            requestBody: r,
            parameters: {
                path: {
                    connection_id: n
                },
                query: {
                    account_id: t
                }
            }
        })
    }
    static async admin_activate_connection_instance(t, n) {
        return await ie.safePost("/ca/v2/admin/connection_instance/{connection_id}/activate", {
            requestBody: {},
            parameters: {
                path: {
                    connection_id: n
                },
                query: {
                    account_id: t
                }
            }
        })
    }
    static async admin_delete_connection_instance(t, n) {
        return await ie.safeDelete("/ca/v2/admin/connection_instance/{connection_id}", {
            parameters: {
                query: {
                    account_id: t
                },
                path: {
                    connection_id: n
                }
            }
        })
    }
    static async admin_connection_allow_user(t, n, r) {
        return await ie.safePost("/ca/v2/admin/connection_instance/{connection_id}/allow_user", {
            parameters: {
                query: {
                    account_id: t
                },
                path: {
                    connection_id: n
                }
            },
            requestBody: {
                user_id: r
            }
        })
    }
    static async admin_connection_disallow_user(t, n, r) {
        return await ie.safePost("/ca/v2/admin/connection_instance/{connection_id}/disallow_user", {
            parameters: {
                query: {
                    account_id: t
                },
                path: {
                    connection_id: n
                }
            },
            requestBody: {
                user_id: r
            }
        })
    }
    static async admin_connection_get_access_policy(t, n) {
        return await ie.safeGet("/ca/v2/admin/connection_instance/{connection_id}/get_access_policy", {
            parameters: {
                query: {
                    account_id: t
                },
                path: {
                    connection_id: n
                }
            }
        })
    }
    static async admin_connection_update_access_policy(t, n, r) {
        return await ie.safePost("/ca/v2/admin/connection_instance/{connection_id}/update_access_policy", {
            parameters: {
                query: {
                    account_id: t
                },
                path: {
                    connection_id: n
                }
            },
            requestBody: {
                allow_all_in_workspace: r
            }
        })
    }
    static async admin_connection_update_credential(t, n, {admin_email: r, credential_id: s, new_service_credential_content: o}) {
        return await ie.safePost("/ca/v2/admin/connection_instance/{connection_id}/update_credential", {
            parameters: {
                query: {
                    account_id: t
                },
                path: {
                    connection_id: n
                }
            },
            requestBody: {
                admin_email: r,
                credential_id: s,
                new_service_credential_content: o
            }
        })
    }
    static async admin_connection_list_item_scopes(t, n, r, s=null) {
        return await ie.safeGet("/ca/v2/admin/connection_instance/{connection_id}/list_item_scopes", {
            parameters: {
                path: {
                    connection_id: n
                },
                query: {
                    page_token: s,
                    account_id: t,
                    object_type: r
                }
            }
        })
    }
    static async admin_connection_update_item_default_scope(t, n, r, s) {
        return await ie.safePost("/ca/v2/admin/connection_instance/{connection_id}/update_item_default_scope", {
            parameters: {
                path: {
                    connection_id: n
                },
                query: {
                    account_id: t
                }
            },
            requestBody: {
                object_type: r,
                default_selection: s
            }
        })
    }
    static async admin_connection_block_items(t, n, r, s) {
        return await ie.safePost("/ca/v2/admin/connection_instance/{connection_id}/block_items", {
            parameters: {
                path: {
                    connection_id: n
                },
                query: {
                    account_id: t
                }
            },
            requestBody: {
                object_type: r,
                object_handles: s
            }
        })
    }
    static async admin_connection_unblock_items(t, n, r, s) {
        return await ie.safePost("/ca/v2/admin/connection_instance/{connection_id}/unblock_items", {
            parameters: {
                path: {
                    connection_id: n
                },
                query: {
                    account_id: t
                }
            },
            requestBody: {
                object_type: r,
                object_handles: s
            }
        })
    }
    static async user_activate_workspace_connection_and_user({link_id: t, user_extension: n}) {
        return await ie.safePost("/ca/v2/user/activate_workspace_connection_and_user", {
            requestBody: n ? {
                link_id: t,
                user_extension: n
            } : {
                link_id: t
            }
        })
    }
    static async user_connection_status() {
        return await ie.safeGet("/ca/v2/user/connection_status", {})
    }
    static async user_connection_list_item_scopes(t, n, r=null) {
        return await ie.safeGet("/ca/v2/user/connection_instance/{connection_id}/list_item_scopes", {
            parameters: {
                path: {
                    connection_id: t
                },
                query: {
                    page_token: r,
                    object_type: n
                }
            }
        })
    }
    static async user_connection_block_items(t, n, r) {
        return await ie.safePost("/ca/v2/user/connection_instance/{connection_id}/block_items", {
            parameters: {
                path: {
                    connection_id: t
                }
            },
            requestBody: {
                object_type: n,
                object_handles: r
            }
        })
    }
    static async user_connection_unblock_items(t, n, r) {
        return await ie.safePost("/ca/v2/user/connection_instance/{connection_id}/unblock_items", {
            parameters: {
                path: {
                    connection_id: t
                }
            },
            requestBody: {
                object_type: n,
                object_handles: r
            }
        })
    }
    static async user_connection_sync_configuration(t) {
        return await ie.safeGet("/ca/v2/user/connection_instance/{connection_id}/user_configuration", {
            parameters: {
                path: {
                    connection_id: t
                }
            }
        })
    }
    static async user_connection_update_sync_configuration(t, n) {
        return await ie.safePost("/ca/v2/user/connection_instance/{synced_knowledge_store_id}/user_configuration", {
            parameters: {
                path: {
                    synced_knowledge_store_id: t
                }
            },
            requestBody: {
                extension: n
            }
        })
    }
    static async user_request_connect(t, n, r) {
        return await ie.safeGet("/ca/v2/user/request_connect", {
            parameters: {
                query: {
                    connection_id: t,
                    after_flow_redirect_to: n,
                    ...r ? {
                        use_connectors_platform_flow: r
                    } : {}
                }
            }
        })
    }
    static async user_request_connect_upgrade_to_sync({link_id: t, user_extension: n}) {
        return await ie.safePost("/ca/v2/user/upgrade_to_sync", {
            requestBody: {
                link_id: t,
                user_extension: n
            }
        })
    }
    static async user_connection_oauth_callback(t, n, r) {
        return await ie.safePost("/ca/v2/user/connect_and_activate", {
            requestBody: {
                plugin_id: t,
                code: n,
                state: r
            }
        })
    }
    static async user_delete_sync(t) {
        return await ie.safePost("/ca/v2/user/delete_synced", {
            requestBody: {
                link_id: t
            }
        })
    }
    static async user_disconnect(t) {
        return await ie.safePost("/ca/v2/user/disconnect", {
            requestBody: {
                connection_id: t
            }
        })
    }
}
const Ake = ({skip: e=!1}={}) => {
    const {connectionInstanceData: t, refetch: n, isLoading: r} = _h({
        skip: e
    });
    return {
        gDriveOAuthConnectionId: h.useMemo( () => {
            const o = t?.connection_statuses;
            return o && o.length === 1 && o[0].user_connection_details.auth_status === "not_connected" && o[0].user_connection_details.knowledge_connector_type === "google_drive_oauth" ? o[0].user_connection_details.connection_instance_id : null
        }
        , [t]),
        refetch: n,
        isLoading: r
    }
}
  , EB = ({skip: e=!1}={}) => {
    const {connectionInstanceData: t} = _h({
        skip: e
    });
    return t?.connection_statuses.some(r => ["partially_activated", "activated"].includes(r.user_connection_details.activation_status))
}
  , _h = ({skip: e=!1}={}) => {
    const t = nc()
      , {data: n, isLoading: r, refetch: s} = At({
        queryKey: ["user_connection_status"],
        queryFn: ka.user_connection_status,
        enabled: !e && t,
        refetchInterval: o => {
            const i = o.state.status === "success" && o.state.data && !o.state.data.connection_statuses.some(l => l.user_connection_details.activation_status === "activating" || l.user_connection_details.activation_status === "partially_activated");
            return o.state.status === "success" && o.state.data && o.state.data.connection_statuses.some(l => (l.user_connection_details.auth_status === "user_connected" || l.user_connection_details.auth_status === "admin_connected") && !(l.user_connection_details.activation_status === "activating" || l.user_connection_details.activation_status === "partially_activated" || l.user_connection_details.activation_status === "activated")) ? 2 * 1e3 : i ? !1 : 30 * 1e3
        }
    });
    return {
        connectionInstanceData: n,
        isLoading: r,
        refetch: s
    }
}
  , xB = (e, t=!1) => ["fetchConnectorLinkData", e, t]
  , TB = (e, t) => ["fetchPlatformConnectorData", e, t]
  , Mke = (e, t) => ["connectors", e, t].filter(n => !!n)
  , Ike = (e, t) => ["roles", e, t].filter(n => !!n)
  , Rke = (e, t, n) => ["permissions", e, t, n];
function ghe() {
    const e = ue();
    return Xe(e, "3999836663")
}
function yh() {
    const e = ue()
      , t = Xe(e, "3544641259")
      , n = !!Vn(e, "463092697")?.value?.enabled
      , r = ghe();
    return t || n || r
}
var cb, eO;
function vhe() {
    if (eO)
        return cb;
    eO = 1;
    function e(t, n, r, s) {
        for (var o = -1, i = t == null ? 0 : t.length; ++o < i; ) {
            var a = t[o];
            n(s, a, r(a), t)
        }
        return s
    }
    return cb = e,
    cb
}
var ub, tO;
function _he() {
    if (tO)
        return ub;
    tO = 1;
    function e(t) {
        return function(n, r, s) {
            for (var o = -1, i = Object(n), a = s(n), l = a.length; l--; ) {
                var c = a[t ? l : ++o];
                if (r(i[c], c, i) === !1)
                    break
            }
            return n
        }
    }
    return ub = e,
    ub
}
var db, nO;
function yhe() {
    if (nO)
        return db;
    nO = 1;
    var e = _he()
      , t = e();
    return db = t,
    db
}
var fb, rO;
function bhe() {
    if (rO)
        return fb;
    rO = 1;
    var e = yhe()
      , t = Yu();
    function n(r, s) {
        return r && e(r, s, t)
    }
    return fb = n,
    fb
}
var hb, sO;
function Che() {
    if (sO)
        return hb;
    sO = 1;
    var e = l1();
    function t(n, r) {
        return function(s, o) {
            if (s == null)
                return s;
            if (!e(s))
                return n(s, o);
            for (var i = s.length, a = r ? i : -1, l = Object(s); (r ? a-- : ++a < i) && o(l[a], a, l) !== !1; )
                ;
            return s
        }
    }
    return hb = t,
    hb
}
var pb, oO;
function She() {
    if (oO)
        return pb;
    oO = 1;
    var e = bhe()
      , t = Che()
      , n = t(e);
    return pb = n,
    pb
}
var mb, iO;
function whe() {
    if (iO)
        return mb;
    iO = 1;
    var e = She();
    function t(n, r, s, o) {
        return e(n, function(i, a, l) {
            r(o, i, s(i), l)
        }),
        o
    }
    return mb = t,
    mb
}
var gb, aO;
function Ehe() {
    if (aO)
        return gb;
    aO = 1;
    var e = vhe()
      , t = whe()
      , n = ih()
      , r = ks();
    function s(o, i) {
        return function(a, l) {
            var c = r(a) ? e : t
              , u = i ? i() : {};
            return c(a, o, n(l, 2), u)
        }
    }
    return gb = s,
    gb
}
var vb, lO;
function xhe() {
    if (lO)
        return vb;
    lO = 1;
    var e = t4()
      , t = Ehe()
      , n = Object.prototype
      , r = n.hasOwnProperty
      , s = t(function(o, i, a) {
        r.call(o, a) ? o[a].push(i) : e(o, a, [i])
    });
    return vb = s,
    vb
}
var The = xhe();
const kB = mn(The)
  , khe = async (e, t=void 0) => (await ie.safePost("/aip/connectors/list_accessible", {
    requestBody: {
        principals: [{
            type: "USER",
            id: e
        }]
    },
    additionalHeaders: t ? {
        [pr]: t
    } : void 0
})).connectors
  , OB = async (e, t=!1, n=void 0) => {
    const r = await ie.safePost("/aip/connectors/links/list_accessible", {
        requestBody: {
            principals: [{
                type: "USER",
                id: e
            }],
            link_refresh_strategy: t ? "BLOCKING" : "NONE"
        },
        additionalHeaders: n ? {
            [pr]: n
        } : void 0
    });
    return kB(r.links, ({connector_id: s}) => s)
}
;
function Vl({skip: e=!1, fetchValidLinksOnly: t=!1, productSku: n}={}) {
    const r = ue()
      , s = bn(r)
      , o = yh()
      , {data: i, isLoading: a, isFetching: l, error: c, refetch: u} = At({
        queryKey: xB(s?.normalizedAccountUserId, t),
        enabled: !e && !!s && o,
        queryFn: async () => !s || !s.normalizedAccountUserId ? {} : await OB(s.normalizedAccountUserId, t, n)
    });
    return {
        connectorLinks: h.useMemo( () => i ? new Map(Object.entries(i)) : new Map, [i]),
        isLoading: a,
        isFetching: l,
        error: c,
        refetch: u
    }
}
function Nke({skip: e=!1, productSku: t}={}) {
    const n = yh()
      , r = ue()
      , s = bn(r)
      , o = Lr();
    h.useEffect( () => {
        if (e || !s?.normalizedAccountUserId || !n)
            return;
        const i = s.normalizedAccountUserId;
        o.prefetchQuery({
            queryKey: TB(i, void 0),
            queryFn: () => khe(i, t)
        }).catch( () => {}
        ),
        o.prefetchQuery({
            queryKey: xB(i, !1),
            queryFn: () => OB(i, !1, t)
        }).catch( () => {}
        )
    }
    , [e, s?.normalizedAccountUserId, o, n, t])
}
const Ohe = async (e, t, n) => (await ie.safePost("/aip/connectors/list_accessible", {
    requestBody: {
        principals: [{
            type: "USER",
            id: e
        }],
        purpose: n
    },
    additionalHeaders: t ? {
        [pr]: t
    } : void 0
})).connectors;
function bh(e=!0, t=void 0, n=void 0) {
    const r = yh()
      , s = ue()
      , o = bn(s)
      , {data: i, isLoading: a, isFetching: l, error: c, refetch: u} = At({
        queryKey: TB(o?.normalizedAccountUserId, n),
        queryFn: async () => !o || !o.normalizedAccountUserId ? [] : await Ohe(o.normalizedAccountUserId, t, n),
        enabled: !!o && e && r
    });
    return {
        platformConnectors: h.useMemo( () => new Map(i?.map(f => [f.id, f])), [i]),
        isLoading: a,
        isFetching: l,
        error: c,
        refetch: u
    }
}
function AB(e) {
    const t = Tn();
    return At({
        queryKey: ["userContext"],
        queryFn: () => ie.safeGet("/user_system_messages").catch(n => {
            throw t.danger({
                id: "userContextModal.getCustomInstructionsError",
                defaultMessage: "Failed to get your settings",
                description: "Error message when getting custom instructions fails"
            }, {
                toastId: "user_context_modal_get_custom_instructions_error"
            }),
            n
        }
        ),
        enabled: e,
        select: n => {
            const {about_user_message: r, about_model_message: s, personality_type_selection: o, name_user_message: i, role_user_message: a, traits_model_message: l, other_user_message: c, disabled_tools: u, enabled: d, object: f, ...p} = n;
            return {
                ...p,
                aboutUserMessage: r ?? "",
                aboutModelMessage: s ?? "",
                personalityTypeMessage: o ?? "",
                nameUserMessage: i ?? "",
                roleUserMessage: a ?? "",
                traitsModelMessage: l ?? "",
                otherUserMessage: c ?? "",
                disabledTools: u ?? [],
                enabled: d ?? !0
            }
        }
    })
}
function Ahe({aboutUserMessage: e, aboutModelMessage: t, personalityTypeMessage: n, nameUserMessage: r="", roleUserMessage: s="", traitsModelMessage: o="", otherUserMessage: i="", disabledTools: a, enabled: l, ...c}) {
    return ie.safePost("/user_system_messages", {
        requestBody: {
            about_user_message: e,
            about_model_message: t,
            personality_type_selection: n,
            name_user_message: r,
            role_user_message: s,
            traits_model_message: o,
            other_user_message: i,
            disabled_tools: a,
            enabled: l,
            ...c
        }
    })
}
const Mhe = e => h.createElement("svg", {
    width: 24,
    height: 24,
    viewBox: "0 0 24 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ...e
}, h.createElement("g", {
    clipPath: "url(#clip0_5707_424)"
}, h.createElement("path", {
    d: "M22 2H2V22H22V2Z",
    fill: "#0472F8"
}), h.createElement("path", {
    fillRule: "evenodd",
    clipRule: "evenodd",
    d: "M12.1302 13.5156C11.3673 13.5156 10.7134 12.8617 10.7134 12.0625C10.7134 11.2633 11.331 10.6094 12.1302 10.6094C12.893 10.6094 13.5469 11.2633 13.5469 12.0625C13.5469 12.8617 12.9294 13.5156 12.1302 13.5156ZM7.98887 13.5156C7.226 13.5156 6.57212 12.8617 6.57212 12.0625C6.57212 11.2633 7.18967 10.6094 7.98887 10.6094C8.75174 10.6094 9.40563 11.2633 9.40563 12.0625C9.40563 12.8617 8.78806 13.5156 7.98887 13.5156ZM17.4339 9.91917C17.6156 9.70121 17.9425 9.66489 18.1605 9.84652C18.3784 9.99183 18.4511 10.3188 18.2695 10.5367L16.9617 12.1715L18.2695 13.8062C18.4511 14.0241 18.3784 14.3148 18.1605 14.4964C17.9425 14.6417 17.6156 14.6054 17.4339 14.4237L16.3078 13.0433L15.1817 14.4237C15 14.6417 14.6731 14.678 14.4551 14.4964C14.2371 14.3511 14.1645 14.0241 14.3461 13.8062L15.6539 12.1715L14.3825 10.5004C14.2008 10.2824 14.2735 9.99183 14.4914 9.81019C14.7094 9.66489 15.0363 9.70121 15.218 9.88285L16.3441 11.2996L17.4339 9.91917ZM6.13619 7.59424C6.39048 7.59424 6.60845 7.8122 6.60845 8.06649V10.1371C7.00804 9.84652 7.48029 9.66489 8.02519 9.66489C8.93338 9.66489 9.69624 10.1735 10.0958 10.9727C10.4954 10.2098 11.2583 9.66489 12.1665 9.66489C13.4743 9.66489 14.4914 10.7547 14.4914 12.0988C14.4914 13.4429 13.4379 14.5327 12.1665 14.5327C11.2583 14.5327 10.4954 14.0241 10.0958 13.2249C9.69624 13.9878 8.93338 14.5327 8.02519 14.5327C6.75374 14.5327 5.70027 13.4792 5.70027 12.1351V8.06649C5.66394 7.8122 5.8819 7.59424 6.13619 7.59424Z",
    fill: "white"
})), h.createElement("defs", null, h.createElement("clipPath", {
    id: "clip0_5707_424"
}, h.createElement("rect", {
    x: 2,
    y: 2,
    width: 20,
    height: 20,
    rx: 2,
    fill: "white"
}))))
  , Ihe = e => h.createElement("svg", {
    width: 24,
    height: 24,
    viewBox: "0 0 24 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ...e
}, h.createElement("g", {
    clipPath: "url(#clip0_5904_434)"
}, h.createElement("path", {
    d: "M12 22C17.5228 22 22 17.5228 22 12C22 6.47715 17.5228 2 12 2C6.47715 2 2 6.47715 2 12C2 17.5228 6.47715 22 12 22Z",
    fill: "#7D2AE7"
}), h.createElement("path", {
    d: "M12 22C17.5228 22 22 17.5228 22 12C22 6.47715 17.5228 2 12 2C6.47715 2 2 6.47715 2 12C2 17.5228 6.47715 22 12 22Z",
    fill: "url(#paint0_radial_5904_434)"
}), h.createElement("path", {
    d: "M12 22C17.5228 22 22 17.5228 22 12C22 6.47715 17.5228 2 12 2C6.47715 2 2 6.47715 2 12C2 17.5228 6.47715 22 12 22Z",
    fill: "url(#paint1_radial_5904_434)"
}), h.createElement("path", {
    d: "M12 22C17.5228 22 22 17.5228 22 12C22 6.47715 17.5228 2 12 2C6.47715 2 2 6.47715 2 12C2 17.5228 6.47715 22 12 22Z",
    fill: "url(#paint2_radial_5904_434)"
}), h.createElement("path", {
    d: "M12 22C17.5228 22 22 17.5228 22 12C22 6.47715 17.5228 2 12 2C6.47715 2 2 6.47715 2 12C2 17.5228 6.47715 22 12 22Z",
    fill: "url(#paint3_radial_5904_434)"
}), h.createElement("path", {
    d: "M16.3172 14.0514C16.2346 14.0514 16.162 14.1211 16.0864 14.2733C15.2329 16.0039 13.7588 17.2284 12.053 17.2284C10.0806 17.2284 8.85912 15.4479 8.85912 12.9881C8.85912 8.82143 11.1807 6.41235 13.2198 6.41235C14.1726 6.41235 14.7545 7.01114 14.7545 7.96403C14.7545 9.09497 14.112 9.69376 14.112 10.0926C14.112 10.2717 14.2234 10.3801 14.4442 10.3801C15.3315 10.3801 16.3728 9.36055 16.3728 7.92026C16.3728 6.52375 15.1574 5.49725 13.1183 5.49725C9.74837 5.49725 6.75342 8.62151 6.75342 12.9443C6.75342 16.2904 8.66418 18.5016 11.6124 18.5016C14.7416 18.5016 16.5509 15.3882 16.5509 14.3777C16.5509 14.1539 16.4365 14.0514 16.3172 14.0514Z",
    fill: "white"
})), h.createElement("defs", null, h.createElement("radialGradient", {
    id: "paint0_radial_5904_434",
    cx: 0,
    cy: 0,
    r: 1,
    gradientUnits: "userSpaceOnUse",
    gradientTransform: "translate(5.86316 19.7263) rotate(-49.4156) scale(15.4683)"
}, h.createElement("stop", {
    stopColor: "#6420FF"
}), h.createElement("stop", {
    offset: 1,
    stopColor: "#6420FF",
    stopOpacity: 0
})), h.createElement("radialGradient", {
    id: "paint1_radial_5904_434",
    cx: 0,
    cy: 0,
    r: 1,
    gradientUnits: "userSpaceOnUse",
    gradientTransform: "translate(7.29474 4.27368) rotate(54.7035) scale(17.4434)"
}, h.createElement("stop", {
    stopColor: "#00C4CC"
}), h.createElement("stop", {
    offset: 1,
    stopColor: "#00C4CC",
    stopOpacity: 0
})), h.createElement("radialGradient", {
    id: "paint2_radial_5904_434",
    cx: 0,
    cy: 0,
    r: 1,
    gradientUnits: "userSpaceOnUse",
    gradientTransform: "translate(5.86316 19.7263) rotate(-45.1954) scale(15.2811 7.02796)"
}, h.createElement("stop", {
    stopColor: "#6420FF"
}), h.createElement("stop", {
    offset: 1,
    stopColor: "#6420FF",
    stopOpacity: 0
})), h.createElement("radialGradient", {
    id: "paint3_radial_5904_434",
    cx: 0,
    cy: 0,
    r: 1,
    gradientUnits: "userSpaceOnUse",
    gradientTransform: "translate(10.1789 4.69474) rotate(66.5198) scale(15.7459 26.3779)"
}, h.createElement("stop", {
    stopColor: "#00C4CC",
    stopOpacity: .725916
}), h.createElement("stop", {
    offset: 1e-4,
    stopColor: "#00C4CC"
}), h.createElement("stop", {
    offset: 1,
    stopColor: "#00C4CC",
    stopOpacity: 0
})), h.createElement("clipPath", {
    id: "clip0_5904_434"
}, h.createElement("rect", {
    width: 20,
    height: 20,
    fill: "white",
    transform: "translate(2 2)"
}))))
  , Rhe = e => h.createElement("svg", {
    width: 24,
    height: 24,
    viewBox: "0 0 24 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ...e
}, h.createElement("path", {
    d: "M6.62777 3.00696L1.25488 6.38196L6.62777 9.75695L12.0016 6.38196L17.3745 9.75695L22.7474 6.38196L17.3745 3.00696L12.0016 6.38196L6.62777 3.00696Z",
    fill: "#0061FE"
}), h.createElement("path", {
    d: "M6.62777 16.507L1.25488 13.132L6.62777 9.75696L12.0016 13.132L6.62777 16.507Z",
    fill: "#0061FE"
}), h.createElement("path", {
    d: "M12.0015 13.132L17.3744 9.75696L22.7473 13.132L17.3744 16.507L12.0015 13.132Z",
    fill: "#0061FE"
}), h.createElement("path", {
    d: "M12.0013 21.007L6.62744 17.632L12.0013 14.257L17.3742 17.632L12.0013 21.007Z",
    fill: "#0061FE"
}))
  , MB = e => h.createElement("svg", {
    width: 24,
    height: 24,
    viewBox: "0 0 24 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ...e
}, h.createElement("path", {
    d: "M12 1.95068C17.525 1.95068 22 6.42568 22 11.9507C21.9995 14.0459 21.3419 16.0883 20.1198 17.7902C18.8977 19.4922 17.1727 20.768 15.1875 21.4382C14.6875 21.5382 14.5 21.2257 14.5 20.9632C14.5 20.6257 14.5125 19.5507 14.5125 18.2132C14.5125 17.2757 14.2 16.6757 13.8375 16.3632C16.0625 16.1132 18.4 15.2632 18.4 11.4257C18.4 10.3257 18.0125 9.43818 17.375 8.73818C17.475 8.48818 17.825 7.46318 17.275 6.08818C17.275 6.08818 16.4375 5.81318 14.525 7.11318C13.725 6.88818 12.875 6.77568 12.025 6.77568C11.175 6.77568 10.325 6.88818 9.525 7.11318C7.6125 5.82568 6.775 6.08818 6.775 6.08818C6.225 7.46318 6.575 8.48818 6.675 8.73818C6.0375 9.43818 5.65 10.3382 5.65 11.4257C5.65 15.2507 7.975 16.1132 10.2 16.3632C9.9125 16.6132 9.65 17.0507 9.5625 17.7007C8.9875 17.9632 7.55 18.3882 6.65 16.8757C6.4625 16.5757 5.9 15.8382 5.1125 15.8507C4.275 15.8632 4.775 16.3257 5.125 16.5132C5.55 16.7507 6.0375 17.6382 6.15 17.9257C6.35 18.4882 7 19.5632 9.5125 19.1007C9.5125 19.9382 9.525 20.7257 9.525 20.9632C9.525 21.2257 9.3375 21.5257 8.8375 21.4382C6.8458 20.7752 5.11342 19.502 3.88611 17.799C2.65881 16.096 1.9989 14.0498 2 11.9507C2 6.42568 6.475 1.95068 12 1.95068Z",
    fill: "currentColor"
}))
  , Nhe = e => h.createElement("svg", {
    width: 24,
    height: 24,
    viewBox: "0 0 24 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ...e
}, h.createElement("path", {
    d: "M6.27275 19.8771V11.7634L3.75642 9.46126L1.5 8.18381V18.4452C1.5 19.2375 2.14194 19.8771 2.93183 19.8771H6.27275Z",
    fill: "#4285F4"
}), h.createElement("path", {
    d: "M17.7271 19.8771H21.068C21.8603 19.8771 22.4998 19.2351 22.4998 18.4452V8.18381L19.9441 9.64709L17.7271 11.7634V19.8771Z",
    fill: "#34A853"
}), h.createElement("path", {
    d: "M6.27257 11.7635L5.93018 8.59314L6.27257 5.55887L11.9999 9.85434L17.7272 5.55887L18.1102 8.42932L17.7272 11.7635L11.9999 16.0589L6.27257 11.7635Z",
    fill: "#EA4335"
}), h.createElement("path", {
    d: "M17.7271 5.55879V11.7634L22.4998 8.18381V6.2747C22.4998 4.504 20.4786 3.49457 19.0634 4.5565L17.7271 5.55879Z",
    fill: "#FBBC04"
}), h.createElement("path", {
    d: "M1.5 8.18378L3.69507 9.83008L6.27275 11.7633V5.55876L4.93638 4.55647C3.51887 3.49454 1.5 4.50397 1.5 6.27467V8.18378Z",
    fill: "#C5221F"
}))
  , Phe = e => h.createElement("svg", {
    width: 24,
    height: 24,
    viewBox: "0 0 24 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ...e
}, h.createElement("path", {
    d: "M16.7369 7.26321H7.26318V16.7369H16.7369V7.26321Z",
    fill: "white"
}), h.createElement("path", {
    d: "M16.7367 21L20.9999 16.7369L18.8683 16.3732L16.7367 16.7369L16.3477 18.6866L16.7367 21Z",
    fill: "#EA4335"
}), h.createElement("path", {
    d: "M3 16.7369V19.579C3 20.3641 3.63592 21 4.42105 21H7.26316L7.70087 18.8684L7.26316 16.7369L4.94057 16.3732L3 16.7369Z",
    fill: "#188038"
}), h.createElement("path", {
    d: "M20.9999 7.26316V4.42105C20.9999 3.63592 20.364 3 19.5788 3H16.7367C16.4773 4.05721 16.3477 4.83523 16.3477 5.33408C16.3477 5.83291 16.4773 6.47593 16.7367 7.26316C17.6796 7.53315 18.3901 7.66815 18.8683 7.66815C19.3465 7.66815 20.057 7.53315 20.9999 7.26316Z",
    fill: "#1967D2"
}), h.createElement("path", {
    d: "M21 7.26321H16.7368V16.7369H21V7.26321Z",
    fill: "#FBBC04"
}), h.createElement("path", {
    d: "M16.7369 16.7368H7.26318V21H16.7369V16.7368Z",
    fill: "#34A853"
}), h.createElement("path", {
    d: "M16.7368 2.99997H4.42105C3.63592 2.99997 3 3.63589 3 4.42102V16.7368H7.26316V7.26313H16.7368V2.99997Z",
    fill: "#4285F4"
}), h.createElement("path", {
    d: "M9.20617 14.6124C8.8521 14.3732 8.60696 14.0239 8.47314 13.562L9.295 13.2233C9.3696 13.5075 9.49985 13.7278 9.68577 13.8841C9.87052 14.0404 10.0955 14.1174 10.3584 14.1174C10.6272 14.1174 10.8581 14.0357 11.0512 13.8723C11.2442 13.7089 11.3413 13.5004 11.3413 13.2482C11.3413 12.99 11.2395 12.7792 11.0358 12.6158C10.8321 12.4524 10.5763 12.3707 10.2708 12.3707H9.79591V11.5571H10.2222C10.4851 11.5571 10.7066 11.4861 10.8866 11.344C11.0666 11.2019 11.1566 11.0077 11.1566 10.7602C11.1566 10.5399 11.076 10.3646 10.915 10.2332C10.7539 10.1017 10.5502 10.0354 10.3027 10.0354C10.0612 10.0354 9.86933 10.0994 9.72723 10.2285C9.58522 10.3579 9.47844 10.5213 9.41696 10.7033L8.60341 10.3646C8.71117 10.0591 8.90894 9.7891 9.19906 9.55581C9.48921 9.32252 9.85985 9.20529 10.3099 9.20529C10.6426 9.20529 10.9422 9.26925 11.2075 9.39831C11.4727 9.5274 11.6812 9.70621 11.8316 9.93358C11.982 10.1621 12.0566 10.4179 12.0566 10.7021C12.0566 10.9923 11.9867 11.2374 11.847 11.4387C11.7072 11.64 11.5355 11.794 11.3318 11.9017V11.9503C11.5948 12.0587 11.8233 12.2368 11.9926 12.4654C12.1643 12.6964 12.2508 12.9723 12.2508 13.2944C12.2508 13.6165 12.1691 13.9042 12.0056 14.1565C11.8422 14.4087 11.616 14.6077 11.3295 14.7521C11.0417 14.8966 10.7184 14.97 10.3596 14.97C9.94394 14.9712 9.56025 14.8516 9.20617 14.6124ZM14.2545 10.534L13.3521 11.1865L12.9009 10.502L14.5197 9.33437H15.1402V14.8421H14.2545V10.534Z",
    fill: "#4285F4"
}))
  , Dhe = e => h.createElement("svg", {
    width: 24,
    height: 24,
    viewBox: "0 0 24 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ...e
}, h.createElement("path", {
    d: "M9.48739 11.7436C5.94383 11.7436 3.07715 14.6102 3.07715 18.1538V20.8462C3.07715 21.4833 3.59383 22 4.23099 22H7.30791L10.3848 11.7436H9.48739Z",
    fill: "#86A9FF"
}), h.createElement("path", {
    d: "M20.0001 15.9744C20.0001 13.6359 18.1077 11.7436 15.7693 11.7436H12.6924V22H15.7693C18.1078 22 20.0001 20.1077 20.0001 17.7692",
    fill: "#578CFF"
}), h.createElement("path", {
    d: "M6.15381 15.9744C6.15381 13.6359 8.04613 11.7436 10.3846 11.7436H12.6922C15.0307 11.7436 16.923 13.6359 16.923 15.9744V17.7692C16.923 20.1077 15.0307 22 12.6922 22H7.30765C6.67049 22 6.15381 21.4833 6.15381 20.8462V15.9744Z",
    fill: "#0057CC"
}), h.createElement("path", {
    d: "M11.5383 9.94872C13.7333 9.94872 15.5127 8.16934 15.5127 5.97436C15.5127 3.77938 13.7333 2 11.5383 2C9.34335 2 7.56396 3.77938 7.56396 5.97436C7.56396 8.16934 9.34335 9.94872 11.5383 9.94872Z",
    fill: "#0057CC"
}))
  , td = e => h.createElement("svg", {
    width: 24,
    height: 24,
    viewBox: "0 0 24 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ...e
}, h.createElement("path", {
    d: "M3.51105 18.4269L4.39307 19.9615C4.57634 20.2846 4.8398 20.5384 5.14908 20.723L8.29914 15.2307H1.99902C1.99902 15.5884 2.09066 15.9461 2.27394 16.2692L3.51105 18.4269Z",
    fill: "#0066DA"
}), h.createElement("path", {
    d: "M11.999 8.76916L8.84897 3.27686C8.53969 3.46147 8.27623 3.71532 8.09295 4.03839L2.27394 14.1922C2.09403 14.5083 1.99926 14.8663 1.99902 15.2307H8.29914L11.999 8.76916Z",
    fill: "#00AC47"
}), h.createElement("path", {
    d: "M18.8492 20.723C19.1585 20.5384 19.422 20.2846 19.6053 19.9615L19.9718 19.3269L21.7244 16.2692C21.9077 15.9461 21.9993 15.5884 21.9993 15.2307H15.6987L17.0394 17.8846L18.8492 20.723Z",
    fill: "#EA4335"
}), h.createElement("path", {
    d: "M11.9982 8.76923L15.1483 3.27692C14.839 3.09231 14.4839 3 14.1173 3H9.87907C9.51252 3 9.15742 3.10385 8.84814 3.27692L11.9982 8.76923Z",
    fill: "#00832D"
}), h.createElement("path", {
    d: "M15.6983 15.2307H8.29849L5.14844 20.723C5.45772 20.9076 5.81281 20.9999 6.17937 20.9999H17.8174C18.1839 20.9999 18.539 20.8961 18.8483 20.723L15.6983 15.2307Z",
    fill: "#2684FC"
}), h.createElement("path", {
    d: "M18.8146 9.11532L15.9051 4.03839C15.7218 3.71532 15.4584 3.46147 15.1491 3.27686L11.999 8.76916L15.6989 15.2307H21.9876C21.9876 14.873 21.8959 14.5153 21.7127 14.1922L18.8146 9.11532Z",
    fill: "#FFBA00"
}))
  , Lhe = e => h.createElement("svg", {
    width: 24,
    height: 24,
    viewBox: "0 0 24 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ...e
}, h.createElement("path", {
    d: "M16.888 8.14381V5.93591C17.1798 5.79955 17.4268 5.58312 17.6004 5.31182C17.7739 5.04053 17.8668 4.72552 17.8683 4.40346V4.35276C17.8683 3.41376 17.1071 2.65254 16.1681 2.65254H16.1174C15.6665 2.65254 15.234 2.83167 14.9152 3.15052C14.5963 3.46937 14.4172 3.90183 14.4172 4.35276V4.40346C14.4187 4.72552 14.5116 5.04053 14.6851 5.31182C14.8587 5.58312 15.1057 5.79955 15.3975 5.93591V8.14381C14.5589 8.27221 13.7692 8.61989 13.1082 9.15167L7.05292 4.43539C7.09611 4.27951 7.11865 4.11926 7.12116 3.95838C7.1219 3.57946 7.01024 3.20884 6.80032 2.89339C6.5904 2.57794 6.29164 2.33183 5.94183 2.1862C5.59202 2.04056 5.20688 2.00195 4.83512 2.07523C4.46335 2.14852 4.12168 2.33041 3.85331 2.59791C3.58494 2.8654 3.40193 3.20648 3.32743 3.578C3.25293 3.94952 3.29029 4.33478 3.43478 4.68507C3.57927 5.03535 3.82439 5.33492 4.13916 5.54587C4.45392 5.75682 4.82418 5.86968 5.20309 5.87018C5.53459 5.86862 5.85988 5.78012 6.14648 5.61352L12.1091 10.2534C11.5735 11.0626 11.294 12.0144 11.3072 12.9848C11.3204 13.9551 11.6256 14.899 12.183 15.6934L10.3695 17.5075C10.2229 17.4606 10.0701 17.4357 9.91624 17.4336C9.60521 17.4339 9.30123 17.5263 9.04273 17.6993C8.78422 17.8722 8.58278 18.1179 8.46386 18.4053C8.34495 18.6927 8.3139 19.0089 8.37464 19.314C8.43538 19.619 8.58519 19.8992 8.80512 20.1192C9.02505 20.3391 9.30524 20.4889 9.61028 20.5496C9.91532 20.6104 10.2315 20.5793 10.5189 20.4604C10.8063 20.3415 11.052 20.1401 11.225 19.8815C11.3979 19.623 11.4904 19.3191 11.4906 19.008C11.4886 18.8541 11.4637 18.7014 11.4168 18.5548L13.2109 16.7601C13.7959 17.2105 14.4763 17.521 15.1999 17.6678C15.9235 17.8147 16.6711 17.7939 17.3854 17.6072C18.0998 17.4205 18.7619 17.0727 19.3211 16.5906C19.8803 16.1085 20.3217 15.5047 20.6115 14.8256C20.9013 14.1465 21.0318 13.4101 20.9931 12.6728C20.9543 11.9355 20.7473 11.2168 20.3879 10.5718C20.0285 9.92689 19.5262 9.37275 18.9196 8.95189C18.3129 8.53103 17.618 8.25461 16.888 8.14381ZM16.1443 15.4054C15.8127 15.4145 15.4827 15.3571 15.1737 15.2365C14.8647 15.1159 14.583 14.9346 14.3452 14.7033C14.1075 14.472 13.9185 14.1954 13.7895 13.8899C13.6604 13.5843 13.594 13.256 13.594 12.9243C13.594 12.5926 13.6604 12.2642 13.7895 11.9587C13.9185 11.6531 14.1075 11.3765 14.3452 11.1452C14.583 10.9139 14.8647 10.7326 15.1737 10.612C15.4827 10.4914 15.8127 10.434 16.1443 10.4431C16.7869 10.4656 17.3958 10.7366 17.8426 11.1991C18.2893 11.6616 18.5392 12.2794 18.5395 12.9224C18.5399 13.5655 18.2906 14.1835 17.8443 14.6464C17.398 15.1094 16.7894 15.381 16.1468 15.4042",
    fill: "#FF7A59"
}))
  , Fhe = e => h.createElement("svg", {
    width: 24,
    height: 24,
    viewBox: "0 0 24 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ...e
}, h.createElement("g", {
    clipPath: "url(#clip0_5645_167)"
}, h.createElement("path", {
    d: "M19.289 12.9098C19.289 13.0866 19.2193 13.2561 19.0953 13.381C18.9713 13.506 18.8032 13.5763 18.6278 13.5763C18.4525 13.5763 18.2843 13.506 18.1603 13.381C18.0363 13.2561 17.9667 13.0866 17.9667 12.9098V6.95655C17.9667 6.77982 18.0363 6.61032 18.1603 6.48536C18.2843 6.36038 18.4525 6.29017 18.6278 6.29017C18.8032 6.29017 18.9713 6.36038 19.0953 6.48536C19.2193 6.61032 19.289 6.77982 19.289 6.95655V12.9098ZM19.0595 17.0348C18.9721 17.1229 16.5134 19.1881 12.0057 19.1881C7.49817 19.1881 5.05587 17.1339 4.95206 17.0457C4.88664 16.9902 4.83275 16.9221 4.79348 16.8455C4.75422 16.7688 4.73035 16.6851 4.72324 16.5991C4.71614 16.5132 4.72594 16.4267 4.75207 16.3445C4.77821 16.2624 4.82018 16.1863 4.87557 16.1205C4.98967 15.9875 5.15135 15.9053 5.32535 15.8918C5.49935 15.8784 5.67155 15.935 5.8044 16.049C5.84266 16.0765 8.03908 17.8718 12.0003 17.8718C15.9616 17.8718 18.1743 16.0655 18.1962 16.049C18.3305 15.9359 18.5033 15.8802 18.6777 15.8936C18.8523 15.907 19.0147 15.9883 19.1305 16.1205C19.242 16.2517 19.2976 16.4218 19.2853 16.594C19.273 16.7662 19.1938 16.9266 19.065 17.0403L19.0595 17.0348ZM4.71712 6.95655C4.727 6.77926 4.80611 6.61311 4.93716 6.49444C5.0682 6.37577 5.24054 6.31421 5.41648 6.32322C5.57959 6.33256 5.73349 6.40243 5.84851 6.51938C5.96353 6.63633 6.03151 6.79207 6.03934 6.95655V12.8989C6.03934 13.0756 5.96969 13.245 5.84571 13.37C5.72173 13.495 5.55357 13.5652 5.37823 13.5652C5.20289 13.5652 5.03473 13.495 4.91075 13.37C4.78677 13.245 4.71712 13.0756 4.71712 12.8989V6.95655ZM8.03362 5.63482C8.0435 5.45752 8.12261 5.29138 8.25366 5.17271C8.38471 5.05403 8.55704 4.99248 8.73298 5.00149C8.89609 5.01083 9.05 5.0807 9.16501 5.19765C9.28002 5.3146 9.348 5.47033 9.35585 5.63482V14.4463C9.35585 14.6231 9.2862 14.7926 9.16221 14.9176C9.03823 15.0425 8.87007 15.1127 8.69474 15.1127C8.5194 15.1127 8.35124 15.0425 8.22726 14.9176C8.10327 14.7926 8.03362 14.6231 8.03362 14.4463V5.63482ZM11.3665 5.30438C11.3665 5.12765 11.4362 4.95816 11.5602 4.83319C11.6842 4.70822 11.8523 4.63801 12.0276 4.63801C12.203 4.63801 12.3711 4.70822 12.4951 4.83319C12.6191 4.95816 12.6888 5.12765 12.6888 5.30438V14.887C12.6888 15.0637 12.6191 15.2331 12.4951 15.3582C12.3711 15.4831 12.203 15.5533 12.0276 15.5533C11.8523 15.5533 11.6842 15.4831 11.5602 15.3582C11.4362 15.2331 11.3665 15.0637 11.3665 14.887V5.30438ZM14.6448 5.63482C14.6448 5.45809 14.7144 5.28859 14.8384 5.16362C14.9623 5.03865 15.1305 4.96844 15.3059 4.96844C15.4812 4.96844 15.6494 5.03865 15.7734 5.16362C15.8973 5.28859 15.967 5.45809 15.967 5.63482V14.4463C15.967 14.6231 15.8973 14.7926 15.7734 14.9176C15.6494 15.0425 15.4812 15.1127 15.3059 15.1127C15.1305 15.1127 14.9623 15.0425 14.8384 14.9176C14.7144 14.7926 14.6448 14.6231 14.6448 14.4463V5.63482ZM19.4693 2.00005H4.56414C4.23936 1.99788 3.91735 2.06029 3.61654 2.18373C3.31573 2.30716 3.04203 2.48919 2.81111 2.71939C2.58019 2.94959 2.39658 3.22343 2.27081 3.52526C2.14503 3.82708 2.07955 4.15094 2.07812 4.4783V19.3478C2.07955 19.6751 2.14503 19.999 2.27081 20.3009C2.39658 20.6026 2.58019 20.8765 2.81111 21.1067C3.04203 21.3369 3.31573 21.519 3.61654 21.6423C3.91735 21.7658 4.23936 21.8282 4.56414 21.826H19.4693C19.7936 21.8282 20.1151 21.766 20.4156 21.6429C20.7161 21.5198 20.9895 21.3383 21.2203 21.1086C21.4512 20.879 21.635 20.6058 21.761 20.3046C21.8871 20.0035 21.9531 19.6802 21.9553 19.3533V4.4783C21.9538 4.15141 21.8885 3.828 21.7631 3.52654C21.6376 3.22508 21.4545 2.95148 21.2242 2.72135C20.9939 2.49122 20.7208 2.30908 20.4206 2.18532C20.1204 2.06156 19.799 1.99861 19.4747 2.00005",
    fill: "currentColor"
})), h.createElement("defs", null, h.createElement("clipPath", {
    id: "clip0_5645_167"
}, h.createElement("rect", {
    width: 20,
    height: 20,
    fill: "white",
    transform: "translate(2 2)"
}))))
  , jhe = e => h.createElement("svg", {
    width: 24,
    height: 24,
    viewBox: "0 0 24 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ...e
}, h.createElement("g", {
    clipPath: "url(#clip0_5645_169)"
}, h.createElement("path", {
    d: "M2.41207 13.8046C2.36757 13.6149 2.59357 13.4954 2.73135 13.6332L10.0338 20.9356C10.1716 21.0734 10.0521 21.2994 9.86243 21.2549C6.17729 20.3904 3.27655 17.4897 2.41207 13.8046ZM2.16737 10.8778C2.16384 10.9345 2.18514 10.9898 2.22528 11.0299L12.6371 21.4417C12.6772 21.4818 12.7325 21.5032 12.7892 21.4996C13.263 21.4701 13.7279 21.4076 14.1817 21.3144C14.3346 21.283 14.3877 21.0952 14.2773 20.9848L2.68218 9.3897C2.57181 9.27932 2.38395 9.33244 2.35255 9.48534C2.25936 9.93906 2.19688 10.404 2.16737 10.8778ZM3.00918 7.44108C2.97588 7.51584 2.99284 7.6032 3.05071 7.66108L16.0059 20.6163C16.0638 20.6742 16.1512 20.6911 16.2259 20.6578C16.5831 20.4987 16.9293 20.3193 17.263 20.121C17.3734 20.0554 17.3905 19.9037 17.2997 19.8129L3.85412 6.36734C3.76331 6.27652 3.61158 6.29356 3.54598 6.40398C3.34771 6.73766 3.16829 7.08386 3.00918 7.44108ZM4.69873 5.1148C4.62471 5.04078 4.62013 4.92206 4.68987 4.84398C6.52289 2.79186 9.18927 1.5 12.1574 1.5C17.6855 1.5 22.167 5.98146 22.167 11.5096C22.167 14.4777 20.8751 17.1441 18.823 18.9771C18.745 19.0469 18.6262 19.0423 18.5522 18.9683L4.69873 5.1148Z",
    fill: "#6777FF"
})), h.createElement("defs", null, h.createElement("clipPath", {
    id: "clip0_5645_169"
}, h.createElement("rect", {
    width: 20,
    height: 20,
    fill: "white",
    transform: "translate(2.16699 1.5)"
}))))
  , Uhe = e => h.createElement("svg", {
    "xmlns:dc": "http://purl.org/dc/elements/1.1/",
    "xmlns:cc": "http://creativecommons.org/ns#",
    "xmlns:rdf": "http://www.w3.org/1999/02/22-rdf-syntax-ns#",
    "xmlns:svg": "http://www.w3.org/2000/svg",
    xmlns: "http://www.w3.org/2000/svg",
    "xmlns:sodipodi": "http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd",
    "xmlns:inkscape": "http://www.inkscape.org/namespaces/inkscape",
    width: "170mm",
    height: "173mm",
    viewBox: "0 0 170 173",
    id: "svg8",
    "inkscape:version": "1.0.2 (e86c870879, 2021-01-15, custom)",
    "sodipodi:docname": "cldrnw.svg",
    ...e
}, h.createElement("defs", {
    id: "defs2"
}), h.createElement("sodipodi:namedview", {
    id: "base",
    pagecolor: "#ffffff",
    bordercolor: "#666666",
    borderopacity: 1,
    "inkscape:pageopacity": 0,
    "inkscape:pageshadow": 2,
    "inkscape:zoom": 1,
    "inkscape:cx": 446.39757,
    "inkscape:cy": 364.37241,
    "inkscape:document-units": "mm",
    "inkscape:current-layer": "layer2",
    "inkscape:document-rotation": 0,
    showgrid: "false",
    "inkscape:window-width": 1920,
    "inkscape:window-height": 1017,
    "inkscape:window-x": 1912,
    "inkscape:window-y": -8,
    "inkscape:window-maximized": 1
}), h.createElement("metadata", {
    id: "metadata5"
}, h.createElement("rdf:RDF", null, h.createElement("cc:Work", {
    "rdf:about": ""
}, h.createElement("dc:format", null, "image/svg+xml"), h.createElement("dc:type", {
    "rdf:resource": "http://purl.org/dc/dcmitype/StillImage"
}), h.createElement("dc:title", null)))), h.createElement("g", {
    "inkscape:groupmode": "layer",
    id: "layer2",
    "inkscape:label": "Capa 2",
    style: {
        opacity: 1
    }
}, h.createElement("path", {
    id: "rect862",
    style: {
        fill: "#1b64b6",
        fillOpacity: 1,
        fillRule: "evenodd",
        strokeWidth: 6.46864,
        strokeLinecap: "square",
        paintOrder: "markers fill stroke"
    },
    d: "M 7.9243621,0.40426573 H 162.081 c 4.29879,0 7.75955,3.45686397 7.75955,7.75081597 V 36.958129 c 0,4.293952 -3.46076,7.750816 -7.75955,7.750816 H 7.9243621 c -4.29883,0 -7.75961003,-3.456864 -7.75961003,-7.750816 V 8.1550817 c 0,-4.293952 3.46078003,-7.75081597 7.75961003,-7.75081597 z"
}), h.createElement("rect", {
    style: {
        fill: "#2179d2",
        fillOpacity: 1,
        fillRule: "evenodd",
        stroke: "none",
        strokeWidth: 6.46499,
        strokeLinecap: "square",
        paintOrder: "markers fill stroke"
    },
    id: "rect865",
    width: 53.482864,
    height: 47.625,
    x: .21232992,
    y: 30.049105,
    ry: 0
}), h.createElement("rect", {
    style: {
        fill: "#5edafe",
        fillOpacity: 1,
        fillRule: "evenodd",
        strokeWidth: 6.46499,
        strokeLinecap: "square",
        paintOrder: "markers fill stroke"
    },
    id: "rect865-6",
    width: 53.483627,
    height: 47.625,
    x: 116.33598,
    y: 30.049105,
    ry: 0
}), h.createElement("rect", {
    style: {
        fill: "#3ca8e8",
        fillOpacity: 1,
        fillRule: "evenodd",
        strokeWidth: 6.99654,
        strokeLinecap: "square",
        paintOrder: "markers fill stroke"
    },
    id: "rect865-5",
    width: 62.640022,
    height: 47.625,
    x: 53.695198,
    y: 30.049105,
    ry: 0
}), h.createElement("rect", {
    style: {
        fill: "#1b64b6",
        fillOpacity: 1,
        fillRule: "evenodd",
        strokeWidth: 6.46499,
        strokeLinecap: "square",
        paintOrder: "markers fill stroke"
    },
    id: "rect865-1",
    width: 53.483627,
    height: 47.625,
    x: .21232992,
    y: 77.674103,
    ry: 0
}), h.createElement("rect", {
    style: {
        fill: "#3ca8e8",
        fillOpacity: 1,
        fillRule: "evenodd",
        strokeWidth: 6.46499,
        strokeLinecap: "square",
        paintOrder: "markers fill stroke"
    },
    id: "rect865-6-7",
    width: 53.483627,
    height: 47.625,
    x: 116.33598,
    y: 77.674103,
    ry: 0
}), h.createElement("rect", {
    style: {
        fill: "#2179d2",
        fillOpacity: 1,
        fillRule: "evenodd",
        strokeWidth: 6.99654,
        strokeLinecap: "square",
        paintOrder: "markers fill stroke"
    },
    id: "rect865-5-7",
    width: 62.640022,
    height: 47.625,
    x: 53.695198,
    y: 77.674103,
    ry: 0
}), h.createElement("rect", {
    style: {
        fill: "#154a8a",
        fillOpacity: 1,
        fillRule: "evenodd",
        strokeWidth: 6.46499,
        strokeLinecap: "square",
        paintOrder: "markers fill stroke"
    },
    id: "rect865-1-1",
    width: 53.483627,
    height: 47.625,
    x: .21232992,
    y: 125.29911,
    ry: 7.7508163
}), h.createElement("rect", {
    style: {
        fill: "#1b64b6",
        fillOpacity: 1,
        fillRule: "evenodd",
        strokeWidth: 6.99654,
        strokeLinecap: "square",
        paintOrder: "markers fill stroke"
    },
    id: "rect865-5-7-8",
    width: 62.639313,
    height: 47.624989,
    x: 53.695961,
    y: 125.29911,
    ry: 0
}), h.createElement("rect", {
    style: {
        fill: "#2179d2",
        fillOpacity: 1,
        fillRule: "evenodd",
        strokeWidth: 6.46499,
        strokeLinecap: "square",
        paintOrder: "markers fill stroke"
    },
    id: "rect865-1-1-4",
    width: 53.483627,
    height: 47.625,
    x: 116.33598,
    y: 125.29911,
    ry: 7.7508163
}), h.createElement("path", {
    style: {
        fill: "#154a8a",
        fillOpacity: 1,
        stroke: "none",
        strokeWidth: "0.264583px",
        strokeLinecap: "butt",
        strokeLinejoin: "miter",
        strokeOpacity: 1
    },
    d: "m 0.21378207,125.2991 53.48140993,1e-5 0.003,47.62499 H 8.4247021 l -8.21573003,-8.21568 z",
    id: "path1012",
    "sodipodi:nodetypes": "cccccc"
}), h.createElement("path", {
    style: {
        fill: "#2179d2",
        fillOpacity: 1,
        stroke: "none",
        strokeWidth: "0.264583px",
        strokeLinecap: "butt",
        strokeLinejoin: "miter",
        strokeOpacity: 1
    },
    d: "m 169.82154,125.29911 h -53.48556 l 0.002,47.625 h 45.27325 l 8.21568,-8.21568 z",
    id: "path1012-9",
    "sodipodi:nodetypes": "cccccc"
})))
  , IB = e => h.createElement("svg", {
    width: 20,
    height: 20,
    viewBox: "0 0 20 20",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ...e
}, h.createElement("path", {
    d: "M7.82373 7.35312L7.82391 7.35249L11.6726 9.65779L13.9659 8.6927C14.4319 8.49124 14.9344 8.38793 15.4421 8.38843C15.5267 8.38843 15.6103 8.39227 15.6935 8.39782C15.4178 7.32269 14.8357 6.35079 14.0181 5.60023C13.2004 4.84966 12.1823 4.35275 11.0876 4.16987C9.99283 3.98699 8.86853 4.12601 7.8513 4.57005C6.83408 5.01409 5.96772 5.74403 5.35751 6.67115C5.37712 6.67091 5.39643 6.66968 5.41608 6.66968C6.26666 6.66852 7.10061 6.90525 7.82373 7.35312Z",
    fill: "#0364B8"
}), h.createElement("path", {
    d: "M7.82449 7.3525L7.82431 7.35313C7.10119 6.90526 6.26724 6.66853 5.41666 6.66968C5.39701 6.66968 5.37767 6.67091 5.35809 6.67116C4.52559 6.68147 3.71163 6.91843 3.00368 7.35659C2.29574 7.79475 1.72058 8.41754 1.34 9.15804C0.959422 9.89853 0.787821 10.7287 0.843637 11.5594C0.899452 12.3901 1.18057 13.1899 1.65679 13.8728L5.05075 12.4446L6.55948 11.8097L9.91879 10.396L11.6731 9.65779L7.82449 7.3525Z",
    fill: "#0078D4"
}), h.createElement("path", {
    d: "M15.6938 8.39782C15.6106 8.39227 15.527 8.38843 15.4424 8.38843C14.9347 8.38793 14.4323 8.49163 13.9663 8.6931L11.6728 9.65779L12.3378 10.0561L14.5178 11.3619L15.4688 11.9316L18.7209 13.8795C19.0164 13.331 19.1695 12.717 19.1663 12.0939C19.163 11.4709 19.0035 10.8586 18.7023 10.3131C18.4011 9.76768 17.9678 9.30653 17.4422 8.97191C16.9166 8.63729 16.3154 8.4399 15.6938 8.39782Z",
    fill: "#1490DF"
}), h.createElement("path", {
    d: "M15.4693 11.9315L14.5182 11.3618L12.3383 10.0561L11.6732 9.65771L9.9189 10.396L6.55959 11.8096L5.05086 12.4445L1.6569 13.8727C2.07866 14.4791 2.64091 14.9744 3.29564 15.3163C3.95037 15.6583 4.67813 15.8367 5.41676 15.8363H15.4428C16.115 15.8365 16.7748 15.6547 17.352 15.3101C17.9292 14.9656 18.4024 14.4712 18.7213 13.8794L15.4693 11.9315Z",
    fill: "#28A8EA"
}))
  , Bhe = e => h.createElement("svg", {
    id: "Livello_1",
    "xmlns:x": "http://ns.adobe.com/Extensibility/1.0/",
    "xmlns:i": "http://ns.adobe.com/AdobeIllustrator/10.0/",
    "xmlns:graph": "http://ns.adobe.com/Graphs/1.0/",
    xmlns: "http://www.w3.org/2000/svg",
    xmlnsXlink: "http://www.w3.org/1999/xlink",
    x: "0px",
    y: "0px",
    viewBox: "0 0 1831.085 1703.335",
    enableBackground: "new 0 0 1831.085 1703.335",
    xmlSpace: "preserve",
    ...e
}, h.createElement("path", {
    fill: "#0A2767",
    d: "M1831.083,894.25c0.1-14.318-7.298-27.644-19.503-35.131h-0.213l-0.767-0.426l-634.492-375.585  c-2.74-1.851-5.583-3.543-8.517-5.067c-24.498-12.639-53.599-12.639-78.098,0c-2.934,1.525-5.777,3.216-8.517,5.067L446.486,858.693  l-0.766,0.426c-19.392,12.059-25.337,37.556-13.278,56.948c3.553,5.714,8.447,10.474,14.257,13.868l634.492,375.585  c2.749,1.835,5.592,3.527,8.517,5.068c24.498,12.639,53.599,12.639,78.098,0c2.925-1.541,5.767-3.232,8.517-5.068l634.492-375.585  C1823.49,922.545,1831.228,908.923,1831.083,894.25z"
}), h.createElement("path", {
    fill: "#0364B8",
    d: "M520.453,643.477h416.38v381.674h-416.38V643.477z M1745.917,255.5V80.908  c1-43.652-33.552-79.862-77.203-80.908H588.204C544.552,1.046,510,37.256,511,80.908V255.5l638.75,170.333L1745.917,255.5z"
}), h.createElement("path", {
    fill: "#0078D4",
    d: "M511,255.5h425.833v383.25H511V255.5z"
}), h.createElement("path", {
    fill: "#28A8EA",
    d: "M1362.667,255.5H936.833v383.25L1362.667,1022h383.25V638.75L1362.667,255.5z"
}), h.createElement("path", {
    fill: "#0078D4",
    d: "M936.833,638.75h425.833V1022H936.833V638.75z"
}), h.createElement("path", {
    fill: "#0364B8",
    d: "M936.833,1022h425.833v383.25H936.833V1022z"
}), h.createElement("path", {
    fill: "#14447D",
    d: "M520.453,1025.151h416.38v346.969h-416.38V1025.151z"
}), h.createElement("path", {
    fill: "#0078D4",
    d: "M1362.667,1022h383.25v383.25h-383.25V1022z"
}), h.createElement("linearGradient", {
    id: "SVGID_1_",
    gradientUnits: "userSpaceOnUse",
    x1: 1128.4584,
    y1: 811.0833,
    x2: 1128.4584,
    y2: 1.9982,
    gradientTransform: "matrix(1 0 0 -1 0 1705.3334)"
}, h.createElement("stop", {
    offset: 0,
    style: {
        stopColor: "#35b8f1"
    }
}), h.createElement("stop", {
    offset: 1,
    style: {
        stopColor: "#28a8ea"
    }
})), h.createElement("path", {
    fill: "url(#SVGID_1_)",
    d: "M1811.58,927.593l-0.809,0.426l-634.492,356.848c-2.768,1.703-5.578,3.321-8.517,4.769  c-10.777,5.132-22.481,8.029-34.407,8.517l-34.663-20.27c-2.929-1.47-5.773-3.105-8.517-4.897L447.167,906.003h-0.298  l-21.036-11.753v722.384c0.328,48.196,39.653,87.006,87.849,86.7h1230.914c0.724,0,1.363-0.341,2.129-0.341  c10.18-0.651,20.216-2.745,29.808-6.217c4.145-1.756,8.146-3.835,11.966-6.217c2.853-1.618,7.75-5.152,7.75-5.152  c21.814-16.142,34.726-41.635,34.833-68.772V894.25C1831.068,908.067,1823.616,920.807,1811.58,927.593z"
}), h.createElement("path", {
    opacity: .5,
    fill: "#0A2767",
    enableBackground: "new    ",
    d: "M1797.017,891.397v44.287l-663.448,456.791L446.699,906.301  c0-0.235-0.191-0.426-0.426-0.426l0,0l-63.023-37.899v-31.938l25.976-0.426l54.932,31.512l1.277,0.426l4.684,2.981  c0,0,645.563,368.346,647.267,369.197l24.698,14.478c2.129-0.852,4.258-1.703,6.813-2.555  c1.278-0.852,640.879-360.681,640.879-360.681L1797.017,891.397z"
}), h.createElement("path", {
    fill: "#1490DF",
    d: "M1811.58,927.593l-0.809,0.468l-634.492,356.848c-2.768,1.703-5.578,3.321-8.517,4.769  c-24.641,12.038-53.457,12.038-78.098,0c-2.918-1.445-5.76-3.037-8.517-4.769L446.657,928.061l-0.766-0.468  c-12.25-6.642-19.93-19.409-20.057-33.343v722.384c0.305,48.188,39.616,87.004,87.803,86.7c0.001,0,0.002,0,0.004,0h1229.636  c48.188,0.307,87.5-38.509,87.807-86.696c0-0.001,0-0.002,0-0.004V894.25C1831.068,908.067,1823.616,920.807,1811.58,927.593z"
}), h.createElement("path", {
    opacity: .1,
    enableBackground: "new    ",
    d: "M1185.52,1279.629l-9.496,5.323c-2.752,1.752-5.595,3.359-8.517,4.812  c-10.462,5.135-21.838,8.146-33.47,8.857l241.405,285.479l421.107,101.476c11.539-8.716,20.717-20.178,26.7-33.343L1185.52,1279.629  z"
}), h.createElement("path", {
    opacity: .05,
    enableBackground: "new    ",
    d: "M1228.529,1255.442l-52.505,29.51c-2.752,1.752-5.595,3.359-8.517,4.812  c-10.462,5.135-21.838,8.146-33.47,8.857l113.101,311.838l549.538,74.989c21.649-16.254,34.394-41.743,34.407-68.815v-9.326  L1228.529,1255.442z"
}), h.createElement("path", {
    fill: "#28A8EA",
    d: "M514.833,1703.333h1228.316c18.901,0.096,37.335-5.874,52.59-17.033l-697.089-408.331  c-2.929-1.47-5.773-3.105-8.517-4.897L447.125,906.088h-0.298l-20.993-11.838v719.914  C425.786,1663.364,465.632,1703.286,514.833,1703.333C514.832,1703.333,514.832,1703.333,514.833,1703.333z"
}), h.createElement("path", {
    opacity: .1,
    enableBackground: "new    ",
    d: "M1022,418.722v908.303c-0.076,31.846-19.44,60.471-48.971,72.392  c-9.148,3.931-19,5.96-28.957,5.962H425.833V383.25H511v-42.583h433.073C987.092,340.83,1021.907,375.702,1022,418.722z"
}), h.createElement("path", {
    opacity: .2,
    enableBackground: "new    ",
    d: "M979.417,461.305v908.302c0.107,10.287-2.074,20.469-6.388,29.808  c-11.826,29.149-40.083,48.273-71.54,48.417H425.833V383.25h475.656c12.356-0.124,24.533,2.958,35.344,8.943  C962.937,405.344,979.407,432.076,979.417,461.305z"
}), h.createElement("path", {
    opacity: .2,
    enableBackground: "new    ",
    d: "M979.417,461.305v823.136c-0.208,43-34.928,77.853-77.927,78.225H425.833V383.25  h475.656c12.356-0.124,24.533,2.958,35.344,8.943C962.937,405.344,979.407,432.076,979.417,461.305z"
}), h.createElement("path", {
    opacity: .2,
    enableBackground: "new    ",
    d: "M936.833,461.305v823.136c-0.046,43.067-34.861,78.015-77.927,78.225H425.833  V383.25h433.072c43.062,0.023,77.951,34.951,77.927,78.013C936.833,461.277,936.833,461.291,936.833,461.305z"
}), h.createElement("linearGradient", {
    id: "SVGID_2_",
    gradientUnits: "userSpaceOnUse",
    x1: 162.7469,
    y1: 1383.0741,
    x2: 774.0864,
    y2: 324.2592,
    gradientTransform: "matrix(1 0 0 -1 0 1705.3334)"
}, h.createElement("stop", {
    offset: 0,
    style: {
        stopColor: "#1784d9"
    }
}), h.createElement("stop", {
    offset: .5,
    style: {
        stopColor: "#107ad5"
    }
}), h.createElement("stop", {
    offset: 1,
    style: {
        stopColor: "#0a63c9"
    }
})), h.createElement("path", {
    fill: "url(#SVGID_2_)",
    d: "M78.055,383.25h780.723c43.109,0,78.055,34.947,78.055,78.055v780.723  c0,43.109-34.946,78.055-78.055,78.055H78.055c-43.109,0-78.055-34.947-78.055-78.055V461.305  C0,418.197,34.947,383.25,78.055,383.25z"
}), h.createElement("path", {
    fill: "#FFFFFF",
    d: "M243.96,710.631c19.238-40.988,50.29-75.289,89.17-98.495c43.057-24.651,92.081-36.94,141.675-35.515  c45.965-0.997,91.321,10.655,131.114,33.683c37.414,22.312,67.547,55.004,86.742,94.109c20.904,43.09,31.322,90.512,30.405,138.396  c1.013,50.043-9.706,99.628-31.299,144.783c-19.652,40.503-50.741,74.36-89.425,97.388c-41.327,23.734-88.367,35.692-136.011,34.578  c-46.947,1.133-93.303-10.651-134.01-34.067c-37.738-22.341-68.249-55.07-87.892-94.28c-21.028-42.467-31.57-89.355-30.745-136.735  C212.808,804.859,223.158,755.686,243.96,710.631z M339.006,941.858c10.257,25.912,27.651,48.385,50.163,64.812  c22.93,16.026,50.387,24.294,78.353,23.591c29.783,1.178,59.14-7.372,83.634-24.358c22.227-16.375,39.164-38.909,48.715-64.812  c10.677-28.928,15.946-59.572,15.543-90.404c0.33-31.127-4.623-62.084-14.649-91.554c-8.855-26.607-25.246-50.069-47.182-67.537  c-23.88-17.79-53.158-26.813-82.91-25.55c-28.572-0.74-56.644,7.593-80.184,23.804c-22.893,16.496-40.617,39.168-51.1,65.365  c-23.255,60.049-23.376,126.595-0.341,186.728L339.006,941.858z"
}), h.createElement("path", {
    fill: "#50D9FF",
    d: "M1362.667,255.5h383.25v383.25h-383.25V255.5z"
}))
  , qhe = e => h.createElement("svg", {
    width: 24,
    height: 24,
    viewBox: "0 0 24 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ...e
}, h.createElement("g", {
    clipPath: "url(#clip0_5645_179)"
}, h.createElement("path", {
    d: "M15.5719 9.75H20.57C21.0422 9.75 21.425 10.1328 21.425 10.605V15.1576C21.425 16.8931 20.0181 18.3 18.2827 18.3H18.2678C16.5323 18.3002 15.1253 16.8936 15.125 15.1581C15.125 15.1579 15.125 15.1578 15.125 15.1576V10.1969C15.125 9.95006 15.3251 9.75 15.5719 9.75Z",
    fill: "#5059C9"
}), h.createElement("path", {
    d: "M18.9498 8.84999C20.0682 8.84999 20.9748 7.94336 20.9748 6.82499C20.9748 5.70661 20.0682 4.79999 18.9498 4.79999C17.8314 4.79999 16.9248 5.70661 16.9248 6.82499C16.9248 7.94336 17.8314 8.84999 18.9498 8.84999Z",
    fill: "#5059C9"
}), h.createElement("path", {
    d: "M12.6501 8.85001C14.2655 8.85001 15.5751 7.54044 15.5751 5.925C15.5751 4.30957 14.2655 3 12.6501 3C11.0347 3 9.7251 4.30957 9.7251 5.925C9.7251 7.54044 11.0347 8.85001 12.6501 8.85001Z",
    fill: "#7B83EB"
}), h.createElement("path", {
    d: "M16.5502 9.75H8.29988C7.8333 9.76155 7.46421 10.1488 7.47503 10.6154V15.8079C7.40988 18.6079 9.62511 20.9315 12.425 21C15.225 20.9315 17.4402 18.6079 17.375 15.8079V10.6154C17.3859 10.1488 17.0168 9.76155 16.5502 9.75Z",
    fill: "#7B83EB"
}), h.createElement("path", {
    opacity: .1,
    d: "M12.8749 9.75V17.0265C12.8726 17.3602 12.6704 17.66 12.3619 17.787C12.2636 17.8286 12.158 17.85 12.0514 17.85H7.87085C7.81235 17.7015 7.75835 17.553 7.71334 17.4C7.55582 16.8836 7.47545 16.3469 7.47484 15.807V10.614C7.46402 10.1482 7.83251 9.76155 8.29834 9.75H12.8749Z",
    fill: "currentColor"
}), h.createElement("path", {
    opacity: .2,
    d: "M12.4249 9.75V17.4765C12.4248 17.5832 12.4034 17.6888 12.3619 17.787C12.2348 18.0956 11.935 18.2978 11.6014 18.3H8.08235C8.00585 18.1515 7.93385 18.003 7.87085 17.85C7.80784 17.697 7.75835 17.553 7.71334 17.4C7.55582 16.8837 7.47545 16.3469 7.47484 15.807V10.614C7.46402 10.1482 7.83251 9.76155 8.29834 9.75H12.4249Z",
    fill: "currentColor"
}), h.createElement("path", {
    opacity: .2,
    d: "M12.4248 9.75V16.5765C12.4214 17.0299 12.0547 17.3966 11.6013 17.4H7.71334C7.55582 16.8837 7.47545 16.3469 7.47484 15.807V10.614C7.46402 10.1482 7.83251 9.76155 8.29834 9.75H12.4248Z",
    fill: "currentColor"
}), h.createElement("path", {
    opacity: .2,
    d: "M11.9748 9.75V16.5765C11.9714 17.0299 11.6047 17.3966 11.1513 17.4H7.71334C7.55582 16.8837 7.47545 16.3469 7.47484 15.807V10.614C7.46402 10.1482 7.83251 9.76155 8.29834 9.75H11.9748Z",
    fill: "currentColor"
}), h.createElement("path", {
    opacity: .1,
    d: "M12.8747 7.4235V8.841C12.7982 8.84549 12.7262 8.85 12.6497 8.85C12.5732 8.85 12.5012 8.8455 12.4247 8.841C12.2728 8.83092 12.1221 8.80682 11.9747 8.769C11.0634 8.5532 10.3106 7.91412 9.94967 7.05C9.88757 6.90489 9.83936 6.75421 9.80566 6.60001H12.0512C12.5053 6.60173 12.8729 6.9694 12.8747 7.4235Z",
    fill: "currentColor"
}), h.createElement("path", {
    opacity: .2,
    d: "M12.4252 7.87348V8.84098C12.2733 8.8309 12.1227 8.8068 11.9752 8.76899C11.0639 8.55318 10.3111 7.91411 9.9502 7.04999H11.6017C12.0558 7.05171 12.4235 7.41939 12.4252 7.87348Z",
    fill: "currentColor"
}), h.createElement("path", {
    opacity: .2,
    d: "M12.4252 7.87348V8.84098C12.2733 8.8309 12.1227 8.8068 11.9752 8.76899C11.0639 8.55318 10.3111 7.91411 9.9502 7.04999H11.6017C12.0558 7.05171 12.4235 7.41939 12.4252 7.87348Z",
    fill: "currentColor"
}), h.createElement("path", {
    opacity: .2,
    d: "M11.9752 7.87349V8.76899C11.0639 8.55318 10.3111 7.91411 9.9502 7.04999H11.1517C11.6058 7.05172 11.9735 7.4194 11.9752 7.87349Z",
    fill: "currentColor"
}), h.createElement("path", {
    d: "M2.90004 7.04999H11.1503C11.6059 7.04999 11.9752 7.41929 11.9752 7.87483V16.1251C11.9752 16.5807 11.6059 16.95 11.1503 16.95H2.90004C2.44449 16.95 2.0752 16.5807 2.0752 16.1251V7.87483C2.0752 7.41929 2.4445 7.04999 2.90004 7.04999Z",
    fill: "url(#paint0_linear_5645_179)"
}), h.createElement("path", {
    d: "M9.1956 10.1901H7.54635V14.6811H6.4956V10.1901H4.854V9.31891H9.1956V10.1901Z",
    fill: "white"
})), h.createElement("defs", null, h.createElement("linearGradient", {
    id: "paint0_linear_5645_179",
    x1: 3.79503,
    y1: 6.40547,
    x2: 10.2554,
    y2: 17.5945,
    gradientUnits: "userSpaceOnUse"
}, h.createElement("stop", {
    stopColor: "#5A62C3"
}), h.createElement("stop", {
    offset: .5,
    stopColor: "#4D55BD"
}), h.createElement("stop", {
    offset: 1,
    stopColor: "#3940AB"
})), h.createElement("clipPath", {
    id: "clip0_5645_179"
}, h.createElement("rect", {
    width: 19.35,
    height: 18,
    fill: "white",
    transform: "translate(2.0752 3)"
}))))
  , a4 = e => h.createElement("svg", {
    width: 24,
    height: 24,
    viewBox: "0 0 24 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ...e
}, h.createElement("path", {
    d: "M6.1039 5.90972C6.68754 6.38386 6.90648 6.34768 8.00238 6.27457L18.3342 5.65418C18.5534 5.65418 18.3711 5.43557 18.2981 5.39924L16.5822 4.15879C16.2534 3.90354 15.8153 3.61122 14.9758 3.68434L4.9715 4.41403C4.60665 4.45021 4.53377 4.63262 4.67909 4.77886L6.1039 5.90972ZM6.72422 8.31752V19.1884C6.72422 19.7726 7.01618 19.9912 7.6733 19.955L19.028 19.298C19.6854 19.2619 19.7586 18.86 19.7586 18.3854V7.58753C19.7586 7.1137 19.5763 6.85816 19.1739 6.89464L7.30815 7.58753C6.87027 7.62433 6.72422 7.84337 6.72422 8.31752ZM17.9335 8.90066C18.0063 9.22933 17.9335 9.55768 17.6043 9.5946L17.0571 9.70361V17.7292C16.5822 17.9845 16.1441 18.1304 15.7791 18.1304C15.1947 18.1304 15.0484 17.9479 14.6107 17.401L11.0321 11.783V17.2186L12.1645 17.4741C12.1645 17.4741 12.1645 18.1304 11.2509 18.1304L8.73222 18.2765C8.65905 18.1304 8.73222 17.7659 8.98769 17.6929L9.64494 17.5108V10.324L8.73237 10.2509C8.6592 9.92222 8.84146 9.44837 9.35298 9.41159L12.0549 9.22946L15.7791 14.9205V9.88603L14.8296 9.77704C14.7567 9.37526 15.0484 9.08353 15.4135 9.04735L17.9335 8.90066ZM4.13151 3.4291L14.5376 2.66279C15.8155 2.55318 16.1443 2.6266 16.9475 3.21005L20.2692 5.54473C20.8173 5.9462 21 6.05551 21 6.49316V19.298C21 20.1005 20.7077 20.5751 19.6856 20.6477L7.60101 21.3775C6.83376 21.4141 6.4686 21.3047 6.0668 20.7937L3.6206 17.6199C3.18227 17.0357 3 16.5986 3 16.0873V4.70545C3 4.04918 3.29242 3.50177 4.13151 3.4291Z",
    fill: "currentColor"
}))
  , F1 = e => h.createElement("svg", {
    width: 24,
    height: 24,
    viewBox: "0 0 24 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ...e
}, h.createElement("path", {
    d: "M6.21613 14.6433C6.21613 15.8058 5.27738 16.7453 4.11588 16.7453C2.95437 16.7453 2.01562 15.8058 2.01562 14.6433C2.01562 13.4809 2.95437 12.5414 4.11588 12.5414H6.21613V14.6433ZM7.26625 14.6433C7.26625 13.4809 8.205 12.5414 9.3665 12.5414C10.528 12.5414 11.4668 13.4809 11.4668 14.6433V19.8982C11.4668 21.0606 10.528 22.0001 9.3665 22.0001C8.205 22.0001 7.26625 21.0606 7.26625 19.8982V14.6433Z",
    fill: "#E01E5A"
}), h.createElement("path", {
    d: "M9.36679 6.20386C8.20529 6.20386 7.26654 5.26436 7.26654 4.10193C7.26654 2.9395 8.20529 2 9.36679 2C10.5283 2 11.467 2.9395 11.467 4.10193V6.20386H9.36679ZM9.36679 7.27074C10.5283 7.27074 11.467 8.21024 11.467 9.37267C11.467 10.5351 10.5283 11.4746 9.36679 11.4746H4.10025C2.93875 11.4746 2 10.5351 2 9.37267C2 8.21024 2.93875 7.27074 4.10025 7.27074H9.36679Z",
    fill: "#36C5F0"
}), h.createElement("path", {
    d: "M17.7838 9.37267C17.7838 8.21024 18.7226 7.27074 19.8841 7.27074C21.0456 7.27074 21.9843 8.21024 21.9843 9.37267C21.9843 10.5351 21.0456 11.4746 19.8841 11.4746H17.7838V9.37267ZM16.7337 9.37267C16.7337 10.5351 15.795 11.4746 14.6335 11.4746C13.472 11.4746 12.5332 10.5351 12.5332 9.37267V4.10193C12.5332 2.9395 13.472 2 14.6335 2C15.795 2 16.7337 2.9395 16.7337 4.10193V9.37267Z",
    fill: "#2EB67D"
}), h.createElement("path", {
    d: "M14.6335 17.7962C15.795 17.7962 16.7337 18.7357 16.7337 19.8982C16.7337 21.0606 15.795 22.0001 14.6335 22.0001C13.472 22.0001 12.5332 21.0606 12.5332 19.8982V17.7962H14.6335ZM14.6335 16.7453C13.472 16.7453 12.5332 15.8058 12.5332 14.6433C12.5332 13.4809 13.472 12.5414 14.6335 12.5414H19.9C21.0615 12.5414 22.0002 13.4809 22.0002 14.6433C22.0002 15.8058 21.0615 16.7453 19.9 16.7453H14.6335Z",
    fill: "#ECB22E"
}));
var sr = (e => (e.CODEX = "CODEX",
e.PROMPT_TEXT_AREA = "PROMPT_TEXT_AREA",
e.CONNECTOR_SETTING = "CONNECTOR_SETTING",
e.ADMIN_SETTING = "ADMIN_SETTING",
e.SLURM = "SLURM",
e.DEEP_RESEARCH = "DEEP_RESEARCH",
e.JIT_PLUGIN = "JIT_PLUGIN",
e.N7JUPD = "N7JUPD",
e))(sr || {});
const Ghe = xt({
    github: {
        id: "platformConnectors.github",
        defaultMessage: "GitHub"
    },
    hubspot: {
        id: "platformConnectors.hubspot",
        defaultMessage: "HubSpot"
    },
    googleDrive: {
        id: "platformConnectors.googleDrive",
        defaultMessage: "Google Drive"
    },
    gmail: {
        id: "platformConnectors.gmail",
        defaultMessage: "Gmail"
    },
    googleContacts: {
        id: "platformConnectors.googleContacts",
        defaultMessage: "Google Contacts"
    },
    gcal: {
        id: "platformConnectors.gcal",
        defaultMessage: "Google Calendar"
    },
    dropbox: {
        id: "platformConnectors.dropbox",
        defaultMessage: "Dropbox"
    },
    linear: {
        id: "platformConnectors.linear",
        defaultMessage: "Linear"
    },
    sharepoint: {
        id: "platformConnectors.sharepoint",
        defaultMessage: "SharePoint"
    },
    outlookEmail: {
        id: "GJeJu+",
        defaultMessage: "Outlook Email"
    },
    outlookCalendar: {
        id: "ZaCgzD",
        defaultMessage: "Outlook Calendar"
    },
    teams: {
        id: "1F0GKN",
        defaultMessage: "Teams"
    },
    box: {
        id: "l5cshA",
        defaultMessage: "Box"
    },
    intercom: {
        id: "IeKzI2",
        defaultMessage: "Intercom"
    },
    notion: {
        id: "ewTDRt",
        defaultMessage: "Notion"
    },
    canva: {
        id: "2oFmyl",
        defaultMessage: "Canva"
    },
    slack: {
        id: "Do199+",
        defaultMessage: "Slack"
    },
    disabledByAdmin: {
        id: "2+q1p8",
        defaultMessage: "Your admin has not enabled this connector."
    }
})
  , Vhe = {}
  , Kn = {
    ...Ghe,
    ...Vhe
}
  , Pke = {
    [U.GITHUB_CONNECTOR]: {
        title: Kn.github,
        icon: MB
    },
    [U.GDRIVE_ACTION_CONNECTOR]: {
        title: Kn.googleDrive,
        icon: td
    },
    [U.DROPBOX_CONNECTOR]: {
        title: Kn.dropbox,
        icon: Rhe
    },
    [U.HUBSPOT_CONNECTOR]: {
        title: Kn.hubspot,
        icon: Lhe
    },
    [U.LINEAR_CONNECTOR]: {
        title: Kn.linear,
        icon: jhe
    },
    [U.SHAREPOINT_CONNECTOR]: {
        title: Kn.sharepoint,
        icon: IB
    },
    [U.TEAMS_CONNECTOR]: {
        title: Kn.teams,
        icon: qhe
    },
    [U.OUTLOOK_EMAIL_CONNECTOR]: {
        title: Kn.outlookEmail,
        icon: Bhe
    },
    [U.OUTLOOK_CALENDAR_CONNECTOR]: {
        title: Kn.outlookCalendar,
        icon: Uhe
    },
    [U.BOX_CONNECTOR]: {
        title: Kn.box,
        icon: Mhe
    },
    [U.INTERCOM_CONNECTOR]: {
        title: Kn.intercom,
        icon: Fhe
    },
    [U.NOTION_CONNECTOR]: {
        title: Kn.notion,
        icon: a4
    },
    [U.GOOGLE_CONTACTS_CONNECTOR]: {
        title: Kn.googleContacts,
        icon: Dhe
    },
    [U.GCAL_CONNECTOR]: {
        title: Kn.gcal,
        icon: Phe
    },
    [U.GMAIL_CONNECTOR]: {
        title: Kn.gmail,
        icon: Nhe
    },
    [U.CANVA_CONNECTOR]: {
        title: Kn.canva,
        icon: Ihe
    },
    [U.SLACK_CONNECTOR]: {
        title: Kn.slack,
        icon: F1
    }
}
  , Hhe = {
    github: U.GITHUB_CONNECTOR,
    google_drive: U.GDRIVE_ACTION_CONNECTOR,
    dropbox: U.DROPBOX_CONNECTOR,
    linear: U.LINEAR_CONNECTOR,
    hubspot: U.HUBSPOT_CONNECTOR,
    sharepoint: U.SHAREPOINT_CONNECTOR,
    google_calendar: U.GCAL_CONNECTOR,
    gmail: U.GMAIL_CONNECTOR,
    google_contacts: U.GOOGLE_CONTACTS_CONNECTOR,
    teams: U.TEAMS_CONNECTOR,
    outlook_email: U.OUTLOOK_EMAIL_CONNECTOR,
    outlook_calendar: U.OUTLOOK_CALENDAR_CONNECTOR,
    box: U.BOX_CONNECTOR,
    intercom: U.INTERCOM_CONNECTOR,
    notion: U.NOTION_CONNECTOR,
    canva: U.CANVA_CONNECTOR,
    slack: U.SLACK_CONNECTOR
}
  , j1 = ({enabled: e=!0, includeDisabledByAdmin: t=!1, productSku: n, purpose: r=void 0}={}) => {
    const {platformConnectors: s, isLoading: o} = bh(e, n, r);
    return {
        availableConnectors: h.useMemo( () => {
            const a = Array.from(s.values())
              , l = a.filter(u => u.connector_type !== "MCP").map(u => ({
                ...u,
                type: fh[u.id]
            }))
              , c = a.filter(u => u.connector_type === "MCP").map(u => ({
                ...u,
                type: th.MCP_CONNECTOR
            }));
            return [...l, ...c].filter(u => !!u.type && (t || u.status !== "DISABLED_BY_ADMIN"))
        }
        , [s, t, n, r]),
        isLoading: o
    }
}
  , zhe = () => {
    const e = ue()
      , t = Vn(e, "3747383021")
      , n = Xe(e, "3544641259")
      , r = h.useMemo( () => {
        const s = Object.entries(Hhe).reduce( (i, [a,l]) => (t.get(a, !1) && i.push(l),
        i), []);
        return t.get("mcp", !1) ? [...s, th.MCP_CONNECTOR] : s
    }
    , [t]);
    return {
        enabled: n,
        availableConnectorsType: n ? r : []
    }
}
  , $he = () => {
    const e = ue();
    return Xe(e, "733205176")
}
  , Dke = () => {
    const e = ue();
    return Xe(e, "3207737252")
}
  , RB = ({getDisabledAutoConnectors: e=!1}) => {
    const t = ue()
      , n = Vn(t, "463092697")?.value
      , {data: r, isLoading: s} = AB(e)
      , o = n?.autoConnectors ?? [];
    if (s)
        return {
            allAutoConnectors: o,
            enabledAutoConnectors: [],
            disabledAutoConnectors: [],
            isLoading: !0
        };
    if (!e)
        return {
            allAutoConnectors: o,
            enabledAutoConnectors: [],
            disabledAutoConnectors: [],
            isLoading: !1
        };
    const {disabledTools: i=[]} = r ?? {}
      , a = i.map(tle).filter(c => c != null);
    a.includes(U.GMAIL_CONNECTOR) && a.includes(U.GCAL_CONNECTOR) && a.push(U.GOOGLE_CONTACTS_CONNECTOR);
    const l = o.filter(c => !a.includes(c));
    return {
        allAutoConnectors: o,
        enabledAutoConnectors: l,
        disabledAutoConnectors: a,
        isLoading: !1
    }
}
  , Whe = () => {
    const e = o4()
      , t = !!(e?.enabled ?? !1)
      , n = e?.autoConnectors ?? []
      , r = e?.enabledConnectors ?? [];
    return {
        enabled: t,
        availableConnectorsType: t ? r : [],
        autoConnectors: n
    }
}
  , Khe = () => ({
    enabled: !0,
    availableConnectorsType: []
})
  , Yhe = ({includeDisabledByAdmin: e}={}) => {
    const {enabled: t, availableConnectorsType: n} = zhe()
      , {availableConnectors: r, isLoading: s} = j1({
        enabled: t,
        includeDisabledByAdmin: e,
        productSku: sr.DEEP_RESEARCH
    })
      , o = h.useMemo( () => r.filter(i => n.includes(i.type)), [n, r]);
    return t ? {
        enabled: !0,
        availableConnectors: o,
        isLoading: s
    } : {
        enabled: !1,
        availableConnectors: [],
        isLoading: !1
    }
}
  , Lke = ({includeDisabledByAdmin: e}={}) => {
    const {enabled: t, availableConnectorsType: n} = Khe()
      , {availableConnectors: r, isLoading: s} = j1({
        enabled: t,
        includeDisabledByAdmin: e,
        productSku: sr.CODEX
    });
    return r.some(o => o.type === U.GITHUB_CONNECTOR) && n.includes(U.GITHUB_CONNECTOR) ? {
        enabled: !0,
        isLoading: s,
        availableConnectors: r.filter(o => o.type === U.GITHUB_CONNECTOR)
    } : {
        enabled: !1,
        availableConnectors: [],
        isLoading: !1
    }
}
  , l4 = ({includeDisabledByAdmin: e, includeAutoConnectors: t, filterDisabledAutoConnectors: n}={}) => {
    const r = Whe();
    let s = r.availableConnectorsType;
    const o = ue()
      , i = Xe(o, "2768222595")
      , {enabledAutoConnectors: a, allAutoConnectors: l, isLoading: c} = RB({
        getDisabledAutoConnectors: i && (r.autoConnectors ?? []).length > 0 && n
    })
      , u = i ? n ? a : l : []
      , d = r.enabled;
    t && (s = [...new Set([...s, ...u])]);
    const {availableConnectors: f, isLoading: p} = j1({
        enabled: d,
        includeDisabledByAdmin: e,
        productSku: sr.SLURM
    })
      , m = h.useMemo( () => s.flatMap(v => v === th.MCP_CONNECTOR ? f.filter(_ => _.type === v) : [f.find(_ => _.type === v)]).filter(v => !!v), [s, f]);
    return d ? {
        enabled: !0,
        availableConnectors: m,
        isLoading: c || p
    } : {
        enabled: !1,
        availableConnectors: [],
        isLoading: !1
    }
}
  , Fke = ({purpose: e=void 0}={}) => {
    const t = yh()
      , {availableConnectors: n, isLoading: r} = j1({
        enabled: t,
        includeDisabledByAdmin: !0,
        productSku: sr.CONNECTOR_SETTING,
        purpose: e
    });
    return {
        enabled: !!(n && n.length > 0),
        isLoading: r,
        availableConnectors: n ?? []
    }
}
  , NB = e => {
    "use forget";
    const t = De.c(17)
      , {availableConnectors: n, fetchValidLinksOnly: r, productSku: s} = e
      , o = r === void 0 ? !1 : r;
    let i;
    t[0] !== o || t[1] !== s ? (i = {
        fetchValidLinksOnly: o,
        productSku: s
    },
    t[0] = o,
    t[1] = s,
    t[2] = i) : i = t[2];
    const {connectorLinks: a, isLoading: l} = Vl(i);
    let c;
    t[3] !== a ? (c = new Set(Array.from(a.values()).flatMap(Qhe)),
    t[3] = a,
    t[4] = c) : c = t[4];
    const u = c;
    let d;
    if (t[5] !== n || t[6] !== u) {
        let v;
        t[8] !== u ? (v = _ => _.type !== th.MCP_CONNECTOR && u.has(_.type),
        t[8] = u,
        t[9] = v) : v = t[9],
        d = new Set(n.filter(v).map(epe)),
        t[5] = n,
        t[6] = u,
        t[7] = d
    } else
        d = t[7];
    const f = d;
    let p;
    t[10] !== n || t[11] !== a ? (p = new Map,
    a.forEach( (v, _) => {
        if (!n.some(b => b.id === _))
            return;
        const y = fh[_];
        y && v.forEach(b => {
            p.set(b.id, y)
        }
        )
    }
    ),
    t[10] = n,
    t[11] = a,
    t[12] = p) : p = t[12];
    let m;
    return t[13] !== f || t[14] !== l || t[15] !== p ? (m = {
        connectedTypes: f,
        isLoading: l,
        linkIdToConnectedType: p
    },
    t[13] = f,
    t[14] = l,
    t[15] = p,
    t[16] = m) : m = t[16],
    m
}
  , Zhe = e => {
    "use forget";
    const t = De.c(7);
    let n;
    t[0] !== e ? (n = e === void 0 ? {} : e,
    t[0] = e,
    t[1] = n) : n = t[1];
    const {enabled: r, includeAutoConnectors: s} = n
      , o = r === void 0 ? !0 : r
      , i = s === void 0 ? !1 : s;
    let a;
    t[2] !== i ? (a = {
        includeAutoConnectors: i
    },
    t[2] = i,
    t[3] = a) : a = t[3];
    const {enabled: l, availableConnectors: c} = l4(a)
      , u = l && o;
    let d;
    return t[4] !== c || t[5] !== u ? (d = {
        enabled: u,
        availableConnectors: c,
        productSku: sr.SLURM
    },
    t[4] = c,
    t[5] = u,
    t[6] = d) : d = t[6],
    NB(d)
}
  , jke = e => {
    "use forget";
    const t = De.c(5);
    let n;
    t[0] !== e ? (n = e === void 0 ? {} : e,
    t[0] = e,
    t[1] = n) : n = t[1];
    const {enabled: r} = n
      , s = r === void 0 ? !0 : r
      , {enabled: o, availableConnectors: i} = Yhe()
      , a = o && s;
    let l;
    return t[2] !== i || t[3] !== a ? (l = {
        enabled: a,
        availableConnectors: i,
        fetchValidLinksOnly: !0,
        productSku: sr.DEEP_RESEARCH
    },
    t[2] = i,
    t[3] = a,
    t[4] = l) : l = t[4],
    NB(l)
}
  , Jhe = () => !!o4()?.enablePopupRedirect
  , Uke = () => {
    const {connectedTypes: e, isLoading: t} = Zhe()
      , n = EB();
    if (t)
        return {
            anyConnectorEnabled: !1,
            anyAccessConnectorEnabled: !1,
            anySyncConnectorEnabled: !1,
            isLoading: !0
        };
    const r = e.size > 0
      , s = n ?? !1;
    return {
        anyConnectorEnabled: r || s,
        anyAccessConnectorEnabled: r,
        anySyncConnectorEnabled: s,
        isLoading: !1
    }
}
;
function Xhe(e) {
    return fh[e.connector_id]
}
function Qhe(e) {
    return e.map(Xhe)
}
function epe(e) {
    return e.type
}
function tpe(e, t) {
    let n = !1;
    return Na( () => n = !t() && (n || e()))
}
var _b, cO;
function npe() {
    if (cO)
        return _b;
    cO = 1;
    var e = fo()
      , t = function() {
        return e.Date.now()
    };
    return _b = t,
    _b
}
var yb, uO;
function PB() {
    if (uO)
        return yb;
    uO = 1;
    var e = Bo()
      , t = npe()
      , n = JL()
      , r = "Expected a function"
      , s = Math.max
      , o = Math.min;
    function i(a, l, c) {
        var u, d, f, p, m, v, _ = 0, y = !1, b = !1, S = !0;
        if (typeof a != "function")
            throw new TypeError(r);
        l = n(l) || 0,
        e(c) && (y = !!c.leading,
        b = "maxWait"in c,
        f = b ? s(n(c.maxWait) || 0, l) : f,
        S = "trailing"in c ? !!c.trailing : S);
        function C(I) {
            var R = u
              , D = d;
            return u = d = void 0,
            _ = I,
            p = a.apply(D, R),
            p
        }
        function w(I) {
            return _ = I,
            m = setTimeout(T, l),
            y ? C(I) : p
        }
        function x(I) {
            var R = I - v
              , D = I - _
              , P = l - R;
            return b ? o(P, f - D) : P
        }
        function E(I) {
            var R = I - v
              , D = I - _;
            return v === void 0 || R >= l || R < 0 || b && D >= f
        }
        function T() {
            var I = t();
            if (E(I))
                return k(I);
            m = setTimeout(T, x(I))
        }
        function k(I) {
            return m = void 0,
            S && u ? C(I) : (u = d = void 0,
            p)
        }
        function A() {
            m !== void 0 && clearTimeout(m),
            _ = 0,
            u = v = d = m = void 0
        }
        function O() {
            return m === void 0 ? p : k(t())
        }
        function M() {
            var I = t()
              , R = E(I);
            if (u = arguments,
            d = this,
            v = I,
            R) {
                if (m === void 0)
                    return w(v);
                if (b)
                    return clearTimeout(m),
                    m = setTimeout(T, l),
                    C(v)
            }
            return m === void 0 && (m = setTimeout(T, l)),
            p
        }
        return M.cancel = A,
        M.flush = O,
        M
    }
    return yb = i,
    yb
}
var rpe = PB();
const DB = mn(rpe);
var bb, dO;
function spe() {
    if (dO)
        return bb;
    dO = 1;
    var e = PB()
      , t = Bo()
      , n = "Expected a function";
    function r(s, o, i) {
        var a = !0
          , l = !0;
        if (typeof s != "function")
            throw new TypeError(n);
        return t(i) && (a = "leading"in i ? !!i.leading : a,
        l = "trailing"in i ? !!i.trailing : l),
        e(s, o, {
            leading: a,
            maxWait: o,
            trailing: l
        })
    }
    return bb = r,
    bb
}
var ope = spe();
const ipe = mn(ope)
  , Ba = DS("Composer")
  , ape = Ba( () => ({
    current: null
}));
function Nf(e) {
    if (!(e instanceof bU))
        throw new Error("ProseMirrorComposerController required");
    return e.view
}
const LB = Ba(e => Pa(t => Gw(Nf(e), ipe(t, 50)), () => Nf(e).state))
  , Bke = Ba(e => Na( () => LB(e)().doc.content.size, {
    getServerFallback: () => 0
}))
  , lpe = Ba(e => Na( () => {
    const t = LB(e);
    return gB(t().doc)
}
, {
    getServerFallback: () => !0
}))
  , cpe = Ba( () => Ct(!1))
  , qke = Ba(e => tpe(cpe(e), lpe(e)))
  , upe = Ba(e => Pa(t => jl(Nf(e).dom, {
    focus: t,
    blur: t
}), () => Nf(e).hasFocus(), {
    getServerFallback: () => !1
}))
  , Gke = Ba(e => {
    const t = Pa(r => {
        const s = DB(r, 150);
        return jl(document, {
            focusin: s,
            focusout: s
        })
    }
    , () => {
        const r = ape(e);
        return r.current != null && (r.current.contains(document.activeElement) || r.current.querySelector('[data-state="open"]') != null)
    }
    , {
        getServerFallback: () => !1
    })
      , n = upe(e);
    return Na( () => t() || n())
}
);
function dpe(e, t, n) {
    try {
        const r = JSON.parse(window.localStorage.getItem(e) ?? "");
        return n(r) ? r : t
    } catch {
        return t
    }
}
function fpe(e, t) {
    window.localStorage.setItem(e, JSON.stringify(t))
}
const fO = dn(e => ({
    data: {},
    setItem: (t, n) => e(r => ({
        data: {
            ...r.data,
            [t]: n
        }
    }))
}));
function hpe(e, t, n) {
    const [r,s] = h.useState(!1)
      , o = fO(l => l.data[e])
      , i = fO(l => l.setItem);
    return h.useEffect( () => {
        if (!r) {
            const l = dpe(e, t, n);
            i(e, l),
            s(!0)
        }
    }
    , [r, e, t, n, i]),
    h.useEffect( () => {
        r && fpe(e, o)
    }
    , [e, o, r]),
    [o ?? t, l => {
        i(e, l)
    }
    ]
}
const ppe = "chatgpt.com/ces"
  , mpe = "https"
  , gpe = `${mpe}://${ppe}`;
function hO(e) {
    return Array.isArray(e) ? e.reduce( (t, n) => (t[n.key] = n.value,
    t), {}) : e
}
var er = (e => (e.DEFAULT = "default",
e.INTERNAL = "internal",
e.CODEX = "Wham",
e.JAWBONE = "jawbone",
e.MOONSHINE = "moonshine",
e.CUSTOMIZE_CHATGPT = "customize_chatgpt",
e.WEB_SANDBOX = "web_sandbox",
e.ECOSYSTEM = "ecosystem",
e.CANVAS = "canvas",
e.COT_SUMMARIZER = "cot_summarizer",
e.CLASSMATES = "classmates",
e.REFERRALS = "referrals",
e.STUDENTS = "students",
e.TEAMS = "teams",
e.WEBSOCKET = "ws",
e.TATERTOT = "tatertot",
e.ECOSYSTEM_DEMO = "ecosystem_demo",
e))(er || {});
class pO {
    counterMap = new Map;
    histMap = new Map
}
class vpe {
    metrics = new pO;
    postUrl = `${gpe}/statsc/flush`;
    postInterval = 3e4;
    maxPostErrors = 10;
    isScheduled = !1;
    numMetricPostErrors = 0;
    numLostMetrics = 0;
    count(t, n, r={}, s=1) {
        r = hO(r);
        const o = this.makeKey(t, n, r);
        var i = this.metrics.counterMap;
        const a = i.get(o);
        a ? a.value += s : i.set(o, {
            namespace: t,
            metric: n,
            tags: r,
            value: s
        }),
        this.scheduleIfNeeded()
    }
    hist(t, n, r={}, s) {
        r = hO(r);
        const o = this.makeKey(t, n, r);
        var i = this.metrics.histMap;
        const a = i.get(o);
        a ? a.values.push(s) : i.set(o, {
            namespace: t,
            metric: n,
            tags: r,
            values: [s]
        }),
        this.scheduleIfNeeded()
    }
    makeKey(t, n, r) {
        const s = Object.entries(r).map( ([o,i]) => `${o}=${i}`).sort().join(",");
        return `${t}:${n}:${s}`
    }
    scheduleIfNeeded() {
        this.isScheduled || (this.isScheduled = !0,
        this.schedule())
    }
    schedule() {
        setTimeout( () => {
            this.postMetrics()
        }
        , this.postInterval)
    }
    hasPendingMetrics() {
        return this.metrics.counterMap.size > 0 || this.metrics.histMap.size > 0 || this.numMetricPostErrors > 0
    }
    async postMetrics() {
        var t = this.metrics;
        this.metrics = new pO;
        var n = t.counterMap.size + t.histMap.size
          , r = Array.from(t.counterMap.values());
        this.numMetricPostErrors > 0 && (r.push({
            namespace: "internal",
            metric: "post_errors",
            tags: {},
            value: this.numMetricPostErrors
        }),
        r.push({
            namespace: "internal",
            metric: "lost_metrics",
            tags: {},
            value: this.numLostMetrics
        }));
        const s = {
            counters: r,
            histograms: Array.from(t.histMap.values()),
            client_type: "web"
        }
          , o = JSON.stringify(s);
        try {
            await at.post(this.postUrl, s, {
                authOption: Qt.Anonymous
            }),
            this.numMetricPostErrors = 0
        } catch (i) {
            i instanceof _t || q.addError(i, {
                json: o
            }),
            this.numMetricPostErrors++,
            this.numLostMetrics += n,
            this.numMetricPostErrors > this.maxPostErrors && (q.addAction(`Exceeded maximum number of post errors (${this.maxPostErrors}). Dropping ${this.numLostMetrics} metrics.`),
            this.numMetricPostErrors = 0,
            this.numLostMetrics = 0)
        }
        this.hasPendingMetrics() ? this.schedule() : this.isScheduled = !1
    }
}
const dr = new vpe;
function Xt(e) {
    if (e === null || e === !0 || e === !1)
        return NaN;
    var t = Number(e);
    return isNaN(t) ? t : t < 0 ? Math.ceil(t) : Math.floor(t)
}
function Ge(e, t) {
    if (t.length < e)
        throw new TypeError(e + " argument" + (e > 1 ? "s" : "") + " required, but only " + t.length + " present")
}
function sm(e) {
    "@babel/helpers - typeof";
    return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? sm = function(n) {
        return typeof n
    }
    : sm = function(n) {
        return n && typeof Symbol == "function" && n.constructor === Symbol && n !== Symbol.prototype ? "symbol" : typeof n
    }
    ,
    sm(e)
}
function Je(e) {
    Ge(1, arguments);
    var t = Object.prototype.toString.call(e);
    return e instanceof Date || sm(e) === "object" && t === "[object Date]" ? new Date(e.getTime()) : typeof e == "number" || t === "[object Number]" ? new Date(e) : ((typeof e == "string" || t === "[object String]") && typeof console < "u" && (console.warn("Starting with v2.0.0-beta.1 date-fns doesn't accept strings as date arguments. Please use `parseISO` to parse strings. See: https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#string-arguments"),
    console.warn(new Error().stack)),
    new Date(NaN))
}
function U1(e, t) {
    Ge(2, arguments);
    var n = Je(e)
      , r = Xt(t);
    return isNaN(r) ? new Date(NaN) : (r && n.setDate(n.getDate() + r),
    n)
}
function FB(e, t) {
    Ge(2, arguments);
    var n = Je(e)
      , r = Xt(t);
    if (isNaN(r))
        return new Date(NaN);
    if (!r)
        return n;
    var s = n.getDate()
      , o = new Date(n.getTime());
    o.setMonth(n.getMonth() + r + 1, 0);
    var i = o.getDate();
    return s >= i ? o : (n.setFullYear(o.getFullYear(), o.getMonth(), s),
    n)
}
function _pe(e, t) {
    Ge(2, arguments);
    var n = Je(e).getTime()
      , r = Xt(t);
    return new Date(n + r)
}
var ype = {};
function nd() {
    return ype
}
function rg(e, t) {
    var n, r, s, o, i, a, l, c;
    Ge(1, arguments);
    var u = nd()
      , d = Xt((n = (r = (s = (o = t?.weekStartsOn) !== null && o !== void 0 ? o : t == null || (i = t.locale) === null || i === void 0 || (a = i.options) === null || a === void 0 ? void 0 : a.weekStartsOn) !== null && s !== void 0 ? s : u.weekStartsOn) !== null && r !== void 0 ? r : (l = u.locale) === null || l === void 0 || (c = l.options) === null || c === void 0 ? void 0 : c.weekStartsOn) !== null && n !== void 0 ? n : 0);
    if (!(d >= 0 && d <= 6))
        throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
    var f = Je(e)
      , p = f.getDay()
      , m = (p < d ? 7 : 0) + p - d;
    return f.setDate(f.getDate() - m),
    f.setHours(0, 0, 0, 0),
    f
}
function J5(e) {
    var t = new Date(Date.UTC(e.getFullYear(), e.getMonth(), e.getDate(), e.getHours(), e.getMinutes(), e.getSeconds(), e.getMilliseconds()));
    return t.setUTCFullYear(e.getFullYear()),
    e.getTime() - t.getTime()
}
function sg(e) {
    Ge(1, arguments);
    var t = Je(e);
    return t.setHours(0, 0, 0, 0),
    t
}
var bpe = 864e5;
function jB(e, t) {
    Ge(2, arguments);
    var n = sg(e)
      , r = sg(t)
      , s = n.getTime() - J5(n)
      , o = r.getTime() - J5(r);
    return Math.round((s - o) / bpe)
}
function UB(e, t) {
    Ge(2, arguments);
    var n = Xt(t)
      , r = n * 7;
    return U1(e, r)
}
function Cpe(e, t) {
    Ge(2, arguments);
    var n = Xt(t);
    return FB(e, n * 12)
}
function Cb(e, t) {
    Ge(2, arguments);
    var n = Je(e)
      , r = Je(t)
      , s = n.getTime() - r.getTime();
    return s < 0 ? -1 : s > 0 ? 1 : s
}
var c4 = 6e4
  , BB = 36e5;
function qB(e, t) {
    Ge(2, arguments);
    var n = sg(e)
      , r = sg(t);
    return n.getTime() === r.getTime()
}
function om(e) {
    "@babel/helpers - typeof";
    return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? om = function(n) {
        return typeof n
    }
    : om = function(n) {
        return n && typeof Symbol == "function" && n.constructor === Symbol && n !== Symbol.prototype ? "symbol" : typeof n
    }
    ,
    om(e)
}
function Spe(e) {
    return Ge(1, arguments),
    e instanceof Date || om(e) === "object" && Object.prototype.toString.call(e) === "[object Date]"
}
function wpe(e) {
    if (Ge(1, arguments),
    !Spe(e) && typeof e != "number")
        return !1;
    var t = Je(e);
    return !isNaN(Number(t))
}
function Epe(e, t) {
    Ge(2, arguments);
    var n = Je(e)
      , r = Je(t)
      , s = n.getFullYear() - r.getFullYear()
      , o = n.getMonth() - r.getMonth();
    return s * 12 + o
}
function mO(e, t) {
    var n = e.getFullYear() - t.getFullYear() || e.getMonth() - t.getMonth() || e.getDate() - t.getDate() || e.getHours() - t.getHours() || e.getMinutes() - t.getMinutes() || e.getSeconds() - t.getSeconds() || e.getMilliseconds() - t.getMilliseconds();
    return n < 0 ? -1 : n > 0 ? 1 : n
}
function Vke(e, t) {
    Ge(2, arguments);
    var n = Je(e)
      , r = Je(t)
      , s = mO(n, r)
      , o = Math.abs(jB(n, r));
    n.setDate(n.getDate() - s * o);
    var i = +(mO(n, r) === -s)
      , a = s * (o - i);
    return a === 0 ? 0 : a
}
function xpe(e, t) {
    return Ge(2, arguments),
    Je(e).getTime() - Je(t).getTime()
}
var gO = {
    ceil: Math.ceil,
    round: Math.round,
    floor: Math.floor,
    trunc: function(t) {
        return t < 0 ? Math.ceil(t) : Math.floor(t)
    }
}
  , Tpe = "trunc";
function kpe(e) {
    return e ? gO[e] : gO[Tpe]
}
function Hke(e, t, n) {
    Ge(2, arguments);
    var r = xpe(e, t) / c4;
    return kpe(void 0)(r)
}
function GB(e) {
    Ge(1, arguments);
    var t = Je(e);
    return t.setHours(23, 59, 59, 999),
    t
}
function Ope(e) {
    Ge(1, arguments);
    var t = Je(e)
      , n = t.getMonth();
    return t.setFullYear(t.getFullYear(), n + 1, 0),
    t.setHours(23, 59, 59, 999),
    t
}
function Ape(e) {
    Ge(1, arguments);
    var t = Je(e);
    return GB(t).getTime() === Ope(t).getTime()
}
function zke(e, t) {
    Ge(2, arguments);
    var n = Je(e), r = Je(t), s = Cb(n, r), o = Math.abs(Epe(n, r)), i;
    if (o < 1)
        i = 0;
    else {
        n.getMonth() === 1 && n.getDate() > 27 && n.setDate(30),
        n.setMonth(n.getMonth() - s * o);
        var a = Cb(n, r) === -s;
        Ape(Je(e)) && o === 1 && Cb(e, r) === 1 && (a = !1),
        i = s * (o - Number(a))
    }
    return i === 0 ? 0 : i
}
function $ke(e, t) {
    var n;
    Ge(1, arguments);
    var r = e || {}
      , s = Je(r.start)
      , o = Je(r.end)
      , i = o.getTime();
    if (!(s.getTime() <= i))
        throw new RangeError("Invalid interval");
    var a = []
      , l = s;
    l.setHours(0, 0, 0, 0);
    var c = Number((n = void 0) !== null && n !== void 0 ? n : 1);
    if (c < 1 || isNaN(c))
        throw new RangeError("`options.step` must be a number greater than 1");
    for (; l.getTime() <= i; )
        a.push(Je(l)),
        l.setDate(l.getDate() + c),
        l.setHours(0, 0, 0, 0);
    return a
}
function Wke(e, t) {
    Ge(1, arguments);
    var n = e || {}
      , r = Je(n.start)
      , s = Je(n.end)
      , o = s.getTime();
    if (!(r.getTime() <= o))
        throw new RangeError("Invalid interval");
    var i = rg(r, t)
      , a = rg(s, t);
    i.setHours(15),
    a.setHours(15),
    o = a.getTime();
    for (var l = [], c = i; c.getTime() <= o; )
        c.setHours(0),
        l.push(Je(c)),
        c = UB(c, 1),
        c.setHours(15);
    return l
}
function Kke(e) {
    Ge(1, arguments);
    var t = Je(e);
    return t.setDate(1),
    t.setHours(0, 0, 0, 0),
    t
}
function Yke(e, t) {
    var n, r, s, o, i, a;
    Ge(1, arguments);
    var l = nd()
      , c = Xt((n = (r = (s = (o = void 0) !== null && o !== void 0 ? o : void 0) !== null && s !== void 0 ? s : l.weekStartsOn) !== null && r !== void 0 ? r : (i = l.locale) === null || i === void 0 || (a = i.options) === null || a === void 0 ? void 0 : a.weekStartsOn) !== null && n !== void 0 ? n : 0);
    if (!(c >= 0 && c <= 6))
        throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
    var u = Je(e)
      , d = u.getDay()
      , f = (d < c ? -7 : 0) + 6 - (d - c);
    return u.setDate(u.getDate() + f),
    u.setHours(23, 59, 59, 999),
    u
}
function Zke() {
    return GB(Date.now())
}
function Mpe(e, t) {
    Ge(2, arguments);
    var n = Xt(t);
    return _pe(e, -n)
}
var Ipe = 864e5;
function Rpe(e) {
    Ge(1, arguments);
    var t = Je(e)
      , n = t.getTime();
    t.setUTCMonth(0, 1),
    t.setUTCHours(0, 0, 0, 0);
    var r = t.getTime()
      , s = n - r;
    return Math.floor(s / Ipe) + 1
}
function og(e) {
    Ge(1, arguments);
    var t = 1
      , n = Je(e)
      , r = n.getUTCDay()
      , s = (r < t ? 7 : 0) + r - t;
    return n.setUTCDate(n.getUTCDate() - s),
    n.setUTCHours(0, 0, 0, 0),
    n
}
function VB(e) {
    Ge(1, arguments);
    var t = Je(e)
      , n = t.getUTCFullYear()
      , r = new Date(0);
    r.setUTCFullYear(n + 1, 0, 4),
    r.setUTCHours(0, 0, 0, 0);
    var s = og(r)
      , o = new Date(0);
    o.setUTCFullYear(n, 0, 4),
    o.setUTCHours(0, 0, 0, 0);
    var i = og(o);
    return t.getTime() >= s.getTime() ? n + 1 : t.getTime() >= i.getTime() ? n : n - 1
}
function Npe(e) {
    Ge(1, arguments);
    var t = VB(e)
      , n = new Date(0);
    n.setUTCFullYear(t, 0, 4),
    n.setUTCHours(0, 0, 0, 0);
    var r = og(n);
    return r
}
var Ppe = 6048e5;
function Dpe(e) {
    Ge(1, arguments);
    var t = Je(e)
      , n = og(t).getTime() - Npe(t).getTime();
    return Math.round(n / Ppe) + 1
}
function ig(e, t) {
    var n, r, s, o, i, a, l, c;
    Ge(1, arguments);
    var u = nd()
      , d = Xt((n = (r = (s = (o = t?.weekStartsOn) !== null && o !== void 0 ? o : t == null || (i = t.locale) === null || i === void 0 || (a = i.options) === null || a === void 0 ? void 0 : a.weekStartsOn) !== null && s !== void 0 ? s : u.weekStartsOn) !== null && r !== void 0 ? r : (l = u.locale) === null || l === void 0 || (c = l.options) === null || c === void 0 ? void 0 : c.weekStartsOn) !== null && n !== void 0 ? n : 0);
    if (!(d >= 0 && d <= 6))
        throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
    var f = Je(e)
      , p = f.getUTCDay()
      , m = (p < d ? 7 : 0) + p - d;
    return f.setUTCDate(f.getUTCDate() - m),
    f.setUTCHours(0, 0, 0, 0),
    f
}
function HB(e, t) {
    var n, r, s, o, i, a, l, c;
    Ge(1, arguments);
    var u = Je(e)
      , d = u.getUTCFullYear()
      , f = nd()
      , p = Xt((n = (r = (s = (o = t?.firstWeekContainsDate) !== null && o !== void 0 ? o : t == null || (i = t.locale) === null || i === void 0 || (a = i.options) === null || a === void 0 ? void 0 : a.firstWeekContainsDate) !== null && s !== void 0 ? s : f.firstWeekContainsDate) !== null && r !== void 0 ? r : (l = f.locale) === null || l === void 0 || (c = l.options) === null || c === void 0 ? void 0 : c.firstWeekContainsDate) !== null && n !== void 0 ? n : 1);
    if (!(p >= 1 && p <= 7))
        throw new RangeError("firstWeekContainsDate must be between 1 and 7 inclusively");
    var m = new Date(0);
    m.setUTCFullYear(d + 1, 0, p),
    m.setUTCHours(0, 0, 0, 0);
    var v = ig(m, t)
      , _ = new Date(0);
    _.setUTCFullYear(d, 0, p),
    _.setUTCHours(0, 0, 0, 0);
    var y = ig(_, t);
    return u.getTime() >= v.getTime() ? d + 1 : u.getTime() >= y.getTime() ? d : d - 1
}
function Lpe(e, t) {
    var n, r, s, o, i, a, l, c;
    Ge(1, arguments);
    var u = nd()
      , d = Xt((n = (r = (s = (o = t?.firstWeekContainsDate) !== null && o !== void 0 ? o : t == null || (i = t.locale) === null || i === void 0 || (a = i.options) === null || a === void 0 ? void 0 : a.firstWeekContainsDate) !== null && s !== void 0 ? s : u.firstWeekContainsDate) !== null && r !== void 0 ? r : (l = u.locale) === null || l === void 0 || (c = l.options) === null || c === void 0 ? void 0 : c.firstWeekContainsDate) !== null && n !== void 0 ? n : 1)
      , f = HB(e, t)
      , p = new Date(0);
    p.setUTCFullYear(f, 0, d),
    p.setUTCHours(0, 0, 0, 0);
    var m = ig(p, t);
    return m
}
var Fpe = 6048e5;
function jpe(e, t) {
    Ge(1, arguments);
    var n = Je(e)
      , r = ig(n, t).getTime() - Lpe(n, t).getTime();
    return Math.round(r / Fpe) + 1
}
function qt(e, t) {
    for (var n = e < 0 ? "-" : "", r = Math.abs(e).toString(); r.length < t; )
        r = "0" + r;
    return n + r
}
var Hi = {
    y: function(t, n) {
        var r = t.getUTCFullYear()
          , s = r > 0 ? r : 1 - r;
        return qt(n === "yy" ? s % 100 : s, n.length)
    },
    M: function(t, n) {
        var r = t.getUTCMonth();
        return n === "M" ? String(r + 1) : qt(r + 1, 2)
    },
    d: function(t, n) {
        return qt(t.getUTCDate(), n.length)
    },
    a: function(t, n) {
        var r = t.getUTCHours() / 12 >= 1 ? "pm" : "am";
        switch (n) {
        case "a":
        case "aa":
            return r.toUpperCase();
        case "aaa":
            return r;
        case "aaaaa":
            return r[0];
        case "aaaa":
        default:
            return r === "am" ? "a.m." : "p.m."
        }
    },
    h: function(t, n) {
        return qt(t.getUTCHours() % 12 || 12, n.length)
    },
    H: function(t, n) {
        return qt(t.getUTCHours(), n.length)
    },
    m: function(t, n) {
        return qt(t.getUTCMinutes(), n.length)
    },
    s: function(t, n) {
        return qt(t.getUTCSeconds(), n.length)
    },
    S: function(t, n) {
        var r = n.length
          , s = t.getUTCMilliseconds()
          , o = Math.floor(s * Math.pow(10, r - 3));
        return qt(o, n.length)
    }
}
  , Nc = {
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
}
  , Upe = {
    G: function(t, n, r) {
        var s = t.getUTCFullYear() > 0 ? 1 : 0;
        switch (n) {
        case "G":
        case "GG":
        case "GGG":
            return r.era(s, {
                width: "abbreviated"
            });
        case "GGGGG":
            return r.era(s, {
                width: "narrow"
            });
        case "GGGG":
        default:
            return r.era(s, {
                width: "wide"
            })
        }
    },
    y: function(t, n, r) {
        if (n === "yo") {
            var s = t.getUTCFullYear()
              , o = s > 0 ? s : 1 - s;
            return r.ordinalNumber(o, {
                unit: "year"
            })
        }
        return Hi.y(t, n)
    },
    Y: function(t, n, r, s) {
        var o = HB(t, s)
          , i = o > 0 ? o : 1 - o;
        if (n === "YY") {
            var a = i % 100;
            return qt(a, 2)
        }
        return n === "Yo" ? r.ordinalNumber(i, {
            unit: "year"
        }) : qt(i, n.length)
    },
    R: function(t, n) {
        var r = VB(t);
        return qt(r, n.length)
    },
    u: function(t, n) {
        var r = t.getUTCFullYear();
        return qt(r, n.length)
    },
    Q: function(t, n, r) {
        var s = Math.ceil((t.getUTCMonth() + 1) / 3);
        switch (n) {
        case "Q":
            return String(s);
        case "QQ":
            return qt(s, 2);
        case "Qo":
            return r.ordinalNumber(s, {
                unit: "quarter"
            });
        case "QQQ":
            return r.quarter(s, {
                width: "abbreviated",
                context: "formatting"
            });
        case "QQQQQ":
            return r.quarter(s, {
                width: "narrow",
                context: "formatting"
            });
        case "QQQQ":
        default:
            return r.quarter(s, {
                width: "wide",
                context: "formatting"
            })
        }
    },
    q: function(t, n, r) {
        var s = Math.ceil((t.getUTCMonth() + 1) / 3);
        switch (n) {
        case "q":
            return String(s);
        case "qq":
            return qt(s, 2);
        case "qo":
            return r.ordinalNumber(s, {
                unit: "quarter"
            });
        case "qqq":
            return r.quarter(s, {
                width: "abbreviated",
                context: "standalone"
            });
        case "qqqqq":
            return r.quarter(s, {
                width: "narrow",
                context: "standalone"
            });
        case "qqqq":
        default:
            return r.quarter(s, {
                width: "wide",
                context: "standalone"
            })
        }
    },
    M: function(t, n, r) {
        var s = t.getUTCMonth();
        switch (n) {
        case "M":
        case "MM":
            return Hi.M(t, n);
        case "Mo":
            return r.ordinalNumber(s + 1, {
                unit: "month"
            });
        case "MMM":
            return r.month(s, {
                width: "abbreviated",
                context: "formatting"
            });
        case "MMMMM":
            return r.month(s, {
                width: "narrow",
                context: "formatting"
            });
        case "MMMM":
        default:
            return r.month(s, {
                width: "wide",
                context: "formatting"
            })
        }
    },
    L: function(t, n, r) {
        var s = t.getUTCMonth();
        switch (n) {
        case "L":
            return String(s + 1);
        case "LL":
            return qt(s + 1, 2);
        case "Lo":
            return r.ordinalNumber(s + 1, {
                unit: "month"
            });
        case "LLL":
            return r.month(s, {
                width: "abbreviated",
                context: "standalone"
            });
        case "LLLLL":
            return r.month(s, {
                width: "narrow",
                context: "standalone"
            });
        case "LLLL":
        default:
            return r.month(s, {
                width: "wide",
                context: "standalone"
            })
        }
    },
    w: function(t, n, r, s) {
        var o = jpe(t, s);
        return n === "wo" ? r.ordinalNumber(o, {
            unit: "week"
        }) : qt(o, n.length)
    },
    I: function(t, n, r) {
        var s = Dpe(t);
        return n === "Io" ? r.ordinalNumber(s, {
            unit: "week"
        }) : qt(s, n.length)
    },
    d: function(t, n, r) {
        return n === "do" ? r.ordinalNumber(t.getUTCDate(), {
            unit: "date"
        }) : Hi.d(t, n)
    },
    D: function(t, n, r) {
        var s = Rpe(t);
        return n === "Do" ? r.ordinalNumber(s, {
            unit: "dayOfYear"
        }) : qt(s, n.length)
    },
    E: function(t, n, r) {
        var s = t.getUTCDay();
        switch (n) {
        case "E":
        case "EE":
        case "EEE":
            return r.day(s, {
                width: "abbreviated",
                context: "formatting"
            });
        case "EEEEE":
            return r.day(s, {
                width: "narrow",
                context: "formatting"
            });
        case "EEEEEE":
            return r.day(s, {
                width: "short",
                context: "formatting"
            });
        case "EEEE":
        default:
            return r.day(s, {
                width: "wide",
                context: "formatting"
            })
        }
    },
    e: function(t, n, r, s) {
        var o = t.getUTCDay()
          , i = (o - s.weekStartsOn + 8) % 7 || 7;
        switch (n) {
        case "e":
            return String(i);
        case "ee":
            return qt(i, 2);
        case "eo":
            return r.ordinalNumber(i, {
                unit: "day"
            });
        case "eee":
            return r.day(o, {
                width: "abbreviated",
                context: "formatting"
            });
        case "eeeee":
            return r.day(o, {
                width: "narrow",
                context: "formatting"
            });
        case "eeeeee":
            return r.day(o, {
                width: "short",
                context: "formatting"
            });
        case "eeee":
        default:
            return r.day(o, {
                width: "wide",
                context: "formatting"
            })
        }
    },
    c: function(t, n, r, s) {
        var o = t.getUTCDay()
          , i = (o - s.weekStartsOn + 8) % 7 || 7;
        switch (n) {
        case "c":
            return String(i);
        case "cc":
            return qt(i, n.length);
        case "co":
            return r.ordinalNumber(i, {
                unit: "day"
            });
        case "ccc":
            return r.day(o, {
                width: "abbreviated",
                context: "standalone"
            });
        case "ccccc":
            return r.day(o, {
                width: "narrow",
                context: "standalone"
            });
        case "cccccc":
            return r.day(o, {
                width: "short",
                context: "standalone"
            });
        case "cccc":
        default:
            return r.day(o, {
                width: "wide",
                context: "standalone"
            })
        }
    },
    i: function(t, n, r) {
        var s = t.getUTCDay()
          , o = s === 0 ? 7 : s;
        switch (n) {
        case "i":
            return String(o);
        case "ii":
            return qt(o, n.length);
        case "io":
            return r.ordinalNumber(o, {
                unit: "day"
            });
        case "iii":
            return r.day(s, {
                width: "abbreviated",
                context: "formatting"
            });
        case "iiiii":
            return r.day(s, {
                width: "narrow",
                context: "formatting"
            });
        case "iiiiii":
            return r.day(s, {
                width: "short",
                context: "formatting"
            });
        case "iiii":
        default:
            return r.day(s, {
                width: "wide",
                context: "formatting"
            })
        }
    },
    a: function(t, n, r) {
        var s = t.getUTCHours()
          , o = s / 12 >= 1 ? "pm" : "am";
        switch (n) {
        case "a":
        case "aa":
            return r.dayPeriod(o, {
                width: "abbreviated",
                context: "formatting"
            });
        case "aaa":
            return r.dayPeriod(o, {
                width: "abbreviated",
                context: "formatting"
            }).toLowerCase();
        case "aaaaa":
            return r.dayPeriod(o, {
                width: "narrow",
                context: "formatting"
            });
        case "aaaa":
        default:
            return r.dayPeriod(o, {
                width: "wide",
                context: "formatting"
            })
        }
    },
    b: function(t, n, r) {
        var s = t.getUTCHours(), o;
        switch (s === 12 ? o = Nc.noon : s === 0 ? o = Nc.midnight : o = s / 12 >= 1 ? "pm" : "am",
        n) {
        case "b":
        case "bb":
            return r.dayPeriod(o, {
                width: "abbreviated",
                context: "formatting"
            });
        case "bbb":
            return r.dayPeriod(o, {
                width: "abbreviated",
                context: "formatting"
            }).toLowerCase();
        case "bbbbb":
            return r.dayPeriod(o, {
                width: "narrow",
                context: "formatting"
            });
        case "bbbb":
        default:
            return r.dayPeriod(o, {
                width: "wide",
                context: "formatting"
            })
        }
    },
    B: function(t, n, r) {
        var s = t.getUTCHours(), o;
        switch (s >= 17 ? o = Nc.evening : s >= 12 ? o = Nc.afternoon : s >= 4 ? o = Nc.morning : o = Nc.night,
        n) {
        case "B":
        case "BB":
        case "BBB":
            return r.dayPeriod(o, {
                width: "abbreviated",
                context: "formatting"
            });
        case "BBBBB":
            return r.dayPeriod(o, {
                width: "narrow",
                context: "formatting"
            });
        case "BBBB":
        default:
            return r.dayPeriod(o, {
                width: "wide",
                context: "formatting"
            })
        }
    },
    h: function(t, n, r) {
        if (n === "ho") {
            var s = t.getUTCHours() % 12;
            return s === 0 && (s = 12),
            r.ordinalNumber(s, {
                unit: "hour"
            })
        }
        return Hi.h(t, n)
    },
    H: function(t, n, r) {
        return n === "Ho" ? r.ordinalNumber(t.getUTCHours(), {
            unit: "hour"
        }) : Hi.H(t, n)
    },
    K: function(t, n, r) {
        var s = t.getUTCHours() % 12;
        return n === "Ko" ? r.ordinalNumber(s, {
            unit: "hour"
        }) : qt(s, n.length)
    },
    k: function(t, n, r) {
        var s = t.getUTCHours();
        return s === 0 && (s = 24),
        n === "ko" ? r.ordinalNumber(s, {
            unit: "hour"
        }) : qt(s, n.length)
    },
    m: function(t, n, r) {
        return n === "mo" ? r.ordinalNumber(t.getUTCMinutes(), {
            unit: "minute"
        }) : Hi.m(t, n)
    },
    s: function(t, n, r) {
        return n === "so" ? r.ordinalNumber(t.getUTCSeconds(), {
            unit: "second"
        }) : Hi.s(t, n)
    },
    S: function(t, n) {
        return Hi.S(t, n)
    },
    X: function(t, n, r, s) {
        var o = s._originalDate || t
          , i = o.getTimezoneOffset();
        if (i === 0)
            return "Z";
        switch (n) {
        case "X":
            return _O(i);
        case "XXXX":
        case "XX":
            return ll(i);
        case "XXXXX":
        case "XXX":
        default:
            return ll(i, ":")
        }
    },
    x: function(t, n, r, s) {
        var o = s._originalDate || t
          , i = o.getTimezoneOffset();
        switch (n) {
        case "x":
            return _O(i);
        case "xxxx":
        case "xx":
            return ll(i);
        case "xxxxx":
        case "xxx":
        default:
            return ll(i, ":")
        }
    },
    O: function(t, n, r, s) {
        var o = s._originalDate || t
          , i = o.getTimezoneOffset();
        switch (n) {
        case "O":
        case "OO":
        case "OOO":
            return "GMT" + vO(i, ":");
        case "OOOO":
        default:
            return "GMT" + ll(i, ":")
        }
    },
    z: function(t, n, r, s) {
        var o = s._originalDate || t
          , i = o.getTimezoneOffset();
        switch (n) {
        case "z":
        case "zz":
        case "zzz":
            return "GMT" + vO(i, ":");
        case "zzzz":
        default:
            return "GMT" + ll(i, ":")
        }
    },
    t: function(t, n, r, s) {
        var o = s._originalDate || t
          , i = Math.floor(o.getTime() / 1e3);
        return qt(i, n.length)
    },
    T: function(t, n, r, s) {
        var o = s._originalDate || t
          , i = o.getTime();
        return qt(i, n.length)
    }
};
function vO(e, t) {
    var n = e > 0 ? "-" : "+"
      , r = Math.abs(e)
      , s = Math.floor(r / 60)
      , o = r % 60;
    if (o === 0)
        return n + String(s);
    var i = t;
    return n + String(s) + i + qt(o, 2)
}
function _O(e, t) {
    if (e % 60 === 0) {
        var n = e > 0 ? "-" : "+";
        return n + qt(Math.abs(e) / 60, 2)
    }
    return ll(e, t)
}
function ll(e, t) {
    var n = t || ""
      , r = e > 0 ? "-" : "+"
      , s = Math.abs(e)
      , o = qt(Math.floor(s / 60), 2)
      , i = qt(s % 60, 2);
    return r + o + n + i
}
var yO = function(t, n) {
    switch (t) {
    case "P":
        return n.date({
            width: "short"
        });
    case "PP":
        return n.date({
            width: "medium"
        });
    case "PPP":
        return n.date({
            width: "long"
        });
    case "PPPP":
    default:
        return n.date({
            width: "full"
        })
    }
}
  , zB = function(t, n) {
    switch (t) {
    case "p":
        return n.time({
            width: "short"
        });
    case "pp":
        return n.time({
            width: "medium"
        });
    case "ppp":
        return n.time({
            width: "long"
        });
    case "pppp":
    default:
        return n.time({
            width: "full"
        })
    }
}
  , Bpe = function(t, n) {
    var r = t.match(/(P+)(p+)?/) || []
      , s = r[1]
      , o = r[2];
    if (!o)
        return yO(t, n);
    var i;
    switch (s) {
    case "P":
        i = n.dateTime({
            width: "short"
        });
        break;
    case "PP":
        i = n.dateTime({
            width: "medium"
        });
        break;
    case "PPP":
        i = n.dateTime({
            width: "long"
        });
        break;
    case "PPPP":
    default:
        i = n.dateTime({
            width: "full"
        });
        break
    }
    return i.replace("{{date}}", yO(s, n)).replace("{{time}}", zB(o, n))
}
  , qpe = {
    p: zB,
    P: Bpe
}
  , Gpe = ["D", "DD"]
  , Vpe = ["YY", "YYYY"];
function Hpe(e) {
    return Gpe.indexOf(e) !== -1
}
function zpe(e) {
    return Vpe.indexOf(e) !== -1
}
function bO(e, t, n) {
    if (e === "YYYY")
        throw new RangeError("Use `yyyy` instead of `YYYY` (in `".concat(t, "`) for formatting years to the input `").concat(n, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
    if (e === "YY")
        throw new RangeError("Use `yy` instead of `YY` (in `".concat(t, "`) for formatting years to the input `").concat(n, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
    if (e === "D")
        throw new RangeError("Use `d` instead of `D` (in `".concat(t, "`) for formatting days of the month to the input `").concat(n, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
    if (e === "DD")
        throw new RangeError("Use `dd` instead of `DD` (in `".concat(t, "`) for formatting days of the month to the input `").concat(n, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"))
}
var $pe = {
    lessThanXSeconds: {
        one: "less than a second",
        other: "less than {{count}} seconds"
    },
    xSeconds: {
        one: "1 second",
        other: "{{count}} seconds"
    },
    halfAMinute: "half a minute",
    lessThanXMinutes: {
        one: "less than a minute",
        other: "less than {{count}} minutes"
    },
    xMinutes: {
        one: "1 minute",
        other: "{{count}} minutes"
    },
    aboutXHours: {
        one: "about 1 hour",
        other: "about {{count}} hours"
    },
    xHours: {
        one: "1 hour",
        other: "{{count}} hours"
    },
    xDays: {
        one: "1 day",
        other: "{{count}} days"
    },
    aboutXWeeks: {
        one: "about 1 week",
        other: "about {{count}} weeks"
    },
    xWeeks: {
        one: "1 week",
        other: "{{count}} weeks"
    },
    aboutXMonths: {
        one: "about 1 month",
        other: "about {{count}} months"
    },
    xMonths: {
        one: "1 month",
        other: "{{count}} months"
    },
    aboutXYears: {
        one: "about 1 year",
        other: "about {{count}} years"
    },
    xYears: {
        one: "1 year",
        other: "{{count}} years"
    },
    overXYears: {
        one: "over 1 year",
        other: "over {{count}} years"
    },
    almostXYears: {
        one: "almost 1 year",
        other: "almost {{count}} years"
    }
}
  , Wpe = function(t, n, r) {
    var s, o = $pe[t];
    return typeof o == "string" ? s = o : n === 1 ? s = o.one : s = o.other.replace("{{count}}", n.toString()),
    r != null && r.addSuffix ? r.comparison && r.comparison > 0 ? "in " + s : s + " ago" : s
};
function Sb(e) {
    return function() {
        var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}
          , n = t.width ? String(t.width) : e.defaultWidth
          , r = e.formats[n] || e.formats[e.defaultWidth];
        return r
    }
}
var Kpe = {
    full: "EEEE, MMMM do, y",
    long: "MMMM do, y",
    medium: "MMM d, y",
    short: "MM/dd/yyyy"
}
  , Ype = {
    full: "h:mm:ss a zzzz",
    long: "h:mm:ss a z",
    medium: "h:mm:ss a",
    short: "h:mm a"
}
  , Zpe = {
    full: "{{date}} 'at' {{time}}",
    long: "{{date}} 'at' {{time}}",
    medium: "{{date}}, {{time}}",
    short: "{{date}}, {{time}}"
}
  , Jpe = {
    date: Sb({
        formats: Kpe,
        defaultWidth: "full"
    }),
    time: Sb({
        formats: Ype,
        defaultWidth: "full"
    }),
    dateTime: Sb({
        formats: Zpe,
        defaultWidth: "full"
    })
}
  , Xpe = {
    lastWeek: "'last' eeee 'at' p",
    yesterday: "'yesterday at' p",
    today: "'today at' p",
    tomorrow: "'tomorrow at' p",
    nextWeek: "eeee 'at' p",
    other: "P"
}
  , Qpe = function(t, n, r, s) {
    return Xpe[t]
};
function wd(e) {
    return function(t, n) {
        var r = n != null && n.context ? String(n.context) : "standalone", s;
        if (r === "formatting" && e.formattingValues) {
            var o = e.defaultFormattingWidth || e.defaultWidth
              , i = n != null && n.width ? String(n.width) : o;
            s = e.formattingValues[i] || e.formattingValues[o]
        } else {
            var a = e.defaultWidth
              , l = n != null && n.width ? String(n.width) : e.defaultWidth;
            s = e.values[l] || e.values[a]
        }
        var c = e.argumentCallback ? e.argumentCallback(t) : t;
        return s[c]
    }
}
var eme = {
    narrow: ["B", "A"],
    abbreviated: ["BC", "AD"],
    wide: ["Before Christ", "Anno Domini"]
}
  , tme = {
    narrow: ["1", "2", "3", "4"],
    abbreviated: ["Q1", "Q2", "Q3", "Q4"],
    wide: ["1st quarter", "2nd quarter", "3rd quarter", "4th quarter"]
}
  , nme = {
    narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
    abbreviated: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
    wide: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]
}
  , rme = {
    narrow: ["S", "M", "T", "W", "T", "F", "S"],
    short: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
    abbreviated: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
    wide: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]
}
  , sme = {
    narrow: {
        am: "a",
        pm: "p",
        midnight: "mi",
        noon: "n",
        morning: "morning",
        afternoon: "afternoon",
        evening: "evening",
        night: "night"
    },
    abbreviated: {
        am: "AM",
        pm: "PM",
        midnight: "midnight",
        noon: "noon",
        morning: "morning",
        afternoon: "afternoon",
        evening: "evening",
        night: "night"
    },
    wide: {
        am: "a.m.",
        pm: "p.m.",
        midnight: "midnight",
        noon: "noon",
        morning: "morning",
        afternoon: "afternoon",
        evening: "evening",
        night: "night"
    }
}
  , ome = {
    narrow: {
        am: "a",
        pm: "p",
        midnight: "mi",
        noon: "n",
        morning: "in the morning",
        afternoon: "in the afternoon",
        evening: "in the evening",
        night: "at night"
    },
    abbreviated: {
        am: "AM",
        pm: "PM",
        midnight: "midnight",
        noon: "noon",
        morning: "in the morning",
        afternoon: "in the afternoon",
        evening: "in the evening",
        night: "at night"
    },
    wide: {
        am: "a.m.",
        pm: "p.m.",
        midnight: "midnight",
        noon: "noon",
        morning: "in the morning",
        afternoon: "in the afternoon",
        evening: "in the evening",
        night: "at night"
    }
}
  , ime = function(t, n) {
    var r = Number(t)
      , s = r % 100;
    if (s > 20 || s < 10)
        switch (s % 10) {
        case 1:
            return r + "st";
        case 2:
            return r + "nd";
        case 3:
            return r + "rd"
        }
    return r + "th"
}
  , ame = {
    ordinalNumber: ime,
    era: wd({
        values: eme,
        defaultWidth: "wide"
    }),
    quarter: wd({
        values: tme,
        defaultWidth: "wide",
        argumentCallback: function(t) {
            return t - 1
        }
    }),
    month: wd({
        values: nme,
        defaultWidth: "wide"
    }),
    day: wd({
        values: rme,
        defaultWidth: "wide"
    }),
    dayPeriod: wd({
        values: sme,
        defaultWidth: "wide",
        formattingValues: ome,
        defaultFormattingWidth: "wide"
    })
};
function Ed(e) {
    return function(t) {
        var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}
          , r = n.width
          , s = r && e.matchPatterns[r] || e.matchPatterns[e.defaultMatchWidth]
          , o = t.match(s);
        if (!o)
            return null;
        var i = o[0], a = r && e.parsePatterns[r] || e.parsePatterns[e.defaultParseWidth], l = Array.isArray(a) ? cme(a, function(d) {
            return d.test(i)
        }) : lme(a, function(d) {
            return d.test(i)
        }), c;
        c = e.valueCallback ? e.valueCallback(l) : l,
        c = n.valueCallback ? n.valueCallback(c) : c;
        var u = t.slice(i.length);
        return {
            value: c,
            rest: u
        }
    }
}
function lme(e, t) {
    for (var n in e)
        if (e.hasOwnProperty(n) && t(e[n]))
            return n
}
function cme(e, t) {
    for (var n = 0; n < e.length; n++)
        if (t(e[n]))
            return n
}
function ume(e) {
    return function(t) {
        var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}
          , r = t.match(e.matchPattern);
        if (!r)
            return null;
        var s = r[0]
          , o = t.match(e.parsePattern);
        if (!o)
            return null;
        var i = e.valueCallback ? e.valueCallback(o[0]) : o[0];
        i = n.valueCallback ? n.valueCallback(i) : i;
        var a = t.slice(s.length);
        return {
            value: i,
            rest: a
        }
    }
}
var dme = /^(\d+)(th|st|nd|rd)?/i
  , fme = /\d+/i
  , hme = {
    narrow: /^(b|a)/i,
    abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
    wide: /^(before christ|before common era|anno domini|common era)/i
}
  , pme = {
    any: [/^b/i, /^(a|c)/i]
}
  , mme = {
    narrow: /^[1234]/i,
    abbreviated: /^q[1234]/i,
    wide: /^[1234](th|st|nd|rd)? quarter/i
}
  , gme = {
    any: [/1/i, /2/i, /3/i, /4/i]
}
  , vme = {
    narrow: /^[jfmasond]/i,
    abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
    wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
}
  , _me = {
    narrow: [/^j/i, /^f/i, /^m/i, /^a/i, /^m/i, /^j/i, /^j/i, /^a/i, /^s/i, /^o/i, /^n/i, /^d/i],
    any: [/^ja/i, /^f/i, /^mar/i, /^ap/i, /^may/i, /^jun/i, /^jul/i, /^au/i, /^s/i, /^o/i, /^n/i, /^d/i]
}
  , yme = {
    narrow: /^[smtwf]/i,
    short: /^(su|mo|tu|we|th|fr|sa)/i,
    abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
    wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
}
  , bme = {
    narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
    any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
}
  , Cme = {
    narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
    any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
}
  , Sme = {
    any: {
        am: /^a/i,
        pm: /^p/i,
        midnight: /^mi/i,
        noon: /^no/i,
        morning: /morning/i,
        afternoon: /afternoon/i,
        evening: /evening/i,
        night: /night/i
    }
}
  , wme = {
    ordinalNumber: ume({
        matchPattern: dme,
        parsePattern: fme,
        valueCallback: function(t) {
            return parseInt(t, 10)
        }
    }),
    era: Ed({
        matchPatterns: hme,
        defaultMatchWidth: "wide",
        parsePatterns: pme,
        defaultParseWidth: "any"
    }),
    quarter: Ed({
        matchPatterns: mme,
        defaultMatchWidth: "wide",
        parsePatterns: gme,
        defaultParseWidth: "any",
        valueCallback: function(t) {
            return t + 1
        }
    }),
    month: Ed({
        matchPatterns: vme,
        defaultMatchWidth: "wide",
        parsePatterns: _me,
        defaultParseWidth: "any"
    }),
    day: Ed({
        matchPatterns: yme,
        defaultMatchWidth: "wide",
        parsePatterns: bme,
        defaultParseWidth: "any"
    }),
    dayPeriod: Ed({
        matchPatterns: Cme,
        defaultMatchWidth: "any",
        parsePatterns: Sme,
        defaultParseWidth: "any"
    })
}
  , Eme = {
    code: "en-US",
    formatDistance: Wpe,
    formatLong: Jpe,
    formatRelative: Qpe,
    localize: ame,
    match: wme,
    options: {
        weekStartsOn: 0,
        firstWeekContainsDate: 1
    }
}
  , xme = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g
  , Tme = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g
  , kme = /^'([^]*?)'?$/
  , Ome = /''/g
  , Ame = /[a-zA-Z]/;
function Jke(e, t, n) {
    var r, s, o, i, a, l, c, u, d, f, p, m, v, _;
    Ge(2, arguments);
    var y = String(t)
      , b = nd()
      , S = (r = (s = void 0) !== null && s !== void 0 ? s : b.locale) !== null && r !== void 0 ? r : Eme
      , C = Xt((o = (i = (a = (l = void 0) !== null && l !== void 0 ? l : void 0) !== null && a !== void 0 ? a : b.firstWeekContainsDate) !== null && i !== void 0 ? i : (c = b.locale) === null || c === void 0 || (u = c.options) === null || u === void 0 ? void 0 : u.firstWeekContainsDate) !== null && o !== void 0 ? o : 1);
    if (!(C >= 1 && C <= 7))
        throw new RangeError("firstWeekContainsDate must be between 1 and 7 inclusively");
    var w = Xt((d = (f = (p = (m = void 0) !== null && m !== void 0 ? m : void 0) !== null && p !== void 0 ? p : b.weekStartsOn) !== null && f !== void 0 ? f : (v = b.locale) === null || v === void 0 || (_ = v.options) === null || _ === void 0 ? void 0 : _.weekStartsOn) !== null && d !== void 0 ? d : 0);
    if (!(w >= 0 && w <= 6))
        throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
    if (!S.localize)
        throw new RangeError("locale must contain localize property");
    if (!S.formatLong)
        throw new RangeError("locale must contain formatLong property");
    var x = Je(e);
    if (!wpe(x))
        throw new RangeError("Invalid time value");
    var E = J5(x)
      , T = Mpe(x, E)
      , k = {
        firstWeekContainsDate: C,
        weekStartsOn: w,
        locale: S,
        _originalDate: x
    }
      , A = y.match(Tme).map(function(O) {
        var M = O[0];
        if (M === "p" || M === "P") {
            var I = qpe[M];
            return I(O, S.formatLong)
        }
        return O
    }).join("").match(xme).map(function(O) {
        if (O === "''")
            return "'";
        var M = O[0];
        if (M === "'")
            return Mme(O);
        var I = Upe[M];
        if (I)
            return zpe(O) && bO(O, t, String(e)),
            Hpe(O) && bO(O, t, String(e)),
            I(T, O, S.localize, k);
        if (M.match(Ame))
            throw new RangeError("Format string contains an unescaped latin alphabet character `" + M + "`");
        return O
    }).join("");
    return A
}
function Mme(e) {
    var t = e.match(kme);
    return t ? t[1].replace(Ome, "'") : e
}
function Ime(e) {
    Ge(1, arguments);
    var t = Xt(e);
    return Je(t * 1e3)
}
function Rme(e) {
    Ge(1, arguments);
    var t = Je(e)
      , n = t.getFullYear()
      , r = t.getMonth()
      , s = new Date(0);
    return s.setFullYear(n, r + 1, 0),
    s.setHours(0, 0, 0, 0),
    s.getDate()
}
function Nme(e) {
    Ge(1, arguments);
    var t = Je(e)
      , n = t.getMonth();
    return n
}
function Pme(e) {
    Ge(1, arguments);
    var t = Je(e)
      , n = t.getTime();
    return n
}
function Dme(e) {
    return Ge(1, arguments),
    Math.floor(Pme(e) / 1e3)
}
function CO(e) {
    return Ge(1, arguments),
    Je(e).getFullYear()
}
function Xke(e, t, n) {
    var r;
    Ge(1, arguments);
    var s;
    return n = t,
    new Intl.DateTimeFormat((r = n) === null || r === void 0 ? void 0 : r.locale,s).format(e)
}
function Qke(e, t) {
    Ge(2, arguments);
    var n = Je(e)
      , r = Je(t);
    return n.getTime() > r.getTime()
}
function eOe(e, t) {
    Ge(2, arguments);
    var n = Je(e)
      , r = Je(t);
    return n.getTime() < r.getTime()
}
function tOe(e, t) {
    Ge(2, arguments);
    var n = Je(e)
      , r = Je(t);
    return n.getTime() === r.getTime()
}
function nOe(e, t, n) {
    Ge(2, arguments);
    var r = rg(e, n)
      , s = rg(t, n);
    return r.getTime() === s.getTime()
}
function rOe(e, t) {
    Ge(2, arguments);
    var n = Je(e)
      , r = Je(t);
    return n.getFullYear() === r.getFullYear() && n.getMonth() === r.getMonth()
}
function Lme(e, t) {
    Ge(2, arguments);
    var n = Je(e)
      , r = Je(t);
    return n.getFullYear() === r.getFullYear()
}
function Fme(e) {
    return Ge(1, arguments),
    Lme(e, Date.now())
}
function jme(e) {
    return Ge(1, arguments),
    qB(e, Date.now())
}
function Ume(e) {
    return Ge(1, arguments),
    qB(e, U1(Date.now(), 1))
}
function sOe(e, t) {
    Ge(2, arguments);
    var n = Xt(t);
    return U1(e, -n)
}
function oOe(e, t) {
    var n;
    Ge(1, arguments);
    var r = Xt((n = void 0) !== null && n !== void 0 ? n : 2);
    if (r !== 2 && r !== 1 && r !== 0)
        throw new RangeError("additionalDigits must be 0, 1 or 2");
    if (!(typeof e == "string" || Object.prototype.toString.call(e) === "[object String]"))
        return new Date(NaN);
    var s = Vme(e), o;
    if (s.date) {
        var i = Hme(s.date, r);
        o = zme(i.restDateString, i.year)
    }
    if (!o || isNaN(o.getTime()))
        return new Date(NaN);
    var a = o.getTime(), l = 0, c;
    if (s.time && (l = $me(s.time),
    isNaN(l)))
        return new Date(NaN);
    if (s.timezone) {
        if (c = Wme(s.timezone),
        isNaN(c))
            return new Date(NaN)
    } else {
        var u = new Date(a + l)
          , d = new Date(0);
        return d.setFullYear(u.getUTCFullYear(), u.getUTCMonth(), u.getUTCDate()),
        d.setHours(u.getUTCHours(), u.getUTCMinutes(), u.getUTCSeconds(), u.getUTCMilliseconds()),
        d
    }
    return new Date(a + l + c)
}
var bp = {
    dateTimeDelimiter: /[T ]/,
    timeZoneDelimiter: /[Z ]/i,
    timezone: /([Z+-].*)$/
}
  , Bme = /^-?(?:(\d{3})|(\d{2})(?:-?(\d{2}))?|W(\d{2})(?:-?(\d{1}))?|)$/
  , qme = /^(\d{2}(?:[.,]\d*)?)(?::?(\d{2}(?:[.,]\d*)?))?(?::?(\d{2}(?:[.,]\d*)?))?$/
  , Gme = /^([+-])(\d{2})(?::?(\d{2}))?$/;
function Vme(e) {
    var t = {}, n = e.split(bp.dateTimeDelimiter), r;
    if (n.length > 2)
        return t;
    if (/:/.test(n[0]) ? r = n[0] : (t.date = n[0],
    r = n[1],
    bp.timeZoneDelimiter.test(t.date) && (t.date = e.split(bp.timeZoneDelimiter)[0],
    r = e.substr(t.date.length, e.length))),
    r) {
        var s = bp.timezone.exec(r);
        s ? (t.time = r.replace(s[1], ""),
        t.timezone = s[1]) : t.time = r
    }
    return t
}
function Hme(e, t) {
    var n = new RegExp("^(?:(\\d{4}|[+-]\\d{" + (4 + t) + "})|(\\d{2}|[+-]\\d{" + (2 + t) + "})$)")
      , r = e.match(n);
    if (!r)
        return {
            year: NaN,
            restDateString: ""
        };
    var s = r[1] ? parseInt(r[1]) : null
      , o = r[2] ? parseInt(r[2]) : null;
    return {
        year: o === null ? s : o * 100,
        restDateString: e.slice((r[1] || r[2]).length)
    }
}
function zme(e, t) {
    if (t === null)
        return new Date(NaN);
    var n = e.match(Bme);
    if (!n)
        return new Date(NaN);
    var r = !!n[4]
      , s = xd(n[1])
      , o = xd(n[2]) - 1
      , i = xd(n[3])
      , a = xd(n[4])
      , l = xd(n[5]) - 1;
    if (r)
        return Xme(t, a, l) ? Kme(t, a, l) : new Date(NaN);
    var c = new Date(0);
    return !Zme(t, o, i) || !Jme(t, s) ? new Date(NaN) : (c.setUTCFullYear(t, o, Math.max(s, i)),
    c)
}
function xd(e) {
    return e ? parseInt(e) : 1
}
function $me(e) {
    var t = e.match(qme);
    if (!t)
        return NaN;
    var n = wb(t[1])
      , r = wb(t[2])
      , s = wb(t[3]);
    return Qme(n, r, s) ? n * BB + r * c4 + s * 1e3 : NaN
}
function wb(e) {
    return e && parseFloat(e.replace(",", ".")) || 0
}
function Wme(e) {
    if (e === "Z")
        return 0;
    var t = e.match(Gme);
    if (!t)
        return 0;
    var n = t[1] === "+" ? -1 : 1
      , r = parseInt(t[2])
      , s = t[3] && parseInt(t[3]) || 0;
    return ege(r, s) ? n * (r * BB + s * c4) : NaN
}
function Kme(e, t, n) {
    var r = new Date(0);
    r.setUTCFullYear(e, 0, 4);
    var s = r.getUTCDay() || 7
      , o = (t - 1) * 7 + n + 1 - s;
    return r.setUTCDate(r.getUTCDate() + o),
    r
}
var Yme = [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
function $B(e) {
    return e % 400 === 0 || e % 4 === 0 && e % 100 !== 0
}
function Zme(e, t, n) {
    return t >= 0 && t <= 11 && n >= 1 && n <= (Yme[t] || ($B(e) ? 29 : 28))
}
function Jme(e, t) {
    return t >= 1 && t <= ($B(e) ? 366 : 365)
}
function Xme(e, t, n) {
    return t >= 1 && t <= 53 && n >= 0 && n <= 6
}
function Qme(e, t, n) {
    return e === 24 ? t === 0 && n === 0 : n >= 0 && n < 60 && t >= 0 && t < 60 && e >= 0 && e < 25
}
function ege(e, t) {
    return t >= 0 && t <= 59
}
function tge(e, t) {
    Ge(2, arguments);
    var n = Je(e)
      , r = Xt(t)
      , s = n.getFullYear()
      , o = n.getDate()
      , i = new Date(0);
    i.setFullYear(s, r, 15),
    i.setHours(0, 0, 0, 0);
    var a = Rme(i);
    return n.setMonth(r, Math.min(o, a)),
    n
}
function im(e) {
    "@babel/helpers - typeof";
    return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? im = function(n) {
        return typeof n
    }
    : im = function(n) {
        return n && typeof Symbol == "function" && n.constructor === Symbol && n !== Symbol.prototype ? "symbol" : typeof n
    }
    ,
    im(e)
}
function iOe(e, t) {
    if (Ge(2, arguments),
    im(t) !== "object" || t === null)
        throw new RangeError("values parameter must be an object");
    var n = Je(e);
    return isNaN(n.getTime()) ? new Date(NaN) : (t.year != null && n.setFullYear(t.year),
    t.month != null && (n = tge(n, t.month)),
    t.date != null && n.setDate(Xt(t.date)),
    t.hours != null && n.setHours(Xt(t.hours)),
    t.minutes != null && n.setMinutes(Xt(t.minutes)),
    t.seconds != null && n.setSeconds(Xt(t.seconds)),
    t.milliseconds != null && n.setMilliseconds(Xt(t.milliseconds)),
    n)
}
function aOe(e, t) {
    Ge(2, arguments);
    var n = Xt(t);
    return FB(e, -n)
}
function lOe(e, t) {
    Ge(2, arguments);
    var n = Xt(t);
    return UB(e, -n)
}
function cOe(e, t) {
    Ge(2, arguments);
    var n = Xt(t);
    return Cpe(e, -n)
}
const nge = 3
  , rge = 3;
function sge() {
    const e = ue();
    return $t(e, "1092897457", {
        disableExposureLog: !0
    }).get("is_tatertot_enabled", !0) ? Xe(e, "3240576626") : !1
}
function oge(e) {
    return e ? new Date > U1(e, nge) : !0
}
function uOe(e) {
    const [t,n] = hpe(Ft.TatertotInContextUpsellBannerV2, null, l => l != null && typeof l == "object" && typeof l.messageId == "string" && typeof l.lastSeenAt == "number" && typeof l.interacted == "boolean" && typeof l.viewCount == "number")
      , r = Xe(ue(), "3240576626")
      , s = t ? Ime(t.lastSeenAt) : null
      , o = t ? t.viewCount ?? 0 : 0;
    return {
        canBeSeen: e !== "" && (!t || o <= rge && (oge(s) || t.messageId === e && t.interacted === !1)) && r,
        markSeen: l => {
            const c = {
                messageId: e,
                lastSeenAt: Dme(new Date),
                interacted: l,
                viewCount: (t ? t.viewCount : 0) + (l ? 0 : 1)
            };
            dr.count(er.TATERTOT, "tatertot_upsell_banner_shown"),
            n(c),
            localStorage.setItem(Ft.TatertotInContextUpsellBannerV2, JSON.stringify(c))
        }
    }
}
const ige = "o4-mini"
  , gu = ({chunk: e, href: t}) => g.jsx("a", {
    href: t,
    target: "_blank",
    className: "underline",
    rel: "noreferrer",
    children: e
})
  , K = xt({
    modelsTitle: {
        id: "t+hUfA",
        defaultMessage: "Models"
    },
    modelsDescription: {
        id: "zFj9MF",
        defaultMessage: "Manage access to models for members"
    },
    gpt5ThinkingDescription: {
        id: "eqYr0u",
        defaultMessage: "Thinks longer for better answers. If enabled, GPT-5 Auto will be able to switch to Thinking for responses when needed."
    },
    gpt5ThinkingProDescription: {
        id: "AmHfHH",
        defaultMessage: "Research-grade intelligence."
    },
    gpt5ThinkingMiniDescription: {
        id: "1H7DaL",
        defaultMessage: "Thinks quickly. If enabled, GPT-5 Auto will be able to switch to Thinking Mini for responses when needed."
    },
    legacyModelsTitle: {
        id: "5MXz0X",
        defaultMessage: "Enable legacy models"
    },
    legacyModelsDescription: {
        id: "83N6uo",
        defaultMessage: "Allow members to use legacy models. This is a global setting for the workspace."
    },
    additionalModelsTitle: {
        id: "2ljqlu",
        defaultMessage: "Enable additional models"
    },
    additionalModelsDescription: {
        id: "DDljrd",
        defaultMessage: "Allow members to use additional models."
    },
    gpt41Description: {
        id: "J2sMy+",
        defaultMessage: "Great for quick coding and analysis."
    },
    gptO3Description: {
        id: "sG0ZYa",
        defaultMessage: "A powerful engine for complex, multi-step analysis."
    },
    gptO4MiniDescription: {
        id: "kH5Wky",
        defaultMessage: "Fast, cost-efficient reasoning for code, math and visual tasks."
    },
    imageGenTitle: {
        id: "iPlNq5",
        defaultMessage: "Image generation"
    },
    imageGenDescription: {
        id: "6NZOo3",
        defaultMessage: "Allows users create AI-generated images inside ChatGPT."
    },
    webSearchTitle: {
        id: "Qzwh18",
        defaultMessage: "Web search"
    },
    webSearchDescription: {
        id: "2MpcaO",
        defaultMessage: "Manage whether ChatGPT and GPTs created in this workspace can browse the internet. When enabled, it may send search queries and general location information to Bing, but this data is not linked to or associated with user accounts. This does not apply to third-party GPTs. <link>Learn more</link>"
    },
    webSearchDescriptionOfflineOnly: {
        id: "exxzV0",
        defaultMessage: "ChatGPT web search may send queries to third-party search providers based on your inputs to ChatGPT. You should ensure your use of ChatGPT search complies with your obligations under HIPAA."
    },
    codexTitle: {
        id: "Tpse/7",
        defaultMessage: "Allow members to use Codex"
    },
    codexDescription: {
        id: "jVlxKv",
        defaultMessage: "Manage whether members can use Codex."
    },
    codexCliTitle: {
        id: "wdPl2u",
        defaultMessage: "Allow members to use Codex CLI and IDE Extension"
    },
    codexCliDescription: {
        id: "e5oEdc",
        defaultMessage: "Manage whether members can use Codex CLI and IDE Extension."
    },
    codexAgentNetworkTitle: {
        id: "+0TP+Y",
        defaultMessage: "Allow Codex agent to access the internet"
    },
    codexAgentNetworkDescription: {
        id: "ObRZ8h",
        defaultMessage: "Allows environments to be created with agent internet access enabled."
    },
    disabledReasonGithub: {
        id: "HNofTP",
        defaultMessage: "Disabled because there's no active GitHub connector."
    },
    recordTitle: {
        id: "AXkmJg",
        defaultMessage: "Record"
    },
    recordDescription: {
        id: "l0y0CK",
        defaultMessage: "Manage whether users can use ChatGPT to record, transcribe, and summarize longform audio. Recordings will be used solely for transcription purposes and will not be stored by OpenAI. <link>Learn more</link>"
    },
    recordReferencePastTranscriptsTitle: {
        id: "ZsmGaz",
        defaultMessage: "Allow ChatGPT to reference past notes and transcripts"
    },
    recordReferencePastTranscriptsDescription: {
        id: "OlM3tz",
        defaultMessage: "Allow members to reference past notes and transcripts in ChatGPT Record."
    },
    deepResearchTitle: {
        id: "xd3kLo",
        defaultMessage: "Deep research"
    },
    deepResearchDescription: {
        id: "b5K/+B",
        defaultMessage: "Lets users run in-depth research with web-connected and multi-step reasoning tools."
    },
    advanceVoiceTitle: {
        id: "BBl2PG",
        defaultMessage: "Advanced voice capabilities"
    },
    advanceVoiceDescription: {
        id: "Tfn5Vm",
        defaultMessage: "Enables real-time voice interaction with AI, including speech recognition and lifelike responses."
    },
    gptSectionTitle: {
        id: "lDlJlK",
        defaultMessage: "GPTs"
    },
    gptSectionDescription: {
        id: "MMDdKL",
        defaultMessage: "Choose which GPT access this role has"
    },
    gptCrudTitle: {
        id: "ySiNVL",
        defaultMessage: "Create and manage GPTs"
    },
    gptCrudDescription: {
        id: "aCMqKu",
        defaultMessage: "Allow members to create and manage GPTs"
    },
    gptShareWorkspaceTitle: {
        id: "arwdQz",
        defaultMessage: "Publish GPTs to workspace"
    },
    gptShareWorkspaceDescription: {
        id: "O0HyJZ",
        defaultMessage: "Allow members to publish GPTs they own to the workspace GPT Store"
    },
    gptShareExternalTitle: {
        id: "zl4S+n",
        defaultMessage: "Publish GPTs externally"
    },
    gptShareExternalDescription: {
        id: "wXPceF",
        defaultMessage: "Controls ability to share with others outside the org (via email or link)"
    },
    gptAllowAllThirdPartyTitle: {
        id: "ZYlBcx",
        defaultMessage: "Allow all third party GPTs"
    },
    gptAllowAllThirdPartyDescription: {
        id: "NVpEpJ",
        defaultMessage: "If enabled, user will have access to all 3P GPTs"
    },
    gptAllowSpecificThirdPartyTitle: {
        id: "7oaevm",
        defaultMessage: "Allow owner-approved GPTs only"
    },
    gptAllowSpecificThirdPartyDescription: {
        id: "ubkAtB",
        defaultMessage: "If enabled, user will have access to approved 3P GPTs"
    },
    projectSectionTitle: {
        id: "muqJOY",
        defaultMessage: "Projects"
    },
    projectSectionDescription: {
        id: "oDGRtQ",
        defaultMessage: "Choose which project access this role has"
    },
    projectCrudTitle: {
        id: "PDOJ0T",
        defaultMessage: "Create and manage projects"
    },
    projectCrudDescription: {
        id: "MfPKqd",
        defaultMessage: "Allow members to create and manage projects"
    },
    sharingTitle: {
        id: "8DIoJe",
        defaultMessage: "Sharing"
    },
    memoryTitle: {
        id: "h6Ufv3",
        defaultMessage: "Memory"
    },
    memoryDescription: {
        id: "NpeSvG",
        defaultMessage: "Manage whether members can enable memory. This allows ChatGPT to become more helpful by remembering details and preferences across chats. <link>Learn more</link>"
    },
    canvasCodeExecutionTitle: {
        id: "sB8WQp",
        defaultMessage: "Canvas code execution"
    },
    canvasCodeExecutionDescription: {
        id: "kkkA1m",
        defaultMessage: "Allow members to run code snippets within the canvas."
    },
    canvasCodeNetworkAccessTitle: {
        id: "L5mfFJ",
        defaultMessage: "Canvas code network access"
    },
    canvasCodeNetworkAccessDescription: {
        id: "OF7Jbc",
        defaultMessage: "Allow members to execute code with network access within the canvas."
    },
    videoScreenSharingTitle: {
        id: "GSzhi0",
        defaultMessage: "Allow members to share their screen or video while using voice mode"
    },
    videoScreenSharingDescription: {
        id: "WZkcdj",
        defaultMessage: "Allow members to share their screen or video while using voice mode"
    },
    canvasTitle: {
        id: "OuhDUU",
        defaultMessage: "Canvas"
    },
    searchTitle: {
        id: "rY8bdY",
        defaultMessage: "Search"
    },
    voiceTitle: {
        id: "e83f8K",
        defaultMessage: "Voice"
    },
    codex: {
        id: "aOXMaL",
        defaultMessage: "Codex"
    },
    recordAccessTitle: {
        id: "fso8vg",
        defaultMessage: "Allow members to use ChatGPT record."
    },
    appsTitle: {
        id: "DeAoJ2",
        defaultMessage: "Apps"
    },
    shareChatWithWorkspaceTitle: {
        id: "kKfDOF",
        defaultMessage: "Members can share chats with workspace."
    },
    shareChatTitle: {
        id: "x8jgoP",
        defaultMessage: "Allow members to share a chat or canvas with..."
    },
    shareChatProjectTitle: {
        id: "LQ2EVd",
        defaultMessage: "Allow members to share a chat, canvas, or project with..."
    },
    memoryAccessTitle: {
        id: "EVIMwx",
        defaultMessage: "Allow members to use memory"
    },
    chatRetentionPolicyTitle: {
        id: "HOkfAn",
        defaultMessage: "Chat retention policy"
    },
    chatRetentionPolicyDescription: {
        id: "b5pfhv",
        defaultMessage: "Contact your account manager to change this setting."
    },
    githubConnectorDescription: {
        id: "bN9L7e",
        defaultMessage: "Codex requires the GitHub connector.{br}You can enable or disable it in <settingsLink>Connector Settings</settingsLink>"
    },
    workWithAppsTitle: {
        id: "GDQEgW",
        defaultMessage: "Allow work with apps"
    },
    workWithAppsDescription: {
        id: "tZymPd",
        defaultMessage: "Control whether users in this workspace can enable ChatGPT to work with apps. This allows ChatGPT to read and edit the content of specific apps on their desktop to provide better responses. <link>Learn more</link>"
    },
    appleIntelligenceTitle: {
        id: "b5tisR",
        defaultMessage: "Allow members to link Apple Intelligence"
    },
    appleIntelligenceDescription: {
        id: "b2Jsop",
        defaultMessage: "Manage whether members can link with Apple Intelligence."
    },
    appleIntelligenceMDMTitle: {
        id: "0wNa7q",
        defaultMessage: "Apple Intelligence MDM"
    },
    appleIntelligenceMDMDescription: {
        id: "ZgxOdq",
        defaultMessage: "Only allow linking this workspace with Apple Intelligence on MDM managed devices."
    },
    imageGenSectionTitle: {
        id: "fKZG6M",
        defaultMessage: "Images"
    },
    mdmSectionTitle: {
        id: "jh/ICj",
        defaultMessage: "MDM"
    },
    mdmDisableCopyPasteTitle: {
        id: "iby11U",
        defaultMessage: "Disable copy and paste"
    },
    mdmDisableFileUploadTitle: {
        id: "4Mdk8I",
        defaultMessage: "Disable file upload"
    },
    mdmDisableFileDownloadTitle: {
        id: "S75iuY",
        defaultMessage: "Disable file download"
    },
    mdmRequirePinUnlockTitle: {
        id: "DAUS4M",
        defaultMessage: "Require PIN unlock"
    },
    mdmRequireBiometricUnlockTitle: {
        id: "8rpAr5",
        defaultMessage: "Require biometric unlock"
    },
    agentModeTitle: {
        id: "t4P9Ws",
        defaultMessage: "Agent mode"
    },
    agentModeDescription: {
        id: "rE0L/V",
        defaultMessage: "Allow members to use agent mode. <link>Learn more</link>"
    },
    agentModeDisabledReason: {
        id: "/E6A5q",
        defaultMessage: "Agent mode is disabled because Web search is not enabled."
    },
    deepResearchDisabledReason: {
        id: "QvYF92",
        defaultMessage: "Deep research is disabled because Web search is not enabled."
    },
    connectedDataSectionTitle: {
        id: "QE+kpm",
        defaultMessage: "Connected data"
    },
    createMcpConnectorTitle: {
        id: "g4npER",
        defaultMessage: "Create custom MCP connectors"
    },
    connectorRoleTitle: {
        id: "jeAMAA",
        defaultMessage: "Allow members to use connectors"
    }
});
var rc = (e => (e.GPT5ThinkingAccess = "chatgpt.workspace.model.GPT-5-reasoning.access",
e.GPT5ThinkingProAccess = "chatgpt.workspace.model.GPT-5-pro.access",
e.GPT5ThinkingMiniAccess = "chatgpt.workspace.model.GPT-5-reasoning-mini.access",
e.GPT41Access = "chatgpt.workspace.model.GPT-4.1.access",
e.GPT45Access = "chatgpt.workspace.model.GPT-4.5.access",
e.GPTO3Access = "chatgpt.workspace.model.o3.access",
e.GPTO3ProAccess = "chatgpt.workspace.model.o3-pro.access",
e.GPTO4MiniAccess = "chatgpt.workspace.model.o4-mini.access",
e.GPTO4MiniHighAccess = "chatgpt.workspace.model.o4-mini-high.access",
e.CrudGPT = "chatgpt.workspace.gpt.crud",
e.ShareWorkspaceGPT = "chatgpt.workspace.gpt.share_workspace",
e.ShareExternalGPT = "chatgpt.workspace.gpt.share_external",
e.AllowAllThirdPartyGPT = "chatgpt.workspace.gpt.allow_all_third_party",
e.AllowSpecificThirdPartyGPT = "chatgpt.workspace.gpt.allow_specific_third_party",
e.CrudProject = "chatgpt.workspace.project.crud",
e.ShareChatWithWorkspace = "chatgpt.workspace.feature.share-chat-with-workspace.access",
e.AllowCodexAccess = "chatgpt.workspace.feature.allow-codex-access.access",
e.AllowCodexLocalAccess = "chatgpt.workspace.feature.allow-codex-local-access.access",
e.CodexAgentNetworkAccess = "chatgpt.workspace.feature.codex-agent-network-access.access",
e.ImageGenAccess = "chatgpt.workspace.feature.image-gen.access",
e.SearchAccess = "chatgpt.workspace.feature.search.access",
e.DeepResearchAccess = "chatgpt.workspace.feature.deep-research.access",
e.VoiceAccess = "chatgpt.workspace.feature.voice.access",
e.HiveAccess = "chatgpt.workspace.feature.hive.access",
e.HiveKnowledgeRetrievalAccess = "chatgpt.workspace.feature.hive-knowledge-retrieval.access",
e.MemoryAccess = "chatgpt.workspace.feature.memory.access",
e.CanvasCodeExecutionAccess = "chatgpt.workspace.feature.canvas-code-execution.access",
e.CanvasCodeNetworkAccess = "chatgpt.workspace.feature.canvas-code-network-access.access",
e.VideoScreenSharingAccess = "chatgpt.workspace.feature.video-screen-sharing.access",
e.AppPairingAccess = "chatgpt.workspace.feature.app-pairing.access",
e.ClientApplicationAppleAccess = "chatgpt.workspace.feature.client-application-apple.access",
e.AgentModeAccess = "chatgpt.workspace.feature.agent-mode.access",
e.CreateMcpConnector = "chatgpt.workspace.connector.mcp.create",
e.UseConnector = "chatgpt.workspace_connector.use",
e))(rc || {});
const age = ({isRbacEnabled: e, isSharedProjectsEnabled: t, includeBetaSettingsAdvanced: n}) => ({
    title: K.sharingTitle,
    entries: [...n && e ? [{
        rbac: !0,
        title: K.shareChatWithWorkspaceTitle,
        permissionName: "chatgpt.workspace.feature.share-chat-with-workspace.access"
    }] : [{
        rbac: !1,
        title: t ? K.shareChatProjectTitle : K.shareChatTitle,
        settingName: "share_chat"
    }]]
})
  , lge = () => ({
    title: K.memoryTitle,
    availableForQuorum: !0,
    entries: [{
        rbac: !1,
        title: K.memoryAccessTitle,
        description: K.memoryDescription,
        descriptionValues: {
            link: e => g.jsx(gu, {
                chunk: e,
                href: "https://help.openai.com/en/articles/8590148-memory-in-chatgpt-faq"
            })
        },
        settingName: "memory_access"
    }, {
        rbac: !1,
        title: K.chatRetentionPolicyTitle,
        description: K.chatRetentionPolicyDescription,
        settingName: "rentention_policy"
    }]
})
  , cge = ({isRbacEnabled: e, includeBetaSettingsAdvanced: t}) => ({
    title: K.canvasTitle,
    availableForQuorum: !0,
    entries: e && t ? [{
        rbac: !0,
        title: K.canvasCodeExecutionTitle,
        description: K.canvasCodeExecutionDescription,
        permissionName: "chatgpt.workspace.feature.canvas-code-execution.access"
    }, {
        rbac: !0,
        title: K.canvasCodeNetworkAccessTitle,
        description: K.canvasCodeNetworkAccessDescription,
        permissionName: "chatgpt.workspace.feature.canvas-code-network-access.access"
    }] : [{
        rbac: !1,
        title: K.canvasCodeExecutionTitle,
        description: K.canvasCodeExecutionDescription,
        settingName: "canvas_code_execution"
    }, {
        rbac: !1,
        title: K.canvasCodeNetworkAccessTitle,
        description: K.canvasCodeNetworkAccessDescription,
        settingName: "canvas_code_network_access"
    }]
})
  , uge = ({isCBP: e, isRbacEnabled: t, showDeepResearchToggle: n, includeBetaSettings: r, includeFeatures: s, includeAgentMode: o, isQuorum: i, isSearchEnabled: a}) => ({
    title: K.searchTitle,
    availableForQuorum: !0,
    entries: [...r && t ? [{
        rbac: !0,
        title: K.webSearchTitle,
        description: i ? K.webSearchDescriptionOfflineOnly : K.webSearchDescription,
        descriptionValues: {
            link: l => g.jsx(gu, {
                chunk: l,
                href: "https://help.openai.com/en/articles/10093903-chatgpt-search-for-enterprise-and-edu"
            })
        },
        permissionName: "chatgpt.workspace.feature.search.access"
    }] : [{
        rbac: !1,
        title: K.webSearchTitle,
        description: i ? K.webSearchDescriptionOfflineOnly : K.webSearchDescription,
        descriptionValues: {
            link: l => g.jsx(gu, {
                chunk: l,
                href: "https://help.openai.com/en/articles/10093903-chatgpt-search-for-enterprise-and-edu"
            })
        },
        settingName: "web_search"
    }], ...n ? s || !e ? [{
        rbac: !0,
        title: K.deepResearchTitle,
        description: K.deepResearchDescription,
        permissionName: "chatgpt.workspace.feature.deep-research.access",
        disabled: !a,
        disabledReason: a ? void 0 : K.deepResearchDisabledReason
    }] : [] : [], ...o ? [{
        rbac: !0,
        title: K.agentModeTitle,
        description: K.agentModeDescription,
        descriptionValues: {
            link: l => g.jsx(gu, {
                chunk: l,
                href: "https://help.openai.com/en/articles/11752874-chatgpt-agent"
            })
        },
        permissionName: "chatgpt.workspace.feature.agent-mode.access",
        disabled: !a,
        disabledReason: a ? void 0 : K.agentModeDisabledReason
    }] : []]
})
  , dge = {
    title: K.imageGenSectionTitle,
    availableForQuorum: !0,
    entries: [{
        rbac: !0,
        title: K.imageGenTitle,
        description: K.imageGenDescription,
        permissionName: "chatgpt.workspace.feature.image-gen.access"
    }]
}
  , fge = ({isRbacEnabled: e, includeFeatures: t, includeBetaSettingsAdvanced: n}) => ({
    title: K.voiceTitle,
    availableForQuorum: !0,
    entries: [...t && e ? [{
        rbac: !0,
        title: K.advanceVoiceTitle,
        description: K.advanceVoiceDescription,
        permissionName: "chatgpt.workspace.feature.voice.access"
    }] : [], ...n && e ? [{
        rbac: !0,
        title: K.videoScreenSharingTitle,
        description: K.videoScreenSharingDescription,
        permissionName: "chatgpt.workspace.feature.video-screen-sharing.access"
    }] : [{
        rbac: !1,
        title: K.videoScreenSharingTitle,
        description: K.videoScreenSharingDescription,
        settingName: "video_screen_sharing"
    }]]
})
  , hge = ({isRbacEnabled: e, showAgentInternetAccessToggle: t, includeBetaSettings: n, githubConnectorEnabled: r, isCodexEnabledInRBACRole: s}) => {
    const o = !r && !s;
    return {
        title: K.codex,
        availableForQuorum: !1,
        entries: [{
            rbac: !0,
            title: "GitHub",
            description: K.githubConnectorDescription,
            descriptionValues: {
                br: g.jsx("br", {}),
                settingsLink: i => g.jsx(Bf, {
                    to: "/admin/ca",
                    className: "underline",
                    children: i
                })
            },
            permissionName: "codex_github_connector"
        }, ...n && e ? [{
            rbac: !0,
            title: K.codexTitle,
            description: K.codexDescription,
            permissionName: "chatgpt.workspace.feature.allow-codex-access.access",
            disabled: o,
            disabledReason: o ? K.disabledReasonGithub : void 0
        }, {
            rbac: !0,
            title: K.codexCliTitle,
            description: K.codexCliDescription,
            permissionName: "chatgpt.workspace.feature.allow-codex-local-access.access"
        }] : [{
            rbac: !1,
            title: K.codexTitle,
            description: K.codexDescription,
            settingName: "codex_access"
        }, {
            rbac: !1,
            title: K.codexCliTitle,
            description: K.codexCliDescription,
            settingName: "codex_local_access"
        }], ...t ? n && e ? [{
            rbac: !0,
            title: K.codexAgentNetworkTitle,
            description: K.codexAgentNetworkDescription,
            permissionName: "chatgpt.workspace.feature.codex-agent-network-access.access"
        }] : [{
            rbac: !1,
            title: K.codexAgentNetworkTitle,
            description: K.codexAgentNetworkDescription,
            settingName: "codex_agent_network"
        }] : []]
    }
}
  , pge = ({isRbacEnabled: e, isInSupportedDrRegion: t, includeBetaSettings: n}) => ({
    title: K.recordTitle,
    availableForEnterprise: !0,
    availableForQuorum: !0,
    description: K.recordDescription,
    descriptionValues: {
        link: r => g.jsx(gu, {
            chunk: r,
            href: "https://help.openai.com/en/articles/11487532"
        })
    },
    entries: n && e ? [{
        rbac: !0,
        title: K.recordAccessTitle,
        permissionName: "chatgpt.workspace.feature.hive.access"
    }, ...t ? [{
        rbac: !0,
        title: K.recordReferencePastTranscriptsTitle,
        description: K.recordReferencePastTranscriptsDescription,
        permissionName: "chatgpt.workspace.feature.hive-knowledge-retrieval.access"
    }] : []] : [{
        rbac: !1,
        title: K.recordAccessTitle,
        settingName: "record_access"
    }, ...t ? [{
        rbac: !1,
        title: K.recordReferencePastTranscriptsTitle,
        description: K.recordReferencePastTranscriptsDescription,
        settingName: "record_reference_past_transcripts"
    }] : []]
})
  , mge = ({isAppleIntelligenceToggleEnabled: e, isAppleIntelligenceMdmToggleEnabled: t}) => ({
    title: K.appsTitle,
    availableForQuorum: !0,
    entries: [{
        rbac: !1,
        title: K.workWithAppsTitle,
        description: K.workWithAppsDescription,
        descriptionValues: {
            link: n => g.jsx(gu, {
                chunk: n,
                href: "https://help.openai.com/en/articles/10119604-work-with-apps-on-macos"
            })
        },
        settingName: "apps_access"
    }, ...e ? [{
        rbac: !1,
        title: K.appleIntelligenceTitle,
        description: K.appleIntelligenceDescription,
        settingName: "apple_intelligence_access"
    }] : [], ...e && t ? [{
        rbac: !1,
        title: K.appleIntelligenceMDMTitle,
        description: K.appleIntelligenceMDMDescription,
        settingName: "apple_intelligence_mdm_access"
    }] : []]
})
  , gge = ({isRbacEnabled: e, includeModels: t, legacyModelsEnabled: n, isEnterprisey: r, includeThinkingMini: s}) => ({
    title: K.modelsTitle,
    availableForEnterprise: !0,
    availableForQuorum: !0,
    description: K.modelsDescription,
    entries: [...s && e ? [{
        rbac: !0,
        title: "GPT-5 Thinking Mini",
        description: K.gpt5ThinkingMiniDescription,
        permissionName: "chatgpt.workspace.model.GPT-5-reasoning-mini.access"
    }] : [], ...t && e ? [{
        rbac: !0,
        title: "GPT-5 Thinking",
        description: K.gpt5ThinkingDescription,
        permissionName: "chatgpt.workspace.model.GPT-5-reasoning.access"
    }, {
        rbac: !0,
        title: "GPT-5 Pro",
        description: K.gpt5ThinkingProDescription,
        permissionName: "chatgpt.workspace.model.GPT-5-pro.access"
    }] : [], ...r ? [{
        rbac: !1,
        title: K.legacyModelsTitle,
        description: K.legacyModelsDescription,
        settingName: "legacy_models"
    }] : [{
        rbac: !1,
        title: K.additionalModelsTitle,
        description: K.additionalModelsDescription,
        settingName: "legacy_models"
    }], ...t && e && n ? [{
        rbac: !0,
        title: "GPT-4.1",
        description: K.gpt41Description,
        permissionName: "chatgpt.workspace.model.GPT-4.1.access"
    }, {
        rbac: !0,
        title: "o3",
        description: K.gptO3Description,
        permissionName: "chatgpt.workspace.model.o3.access"
    }, {
        rbac: !0,
        title: "o4-mini",
        description: K.gptO4MiniDescription,
        permissionName: "chatgpt.workspace.model.o4-mini.access"
    }] : []]
})
  , vge = () => ({
    title: K.gptSectionTitle,
    availableForQuorum: !0,
    description: K.gptSectionDescription,
    entries: [{
        rbac: !0,
        title: K.gptCrudTitle,
        description: K.gptCrudDescription,
        permissionName: "chatgpt.workspace.gpt.crud"
    }, {
        rbac: !0,
        title: K.gptShareWorkspaceTitle,
        description: K.gptShareWorkspaceDescription,
        permissionName: "chatgpt.workspace.gpt.share_workspace"
    }, {
        rbac: !0,
        disabledForQuorum: !0,
        title: K.gptShareExternalTitle,
        description: K.gptShareExternalDescription,
        permissionName: "chatgpt.workspace.gpt.share_external"
    }, {
        rbac: !0,
        disabledForQuorum: !0,
        title: K.gptAllowAllThirdPartyTitle,
        description: K.gptAllowAllThirdPartyDescription,
        permissionName: "chatgpt.workspace.gpt.allow_all_third_party"
    }, {
        rbac: !0,
        disabledForQuorum: !0,
        title: K.gptAllowSpecificThirdPartyTitle,
        description: K.gptAllowSpecificThirdPartyDescription,
        permissionName: "chatgpt.workspace.gpt.allow_specific_third_party"
    }]
})
  , _ge = () => ({
    title: K.projectSectionTitle,
    availableForQuorum: !0,
    description: K.projectSectionDescription,
    entries: [{
        rbac: !0,
        title: K.projectCrudTitle,
        description: K.projectCrudDescription,
        permissionName: "chatgpt.workspace.project.crud"
    }]
})
  , yge = {
    title: K.mdmSectionTitle,
    entries: [{
        rbac: !0,
        title: K.mdmDisableCopyPasteTitle,
        permissionName: "chatgpt.workspace.mdm.disable_copy_paste"
    }, {
        rbac: !0,
        title: K.mdmDisableFileUploadTitle,
        permissionName: "chatgpt.workspace.mdm.disable_file_transfer.upload"
    }, {
        rbac: !0,
        title: K.mdmDisableFileDownloadTitle,
        permissionName: "chatgpt.workspace.mdm.disable_file_transfer.download"
    }]
}
  , bge = () => ({
    title: K.connectedDataSectionTitle,
    entries: [{
        rbac: !0,
        title: K.connectorRoleTitle,
        permissionName: "chatgpt.workspace_connector.use",
        nestedKey: "chatgpt.workspace_connector.use"
    }, {
        rbac: !0,
        title: K.createMcpConnectorTitle,
        permissionName: "chatgpt.workspace.connector.mcp.create"
    }]
});
function dOe({isCBP: e, isRbacEnabled: t, githubConnectorEnabled: n, isInSupportedDrRegion: r, includeFeatures: s, includeModels: o, isSharedProjectsEnabled: i, isCanvasEnabled: a, isSearchEnabled: l, isEnterprisey: c, showHiveToggle: u, showDeepResearchToggle: d, includeBetaSettings: f, includeBetaSettingsAdvanced: p, includeGizmoPermissions: m, showAgentInternetAccessToggle: v, isAppleIntelligenceToggleEnabled: _, isAppleIntelligenceMdmToggleEnabled: y, isMDMEnabled: b, includeAgentMode: S, isQuorum: C, legacyModelsEnabled: w, includeConnectorPermissions: x, includeThinkingMini: E, isCodexEnabledInRBACRole: T}) {
    return [age({
        isRbacEnabled: t,
        isSharedProjectsEnabled: i,
        includeBetaSettingsAdvanced: p
    }), lge(), ...a ? [cge({
        isRbacEnabled: t,
        includeBetaSettingsAdvanced: p
    })] : [], uge({
        isCBP: e,
        isRbacEnabled: t,
        showDeepResearchToggle: d,
        includeBetaSettings: f,
        includeFeatures: s,
        includeAgentMode: S,
        isQuorum: C,
        isSearchEnabled: l
    }), ...s && t ? [dge] : [], fge({
        isRbacEnabled: t,
        includeFeatures: s,
        includeBetaSettingsAdvanced: p
    }), ...c ? [hge({
        isRbacEnabled: t,
        showAgentInternetAccessToggle: v,
        includeBetaSettings: f,
        githubConnectorEnabled: n,
        isCodexEnabledInRBACRole: T
    })] : [], ...u ? [pge({
        isRbacEnabled: t,
        isInSupportedDrRegion: r,
        includeBetaSettings: f
    })] : [], mge({
        isAppleIntelligenceToggleEnabled: _,
        isAppleIntelligenceMdmToggleEnabled: y
    }), gge({
        isRbacEnabled: t,
        includeModels: o,
        legacyModelsEnabled: w,
        isEnterprisey: c,
        includeThinkingMini: E
    }), ...t && m ? [vge()] : [], ...t && m ? [_ge()] : [], ...t && b ? [yge] : [], ...t && x ? [bge()] : []]
}
const fOe = () => {
    const e = ue();
    return Xe(e, "1355972088")
}
  , po = () => {
    const e = ue();
    return Vn(e, "2826703856")
}
  , hOe = () => po().get("self_serve_page_enabled", !1)
  , pOe = () => po().get("models_display_in_rbac_page", !1)
  , mOe = () => po().get("features_display_in_rbac_page", !1)
  , gOe = () => po().get("beta_settings_display_in_rbac_page", !1)
  , vOe = () => po().get("beta_settings_display_in_rbac_page_advanced", !1)
  , _Oe = () => po().get("gpt_settings_display_in_rbac_page", !1)
  , Cge = () => po().get("enable_gpt_fe_controls", !1)
  , Sge = () => po().get("enable_project_fe_controls", !1)
  , yOe = () => po().get("enable_combined_rbac_page", !1)
  , bOe = () => {
    const e = ue();
    return Xe(e, "1277555238")
}
  , COe = () => po().get("enable_agent_mode", !1)
  , SOe = () => po().get("enable_thinking_mini", !1)
  , wOe = () => {
    const e = ue();
    return Xe(e, "2401070674")
}
  , u4 = e => {
    const t = ir()
      , n = t?.getWorkspaceId()
      , r = Sge()
      , {data: s, isLoading: o} = n1(n);
    if (!t?.isWorkspaceAccount())
        return {
            hasWorkspacePermission: !0,
            isLoading: !1
        };
    const i = s?.permissions?.includes(e) ?? !1;
    return {
        hasWorkspacePermission: r ? i : !0,
        isLoading: o
    }
}
  , EOe = () => {
    const {hasWorkspacePermission: e, isLoading: t} = u4(rc.CrudProject);
    return {
        canCreate: e,
        isLoading: t
    }
}
  , xOe = e => {
    const {hasWorkspacePermission: t, isLoading: n} = u4(rc.CrudProject);
    return {
        canEdit: (t && e?.gizmo.current_user_permission?.can_write) ?? !1,
        isLoading: n
    }
}
  , TOe = e => {
    const {hasWorkspacePermission: t, isLoading: n} = u4(rc.CrudProject);
    return {
        canDelete: (t && e?.gizmo.current_user_permission?.can_delete) ?? !1,
        isLoading: n
    }
}
;
function Mi(e) {
    return e.slice(0, 4) === "g-p-"
}
function wge(e) {
    return e != null && !Mi(e)
}
function kOe(e, t) {
    return !wge(e) && !t
}
function WB(e) {
    return Mi(e.gizmo.id)
}
function OOe(e, t) {
    return !(Wt.getItem(Ft.TasksHasSeenProjectDisclaimerBanner) != null) && e === ige && WB(t) && t.files.length > 0
}
const KB = en( () => Ct({}));
var Eb, SO;
function Ege() {
    if (SO)
        return Eb;
    SO = 1;
    function e(t) {
        return t !== t
    }
    return Eb = e,
    Eb
}
var xb, wO;
function xge() {
    if (wO)
        return xb;
    wO = 1;
    function e(t, n, r) {
        for (var s = r - 1, o = t.length; ++s < o; )
            if (t[s] === n)
                return s;
        return -1
    }
    return xb = e,
    xb
}
var Tb, EO;
function Tge() {
    if (EO)
        return Tb;
    EO = 1;
    var e = ZL()
      , t = Ege()
      , n = xge();
    function r(s, o, i) {
        return o === o ? n(s, o, i) : e(s, t, i)
    }
    return Tb = r,
    Tb
}
var kb, xO;
function kge() {
    if (xO)
        return kb;
    xO = 1;
    var e = Tge();
    function t(n, r) {
        var s = n == null ? 0 : n.length;
        return !!s && e(n, r, 0) > -1
    }
    return kb = t,
    kb
}
var Ob, TO;
function Oge() {
    if (TO)
        return Ob;
    TO = 1;
    function e(t, n, r) {
        for (var s = -1, o = t == null ? 0 : t.length; ++s < o; )
            if (r(n, t[s]))
                return !0;
        return !1
    }
    return Ob = e,
    Ob
}
var Ab, kO;
function Age() {
    if (kO)
        return Ab;
    kO = 1;
    var e = TL()
      , t = QP()
      , n = V6()
      , r = 1 / 0
      , s = e && 1 / n(new e([, -0]))[1] == r ? function(o) {
        return new e(o)
    }
    : t;
    return Ab = s,
    Ab
}
var Mb, OO;
function Mge() {
    if (OO)
        return Mb;
    OO = 1;
    var e = gL()
      , t = kge()
      , n = Oge()
      , r = vL()
      , s = Age()
      , o = V6()
      , i = 200;
    function a(l, c, u) {
        var d = -1
          , f = t
          , p = l.length
          , m = !0
          , v = []
          , _ = v;
        if (u)
            m = !1,
            f = n;
        else if (p >= i) {
            var y = c ? null : s(l);
            if (y)
                return o(y);
            m = !1,
            f = r,
            _ = new e
        } else
            _ = c ? [] : v;
        e: for (; ++d < p; ) {
            var b = l[d]
              , S = c ? c(b) : b;
            if (b = u || b !== 0 ? b : 0,
            m && S === S) {
                for (var C = _.length; C--; )
                    if (_[C] === S)
                        continue e;
                c && _.push(S),
                v.push(b)
            } else
                f(_, S, u) || (_ !== v && _.push(S),
                v.push(b))
        }
        return v
    }
    return Mb = a,
    Mb
}
var Ib, AO;
function Ige() {
    if (AO)
        return Ib;
    AO = 1;
    var e = Mge();
    function t(n) {
        return n && n.length ? e(n) : []
    }
    return Ib = t,
    Ib
}
var Rge = Ige();
const Nge = mn(Rge)
  , Pge = "hints"
  , Dge = "system_hints";
function X5(e) {
    const t = [Pge, Dge].flatMap(n => e.getAll(n)).flatMap(n => n.split(",")).flatMap(n => {
        const r = wQ(n);
        return r ? [r] : []
    }
    );
    return Nge(t)
}
var Q5 = (e => (e.Hover = "hover",
e.Enable = "enable",
e.Disable = "disable",
e))(Q5 || {});
const Lge = new Map([[xe.Search, {
    hover: ["Composer Search Button Hovered", "composer_search_button_hovered"],
    enable: ["Composer Search Button Clicked", "composer_search_button_clicked"],
    disable: ["Composer Search Button Clicked", "composer_search_button_clicked"]
}], [xe.Think, {
    hover: ["Composer Think Button Hovered", "composer_think_button_hovered"],
    enable: ["Composer Think Button Enabled", "composer_think_button_enabled"],
    disable: ["Composer Think Button Disabled", "composer_think_button_disabled"]
}], [xe.Research, {
    hover: ["Composer Research Button Hovered", "composer_research_button_hovered"],
    enable: ["Composer Research Button Enabled", "composer_research_button_enabled"],
    disable: ["Composer Research Button Disabled", "composer_research_button_disabled"]
}], [xe.Agent, {
    hover: ["Composer Agent System Hint Button Hovered", "composer_agent_system_hint_button_hovered"],
    enable: ["Composer Agent System Hint Button Enabled", "composer_agent_system_hint_button_enabled"],
    disable: ["Composer Agent System Hint Button Disabled", "composer_agent_system_hint_button_disabled"]
}], [xe.PictureV2, {
    hover: ["Composer Create Image Button Hovered", "composer_create_image_button_hovered"],
    enable: ["Composer Create Image Button Enabled", "composer_create_image_button_enabled"],
    disable: ["Composer Create Image Button Disabled", "composer_create_image_button_disabled"]
}], [xe.Slurm, {
    hover: ["Composer Slurm Button Hovered", "composer_slurm_button_hovered"],
    enable: ["Composer Slurm Button Enabled", "composer_slurm_button_enabled"],
    disable: ["Composer Slurm Button Disabled", "composer_slurm_button_disabled"]
}]]);
function MO(e, t, n) {
    const [r,s] = Lge.get(e)?.[t] ?? [];
    r && s && V.logEventWithStatsig(r, s, n)
}
const Fge = e => h.createElement("svg", {
    width: 20,
    height: 20,
    viewBox: "0 0 20 20",
    fill: "currentColor",
    xmlns: "http://www.w3.org/2000/svg",
    ...e
}, h.createElement("path", {
    d: "M10.3227 1.62663C11.1514 1.62663 11.9182 2.066 12.3373 2.78092L13.1586 4.18131L13.2123 4.25065C13.2735 4.31105 13.3565 4.34658 13.4448 4.34733L15.06 4.36002L15.2143 4.36686C15.9825 4.4239 16.6774 4.85747 17.0649 5.53092L17.393 6.10221L17.4662 6.23795C17.7814 6.88041 17.7842 7.63306 17.4741 8.27799L17.4028 8.41373L16.6 9.83561C16.5426 9.93768 16.5425 10.0627 16.6 10.1647L17.4028 11.5856L17.4741 11.7223C17.7841 12.3673 17.7815 13.1199 17.4662 13.7624L17.393 13.8981L17.0649 14.4694C16.6774 15.1427 15.9824 15.5764 15.2143 15.6335L15.06 15.6393L13.4448 15.653C13.3565 15.6537 13.2736 15.6892 13.2123 15.7497L13.1586 15.818L12.3373 17.2194C11.9182 17.9342 11.1513 18.3737 10.3227 18.3737H9.6762C8.8995 18.3735 8.17705 17.9874 7.74456 17.3503L7.66253 17.2194L6.84124 15.818C6.79652 15.7418 6.72408 15.6876 6.64105 15.6647L6.55511 15.653L4.93987 15.6393C4.16288 15.633 3.44339 15.2413 3.01605 14.6003L2.93499 14.4694L2.60687 13.8981C2.19555 13.1831 2.1916 12.3039 2.5971 11.5856L3.39886 10.1647L3.43206 10.0846C3.44649 10.0293 3.44644 9.97102 3.43206 9.91569L3.39886 9.83561L2.5971 8.41373C2.19175 7.6955 2.19562 6.8171 2.60687 6.10221L2.93499 5.53092L3.01605 5.40006C3.44337 4.75894 4.1628 4.36636 4.93987 4.36002L6.55511 4.34733L6.64105 4.33561C6.72418 4.31275 6.79651 4.25762 6.84124 4.18131L7.66253 2.78092L7.74456 2.65006C8.17704 2.01277 8.89941 1.62678 9.6762 1.62663H10.3227ZM9.6762 2.9567C9.36439 2.95685 9.07299 3.10138 8.88421 3.34342L8.80999 3.45377L7.9887 4.85416C7.72933 5.29669 7.28288 5.59093 6.78265 5.6608L6.56585 5.67741L4.95062 5.6901C4.63868 5.69265 4.34845 5.84001 4.16155 6.08366L4.08733 6.19401L3.75921 6.7653C3.58227 7.073 3.5808 7.45131 3.7553 7.76041L4.55706 9.18131L4.65179 9.37663C4.81309 9.77605 4.81294 10.2232 4.65179 10.6227L4.55706 10.819L3.7553 12.2399C3.58083 12.549 3.5822 12.9273 3.75921 13.235L4.08733 13.8053L4.16155 13.9157C4.34844 14.1596 4.6385 14.3067 4.95062 14.3092L6.56585 14.3229L6.78265 14.3385C7.28292 14.4084 7.72931 14.7036 7.9887 15.1462L8.80999 16.5465L8.88421 16.6559C9.07298 16.8982 9.36422 17.0435 9.6762 17.0436H10.3227C10.6793 17.0436 11.0095 16.8542 11.1899 16.5465L12.0112 15.1462L12.1332 14.9655C12.4432 14.5668 12.9212 14.3271 13.434 14.3229L15.0492 14.3092L15.1811 14.2995C15.4854 14.2567 15.7569 14.076 15.9125 13.8053L16.2407 13.235L16.2983 13.1169C16.3983 12.8745 16.3999 12.6023 16.3022 12.359L16.2446 12.2399L15.4418 10.819C15.1551 10.311 15.1551 9.6893 15.4418 9.18131L16.2446 7.76041L16.3022 7.64127C16.4 7.39806 16.3982 7.12584 16.2983 6.88346L16.2407 6.7653L15.9125 6.19401C15.7568 5.92338 15.4855 5.74264 15.1811 5.69987L15.0492 5.6901L13.434 5.67741C12.9212 5.67322 12.4432 5.43341 12.1332 5.03483L12.0112 4.85416L11.1899 3.45377C11.0095 3.14604 10.6794 2.9567 10.3227 2.9567H9.6762ZM11.5854 9.99967C11.5852 9.12461 10.8755 8.41497 10.0004 8.41471C9.12516 8.41471 8.41466 9.12445 8.41448 9.99967C8.41448 10.875 9.12505 11.5846 10.0004 11.5846C10.8756 11.5844 11.5854 10.8749 11.5854 9.99967ZM12.9145 9.99967C12.9145 11.6094 11.6101 12.9145 10.0004 12.9147C8.39051 12.9147 7.08538 11.6096 7.08538 9.99967C7.08556 8.38991 8.39062 7.08463 10.0004 7.08463C11.61 7.08489 12.9143 8.39007 12.9145 9.99967Z"
}))
  , jge = ({icon: e, title: t, description: n, statusIndicator: r, showGitHubConfigure: s}) => {
    const o = Jae("installations/select_target");
    return g.jsxs("div", {
        className: "flex w-full items-center justify-between gap-4",
        children: [g.jsxs("div", {
            className: "me-4 flex items-center gap-3 text-start text-sm",
            children: [e, n ? g.jsxs("div", {
                className: "flex min-w-0 flex-1 flex-col",
                children: [t, g.jsx("div", {
                    className: "text-token-text-secondary text-xs",
                    children: n
                })]
            }) : t]
        }), s && g.jsx(an, {
            onClick: () => {
                window.open(o, "_blank")
            }
            ,
            color: "secondary",
            size: "small",
            children: g.jsx(Fge, {
                className: "icon-sm"
            })
        }), r]
    })
}
;
function AOe(e, t) {
    const n = h.useRef(e);
    h.useEffect( () => {
        n.current = e
    }
    , [e]),
    h.useEffect( () => {
        function r() {
            n.current()
        }
        if (t != null) {
            const s = window.setInterval(r, t);
            return () => clearInterval(s)
        }
    }
    , [t])
}
var am = {
    exports: {}
}, Uge = am.exports, IO;
function Bge() {
    return IO || (IO = 1,
    function(e) {
        (function(t, n, r) {
            function s(l) {
                var c = this
                  , u = a();
                c.next = function() {
                    var d = 2091639 * c.s0 + c.c * 23283064365386963e-26;
                    return c.s0 = c.s1,
                    c.s1 = c.s2,
                    c.s2 = d - (c.c = d | 0)
                }
                ,
                c.c = 1,
                c.s0 = u(" "),
                c.s1 = u(" "),
                c.s2 = u(" "),
                c.s0 -= u(l),
                c.s0 < 0 && (c.s0 += 1),
                c.s1 -= u(l),
                c.s1 < 0 && (c.s1 += 1),
                c.s2 -= u(l),
                c.s2 < 0 && (c.s2 += 1),
                u = null
            }
            function o(l, c) {
                return c.c = l.c,
                c.s0 = l.s0,
                c.s1 = l.s1,
                c.s2 = l.s2,
                c
            }
            function i(l, c) {
                var u = new s(l)
                  , d = c && c.state
                  , f = u.next;
                return f.int32 = function() {
                    return u.next() * 4294967296 | 0
                }
                ,
                f.double = function() {
                    return f() + (f() * 2097152 | 0) * 11102230246251565e-32
                }
                ,
                f.quick = f,
                d && (typeof d == "object" && o(d, u),
                f.state = function() {
                    return o(u, {})
                }
                ),
                f
            }
            function a() {
                var l = 4022871197
                  , c = function(u) {
                    u = String(u);
                    for (var d = 0; d < u.length; d++) {
                        l += u.charCodeAt(d);
                        var f = .02519603282416938 * l;
                        l = f >>> 0,
                        f -= l,
                        f *= l,
                        l = f >>> 0,
                        f -= l,
                        l += f * 4294967296
                    }
                    return (l >>> 0) * 23283064365386963e-26
                };
                return c
            }
            n && n.exports ? n.exports = i : this.alea = i
        }
        )(Uge, e)
    }(am)),
    am.exports
}
var lm = {
    exports: {}
}, qge = lm.exports, RO;
function Gge() {
    return RO || (RO = 1,
    function(e) {
        (function(t, n, r) {
            function s(a) {
                var l = this
                  , c = "";
                l.x = 0,
                l.y = 0,
                l.z = 0,
                l.w = 0,
                l.next = function() {
                    var d = l.x ^ l.x << 11;
                    return l.x = l.y,
                    l.y = l.z,
                    l.z = l.w,
                    l.w ^= l.w >>> 19 ^ d ^ d >>> 8
                }
                ,
                a === (a | 0) ? l.x = a : c += a;
                for (var u = 0; u < c.length + 64; u++)
                    l.x ^= c.charCodeAt(u) | 0,
                    l.next()
            }
            function o(a, l) {
                return l.x = a.x,
                l.y = a.y,
                l.z = a.z,
                l.w = a.w,
                l
            }
            function i(a, l) {
                var c = new s(a)
                  , u = l && l.state
                  , d = function() {
                    return (c.next() >>> 0) / 4294967296
                };
                return d.double = function() {
                    do
                        var f = c.next() >>> 11
                          , p = (c.next() >>> 0) / 4294967296
                          , m = (f + p) / (1 << 21);
                    while (m === 0);
                    return m
                }
                ,
                d.int32 = c.next,
                d.quick = d,
                u && (typeof u == "object" && o(u, c),
                d.state = function() {
                    return o(c, {})
                }
                ),
                d
            }
            n && n.exports ? n.exports = i : this.xor128 = i
        }
        )(qge, e)
    }(lm)),
    lm.exports
}
var cm = {
    exports: {}
}, Vge = cm.exports, NO;
function Hge() {
    return NO || (NO = 1,
    function(e) {
        (function(t, n, r) {
            function s(a) {
                var l = this
                  , c = "";
                l.next = function() {
                    var d = l.x ^ l.x >>> 2;
                    return l.x = l.y,
                    l.y = l.z,
                    l.z = l.w,
                    l.w = l.v,
                    (l.d = l.d + 362437 | 0) + (l.v = l.v ^ l.v << 4 ^ (d ^ d << 1)) | 0
                }
                ,
                l.x = 0,
                l.y = 0,
                l.z = 0,
                l.w = 0,
                l.v = 0,
                a === (a | 0) ? l.x = a : c += a;
                for (var u = 0; u < c.length + 64; u++)
                    l.x ^= c.charCodeAt(u) | 0,
                    u == c.length && (l.d = l.x << 10 ^ l.x >>> 4),
                    l.next()
            }
            function o(a, l) {
                return l.x = a.x,
                l.y = a.y,
                l.z = a.z,
                l.w = a.w,
                l.v = a.v,
                l.d = a.d,
                l
            }
            function i(a, l) {
                var c = new s(a)
                  , u = l && l.state
                  , d = function() {
                    return (c.next() >>> 0) / 4294967296
                };
                return d.double = function() {
                    do
                        var f = c.next() >>> 11
                          , p = (c.next() >>> 0) / 4294967296
                          , m = (f + p) / (1 << 21);
                    while (m === 0);
                    return m
                }
                ,
                d.int32 = c.next,
                d.quick = d,
                u && (typeof u == "object" && o(u, c),
                d.state = function() {
                    return o(c, {})
                }
                ),
                d
            }
            n && n.exports ? n.exports = i : this.xorwow = i
        }
        )(Vge, e)
    }(cm)),
    cm.exports
}
var um = {
    exports: {}
}, zge = um.exports, PO;
function $ge() {
    return PO || (PO = 1,
    function(e) {
        (function(t, n, r) {
            function s(a) {
                var l = this;
                l.next = function() {
                    var u = l.x, d = l.i, f, p;
                    return f = u[d],
                    f ^= f >>> 7,
                    p = f ^ f << 24,
                    f = u[d + 1 & 7],
                    p ^= f ^ f >>> 10,
                    f = u[d + 3 & 7],
                    p ^= f ^ f >>> 3,
                    f = u[d + 4 & 7],
                    p ^= f ^ f << 7,
                    f = u[d + 7 & 7],
                    f = f ^ f << 13,
                    p ^= f ^ f << 9,
                    u[d] = p,
                    l.i = d + 1 & 7,
                    p
                }
                ;
                function c(u, d) {
                    var f, p = [];
                    if (d === (d | 0))
                        p[0] = d;
                    else
                        for (d = "" + d,
                        f = 0; f < d.length; ++f)
                            p[f & 7] = p[f & 7] << 15 ^ d.charCodeAt(f) + p[f + 1 & 7] << 13;
                    for (; p.length < 8; )
                        p.push(0);
                    for (f = 0; f < 8 && p[f] === 0; ++f)
                        ;
                    for (f == 8 ? p[7] = -1 : p[f],
                    u.x = p,
                    u.i = 0,
                    f = 256; f > 0; --f)
                        u.next()
                }
                c(l, a)
            }
            function o(a, l) {
                return l.x = a.x.slice(),
                l.i = a.i,
                l
            }
            function i(a, l) {
                a == null && (a = +new Date);
                var c = new s(a)
                  , u = l && l.state
                  , d = function() {
                    return (c.next() >>> 0) / 4294967296
                };
                return d.double = function() {
                    do
                        var f = c.next() >>> 11
                          , p = (c.next() >>> 0) / 4294967296
                          , m = (f + p) / (1 << 21);
                    while (m === 0);
                    return m
                }
                ,
                d.int32 = c.next,
                d.quick = d,
                u && (u.x && o(u, c),
                d.state = function() {
                    return o(c, {})
                }
                ),
                d
            }
            n && n.exports ? n.exports = i : this.xorshift7 = i
        }
        )(zge, e)
    }(um)),
    um.exports
}
var dm = {
    exports: {}
}, Wge = dm.exports, DO;
function Kge() {
    return DO || (DO = 1,
    function(e) {
        (function(t, n, r) {
            function s(a) {
                var l = this;
                l.next = function() {
                    var u = l.w, d = l.X, f = l.i, p, m;
                    return l.w = u = u + 1640531527 | 0,
                    m = d[f + 34 & 127],
                    p = d[f = f + 1 & 127],
                    m ^= m << 13,
                    p ^= p << 17,
                    m ^= m >>> 15,
                    p ^= p >>> 12,
                    m = d[f] = m ^ p,
                    l.i = f,
                    m + (u ^ u >>> 16) | 0
                }
                ;
                function c(u, d) {
                    var f, p, m, v, _, y = [], b = 128;
                    for (d === (d | 0) ? (p = d,
                    d = null) : (d = d + "\0",
                    p = 0,
                    b = Math.max(b, d.length)),
                    m = 0,
                    v = -32; v < b; ++v)
                        d && (p ^= d.charCodeAt((v + 32) % d.length)),
                        v === 0 && (_ = p),
                        p ^= p << 10,
                        p ^= p >>> 15,
                        p ^= p << 4,
                        p ^= p >>> 13,
                        v >= 0 && (_ = _ + 1640531527 | 0,
                        f = y[v & 127] ^= p + _,
                        m = f == 0 ? m + 1 : 0);
                    for (m >= 128 && (y[(d && d.length || 0) & 127] = -1),
                    m = 127,
                    v = 4 * 128; v > 0; --v)
                        p = y[m + 34 & 127],
                        f = y[m = m + 1 & 127],
                        p ^= p << 13,
                        f ^= f << 17,
                        p ^= p >>> 15,
                        f ^= f >>> 12,
                        y[m] = p ^ f;
                    u.w = _,
                    u.X = y,
                    u.i = m
                }
                c(l, a)
            }
            function o(a, l) {
                return l.i = a.i,
                l.w = a.w,
                l.X = a.X.slice(),
                l
            }
            function i(a, l) {
                a == null && (a = +new Date);
                var c = new s(a)
                  , u = l && l.state
                  , d = function() {
                    return (c.next() >>> 0) / 4294967296
                };
                return d.double = function() {
                    do
                        var f = c.next() >>> 11
                          , p = (c.next() >>> 0) / 4294967296
                          , m = (f + p) / (1 << 21);
                    while (m === 0);
                    return m
                }
                ,
                d.int32 = c.next,
                d.quick = d,
                u && (u.X && o(u, c),
                d.state = function() {
                    return o(c, {})
                }
                ),
                d
            }
            n && n.exports ? n.exports = i : this.xor4096 = i
        }
        )(Wge, e)
    }(dm)),
    dm.exports
}
var fm = {
    exports: {}
}, Yge = fm.exports, LO;
function Zge() {
    return LO || (LO = 1,
    function(e) {
        (function(t, n, r) {
            function s(a) {
                var l = this
                  , c = "";
                l.next = function() {
                    var d = l.b
                      , f = l.c
                      , p = l.d
                      , m = l.a;
                    return d = d << 25 ^ d >>> 7 ^ f,
                    f = f - p | 0,
                    p = p << 24 ^ p >>> 8 ^ m,
                    m = m - d | 0,
                    l.b = d = d << 20 ^ d >>> 12 ^ f,
                    l.c = f = f - p | 0,
                    l.d = p << 16 ^ f >>> 16 ^ m,
                    l.a = m - d | 0
                }
                ,
                l.a = 0,
                l.b = 0,
                l.c = -1640531527,
                l.d = 1367130551,
                a === Math.floor(a) ? (l.a = a / 4294967296 | 0,
                l.b = a | 0) : c += a;
                for (var u = 0; u < c.length + 20; u++)
                    l.b ^= c.charCodeAt(u) | 0,
                    l.next()
            }
            function o(a, l) {
                return l.a = a.a,
                l.b = a.b,
                l.c = a.c,
                l.d = a.d,
                l
            }
            function i(a, l) {
                var c = new s(a)
                  , u = l && l.state
                  , d = function() {
                    return (c.next() >>> 0) / 4294967296
                };
                return d.double = function() {
                    do
                        var f = c.next() >>> 11
                          , p = (c.next() >>> 0) / 4294967296
                          , m = (f + p) / (1 << 21);
                    while (m === 0);
                    return m
                }
                ,
                d.int32 = c.next,
                d.quick = d,
                u && (typeof u == "object" && o(u, c),
                d.state = function() {
                    return o(c, {})
                }
                ),
                d
            }
            n && n.exports ? n.exports = i : this.tychei = i
        }
        )(Yge, e)
    }(fm)),
    fm.exports
}
var hm = {
    exports: {}
};
const Jge = {}
  , Xge = Object.freeze(Object.defineProperty({
    __proto__: null,
    default: Jge
}, Symbol.toStringTag, {
    value: "Module"
}))
  , Qge = d$(Xge);
var e1e = hm.exports, FO;
function t1e() {
    return FO || (FO = 1,
    function(e) {
        (function(t, n, r) {
            var s = 256, o = 6, i = 52, a = "random", l = r.pow(s, o), c = r.pow(2, i), u = c * 2, d = s - 1, f;
            function p(C, w, x) {
                var E = [];
                w = w == !0 ? {
                    entropy: !0
                } : w || {};
                var T = y(_(w.entropy ? [C, S(n)] : C ?? b(), 3), E)
                  , k = new m(E)
                  , A = function() {
                    for (var O = k.g(o), M = l, I = 0; O < c; )
                        O = (O + I) * s,
                        M *= s,
                        I = k.g(1);
                    for (; O >= u; )
                        O /= 2,
                        M /= 2,
                        I >>>= 1;
                    return (O + I) / M
                };
                return A.int32 = function() {
                    return k.g(4) | 0
                }
                ,
                A.quick = function() {
                    return k.g(4) / 4294967296
                }
                ,
                A.double = A,
                y(S(k.S), n),
                (w.pass || x || function(O, M, I, R) {
                    return R && (R.S && v(R, k),
                    O.state = function() {
                        return v(k, {})
                    }
                    ),
                    I ? (r[a] = O,
                    M) : O
                }
                )(A, T, "global"in w ? w.global : this == r, w.state)
            }
            function m(C) {
                var w, x = C.length, E = this, T = 0, k = E.i = E.j = 0, A = E.S = [];
                for (x || (C = [x++]); T < s; )
                    A[T] = T++;
                for (T = 0; T < s; T++)
                    A[T] = A[k = d & k + C[T % x] + (w = A[T])],
                    A[k] = w;
                (E.g = function(O) {
                    for (var M, I = 0, R = E.i, D = E.j, P = E.S; O--; )
                        M = P[R = d & R + 1],
                        I = I * s + P[d & (P[R] = P[D = d & D + M]) + (P[D] = M)];
                    return E.i = R,
                    E.j = D,
                    I
                }
                )(s)
            }
            function v(C, w) {
                return w.i = C.i,
                w.j = C.j,
                w.S = C.S.slice(),
                w
            }
            function _(C, w) {
                var x = [], E = typeof C, T;
                if (w && E == "object")
                    for (T in C)
                        try {
                            x.push(_(C[T], w - 1))
                        } catch {}
                return x.length ? x : E == "string" ? C : C + "\0"
            }
            function y(C, w) {
                for (var x = C + "", E, T = 0; T < x.length; )
                    w[d & T] = d & (E ^= w[d & T] * 19) + x.charCodeAt(T++);
                return S(w)
            }
            function b() {
                try {
                    var C;
                    return f && (C = f.randomBytes) ? C = C(s) : (C = new Uint8Array(s),
                    (t.crypto || t.msCrypto).getRandomValues(C)),
                    S(C)
                } catch {
                    var w = t.navigator
                      , x = w && w.plugins;
                    return [+new Date, t, x, t.screen, S(n)]
                }
            }
            function S(C) {
                return String.fromCharCode.apply(0, C)
            }
            if (y(r.random(), n),
            e.exports) {
                e.exports = p;
                try {
                    f = Qge
                } catch {}
            } else
                r["seed" + a] = p
        }
        )(typeof self < "u" ? self : e1e, [], Math)
    }(hm)),
    hm.exports
}
var Rb, jO;
function n1e() {
    if (jO)
        return Rb;
    jO = 1;
    var e = Bge()
      , t = Gge()
      , n = Hge()
      , r = $ge()
      , s = Kge()
      , o = Zge()
      , i = t1e();
    return i.alea = e,
    i.xor128 = t,
    i.xorwow = n,
    i.xorshift7 = r,
    i.xor4096 = s,
    i.tychei = o,
    Rb = i,
    Rb
}
var r1e = n1e();
const s1e = mn(r1e);
function o1e({lines: e=1, variance: t=0, size: n="base", width: r=50, widthVariance: s=50, className: o}) {
    const [i] = h.useState( () => YB(e, r, s, t));
    let a = "";
    switch (n) {
    case "sm":
        a = "h-3 mb-2 mt-0.5";
        break;
    case "base":
        a = "h-4 my-2";
        break;
    case "lg":
        a = "h-5 my-2";
        break
    }
    return g.jsx(g.Fragment, {
        children: i.map( (l, c) => g.jsx("div", {
            className: we("bg-token-sidebar-surface-secondary dark:bg-token-border-default relative w-full overflow-hidden rounded-md", a, o),
            style: {
                width: `${l}%`
            },
            children: g.jsx(dN.div, {
                className: "absolute start-0 top-0 h-full w-full rotate-45 bg-linear-to-r from-transparent via-black/20 to-transparent opacity-50 dark:via-white/5",
                animate: {
                    x: ["-100%", "100%"],
                    opacity: [1, 0, 1],
                    transition: {
                        repeat: 1 / 0,
                        repeatType: "loop",
                        duration: 1.5 + c
                    }
                }
            })
        }, c))
    })
}
function MOe({lines: e=1, indexOffset: t=0, variance: n=0, width: r=50, widthVariance: s=50, gapFrequency: o=0, scaleUpAnimation: i, className: a, heightSize: l}) {
    const c = h.useMemo( () => YB(e, r, s, n), [e, n, r, s]);
    return g.jsx(i1e, {
        className: a,
        children: c.map( (u, d) => g.jsx(l1e, {
            index: d + t,
            width: u,
            className: we(o > 0 && (d + 1) % o === 0 && "mb-snc-1"),
            heightSize: l,
            customAnimation: i ? {
                initial: {
                    scaleX: i.initialScaleX
                },
                animate: {
                    scaleX: 1
                },
                transition: {
                    scaleX: {
                        duration: i.duration,
                        ease: "easeInOut",
                        delay: d * .07
                    }
                }
            } : void 0
        }, d))
    })
}
const i1e = ja.div`flex flex-col items-start gap-2`
  , a1e = {
    sm: "h-3.5",
    md: "h-5",
    lg: "h-6"
};
function l1e({index: e, width: t, className: n, customAnimation: r, heightSize: s="md"}) {
    const {initial: o, animate: i, transition: a} = r ?? {
        initial: {},
        animate: {},
        transition: {}
    };
    return g.jsx(dN.div, {
        className: we(a1e[s], "bg-token-border-default origin-left rounded-md dark:bg-white/10", n),
        style: {
            width: `${t}%`
        },
        initial: {
            opacity: 1,
            ...o
        },
        animate: {
            opacity: [1, .4],
            ...i
        },
        transition: {
            opacity: {
                repeat: 1 / 0,
                repeatType: "reverse",
                duration: .85,
                ease: "easeInOut",
                delay: e * .07
            },
            ...a
        }
    })
}
function YB(e, t, n, r) {
    const s = s1e([e, t, n, r].join("-"));
    return Array.from({
        length: e + s() * (r ?? 0)
    }, () => t + s() * n)
}
const c1e = (e, t) => ({as: r, ...s}) => {
    const o = r || e;
    return t(g.jsx(o, {
        ...s
    }))
}
;
let UO, rf, En = typeof window < "u" && window.document && window.document.createElement ? h.useLayoutEffect : h.useEffect, su = e => (t, n) => "calc(" + t + " + (" + n + " - " + t + ") * " + e + ")", xr = typeof window < "u" ? window.navigator.userAgent : null, oi = "unknown", ln = "unknown";
if (typeof window < "u" && navigator.userAgentData && (navigator.userAgentData.brands.some(e => e.brand === "Chromium") && (oi = "chromium"),
navigator.userAgentData.platform === "Android" && (ln = "android")),
ln === "unknown" && xr?.match(/android/i) && (ln = "android"),
oi === "unknown" && (xr?.match(/Chrome/i) ? oi = "chromium" : xr?.match(/Firefox/i) ? oi = "gecko" : xr?.match(/Safari|iPhone/i) && (oi = "webkit")),
oi === "webkit") {
    if (xr?.match(/iPhone/i))
        ln = "ios";
    else if (xr?.match(/iPad/i))
        ln = "ipados";
    else if (xr?.match(/Macintosh/i))
        try {
            document?.createEvent("TouchEvent"),
            ln = "ipados"
        } catch {
            ln = "macos"
        }
}
var ZB = {};
ZB = {
    mapping: {
        Sheet: {
            componentName: "a",
            elementNames: {
                root: 0,
                view: 1,
                backdrop: 2,
                backdropTrap: 3,
                primaryScrollTrapRoot: 4,
                secondaryScrollTrapRoot: 5,
                scrollContainer: 6,
                frontSpacer: 7,
                backSpacer: 8,
                detentMarker: 9,
                contentWrapper: 10,
                content: 11,
                bleedingBackground: 12,
                stickyContainer: 13,
                sticky: 14,
                leftEdge: 15,
                trigger: 16,
                handle: 17,
                outlet: 18
            },
            variationSetsNames: {
                openness: "A",
                staging: "B",
                opennessClosedStatus: "C",
                position: "D",
                positionCoveredStatus: "E",
                placement: "F",
                track: "G",
                swipeDisabled: "H",
                swipeOutDisabledWithDetent: "I",
                swipeOvershootDisabled: "J",
                bleedDisabled: "K",
                inertOutside: "L",
                backdropSwipeable: "M",
                scrollContainerShouldBePassThrough: "N",
                swipeTrap: "M"
            },
            variationValuesNames: {
                open: "a",
                opening: "b",
                closed: "c",
                closing: "d",
                none: "e",
                top: "f",
                bottom: "g",
                left: "h",
                right: "i",
                horizontal: "j",
                vertical: "k",
                front: "l",
                covered: "m",
                true: "o",
                false: "p",
                auto: "q",
                center: "r",
                pending: "s",
                "flushing-to-preparing-open": "t",
                "flushing-to-preparing-opening": "u",
                "preparing-open": "v",
                "preparing-opening": "x",
                "safe-to-unmount": "y",
                content: "z",
                root: "aa",
                "going-down": "ab",
                "going-up": "ac",
                indeterminate: "ad",
                idle: "ae",
                "come-back": "af",
                out: "ag",
                stepping: "ah",
                both: "ai",
                none: "aj"
            }
        },
        ScrollTrap: {
            componentName: "b",
            elementNames: {
                root: 0,
                stabiliser: 1
            },
            variationSetsNames: {
                active: "A",
                axis: "B",
                automaticallyDisabledForOptimisation: "C"
            },
            variationValuesNames: {
                true: "a",
                false: "b",
                horizontal: "e",
                vertical: "f",
                both: "g",
                none: "h"
            }
        },
        Scroll: {
            componentName: "c",
            elementNames: {
                root: 0,
                view: 1,
                scrollContainer: 2,
                content: 3,
                UAScrollbarMeasurer: 4,
                spy: 5,
                startSpacer: 6,
                endSpacer: 7
            },
            variationSetsNames: {
                axis: "A",
                contentPlacement: "B",
                scrollTrapX: "C",
                scrollTrapY: "D",
                scrollGestureOvershoot: "E",
                scrollDisabled: "F",
                side: "G",
                pageScroll: "H",
                overflowX: "I",
                overflowY: "J",
                skipScrollAnimation: "K",
                scrollAnchoring: "L",
                scrollSnapType: "M",
                scrollPadding: "N",
                scrollTimelineName: "O",
                nativeScrollbar: "P",
                scrollOngoing: "Q"
            },
            variationValuesNames: {
                true: "a",
                false: "b",
                x: "c",
                y: "d",
                both: "e",
                unset: "f",
                contain: "g",
                start: "h",
                end: "i",
                center: "j",
                auto: "k",
                default: "l",
                none: "m",
                mandatoryX: "n",
                mandatoryY: "o",
                proximityX: "p",
                proximityY: "q"
            }
        },
        SlideShow: {
            componentName: "d",
            elementNames: {},
            variationSetsNames: {},
            variationValuesNames: {}
        },
        VisuallyHidden: {
            componentName: "e",
            elementNames: {
                root: 0
            },
            variationSetsNames: {},
            variationValuesNames: {}
        },
        SpecialWrapper: {
            componentName: "f",
            elementNames: {
                root: 0,
                content: 1
            },
            variationSetsNames: {},
            variationValuesNames: {}
        },
        Fixed: {
            componentName: "g",
            elementNames: {
                root: 0
            },
            variationSetsNames: {},
            variationValuesNames: {}
        },
        SheetStack: {
            componentName: "h",
            elementNames: {
                root: 0,
                outlet: 1
            },
            variationSetsNames: {},
            variationValuesNames: {}
        },
        AutoFocusTarget: {
            componentName: "i",
            elementNames: {
                root: 0
            },
            variationSetsNames: {},
            variationValuesNames: {}
        }
    }
};
let B1 = ZB.mapping
  , u1e = e => {
    var t;
    return (t = B1[e].componentName) !== null && t !== void 0 ? t : null
}
  , d1e = (e, t) => {
    var n;
    return (n = B1[e].elementNames[t]) !== null && n !== void 0 ? n : null
}
  , f1e = (e, t) => {
    var n;
    return (n = B1[e].variationSetsNames[t]) !== null && n !== void 0 ? n : null
}
  , h1e = (e, t) => {
    var n;
    return (n = B1[e].variationValuesNames[t]) !== null && n !== void 0 ? n : null
}
  , Hn = (e, t) => h.useCallback( (n, r=[], s) => {
    var o, i;
    let a, l, c = (i = s == null || (o = s.dataSilk) === null || o === void 0 ? void 0 : o.filter(Boolean).join(" ")) !== null && i !== void 0 ? i : "";
    {
        let u = u1e(e);
        if (a = u + d1e(e, n),
        t)
            for (let d = 0; d < r.length; d++) {
                let f = r[d]
                  , p = t[f]
                  , m = f1e(e, f)
                  , v = h1e(e, p);
                a += p != null ? " " + u + m + v : ""
            }
        l = {
            className: s?.className,
            "data-silk": a + " " + c
        }
    }
    return l
}
, [e, ...t ? Object.values(t) : []])
  , Td = new WeakMap;
var p1e = typeof Float32Array == "function";
function Cp(e, t, n) {
    return (((1 - 3 * n + 3 * t) * e + (3 * n - 6 * t)) * e + 3 * t) * e
}
function BO(e, t, n) {
    return 3 * (1 - 3 * n + 3 * t) * e * e + 2 * (3 * n - 6 * t) * e + 3 * t
}
function m1e(e) {
    return e
}
var g1e = function(e, t, n, r) {
    if (!(0 <= e && e <= 1 && 0 <= n && n <= 1))
        throw Error("bezier x values must be in [0, 1] range");
    if (e === t && n === r)
        return m1e;
    for (var s = p1e ? new Float32Array(11) : Array(11), o = 0; o < 11; ++o)
        s[o] = Cp(.1 * o, e, n);
    return function(i) {
        return i === 0 || i === 1 ? i : Cp(function(a) {
            for (var l = 0, c = 1; c !== 10 && s[c] <= a; ++c)
                l += .1;
            var u = l + (a - s[--c]) / (s[c + 1] - s[c]) * .1
              , d = BO(u, e, n);
            return d >= .001 ? function(f, p, m, v) {
                for (var _ = 0; _ < 4; ++_) {
                    var y = BO(p, m, v);
                    if (y === 0)
                        break;
                    var b = Cp(p, m, v) - f;
                    p -= b / y
                }
                return p
            }(a, u, e, n) : d === 0 ? u : function(f, p, m, v, _) {
                var y, b, S = 0;
                do
                    (y = Cp(b = p + (m - p) / 2, v, _) - f) > 0 ? m = b : p = b;
                while (Math.abs(y) > 1e-7 && ++S < 10);
                return b
            }(a, l, l + .1, e, n)
        }(i), t, r)
    }
};
let ag = e => typeof e == "string" ? document.querySelector(e) : e?.()
  , JB = (e, t) => Array.isArray(e) ? e.includes(t) : e === t
  , eS = e => e?.getAttribute("data-silk-clone") === "true"
  , v1e = new Set(["checkbox", "radio", "range", "color", "file", "image", "button", "submit", "reset"])
  , _l = e => e instanceof HTMLInputElement && !v1e.has(e.type) || e instanceof HTMLTextAreaElement || e instanceof HTMLElement && e.isContentEditable
  , qO = e => e instanceof HTMLInputElement && e.type === "color" || e instanceof HTMLSelectElement
  , d4 = typeof window < "u" && window.matchMedia("(prefers-reduced-motion: reduce)").matches
  , lg = () => {
    var e;
    return window.innerHeight - 200 > ((e = window.visualViewport) === null || e === void 0 ? void 0 : e.height)
}
;
function Po({nativeEvent: e, defaultBehavior: t, handler: n}) {
    let r = t;
    if (n)
        if (typeof n == "function") {
            let s = {
                ...t,
                nativeEvent: e,
                changeDefault: function(o) {
                    r = {
                        ...t,
                        ...o
                    },
                    Object.assign(this, o)
                }
            };
            s.changeDefault = s.changeDefault.bind(s),
            n(s)
        } else
            r = {
                ...t,
                ...n
            };
    return r
}
function XB(e) {
    return (e.startsWith("rgb(") || e.startsWith("rgba(")) && e.endsWith(")") ? e.substring(e.indexOf("(") + 1, e.indexOf(")")).split(",").map(r => r.trim()).slice(0, 3).map(r => parseFloat(r)) : null
}
let GO = e => {
    let t = null;
    return e.startsWith("rgb(") || e.startsWith("rgba(") ? t = XB(e) : e.startsWith("#") && (t = function(n) {
        let r = n.replace(/^#/, "")
          , s = r.length === 3 ? r.split("").map(l => l + l).join("") : r;
        if (!/^[0-9A-Fa-f]{6}$/.test(s))
            return null;
        let o = parseInt(s.slice(0, 2), 16)
          , i = parseInt(s.slice(2, 4), 16)
          , a = parseInt(s.slice(4, 6), 16);
        return [o, i, a]
    }(e)),
    t
}
  , _1e = ({color: e, overlays: t}) => {
    let n = [...e]
      , r = t.length;
    for (let s = 0; s < r; s++) {
        let o = t[s]
          , i = o.alpha;
        for (let a = 0; a < 3; a++)
            n[a] = (1 - i) * n[a] + i * o.color[a]
    }
    return "rgb(" + n.join(",") + ")"
}
  , y1e = e => {
    h.useEffect( () => {
        let t = () => {
            lg() ? e(!0) : e(!1)
        }
        ;
        return t(),
        visualViewport.addEventListener("resize", t),
        () => {
            visualViewport.removeEventListener("resize", t)
        }
    }
    , [e])
}
  , b1e = e => e.matches('[data-silk~="0ad"]:not([data-silk~="0ai"]) *, [data-silk~="0ab"] *')
  , QB = e => {
    let[t,n] = h.useState(!1)
      , r = h.useCallback(s => {
        e.current && n(!!s && !b1e(e.current))
    }
    , [e]);
    return y1e(r),
    t
}
  , eq = () => ln === "android" && oi === "chromium" && typeof window < "u" && !window.matchMedia("(display-mode: standalone), (display-mode: minimal-ui), (display-mode: fullscreen)").matches
  , C1e = () => {
    var e, t, n;
    return typeof window < "u" && window.navigator.standalone && ((e = document.querySelector("meta[name='viewport']")) === null || e === void 0 ? void 0 : e.content.includes("viewport-fit=cover")) && ((t = document.querySelector("meta[name='apple-mobile-web-app-capable']")) === null || t === void 0 ? void 0 : t.content) === "yes" && ((n = document.querySelector("meta[name='apple-mobile-web-app-status-bar-style']")) === null || n === void 0 ? void 0 : n.content) === "black-translucent"
}
  , aa = () => oi === "webkit"
  , S1e = () => typeof document < "u" ? document.querySelector('meta[name="theme-color"]') : null
  , Ch = ({genericContext: e, customContext: t, value: n, children: r}) => t ? g.jsx(t.Provider, {
    value: n,
    children: g.jsx(e.Provider, {
        value: n,
        children: r
    })
}) : g.jsx(e.Provider, {
    value: n,
    children: r
});
Ch.displayName = "CustomisableContext";
function tS(e) {
    for (let t = 0; t < e.length; t++)
        if (!e[t].matches('[data-silk~="0ad"]'))
            return e[t];
    return e[0]
}
let tq = (e, t) => {
    var n;
    let {safelyFocusableElements: r, safelyTabbableElements: s} = q1(t, ["[data-silk~='0ac']"])
      , o = tt.autoFocusTargets.filter(d => d.layerId === "any" || d.layerId === e)
      , i = o.filter(d => JB(d.timing, "present"))
      , a = r.filter(d => i.map(f => f.element).includes(d))
      , l = tS(a)
      , c = tS(s);
    ((n = l ?? c) !== null && n !== void 0 ? n : t).focus({
        preventScroll: !0
    })
}
  , VO = (e, t, n) => {
    let {focus: r} = Po({
        nativeEvent: null,
        defaultBehavior: {
            focus: !0
        },
        handler: n
    });
    r && tq(e, t)
}
  , w1e = (e, t, n, r) => {
    if (!t.contains(document.activeElement) && document.contains(document.activeElement))
        return;
    let {focus: s} = Po({
        nativeEvent: null,
        defaultBehavior: {
            focus: !0
        },
        handler: n
    });
    if (s) {
        var o;
        let i = tt.autoFocusTargets.filter(f => f.layerId === "any" || f.layerId === e)
          , a = i.filter(f => JB(f.timing, "dismiss") && !t.contains(f.element))
          , {safelyFocusableElements: l} = q1(document.body)
          , c = l.filter(f => a.map(p => p.element).includes(f))
          , u = tS(c);
        ((o = u ?? r) !== null && o !== void 0 ? o : document.body).focus({
            preventScroll: !0
        })
    }
}
  , HO = e => {
    e.parentNode != null && e.parentNode.removeChild(e)
}
  , zO = () => {
    let e = document.createElement("div");
    return e.tabIndex = 0,
    e.style.position = "fixed",
    e.setAttribute("aria-hidden", "true"),
    e.setAttribute("data-silk", "0aa"),
    e
}
  , E1e = e => {
    let t = zO()
      , n = zO();
    return e.insertAdjacentElement("beforebegin", t),
    e.insertAdjacentElement("afterend", n),
    () => {
        HO(t),
        HO(n)
    }
}
  , x1e = e => !!(e.offsetWidth || e.offsetHeight || e.getClientRects().length)
  , q1 = (e, t=[]) => {
    let n = ["input:not([disabled]):not([type=hidden])", "select:not([disabled])", "textarea:not([disabled])", "button:not([disabled])", "a[href]", "area[href]", "summary", "iframe", "object", "embed", "audio[controls]", "video[controls]", "[contenteditable]", "[tabindex]:not([disabled])", ...t]
      , r = n.join(",")
      , s = e ? [...e.matches(r) ? [e] : [], ...e.querySelectorAll(r)] : []
      , o = [...t, "[aria-hidden='true']", "[aria-hidden='true'] *", "[inert]", "[inert] *"]
      , i = s.map(f => ({
        element: f,
        tabbable: f.matches(':not([hidden]):not([tabindex^="-"])'),
        skippable: f.matches(o.join(",")) || !x1e(f)
    }))
      , a = i.filter(f => !f.skippable)
      , l = a.map(f => f.element)
      , c = i.filter(f => f.tabbable)
      , u = c.filter(f => !f.skippable)
      , d = u.map(f => f.element);
    return {
        allFocusableElementsWithData: i,
        safelyFocusableElements: l,
        allTabbableElementsWithData: c,
        safelyTabbableElements: d
    }
}
  , nq = (e, t) => {
    let {safelyTabbableElements: n, allTabbableElementsWithData: r, allFocusableElementsWithData: s} = q1(e, ["[data-silk~='0ac']"])
      , o = [...r]
      , i = [...s];
    return t && [o, i].forEach(a => {
        a.unshift({
            element: e.previousElementSibling,
            tabbable: !0,
            skippable: !0
        }),
        a.push({
            element: e.nextElementSibling,
            tabbable: !0,
            skippable: !0
        })
    }
    ),
    {
        safelyTabbableElements: n,
        allTabbableElementsWithGuardsWithData: o,
        allFocusableElementsWithGuardsWithData: i
    }
}
  , T1e = (e, t) => {
    let n;
    return (n = t.slice(0, e).reverse().find(r => r.skippable === !1)) || (n = t.slice(e + 1 - t.length).reverse().find(r => r.skippable === !1)),
    n
}
  , $O = (e, t) => {
    let n;
    return (n = t.slice(e + 1).find(r => r.skippable === !1)) || (n = t.slice(0, e).find(r => r.skippable === !1)),
    n
}
  , k1e = ({rootElements: e, e: t, fromElement: n, toElement: r, fallbackElement: s}) => {
    if (!r)
        return;
    let o = []
      , i = []
      , a = [];
    e.forEach(_ => {
        let {safelyTabbableElements: y, allTabbableElementsWithGuardsWithData: b, allFocusableElementsWithGuardsWithData: S} = nq(_, !0);
        o = [...o, ...y],
        i = [...i, ...b],
        a = [...a, ...S]
    }
    );
    let l = i.findIndex(_ => _.element === n)
      , c = i.findIndex(_ => _.element === r)
      , u = i[c]
      , d = a.findIndex(_ => _.element === r)
      , f = !!r && e.includes(r) && r.getAttribute("tabindex") === "-1";
    if (d === -1 && !f) {
        let _ = e.find(y => y.getAttribute("tabindex") === "-1");
        _?.focus()
    }
    if (u?.skippable) {
        var p, m, v;
        o.length ? o.length === 1 ? n === o[0] ? (t.preventDefault(),
        t.stopPropagation(),
        requestAnimationFrame( () => n.focus())) : o[0].focus() : l ? c < l ? (m = T1e(c, i)) === null || m === void 0 || m.element.focus() : (v = $O(c, i)) === null || v === void 0 || v.element.focus() : (p = $O(c, i)) === null || p === void 0 || p.element.focus() : s?.focus()
    }
}
  , rq = (e, t, n, r, s) => {
    var o;
    if (!((o = e.target) === null || o === void 0) && o.matches("[data-silk-clone]"))
        return;
    let i = []
      , a = [];
    n.forEach(l => {
        let {safelyFocusableElements: c, safelyTabbableElements: u} = q1(l);
        i = [...i, ...c],
        a = [...a, ...u]
    }
    ),
    n.includes(e.target) || i.includes(e.target) ? e.target && s(e.target) : r ? r.focus() : a.length ? a[0].focus() : t.focus()
}
  , O1e = (e, t) => {
    var n;
    if (!((n = e.relatedTarget) === null || n === void 0) && n.matches("[data-silk-clone]"))
        return;
    let r = pm ?? e.target
      , s = vu ?? e.relatedTarget;
    k1e({
        rootElements: t,
        e,
        fromElement: r,
        toElement: s
    }),
    pm = null,
    vu = null
}
  , A1e = (e, t, n, r, s) => {
    let o = n.find(i => i.contains(e.target));
    e.key !== "Tab" || o || (e.preventDefault(),
    e.stopPropagation(),
    rq(e, t, n, r, s))
}
  , pm = null
  , vu = null
  , M1e = ({rootElements: e, viewElement: t, elementFocusedLast: n, setElementFocusedLast: r}) => {
    let s = [];
    e.forEach(c => {
        s.push(E1e(c))
    }
    );
    let o = function(c, u=document) {
        let d = new Set(c)
          , f = new Set
          , p = document.createTreeWalker(u, NodeFilter.SHOW_ELEMENT, {
            acceptNode: y => (y instanceof HTMLElement && y.dataset.liveAnnouncer === "true" && d.add(y),
            y.tagName === "HEAD" || y.tagName === "SCRIPT" || d.has(y) || y.parentElement && f.has(y.parentElement) ? NodeFilter.FILTER_REJECT : y instanceof HTMLElement && y.getAttribute("role") === "row" || c.some(b => y.contains(b)) ? NodeFilter.FILTER_SKIP : NodeFilter.FILTER_ACCEPT)
        })
          , m = y => {
            var b;
            let S = (b = Td.get(y)) !== null && b !== void 0 ? b : 0;
            (y.getAttribute("aria-hidden") !== "true" || S !== 0) && (S === 0 && y.setAttribute("aria-hidden", "true"),
            f.add(y),
            Td.set(y, S + 1))
        }
          , v = p.nextNode();
        for (; v != null; )
            m(v),
            v = p.nextNode();
        let _ = new MutationObserver(y => {
            for (let b of y)
                if (b.type === "childList" && b.addedNodes.length !== 0 && ![...d, ...f].some(S => S.contains(b.target)))
                    for (let S of b.addedNodes)
                        S instanceof HTMLElement && S.dataset.liveAnnouncer === "true" ? d.add(S) : S instanceof Element && m(S)
        }
        );
        return _.observe(u, {
            childList: !0,
            subtree: !0
        }),
        () => {
            for (let y of (_.disconnect(),
            f)) {
                let b = Td.get(y);
                b === 1 ? (y.removeAttribute("aria-hidden"),
                Td.delete(y)) : b !== void 0 && Td.set(y, b - 1)
            }
        }
    }(e, document)
      , i = c => O1e(c, e)
      , a = c => rq(c, t, e, n, r)
      , l = c => A1e(c, t, e, n, r);
    return document.addEventListener("keydown", l),
    document.addEventListener("focusout", i),
    document.addEventListener("focusin", a),
    () => {
        document.removeEventListener("focusout", i),
        document.removeEventListener("focusin", a),
        document.removeEventListener("keydown", l),
        o(),
        s.forEach(c => c())
    }
}
  , G1 = new Set
  , I1e = e => {
    G1.add(e)
}
  , R1e = e => {
    G1.delete(e)
}
  , sq = (e, t, n, r) => {
    let s = e[t]
      , o = s.onClickOutside
      , i = s.dismissOverlayIfNotAlertDialog
      , a = s.viewElement
      , l = s.scrollContainerElement
      , c = s.backdropElement;
    if (l === r.target || c === r.target || !a?.contains(r.target) && !n.find(u => u.element.contains(r.target)) && function(u) {
        for (let d of tt.automaticLayerElements)
            if (d.contains(u))
                return !1;
        return !0
    }(r.target)) {
        let u = !0
          , d = !0;
        if (o) {
            let {dismiss: f, stopOverlayPropagation: p} = Po({
                nativeEvent: r,
                defaultBehavior: {
                    dismiss: !0,
                    stopOverlayPropagation: !0
                },
                handler: o
            });
            u = f,
            d = p
        }
        u && i && i(),
        t > 0 && !d && sq(e, t - 1, n, r)
    }
}
  , nS = null
  , N1e = (e, t, n) => {
    var r;
    if (G1.size || !((r = e.target) === null || r === void 0) && r.matches('[data-silk~="0ak"] *') || e.target === document.body && nS !== document.body || !e.target || !e.target.isConnected)
        return;
    let s = t.length;
    sq(t, s - 1, n, e),
    nS = null
}
  , P1e = (e, t) => {
    let n = s => nS = s.target
      , r = s => N1e(s, e, t);
    return document.addEventListener("pointerdown", n),
    document.addEventListener("click", r),
    () => {
        document.removeEventListener("pointerdown", n),
        document.removeEventListener("click", r)
    }
}
  , oq = (e, t, n) => {
    let r = e[t]
      , s = r.onEscapeKeyDown
      , o = r.dismissOverlayIfNotAlertDialog
      , i = !0
      , a = !0
      , l = !0;
    if (s) {
        let {dismiss: c, nativePreventDefault: u, stopOverlayPropagation: d} = Po({
            nativeEvent: n,
            defaultBehavior: {
                nativePreventDefault: !0,
                dismiss: !0,
                stopOverlayPropagation: !0
            },
            handler: s
        });
        i = u,
        a = c,
        l = d
    }
    i && n.preventDefault(),
    a && o && o(),
    t > 0 && !l && oq(e, t - 1, n)
}
  , D1e = (e, t) => {
    if (e.key !== "Escape" || G1.size)
        return;
    let n = t.length;
    oq(t, n - 1, e)
}
  , L1e = e => {
    let t = n => D1e(n, e);
    return document.addEventListener("keydown", t),
    () => {
        document.removeEventListener("keydown", t)
    }
}
  , F1e = e => (e.setAttribute("aria-hidden", "true"),
() => e.removeAttribute("aria-hidden"))
  , j1e = e => {
    let {allTabbableElementsWithGuardsWithData: t} = nq(e);
    t.forEach(n => {
        n.element.tabIndex = -1
    }
    )
}
  , U1e = e => {
    var t;
    return e instanceof HTMLInputElement && (!!(e.type === "password" || e.type === "text" && e.autocomplete === "username" || !((t = e.closest("form")) === null || t === void 0) && t.querySelector('input[type="password"]')) || void 0)
}
  , B1e = e => {
    var t, n;
    let r = e.getBoundingClientRect()
      , s = r.height
      , o = (n = (t = window.visualViewport) === null || t === void 0 ? void 0 : t.height) !== null && n !== void 0 ? n : 0
      , i = o - r.bottom;
    return i > -s / 2 && i < s + 32
}
  , Nb = e => {
    var t;
    return (t = e?.closest('[data-silk~="0ab"], [data-silk~="0ad"]')) === null || t === void 0 ? void 0 : t.matches('[data-silk~="0ah"]')
}
  , q1e = () => {
    let e = s => {
        let o = s.target;
        if (Nb(o)) {
            var i;
            (i = o?.closest('[data-silk~="0ah"]')) === null || i === void 0 || i.focus({
                preventScroll: !0
            }),
            document.removeEventListener("touchstart", e, {
                capture: !0
            })
        }
    }
      , t = s => {
        let o = s.target
          , i = s.relatedTarget;
        if (!i)
            return document.addEventListener("touchstart", e, {
                capture: !0,
                passive: !1
            });
        if (Nb(i) && (qO(i) && document.addEventListener("touchstart", e, {
            capture: !0,
            passive: !1
        }),
        !(!_l(i) && !qO(i) || eS(o))))
            if (!U1e(i) && _l(o) && B1e(o)) {
                let a = o.cloneNode(!1);
                a.removeAttribute("id"),
                a.setAttribute("data-silk-clone", "true"),
                a.style.setProperty("position", "fixed"),
                a.style.setProperty("left", "0"),
                a.style.setProperty("top", "0"),
                a.style.setProperty("transform", "translateY(-3000px) scale(0)"),
                document.documentElement.appendChild(a),
                vu = i,
                a?.focus({
                    preventScroll: !0
                }),
                setTimeout( () => {
                    pm = o,
                    vu = i,
                    i?.focus({
                        preventScroll: !0
                    }),
                    a.remove()
                }
                , 32)
            } else
                vu = i,
                i?.focus({
                    preventScroll: !0
                })
    }
      , n = s => {
        var o;
        let i = s.target;
        !(i !== document.activeElement || !_l(i) || lg()) && Nb(i) && ((o = i?.closest('[data-silk~="0ab"], [data-silk~="0ad"]')) === null || o === void 0 || o.focus({
            preventScroll: !0
        }))
    }
      , r = s => {
        var o;
        let i = s.target;
        if (!i || !("setSelectionRange"in i) || !(["password", "search", "tel", "text", "url"].includes(i.type) || i instanceof HTMLTextAreaElement) || i._silk_focusedBefore === !0)
            return;
        let a = i.value.length;
        (o = i.setSelectionRange) === null || o === void 0 || o.call(i, a, a),
        i._silk_focusedBefore = !0
    }
    ;
    return document.addEventListener("blur", t, {
        capture: !0,
        passive: !1
    }),
    document.addEventListener("touchstart", e, {
        capture: !0,
        passive: !0
    }),
    document.addEventListener("touchend", n, {
        capture: !0,
        passive: !0
    }),
    document.addEventListener("focusin", r),
    () => {
        document.removeEventListener("blur", t, {
            capture: !0
        }),
        document.removeEventListener("touchend", n, {
            capture: !0
        }),
        document.removeEventListener("touchstart", e, {
            capture: !0
        }),
        document.removeEventListener("focusin", r)
    }
}
  , iq = ["translate", "translateX", "translateY", "translateZ", "scale", "scaleX", "scaleY", "scaleZ", "rotate", "rotateX", "rotateY", "rotateZ", "skew", "skewX", "skewY"]
  , aq = null
  , lq = e => {
    aq = e
}
  , G1e = {
    sheets: [],
    addSheet: function(e) {
        let t;
        if (!e.id)
            return;
        let n = this.findSheet(e.id);
        return n ? (e.stackId && (n.stackId = e.stackId),
        e.sendToOpennessMachine && (n.sendToOpennessMachine = e.sendToOpennessMachine),
        t = n) : (t = {
            stackingIndex: -1,
            travelAnimations: [],
            aggregatedTravelCallback: function(r, s) {
                let o = this.travelAnimations;
                for (let i = 0, a = o.length; i < a; i++)
                    o[i].callback(r, s)
            },
            stackingAnimations: [],
            aggregatedStackingCallback: function(r, s) {
                let o = this.stackingAnimations;
                for (let i = 0, a = o.length; i < a; i++)
                    o[i].callback(r, s)
            },
            belowSheetsInStack: [],
            outlets: new Set,
            ...e
        },
        this.sheets.push(t)),
        this.updateBelowSheetsInStackOfAllSheets(),
        t
    },
    attemptToRemoveSheet: function(e, t) {
        let n = this.findSheet(e);
        if (n)
            if (n.outlets.size === 0) {
                var r;
                let s = (r = this.findSheet(e)) === null || r === void 0 ? void 0 : r.stackId;
                this.sheets = this.sheets.filter(o => o.id !== e),
                s && this.updateSelfAndAboveTravelProgressSumInStack(s)
            } else
                t && t(n)
    },
    attemptToRemoveSheetOrCleanup: function(e) {
        this.attemptToRemoveSheet(e, t => {
            t.sendToOpennessMachine = null
        }
        )
    },
    findSheet: function(e) {
        return this.sheets.find(t => t.id === e)
    },
    addOutletToSheet: function(e, t) {
        let n = this.findSheet(e);
        n ? n.outlets.add(t) : this.addSheet({
            id: e,
            outlets: new Set([t])
        })
    },
    removeOutletFromSheet: function(e, t) {
        let n = this.findSheet(e);
        n?.outlets.delete(t),
        this.attemptToRemoveSheet(e)
    },
    sheetStacks: [],
    addSheetStack: function(e) {
        let t;
        return this.findSheetStack(e.id) || (t = {
            stackingAnimations: [],
            aggregatedStackingCallback: function(r, s) {
                let o = this.stackingAnimations;
                for (let i = 0, a = o.length; i < a; i++)
                    o[i].callback(r, s)
            },
            ...e
        },
        this.sheetStacks.push(t)),
        this.updateBelowSheetsInStackOfAllSheets(),
        t
    },
    removeSheetStack: function(e) {
        e && (this.sheetStacks = this.sheetStacks.filter(t => t.id !== e),
        this.removeAllOutletPersistedStylesFromStack(e))
    },
    findSheetStack: function(e) {
        return this.sheetStacks.find(t => t.id === e)
    },
    updateBelowSheetsInStackOfAllSheets: function() {
        this.sheets.forEach(e => {
            let t, n = e.stackId;
            if (n) {
                t = this.findSheetStack(n);
                let r = this.sheets.filter(o => o.stackId === e.stackId)
                  , s = r.filter(o => o.stackId === e.stackId && o.stackingIndex > e.stackingIndex);
                t && (s.unshift(t),
                t.stackingIndex = r.length - 1),
                e.belowSheetsInStack = s,
                this.updateSelfAndAboveTravelProgressSumInStack(n)
            }
        }
        )
    },
    updateSheetStackingIndex: function(e, t) {
        let n = this.findSheet(e);
        n && (n.stackingIndex = t),
        this.updateBelowSheetsInStackOfAllSheets()
    },
    updateSheetTravelProgress: function(e, t) {
        let n = this.findSheet(e);
        n && n.stackId && (n.travelProgress = t,
        this.updateSelfAndAboveTravelProgressSumInStack(n.stackId))
    },
    updateSelfAndAboveTravelProgressSumInStack: function(e) {
        let t = this.sheets.filter(s => s.stackId === e).sort( (s, o) => o.stackingIndex - s.stackingIndex)
          , n = this.findSheetStack(e);
        n && t.unshift(n);
        let r = t.length;
        for (let s = 0; s < r; s++) {
            let o = t[s];
            o.selfAndAboveTravelProgressSum = [];
            for (let i = 0; i < r; i++)
                i <= s ? o.selfAndAboveTravelProgressSum[i] = 0 : o.selfAndAboveTravelProgressSum[i] = t.slice(s + 1, i + 1).reduce( (a, l) => a + l.travelProgress, 0)
        }
    },
    addAnimationToSheetOrStack: function({type: e, sheetId: t, stackId: n, element: r, config: s}) {
        let o = s.hasOwnProperty("properties") ? s.properties : s
          , i = [];
        Object.entries(o).forEach( ([d,f]) => {
            if (f !== "ignore" && f && typeof f != "string")
                if (typeof f == "function")
                    if (iq.includes(d)) {
                        let p = i.findIndex(v => v[0] === "transform")
                          , m = v => d + "(" + f(v) + ")";
                        if (p !== -1) {
                            let v = i[p][1];
                            i[p][1] = _ => v(_) + " " + m(_)
                        } else
                            i.push(["transform", m])
                    } else if (d === "transform") {
                        let p = i.findIndex(m => m[0] === "transform");
                        if (p !== -1) {
                            let m = i[p][1];
                            i[p][1] = v => m(v) + " " + f(v)
                        } else
                            i.push(["transform", f])
                    } else
                        i.push([d, f]);
                else if (d === "opacity") {
                    let p = ["opacity", ({tween: m}) => m(f[0], f[1])];
                    i.push(p)
                } else {
                    if (!d.startsWith("scale") && (!isNaN(f[0]) || !isNaN(f[1])))
                        throw Error("Keyframe values used with a 'transform' property require a unit (e.g. 'px', 'em' or '%').");
                    let p = i.findIndex(v => v[0] === "transform")
                      , m = ({tween: v}) => d + "(" + v(f[0], f[1]) + ")";
                    if (p !== -1) {
                        let v = i[p][1];
                        i[p][1] = _ => v(_) + " " + m(_)
                    } else
                        i.push(["transform", m])
                }
        }
        );
        let a = i.map(d => [(d[0].startsWith("webkit") || d[0].startsWith("moz") ? "-" : "") + d[0].replace(/[A-Z]/g, "-$&").toLowerCase(), d[1]])
          , l = a.length
          , c = {
            target: r,
            config: i,
            dashedPropertiesAsArray: a,
            callback: (d, f) => {
                for (let p = 0; p < l; p++) {
                    let[m,v] = a[p];
                    r.style.setProperty(m, v({
                        progress: d,
                        tween: f
                    }))
                }
            }
        }
          , u = n ? this.findSheetStack(n) : this.findSheet(t);
        u && (e === "travel" ? u.travelAnimations.push(c) : u.stackingAnimations.push(c))
    },
    removeAnimationFromSheetOrStack: function({sheetId: e, stackId: t, type: n, element: r}) {
        let s = t ? this.findSheetStack(t) : this.findSheet(e);
        if (s)
            if (n === "travel") {
                let o = s.travelAnimations.filter(i => i.target !== r);
                s.travelAnimations = o
            } else {
                let o = s.stackingAnimations.filter(i => i.target !== r);
                s.stackingAnimations = o
            }
    },
    removeAllOutletPersistedStylesFromSheet: function(e) {
        let t = this.findSheet(e);
        t && [...t.travelAnimations, ...t.stackingAnimations].forEach(n => {
            n.dashedPropertiesAsArray.forEach( ([r]) => {
                n.target.style.removeProperty(r)
            }
            )
        }
        )
    },
    removeAllOutletPersistedStylesFromStack: function(e) {
        let t = this.findSheetStack(e);
        t && t.stackingAnimations.forEach(n => {
            n.dashedPropertiesAsArray.forEach( ([r]) => {
                n.target.style.removeProperty(r)
            }
            )
        }
        )
    },
    getAggregatedStackingCallbackForSheetsBelow: function(e) {
        let t, n = this.findSheet(e);
        return n && (t = r => {
            let s = n.belowSheetsInStack
              , o = s.length;
            for (let i = 0; i < o; i++) {
                let a = s[i]
                  , l = a.selfAndAboveTravelProgressSum[o - 1] + r
                  , c = su(l);
                a.aggregatedStackingCallback(l, c)
            }
        }
        ),
        t
    },
    automaticIslandElements: new Set([]),
    automaticLayerElements: new Set([]),
    automaticLayerAndIslandDetectionCleanup: null,
    focusContainmentRootElements: [],
    focusContainmentCleanup: () => {}
    ,
    escapeKeyDownListenerCleanup: null,
    clickOutsideListenerCleanup: null,
    processLayersAndIslandsChangesTimeout: null,
    setupAutomaticLayerAndIslandDetection: function(e) {
        let t = document.documentElement
          , n = document.body
          , r = () => {
            let o, i = new Set([]), a = new Set([]), l = function(_) {
                let y = _.parentElement;
                for (; y && y !== document.body; ) {
                    if (y.parentElement === document.body)
                        return y;
                    y = y.parentElement
                }
                return _.parentElement === document.body ? _ : null
            }(e);
            o = l ? l.nextElementSibling : n.firstElementChild;
            let c = _ => _.matches('[data-silk~="0ag"], [data-silk~="0ab"], [data-silk~="0aa"], [data-silk-clone]')
              , u = _ => _.tagName !== "SCRIPT";
            for (; o; )
                !c(o) && u(o) && i.add(o),
                o = o.nextElementSibling;
            let d = t.children;
            for (let _ = 0; _ < d.length; _++) {
                let y = d[_];
                y.tagName === "HEAD" || y.tagName === "BODY" || c(y) || a.add(y)
            }
            let f = new Set([...i].filter(_ => !this.automaticLayerElements.has(_)))
              , p = new Set([...this.automaticLayerElements].filter(_ => !i.has(_)));
            this.automaticLayerElements = i;
            let m = new Set([...a].filter(_ => !this.automaticIslandElements.has(_)))
              , v = new Set([...this.automaticIslandElements].filter(_ => !a.has(_)));
            this.automaticIslandElements = a,
            f.forEach(_ => {
                this.updateLayer({
                    automatic: !0,
                    layerId: null,
                    viewElement: _,
                    inertOutside: !1,
                    onPresentAutoFocus: {
                        focus: !1
                    },
                    onDismissAutoFocus: {
                        focus: !1
                    },
                    dismissOverlayIfNotAlertDialog: () => {}
                    ,
                    onClickOutside: {
                        stopOverlayPropagation: !1
                    },
                    onEscapeKeyDown: {
                        stopOverlayPropagation: !1
                    }
                })
            }
            ),
            p.forEach(_ => this.removeLayer(null, _)),
            m.forEach(_ => this.addIsland({
                element: _,
                automatic: !0
            })),
            v.forEach(_ => this.removeIsland(null, _))
        }
        ;
        r();
        let s = new MutationObserver( () => {
            r()
        }
        );
        s.observe(t, {
            childList: !0
        }),
        s.observe(n, {
            childList: !0
        }),
        this.automaticLayerAndIslandDetectionCleanup = function() {
            s.disconnect(),
            this.layers.forEach(o => {
                o.automatic && this.removeLayer(null, o.viewElement)
            }
            ),
            this.automaticLayerElements = new Set([]),
            this.islands.forEach(o => {
                o.automatic && this.removeIsland(null, o.element)
            }
            ),
            this.automaticIslandElements = new Set([]),
            this.automaticLayerAndIslandDetectionCleanup = null
        }
    },
    moveFocusIfNecessary: function(e, t, n, r, s, o) {
        let i = !1;
        for (let a = 0; a < t.length; a++)
            if (t[a].contains(document.activeElement)) {
                i = !0;
                break
            }
        if (n.length) {
            let a = n.filter(l => !l.automatic && !l.external);
            if (a.length) {
                let l = a[a.length - 1];
                return VO(l.layerId, l.viewElement, l.onPresentAutoFocus)
            }
        }
        if (s.length && !i) {
            let a = e[e.length - 1];
            if (!a.external)
                return VO(a.layerId, a.viewElement, a.onPresentAutoFocus)
        }
        if (r.length && r.find(l => l.focusWasInside)) {
            let l = r[0];
            if (!l.external)
                return w1e(l.layerId, l.viewElement, l.onDismissAutoFocus, l.elementFocusedLastBeforeShowing)
        }
        if (o.length && o.find(l => l.focusWasInside)) {
            let l = e[e.length - 1];
            if (l)
                return tq(l.layerId, l.viewElement)
        }
    },
    processLayersAndIslandsChanges: function() {
        var e;
        clearTimeout(this.processLayersAndIslandsChangesTimeout);
        let t = () => {
            let r = this.layers.length, s = new Set([]), o;
            if (this.layers.some(d => d.inertOutside)) {
                this.islands.filter(f => !f.componentId || f.componentId.length === 0).forEach(f => s.add(f.element));
                for (let f = r - 1; f >= 0; f--) {
                    let p = this.layers[f];
                    if (p.external && p.inertOutside) {
                        s = new Set([]);
                        break
                    }
                    s.add(p.viewElement);
                    let m = this.islands.filter(_ => _.componentId && p.layerContextId && _.componentId.includes(p.layerContextId))
                      , v = this.islands.filter(_ => _.componentId && p.layerStackContextId && _.componentId.includes(p.layerStackContextId));
                    if ([...m, ...v].forEach(_ => {
                        s.add(_.element)
                    }
                    ),
                    p.inertOutside) {
                        o = p;
                        break
                    }
                    o = p
                }
            }
            let a = [...s]
              , l = !function(d, f) {
                if (d.length !== f.length)
                    return !1;
                let p = new Set;
                for (let m of d)
                    p.add(m);
                for (let m of f)
                    if (!p.has(m))
                        return !1;
                return !0
            }(this.focusContainmentRootElements, a);
            if (this.focusContainmentRootElements = a,
            l) {
                var c;
                this.focusContainmentCleanup(),
                this.focusContainmentCleanup = () => {}
                ,
                (c = this.automaticLayerAndIslandDetectionCleanup) === null || c === void 0 || c.call(this),
                o && (this.setupAutomaticLayerAndIslandDetection(o?.viewElement),
                this.focusContainmentCleanup = M1e({
                    rootElements: this.focusContainmentRootElements,
                    viewElement: o?.viewElement,
                    elementFocusedLast: aq,
                    setElementFocusedLast: lq
                }))
            }
            this.moveFocusIfNecessary(this.layers, this.focusContainmentRootElements, this.layersJustAdded, this.layersJustRemoved, this.layersJustWentToInertOutsideTrue, this.islandsJustRemoved),
            this.escapeKeyDownListenerCleanup && (this.escapeKeyDownListenerCleanup(),
            this.escapeKeyDownListenerCleanup = null),
            this.clickOutsideListenerCleanup && (this.clickOutsideListenerCleanup(),
            this.clickOutsideListenerCleanup = null),
            r > 0 && (this.escapeKeyDownListenerCleanup = L1e(this.layers),
            this.clickOutsideListenerCleanup = P1e(this.layers, this.islands));
            let u = this.layersJustRemoved.length;
            if (u)
                for (let d = 0; d < u; d++) {
                    let f = this.layersJustRemoved[d]
                      , p = f.viewElement
                      , m = f.automatic;
                    p && !m && (F1e(p),
                    j1e(p))
                }
            this.islandsJustRemoved = [],
            this.layersJustAdded = [],
            this.layersJustRemoved = [],
            this.layersJustWentToInertOutsideTrue = []
        }
        ;
        ((e = this.layersJustAdded[this.layersJustAdded.length - 1]) === null || e === void 0 ? void 0 : e.external) ? t() : this.processLayersAndIslandsChangesTimeout = setTimeout(t, 16)
    },
    autoFocusTargets: [],
    addAutoFocusTarget: function({layerId: e, element: t, timing: n}) {
        this.autoFocusTargets.push({
            layerId: e,
            element: t,
            timing: n
        })
    },
    removeAutoFocusTarget: function(e) {
        this.autoFocusTargets = this.autoFocusTargets.filter(t => t.element !== e)
    },
    islands: [],
    islandsJustRemoved: [],
    addIsland: function(e) {
        var t;
        let n = this.islands[this.islands.length - 1]
          , r = ((t = e.id) !== null && t !== void 0 ? t : n) ? n.id + 1 : 0;
        return this.islands.push({
            ...e,
            id: r
        }),
        this.processLayersAndIslandsChanges(),
        r
    },
    removeIsland: function(e, t) {
        this.islands = this.islands.filter(n => {
            if (e && n.id && n.id !== e || t && n.element && n.element !== t)
                return !0;
            {
                let r = n.element.contains(document.activeElement);
                return this.islandsJustRemoved.push({
                    ...n,
                    focusWasInside: r
                }),
                !1
            }
        }
        ),
        this.processLayersAndIslandsChanges()
    },
    layers: [],
    layersJustAdded: [],
    layersJustRemoved: [],
    layersJustWentToInertOutsideTrue: [],
    updateLayer: function(e) {
        let t = e.layerId
          , n = e.viewElement
          , r = !1
          , s = this.layers;
        for (let i = 0; i < s.length; i++) {
            let a = s[i];
            if (t !== null ? a.layerId === t : a.viewElement === n) {
                let c = {
                    ...a,
                    ...e
                };
                !a.inertOutside && e.inertOutside && this.layersJustWentToInertOutsideTrue.push(c),
                s[i] = c,
                r = !0;
                break
            }
        }
        if (!r) {
            var o;
            let i = {
                ...e,
                elementFocusedLastBeforeShowing: (o = e.elementFocusedLastBeforeShowing) !== null && o !== void 0 ? o : document.activeElement
            };
            s.push(i),
            this.layersJustAdded.push(i)
        }
        this.processLayersAndIslandsChanges()
    },
    removeLayer: function(e, t) {
        var n;
        this.layers = this.layers.filter(r => {
            if (e && r.layerId && r.layerId !== e || t && r.viewElement && r.viewElement !== t)
                return !0;
            {
                var s;
                let o = (s = r.viewElement) === null || s === void 0 ? void 0 : s.contains(document.activeElement);
                return this.layersJustRemoved.push({
                    ...r,
                    focusWasInside: o
                }),
                !1
            }
        }
        ),
        this.layers.filter(r => !r.automatic).length === 0 && ((n = this.automaticLayerAndIslandDetectionCleanup) === null || n === void 0 || n.call(this)),
        this.processLayersAndIslandsChanges()
    },
    nativeFocusScrollPreventers: [],
    nativeFocusScrollPreventionCleanup: null,
    addNativeFocusScrollPreventer: function(e) {
        this.nativeFocusScrollPreventers.push({
            id: e
        }),
        this.processNativeFocusScrollPreventersChanges()
    },
    removeNativeFocusScrollPreventer: function(e) {
        this.nativeFocusScrollPreventers = this.nativeFocusScrollPreventers.filter(t => t.id !== e),
        this.processNativeFocusScrollPreventersChanges()
    },
    processNativeFocusScrollPreventersChanges: function() {
        let e = this.nativeFocusScrollPreventers.length;
        if (aa() && (ln === "ios" || ln === "ipados"))
            if (e)
                this.nativeFocusScrollPreventionCleanup || (this.nativeFocusScrollPreventionCleanup = q1e());
            else {
                var t;
                (t = this.nativeFocusScrollPreventionCleanup) === null || t === void 0 || t.call(this),
                this.nativeFocusScrollPreventionCleanup = null
            }
    },
    fixedComponents: [],
    addFixedComponent: function(e) {
        this.fixedComponents.push(e)
    },
    updateFixedComponent: function(e) {
        let t = this.fixedComponents.find(n => n.id === e.id);
        t && (e.element && (t.element = e.element),
        e.initialInlineCSSTransform && (t.initialInlineCSSTransform = e.initialInlineCSSTransform),
        typeof e.compensated == "boolean" && (t.compensated = e.compensated))
    },
    removeFixedComponent: function(e) {
        this.fixedComponents = this.fixedComponents.filter(t => t.id !== e)
    },
    findActualFixedComponentsInsideOutlet: function(e) {
        return this.fixedComponents.filter(t => {
            if (t.element && e)
                return e.contains(t.element) && window.getComputedStyle(t.element).getPropertyValue("position") === "fixed"
        }
        )
    },
    themeColorMetaTag: null,
    underlyingThemeColor: null,
    themeColorDimmingOverlays: [],
    storeThemeColorMetaTag: function() {
        if (this.themeColorMetaTag = S1e(),
        !this.themeColorMetaTag) {
            let e = document.createElement("meta");
            e.name = "theme-color",
            e.content = window.getComputedStyle(document.body).backgroundColor,
            document.head.appendChild(e),
            this.themeColorMetaTag = e
        }
    },
    getAndStoreUnderlyingThemeColorAsRGBArray: function() {
        let e;
        if (this.themeColorDimmingOverlays.length > 0)
            e = this.underlyingThemeColor;
        else {
            var t;
            this.themeColorMetaTag || this.storeThemeColorMetaTag();
            let n = (t = this.themeColorMetaTag) === null || t === void 0 ? void 0 : t.content;
            (e = GO(n)) || console.warn("`themeColorDimming` prop ignored: Only `theme-color` meta tag with a value in `rgb()`, `rgba()`, or hexadecimal format is supported."),
            this.underlyingThemeColor = e
        }
        return e
    },
    updateUnderlyingThemeColor: function(e) {
        let t = GO(e);
        if (!t)
            throw Error("The color provided to `updateThemeColor` doesn't match `rgb()`, `rgba()`, or hexadecimal format.");
        this.underlyingThemeColor = t,
        this.setActualThemeColor()
    },
    setActualThemeColor: function() {
        var e;
        this.themeColorMetaTag || this.storeThemeColorMetaTag(),
        (e = this.themeColorMetaTag) === null || e === void 0 || e.setAttribute("content", _1e({
            color: this.underlyingThemeColor,
            overlays: this.themeColorDimmingOverlays
        }))
    },
    findThemeColorDimmingOverlay: function(e) {
        return this.themeColorDimmingOverlays.find(t => t.dimmingOverlayId === e)
    },
    findIndexThemeColorDimmingOverlay: function(e) {
        return this.themeColorDimmingOverlays.findIndex(t => t.dimmingOverlayId === e)
    },
    updateThemeColorDimmingOverlay: function(e) {
        let t = e;
        t.color && (t = {
            ...t,
            color: XB(t.color)
        });
        let n = this.findThemeColorDimmingOverlay(t.dimmingOverlayId);
        return n ? Object.assign(n, t) : (n = t,
        this.themeColorDimmingOverlays.push(t)),
        this.setActualThemeColor(),
        n
    },
    updateThemeColorDimmingOverlayAlphaValue: function(e, t) {
        e.alpha = t,
        this.setActualThemeColor()
    },
    removeThemeColorDimmingOverlay: function(e) {
        let t = this.findThemeColorDimmingOverlay(e);
        t && (t.abortRemoval = !1,
        setTimeout( () => {
            t?.abortRemoval || (this.themeColorDimmingOverlays = this.themeColorDimmingOverlays.filter(n => n.dimmingOverlayId !== e),
            this.setActualThemeColor(),
            this.themeColorDimmingOverlays.length !== 0 || (this.underlyingThemeColor = null,
            this.themeColorMetaTag = null))
        }
        , 20))
    }
};
var tt = G1e;
let cq = e => {
    let t = h.useRef(null);
    return En( () => {
        t.current = e
    }
    ),
    h.useCallback( (...n) => {
        let r = t.current;
        return r(...n)
    }
    , [])
}
  , f4 = e => e === "layout" ? En : h.useEffect
  , rS = e => {
    var t = e?.lastIndexOf(":");
    return t === -1 ? "" : e?.substring(t + 1)
}
  , V1e = e => {
    let t = []
      , n = []
      , r = (s, o, {partOfInitial: i}) => {
        Array.isArray(s) ? s.forEach(a => r(a, o, {
            partOfInitial: i
        })) : (o += (o ? "." : "") + s.name,
        i && n.push(o + ":" + s.initial),
        Object.entries(s.states).forEach( ([a,l]) => {
            let c = o + ":" + a;
            l.machine = o,
            l.path = c,
            l.reactive = !s.silentOnly,
            t.push(l),
            l.machines && r(l.machines, c, {
                partOfInitial: i && s.initial === a
            })
        }
        ))
    }
    ;
    return r(e, "", {
        partOfInitial: !0
    }),
    [n, t]
}
  , WO = (e, t) => e.includes(":") ? e : t.substring(0, t.lastIndexOf(":") + 1) + e
  , KO = e => {
    let t = e.split(".")
      , n = [];
    return t.forEach( (r, s) => {
        let o = n[s - 1]
          , i = (o ? o.full + "." : "") + r
          , a = i.substring(0, i.lastIndexOf(":"))
          , l = i.substring(i.lastIndexOf(":") + 1);
        n.push({
            full: i,
            withoutState: a,
            state: l
        })
    }
    ),
    n
}
  , H1e = ({checkedPoolOfStates: e, referencePoolOfStates: t, callbackOnExclusion: n, callbackOnPresent: r}) => e.filter(o => {
    let i = !0;
    return o.forEach(a => {
        t.forEach(l => {
            l.forEach(c => {
                a.withoutState === c.withoutState && (a.state !== c.state ? (i = !1,
                n?.({
                    decomposedCheckedState: o,
                    checkedStatePiece: a,
                    decomposedReferenceState: l,
                    referenceStatePiece: c
                })) : r({
                    decomposedCheckedState: o,
                    checkedStatePiece: a,
                    decomposedReferenceState: l,
                    referenceStatePiece: c
                }))
            }
            )
        }
        )
    }
    ),
    i
}
)
  , z1e = e => {
    let[t,n] = V1e(e);
    return [t, (r, s) => {
        let o, i = typeof s == "string" ? s : s.type, a = [];
        n.forEach(C => {
            r.includes(C.path) && (!s.machine || s.machine === C.machine) && C.messages && Object.entries(C.messages).forEach( ([w,x]) => {
                if (w === i) {
                    if (typeof x == "string")
                        o = w,
                        a.push(WO(x, C.path));
                    else
                        for (let E of x)
                            if (!E.guard || E.guard(r, s)) {
                                o = w,
                                a.push(WO(E.target, C.path));
                                break
                            }
                }
            }
            )
        }
        );
        let l = r.map(C => KO(C))
          , c = a.map(C => KO(C))
          , u = []
          , d = H1e({
            checkedPoolOfStates: l,
            referencePoolOfStates: c,
            callbackOnExclusion: ({decomposedCheckedState: C}) => {
                u.push(C[C.length - 1].full)
            }
            ,
            callbackOnPresent: ({referenceStatePiece: C}) => {
                C.unchanged = !0
            }
        })
          , f = d.map(C => C[C.length - 1].full)
          , p = []
          , m = [];
        c.forEach(C => {
            C.forEach( (w, x) => {
                if (!w.unchanged) {
                    var E, T;
                    x < C.length - 1 && p.push(w.full);
                    let k = n.find(A => A.path === w.full);
                    (E = k.machines) === null || E === void 0 || (T = E.forEach) === null || T === void 0 || T.call(E, A => {
                        let O = () => {
                            c.find(I => I.find(R => R.withoutState === `${k.path}.${A.name}`)) || m.push(`${k.path}.${A.name}:${A.initial}`)
                        }
                        ;
                        x < C.length - 1 ? k.path + A.name !== C[x + 1].withoutState && O() : O();
                        let M = I => {
                            var R, D;
                            (R = n.find(L => L.path === I).machines) === null || R === void 0 || (D = R.forEach) === null || D === void 0 || D.call(R, L => {
                                c.find(N => N.find(B => B.withoutState === `${k.path}.${L.name}`)) || m.push(`${I}.${L.name}:${L.initial}`),
                                M(`${I}.${L.name}:${L.initial}`)
                            }
                            )
                        }
                        ;
                        M(`${k.path}.${A.name}:${A.initial}`)
                    }
                    )
                }
            }
            )
        }
        );
        let v = [...a, ...p, ...m]
          , _ = [...f, ...v]
          , y = [...u, ...v]
          , b = n.filter(C => y.includes(C.path))
          , S = b.some(C => C.reactive);
        return {
            exitedStates: u,
            transitionTaken: o,
            enteredStates: v,
            nextStates: _,
            reactive: S
        }
    }
    ]
}
  , mm = (e, t) => e?.toStrings().filter(n => n?.startsWith(t)).filter(n => {
    var r;
    return !(!((r = n?.slice(t.length)) === null || r === void 0) && r.includes("."))
}
)[0]
  , YO = e => {
    let[t,n] = h.useMemo( () => z1e(e), [e])
      , r = h.useRef()
      , s = h.useRef([])
      , o = h.useRef([])
      , i = h.useRef([])
      , a = h.useRef([])
      , l = h.useRef(t)
      , c = h.useRef({
        toStrings: () => t,
        matches: m => kl(t, m),
        lastMessageTreatedRef: r,
        exitActionsRef: s,
        transitionActionsRef: o,
        entryActionsRef: i,
        selectorsRef: a
    })
      , [u,d] = h.useState({
        ...c.current,
        silent: c.current
    })
      , f = h.useRef([])
      , p = h.useCallback(m => {
        f.current.push(m);
        let v = _ => {
            let {nextStates: y, exitedStates: b, transitionTaken: S, enteredStates: C, reactive: w} = n(l.current, f.current[0])
              , x = l.current;
            if (l.current = y,
            s.current.forEach(E => {
                b.includes(E.state) && (typeof E.guard == "function" ? E.guard(x, f.current[0]) : E.guard) && E.callback(f.current[0], E.params)
            }
            ),
            o.current.forEach(E => {
                b.includes(E.state) && E.transition === S && (typeof E.guard == "function" ? E.guard(x, f.current[0]) : E.guard) && E.callback(f.current[0], E.params)
            }
            ),
            i.current.forEach(E => {
                C.includes(E.state) && (typeof E.guard == "function" ? E.guard(x, f.current[0]) : E.guard) && E.callback(f.current[0], E.params)
            }
            ),
            r.current = typeof f.current[0] == "string" ? {
                type: f.current[0]
            } : f.current[0],
            f.current.shift(),
            f.current.length)
                v(w || _);
            else {
                let E = y.slice();
                c.current.toStrings = () => E,
                c.current.matches = T => kl(E, T),
                c.current.getValues = () => [rS(E.toStrings)],
                a.current.forEach(T => {
                    let k = T.current.selection;
                    T.current.toStrings = () => [mm(c.current, k)],
                    T.current.matches = A => kl([mm(c.current, k)], A),
                    T.current.getValues = () => [rS(mm(c.current, k))]
                }
                ),
                (_ || w) && d({
                    ...c.current,
                    silent: c.current
                })
            }
        }
        ;
        f.current.length === 1 && v()
    }
    , [n]);
    return [u, p]
}
  , $1e = (e, t, n, {message: r="", delay: s=null, ...o}={
    delay: null
}) => {
    h.useEffect( () => {
        let i;
        return t.matches(n) && (i = setTimeout( () => e({
            type: "",
            ...o
        }), s ?? 0)),
        () => {
            i && clearTimeout(i)
        }
    }
    , [t, n, s, e, r, o])
}
  , js = (e, t, {shallow: n=!0}={}) => {
    let r = h.useMemo( () => mm(e, t), [e, t])
      , s = h.useRef({
        lastMessageTreatedRef: e?.lastMessageTreatedRef,
        exitActionsRef: e?.exitActionsRef,
        transitionActionsRef: e?.transitionActionsRef,
        entryActionsRef: e?.entryActionsRef,
        toStrings: () => [r],
        matches: i => kl([r], i),
        selection: t,
        getValues: () => [rS(r)]
    })
      , o = h.useRef(Symbol());
    return En( () => {
        e.selectorsRef.current.find(a => a.id === o.current) || e.selectorsRef.current.push(s)
    }
    , []),
    h.useMemo( () => ({
        ...s.current,
        silent: s.current
    }), [r])
}
  , kl = (e, t) => Array.isArray(t) ? t.some(n => e.includes(n)) || e.some(n => t.some(r => n?.startsWith(r) && n?.charAt(r.length) === ".")) : e.includes(t) || e.some(n => n?.startsWith(t) && n?.charAt(t.length) === ".")
  , He = (e, t, n) => {
    let {state: r, callback: s, params: o, empty: i=!1} = n
      , a = !n.hasOwnProperty("guard") || n.guard
      , l = h.useMemo( () => o ? Object.values(o) : [], [o])
      , c = h.useMemo( () => t.entryActionsRef, [t])
      , u = f4(e === "before-paint" ? "layout" : "normal")
      , d = cq(p => {
        (p?.matches && p?.matches(r) || !p?.matches && kl(p, r)) && (typeof a == "function" && a() || typeof a != "function" && a) && s(p.lastMessageTreatedRef.current, o)
    }
    )
      , f = h.useRef(Symbol());
    u( () => {
        if (!i)
            if (e === "immediate") {
                let p = {
                    id: f.current,
                    state: r,
                    guard: a,
                    callback: s,
                    params: o
                }
                  , m = c.current.findIndex(v => v.id === f.current);
                m === -1 ? c.current.push(p) : c.current[m] = p
            } else
                d(t)
    }
    , e === "immediate" ? [e, r, a, s, c, ...l] : [e, d, t]),
    h.useEffect( () => () => {
        c.current = c.current.filter(p => p.id !== f.current)
    }
    , [])
}
  , vt = (e, t) => {
    let {state: n, transition: r, callback: s, params: o} = t
      , i = !t.hasOwnProperty("guard") || t.guard
      , a = h.useMemo( () => o ? Object.values(o) : [], [o])
      , l = h.useMemo( () => e.transitionActionsRef, [e])
      , c = h.useRef(Symbol());
    h.useEffect( () => {
        let u = {
            id: c.current,
            state: n,
            transition: r,
            guard: i,
            callback: s,
            params: o
        }
          , d = l.current.findIndex(f => f.id === c.current);
        d === -1 ? l.current.push(u) : l.current[d] = u
    }
    , [n, r, i, s, l, ...a]),
    h.useEffect( () => () => {
        l.current = l.current.filter(u => u.id !== c.current)
    }
    , [])
}
  , zi = (e, t, n) => {
    let {state: r, callback: s, params: o} = n
      , i = !n.hasOwnProperty("guard") || n.guard
      , a = h.useMemo( () => o ? Object.values(o) : [], [o])
      , l = h.useMemo( () => t.exitActionsRef, [t])
      , c = f4("normal");
    cq(d => {
        (d?.matches && d?.matches(r) || !d?.matches && kl(d, r)) && (typeof i == "function" && i() || typeof i != "function" && i) && s(d.lastMessageTreatedRef.current, o)
    }
    );
    let u = h.useRef(Symbol());
    c( () => {
        {
            let d = {
                id: u.current,
                state: r,
                guard: i,
                callback: s,
                params: o
            }
              , f = l.current.findIndex(p => p.id === u.current);
            f === -1 ? l.current.push(d) : l.current[f] = d
        }
        return () => {}
    }
    , [e, r, i, s, l, ...a]),
    h.useEffect( () => () => {
        l.current = l.current.filter(d => d.id !== u.current)
    }
    , [])
}
  , Tr = (e, t, n) => {
    let {state: r, callback: s, params: o, name: i} = n
      , a = !n.hasOwnProperty("guard") || n.guard
      , l = o ? Object.values(o) : []
      , c = typeof e == "string" ? e : e.start
      , u = typeof e == "string" ? e : e.update
      , d = h.useRef(null);
    He("immediate", t, {
        state: r,
        guard: a,
        callback: h.useCallback( () => {
            d.current = s(null, o)
        }
        , [s, o]),
        params: o,
        empty: c !== "immediate"
    });
    let f = f4(u === "before-paint" ? "layout" : "normal")
      , p = h.useRef(!1);
    f( () => {
        let m, v = t?.matches && t?.matches(r) || !t?.matches && kl(t, r) || r === "", _ = typeof a == "function" && a() || typeof a != "function" && a;
        return v && _ && (m = c === "immediate" ? p.current ? s(null, o) : d.current : s(null, o)),
        v && !p.current && (p.current = !0),
        () => {
            var y;
            ((y = t.silent) === null || y === void 0 ? void 0 : y.matches(r)) || (p.current = !1,
            d.current = null),
            m?.()
        }
    }
    , [r !== "" ? t : null, r, a, s, ...l])
}
  , W1e = e => {
    let t = h.useRef({
        value: e
    })
      , [n,r] = h.useState({
        value: e,
        silent: t.current
    })
      , s = h.useCallback(o => {
        let i = typeof o == "function" ? o(t.current.value) : o;
        t.current.value = i,
        r({
            value: i,
            silent: t.current
        })
    }
    , []);
    return [n, s]
}
;
function uq(...e) {
    return t => e.forEach(n => {
        typeof n == "function" ? n(t) : n != null && (n.current = t)
    }
    )
}
function jr(...e) {
    return h.useCallback(uq(...e), e)
}
var K1e = (e, t) => {
    let n = () => {
        t?.()
    }
      , r = o => {
        o.preventDefault(),
        window.addEventListener("touchend", n, {
            once: !0
        })
    }
      , s = e.current;
    return s.addEventListener("touchstart", r, {
        passive: !1
    }),
    () => {
        s && (s.removeEventListener("touchstart", r, {
            passive: !1
        }),
        window.removeEventListener("touchend", n))
    }
}
;
let Pb = !1
  , ZO = 0;
function Hl(e) {
    var t;
    if (h.useId !== void 0)
        return h.useId();
    let[n,r] = h.useState(Pb ? ++ZO : null);
    return En( () => {
        n === null && r(++ZO)
    }
    , []),
    h.useEffect( () => {
        Pb === !1 && (Pb = !0)
    }
    , []),
    (t = n) !== null && t !== void 0 ? t : void 0
}
let zn = h.forwardRef( (e, t) => {
    let {children: n, ...r} = e
      , s = h.Children.toArray(n)
      , o = s.find(Z1e);
    if (o) {
        let i = o.props.children
          , a = s.map(l => l !== o ? l : h.Children.count(i) > 1 ? h.Children.only(null) : h.isValidElement(i) ? i.props.children : null);
        return g.jsx(sS, {
            ...r,
            ref: t,
            children: h.isValidElement(i) ? h.cloneElement(i, void 0, a) : null
        })
    }
    return g.jsx(sS, {
        ...r,
        ref: t,
        children: n
    })
}
);
zn.displayName = "Slot.Root";
let sS = h.forwardRef( (e, t) => {
    let {children: n, ...r} = e
      , s = function(o) {
        var i, a;
        let l = (i = Object.getOwnPropertyDescriptor(o.props, "ref")) === null || i === void 0 ? void 0 : i.get
          , c = l && "isReactWarning"in l && l.isReactWarning;
        return c ? o.ref : (c = (l = (a = Object.getOwnPropertyDescriptor(o, "ref")) === null || a === void 0 ? void 0 : a.get) && "isReactWarning"in l && l.isReactWarning) ? o.props.ref : o.props.ref || o.ref
    }(n);
    return h.isValidElement(n) ? h.cloneElement(n, {
        ...function(o, i) {
            let a = {
                ...i
            };
            for (let l in i) {
                let c = o[l]
                  , u = i[l];
                /^on[A-Z]/.test(l) ? c && u ? a[l] = (...f) => {
                    u(...f),
                    c(...f)
                }
                : c && (a[l] = c) : l === "style" ? a[l] = {
                    ...c,
                    ...u
                } : l === "className" && (a[l] = [c, u].filter(Boolean).join(" "))
            }
            return {
                ...o,
                ...a
            }
        }(r, n.props),
        ref: t ? uq(t, s) : s
    }) : h.Children.count(n) > 1 ? h.Children.only(null) : null
}
);
sS.displayName = "Slot.Anonymous";
let Y1e = ({children: e}) => g.jsx(g.Fragment, {
    children: e
});
function Z1e(e) {
    return h.isValidElement(e) && e.type === Y1e
}
let Sp = 0
  , dq = [0, 0]
  , oS = !1
  , JO = () => {
    clearTimeout(UO),
    oS = !0,
    UO = setTimeout( () => oS = !1, 50)
}
  , XO = () => {
    oS || window.scrollTo(...dq)
}
  , fq = Ne.forwardRef( (e, t) => {
    let {asChild: n, active: r=!0, automaticallyDisabledForOptimisation: s=!0, axis: o="both", preventBodyScroll: i, children: a, "data-silk": l, className: c, ...u} = e
      , d = l?.includes("0ae")
      , f = h.useRef(null)
      , p = jr(f, t);
    En( () => {
        if (dq = [window.screenX, window.scrollY],
        r && i)
            if (Sp === 0) {
                let y = window.innerWidth
                  , b = document.documentElement.clientWidth
                  , S = window.innerHeight
                  , C = document.documentElement.clientHeight;
                document.body.style.setProperty("overflow", "hidden");
                let w = `${y - b}px`
                  , x = `${S - C}px`;
                document.querySelectorAll("[data-silk~='0al']").forEach(T => {
                    T.style.setProperty("--x-collapsed-scrollbar-thickness", w),
                    T.style.setProperty("--y-collapsed-scrollbar-thickness", x)
                }
                ),
                document.body.style.setProperty("padding-right", w),
                document.body.style.setProperty("padding-bottom", x),
                window.addEventListener("resize", JO),
                window.addEventListener("scroll", XO, {
                    passive: !1
                }),
                Sp++
            } else
                Sp++;
        return () => {
            if (r && i && --Sp == 0) {
                let y = document.querySelectorAll("[data-silk~='0al']");
                document.body.style.removeProperty("overflow"),
                y.forEach(b => {
                    b.style.removeProperty("--x-collapsed-scrollbar-thickness"),
                    b.style.removeProperty("--y-collapsed-scrollbar-thickness")
                }
                ),
                document.body.style.removeProperty("padding-right"),
                document.body.style.removeProperty("padding-bottom"),
                window.removeEventListener("scroll", XO),
                window.removeEventListener("resize", JO)
            }
        }
    }
    , [i, r]),
    h.useEffect( () => {
        let y, b = f.current;
        return !d && r && b && (y = new ResizeObserver(S => {
            S.forEach( () => {
                b.scrollTo(300, 300)
            }
            )
        }
        )).observe(b, {
            box: "border-box"
        }),
        () => {
            !d && r && b && y && (y.unobserve(b),
            y.disconnect())
        }
    }
    , [r, d]);
    let m = h.useCallback(y => {
        let b = y.currentTarget;
        b.scrollTo(300, 300),
        ln !== "ios" && ln !== "ipados" || CSS.supports("overscroll-behavior: contain") || (b.style.setProperty("overflow", "hidden"),
        setTimeout( () => {
            b.style.setProperty("overflow", "auto")
        }
        , 10))
    }
    , [])
      , v = n ? zn : "div"
      , _ = Hn("ScrollTrap", {
        active: r,
        automaticallyDisabledForOptimisation: s,
        axis: o
    });
    return g.jsx(v, {
        ..._("root", ["active", "automaticallyDisabledForOptimisation", "axis"], {
            className: c,
            dataSilk: [l, "0ac", "0ae"]
        }),
        onScroll: d ? void 0 : m,
        ...u,
        ref: p,
        children: a
    })
}
);
fq.displayName = "Sheet.Anonymous";
let hq = Ne.forwardRef( (e, t) => {
    let {asChild: n, className: r, dataSilk: s, children: o, ...i} = e
      , a = n ? zn : "div"
      , l = Hn("ScrollTrap", {});
    return g.jsx(a, {
        ...l("stabiliser", [], {
            className: r,
            dataSilk: [s]
        }),
        ...i,
        ref: t,
        children: o
    })
}
);
hq.displayName = "Sheet.DDD";
let pi = {
    Root: fq,
    Stabiliser: hq
}
  , pq = () => {
    let e = Hl();
    return h.useCallback(n => {
        n ? tt.addFixedComponent({
            id: e,
            element: n
        }) : tt.removeFixedComponent(e)
    }
    , [e])
}
  , J1e = Ne.forwardRef( (e, t) => {
    let {asChild: n, children: r, className: s, "data-silk": o, ...i} = e
      , a = pq()
      , l = jr(a, t)
      , c = Hn("Fixed", {});
    return g.jsx(pi.Root, {
        ...c("root", [], {
            className: s,
            dataSilk: [o, "0al"]
        }),
        asChild: n,
        ...i,
        ref: l,
        children: r
    })
}
);
J1e.displayName = "Fixed.Root";
let X1e = Ne.forwardRef( (e, t) => {
    let {asChild: n, children: r, ...s} = e;
    return g.jsx(pi.Stabiliser, {
        asChild: n,
        ...s,
        ref: t,
        children: r
    })
}
);
X1e.displayName = "Fixed.Content";
let Oa = Ne.createContext(null);
Oa.displayName = "Sheet.GenericContext";
let ro = Ne.createContext(null);
ro.displayName = "Sheet.Anonymous";
var Q1e = function(e) {
    let t = "cubic-bezier(";
    if (!e.startsWith(t))
        return null;
    let n = e.slice(t.length, -1)
      , r = n.split(",").map(s => parseFloat(s.trim()));
    return r.length !== 4 || r.some(isNaN) ? null : r
}
  , e0e = ({mass: e, stiffness: t, damping: n, initialVelocity: r=0, fromPosition: s, toPosition: o, precision: i}) => {
    let a = []
      , l = 0
      , c = Math.abs(o - s)
      , u = 0
      , d = r
      , f = !1
      , p = !1
      , m = -(1e-6 * t)
      , v = -(.001 * n)
      , _ = i / 22
      , y = 10 * i;
    for (; !(f && p); ) {
        let S = m * (u - c)
          , C = v * d
          , w = (S + C) / e;
        d += w,
        u += d,
        f = Math.abs(d) <= _,
        p = Math.abs(c - u) <= y;
        let x = u / c;
        a.push(x),
        l++
    }
    return {
        progressValuesArray: a,
        duration: l
    }
}
;
let gm = () => CSS.supports("transition-timing-function", "linear(0, 1)") && !aa()
  , t0e = ({origin: e=0, destination: t=1, animationConfig: n}) => {
    var r, s, o, i, a, l, c, u, d;
    let f = [], p;
    if (n && n.easing && n.easing !== "spring")
        if (n.easing === "linear") {
            p = (l = n.duration) !== null && l !== void 0 ? l : 250;
            let m = p
              , v = 1 / (m - 1);
            for (let _ = 0; _ < m; _++) {
                let y = _ * v;
                f.push(isNaN(y) ? 0 : y)
            }
        } else {
            let m;
            p = (c = n.duration) !== null && c !== void 0 ? c : 250;
            let v = p;
            m = n.easing === "ease" ? [.25, .1, .25, 1] : n.easing === "ease-in" ? [.42, 0, 1, 1] : n.easing === "ease-out" ? [0, 0, .58, 1] : n.easing === "ease-in-out" ? [.42, 0, .58, 1] : n.easing.startsWith("cubic-bezier") && (u = Q1e(n.easing)) !== null && u !== void 0 ? u : [.25, .1, .25, 1];
            let _ = g1e(...m);
            for (let y = 0; y <= v; y++)
                f.push(_(y / v))
        }
    else {
        let m = e0e({
            stiffness: (r = n?.stiffness) !== null && r !== void 0 ? r : 300,
            damping: (s = n?.damping) !== null && s !== void 0 ? s : 34,
            mass: (o = n?.mass) !== null && o !== void 0 ? o : 1,
            initialVelocity: (i = n?.initialVelocity) !== null && i !== void 0 ? i : 0,
            precision: (a = n?.precision) !== null && a !== void 0 ? a : .1,
            fromPosition: e,
            toPosition: t
        });
        f = m.progressValuesArray,
        p = m.duration
    }
    return {
        progressValuesArray: f,
        easing: "linear",
        duration: p,
        delay: (d = n?.delay) !== null && d !== void 0 ? d : 0
    }
}
  , Db = (e, t) => {
    let n = {};
    return e.forEach( ([r,s]) => {
        let o = su(t);
        n[r] = s({
            progress: t,
            tween: o
        })
    }
    ),
    n
}
  , QO = ({type: e, progressValuesArray: t, target: n, templatesPerProperty: r, reversedStackingIndex: s, selfAndAboveTravelProgressSum: o}) => {
    let i = s != null
      , a = l => e === "travel" ? l : i && o ? o?.[s] + l : 0;
    return {
        target: n,
        keyframes: gm() ? [Db(r, a(t[0])), Db(r, a(t[t.length - 1]))] : t.map(l => Db(r, a(l)))
    }
}
  , n0e = ({sheetId: e, destinationDetent: t, setSegment: n, viewElement: r, scrollContainer: s, travellingElement: o, contentPlacement: i, positionToScrollTo: a, scrollAxis: l, animationConfig: c, onTravel: u, onTravelStart: d, onTravelEnd: f, runOnTravelStart: p, rAFLoopEndCallback: m, dimensions: v, trackToTravelOn: _}) => {
    let y, b, S = tt.findSheet(e);
    if (!S)
        return;
    let C = []
      , w = [];
    C = S.travelAnimations,
    S.belowSheetsInStack.forEach(W => {
        w.push(...W.stackingAnimations.map(X => ({
            ...X,
            reversedStackingIndex: S.belowSheetsInStack.length - 1,
            selfAndAboveTravelProgressSum: W.selfAndAboveTravelProgressSum
        })))
    }
    ),
    p && d?.();
    let x = !(c.hasOwnProperty("contentMove") && !c.contentMove)
      , E = v.current.view.travelAxis.unitless
      , T = v.current.content.travelAxis.unitless
      , k = r.getBoundingClientRect()
      , A = o.getBoundingClientRect()
      , O = i !== "center" ? T : T + (E - T) / 2
      , M = A.top - k.top
      , I = A.left - k.left
      , R = 0;
    switch (_) {
    case "top":
        R = M + O;
        break;
    case "bottom":
        R = M - O;
        break;
    case "left":
        R = I + O;
        break;
    case "right":
        R = I - O
    }
    let D = Math.max(Math.abs(R) / O, 0)
      , P = v.current.progressValueAtDetents[t].exact
      , L = P * O
      , N = _ === "left" || _ === "top" ? L : -L
      , {progressValuesArray: B, easing: H, duration: ye, delay: Ie} = t0e({
        origin: R,
        destination: N,
        animationConfig: c
    })
      , be = P - D
      , me = function(W, X) {
        let Te = [];
        for (let se = 0; se < W.length - 1; se += X)
            Te.push(W[se]);
        return W.length % X != 0 && Te.push(W[W.length - 1]),
        Te
    }(B, 8)
      , ge = me.map(W => D + be * W)
      , ce = [];
    C.length && ce?.push(...C.map(W => QO({
        type: "travel",
        progressValuesArray: ge,
        target: W.target,
        templatesPerProperty: W.config
    }))),
    w.length && ce?.push(...w.map(W => QO({
        type: "stacking",
        progressValuesArray: ge,
        target: W.target,
        templatesPerProperty: W.config,
        reversedStackingIndex: W.reversedStackingIndex,
        selfAndAboveTravelProgressSum: W.selfAndAboveTravelProgressSum
    }))),
    y = l === "x" ? "X" : "Y";
    let Z = W => ({
        transform: "translate" + y + "(" + (R - N) * (1 - W) + "px)"
    });
    b = gm() ? [Z(me[0]), Z(me[me.length - 1])] : me.map(W => ({
        transform: "translate" + y + "(" + (R - N) * (1 - W) + "px)"
    }));
    let ne = () => {
        s.scrollTo({
            left: l === "x" ? a : 0,
            top: l === "y" ? a : 0
        })
    }
      , _e = W => {
        let X;
        if (!x)
            return W();
        X = gm() ? o.animate(b, {
            easing: "linear(" + me.join(",") + ")",
            duration: ye,
            delay: Ie
        }) : o.animate(b, {
            easing: H,
            duration: ye,
            delay: Ie
        });
        let Te = () => {
            W(),
            X.removeEventListener("finish", Te)
        }
        ;
        X.addEventListener("finish", Te)
    }
      , ee = W => {
        if (!ce.length)
            return W();
        let X = []
          , Te = gm();
        ce?.forEach( ({target: se, keyframes: G}) => {
            let F;
            F = Te ? se.animate(G, {
                easing: "linear(" + me.join(",") + ")",
                duration: ye,
                delay: Ie
            }) : se.animate(G, {
                easing: H,
                duration: ye,
                delay: Ie
            });
            let ke = new Promise(Ee => {
                let Y = () => {
                    Object.entries(G[G.length - 1]).forEach( ([le,Oe]) => {
                        se.style.setProperty((le.startsWith("webkit") || le.startsWith("moz") ? "-" : "") + le.replace(/[A-Z]/g, "-$&").toLowerCase(), Oe)
                    }
                    ),
                    F.removeEventListener("finish", Y),
                    Ee()
                }
                ;
                F.addEventListener("finish", Y)
            }
            );
            X.push(ke)
        }
        ),
        Promise.all(X).then( () => {
            W()
        }
        )
    }
      , oe = null
      , te = W => {
        (function X(Te, se, G) {
            let F = v.current.progressValueAtDetents
              , ke = F.length;
            oe || (oe = Te);
            let Ee = Te - oe
              , Y = Math.floor(Ee);
            if (Y < B.length) {
                let le = D + be * B[Y];
                if (le < 0)
                    se(le, [0, 0]);
                else if (le > 1)
                    se(le, [1, 1]);
                else
                    for (let Oe = 0; Oe < ke; Oe++) {
                        let ae = F[Oe]
                          , je = ae.after;
                        le > je && Oe + 1 < ke && le < F[Oe + 1].before ? se(le, [Oe, Oe + 1]) : le > ae.before && le < je && se(le, [Oe, Oe])
                    }
                requestAnimationFrame( () => X(document.timeline.currentTime, se, G))
            } else {
                let le = Math.min(ke - 1, t);
                se(P, [le, le]),
                x || ce?.length || m == null || m(),
                G()
            }
        }
        )(document.timeline.currentTime, (X, Te) => {
            u?.({
                progress: X,
                range: {
                    start: Te[0],
                    end: Te[1]
                },
                progressAtDetents: v.current.exactProgressValueAtDetents
            }),
            n(Te)
        }
        , W)
    }
      , ve = W => new Promise(X => {
        W( () => X())
    }
    )
      , Ue = () => {
        f?.()
    }
      , re = async () => {
        await Promise.all([ve(_e), ve(ee), ve(te)]),
        Ue()
    }
    ;
    requestAnimationFrame( () => {
        requestAnimationFrame( () => {
            ne(),
            re()
        }
        )
    }
    )
}
  , r0e = ({desiredDestinationDetent: e, currentDetent: t}) => typeof e == "number" ? e : t
  , s0e = ({trackToTravelOn: e, destinationDetent: t, detentCountExcludingZero: n, actualSwipeOutDisabledWithDetent: r, hasOppositeTracks: s, contentPlacement: o, elementsDimensions: i, snapBackAcceleratorTravelAxisSize: a}) => {
    var l;
    if (((l = i.detentMarkers) === null || l === void 0 ? void 0 : l.length) <= t - 1)
        return {
            positionToScrollTo: null,
            scrollAxis: null
        };
    let c = t === 0
      , u = t === 1
      , d = t === n
      , f = e === "right" || e === "bottom"
      , p = i.view.travelAxis.unitless
      , m = i.content.travelAxis.unitless
      , v = i.snapOutAccelerator.travelAxis.unitless
      , _ = i.detentMarkers
      , y = c ? 0 : _[t - 1].accumulatedOffsets.travelAxis.unitless
      , b = 0;
    if (s)
        d ? b = p - (p - m) / 2 + i.snapOutAccelerator.travelAxis.unitless : c && (b = f ? 0 : 1e4);
    else if (f)
        d ? b = 1e4 : r && u || c ? b = 0 : d || r && u || c || (b = r ? _[t - 1].accumulatedOffsets.travelAxis.unitless - _[0].travelAxis.unitless : y + v);
    else if (e === "left" || e === "top") {
        let S;
        S = r && u ? 2 * a : d ? 0 : a,
        b = o === "center" ? t === 0 ? m + (p - m) / 2 - y + S : 0 : m - y + S
    }
    return {
        positionToScrollTo: b,
        scrollAxis: e === "left" || e === "right" || e === "horizontal" ? "x" : "y"
    }
}
;
var o0e = ({destinationDetent: e, behavior: t="instant", runTravelCallbacksAndAnimations: n=!0, runOnTravelStart: r, animationConfig: s, rAFLoopEndCallback: o, trackToTravelOn: i, contentPlacement: a, onTravel: l, onTravelStart: c, onTravelEnd: u, fullTravelCallback: d, setProgrammaticScrollOngoing: f, currentDetent: p, segment: m, setSegment: v, lastProgressValue: _, dimensions: y, viewRef: b, scrollContainerRef: S, contentWrapperRef: C, sheetId: w, stackId: x, actualSwipeOutDisabledWithDetent: E, hasOppositeTracks: T, snapBackAcceleratorTravelAxisSize: k}) => {
    if (e === void 0 && p === null)
        return;
    let A = y.current
      , O = S.current;
    if (O && A.content) {
        let M = r0e({
            desiredDestinationDetent: e,
            currentDetent: p
        })
          , I = y.current.detentMarkers.length
          , {positionToScrollTo: R, scrollAxis: D} = s0e({
            destinationDetent: M,
            detentCountExcludingZero: I,
            trackToTravelOn: i,
            actualSwipeOutDisabledWithDetent: E,
            hasOppositeTracks: T,
            contentPlacement: a,
            snapBackAcceleratorTravelAxisSize: k,
            elementsDimensions: A
        });
        if (R !== null && D !== null) {
            if (f(!0),
            t === "smooth")
                n0e({
                    sheetId: w,
                    destinationDetent: M,
                    setSegment: v,
                    viewElement: b.current,
                    scrollContainer: O,
                    travellingElement: C.current,
                    positionToScrollTo: R,
                    contentPlacement: a,
                    scrollAxis: D,
                    animationConfig: s,
                    onTravel: l,
                    onTravelStart: c,
                    onTravelEnd: u,
                    runOnTravelStart: r,
                    rAFLoopEndCallback: o,
                    dimensions: y,
                    trackToTravelOn: i
                });
            else if (n && r && c?.(),
            D === "x" ? (O.scrollTo(R, 0),
            O.scrollLeft = R) : (O.scrollTo(0, R),
            O.scrollTop = R),
            v([M, M]),
            n) {
                let P = y.current.progressValueAtDetents[M].exact;
                d?.(P, m),
                u?.()
            }
        }
    }
}
;
let kd = e => {
    let t = h.useRef(null);
    return En( () => {
        t.current = e
    }
    ),
    h.useCallback( (...n) => {
        let r = t.current;
        return r(...n)
    }
    , [])
}
  , i0e = e => {
    let t, n = () => {
        e(),
        t = requestAnimationFrame(n)
    }
    ;
    return n(),
    () => {
        cancelAnimationFrame(t)
    }
}
  , a0e = ( () => {
    let e = !0;
    typeof window > "u" || CSS.supports("scroll-snap-align: start") || (e = !1);
    let t = !0;
    return typeof window > "u" || "IntersectionObserver"in window && "IntersectionObserverEntry"in window && "intersectionRatio"in window.IntersectionObserverEntry.prototype || (t = !1),
    e && t
}
)()
  , cg = {
    gentle: {
        stiffness: 560,
        damping: 68,
        mass: 1.85
    },
    smooth: {
        stiffness: 580,
        damping: 60,
        mass: 1.35
    },
    snappy: {
        stiffness: 350,
        damping: 34,
        mass: .9
    },
    brisk: {
        stiffness: 350,
        damping: 28,
        mass: .65
    },
    bouncy: {
        stiffness: 240,
        damping: 19,
        mass: .7
    },
    elastic: {
        stiffness: 260,
        damping: 20,
        mass: 1
    }
}
  , Lb = (e, t) => {
    var n;
    let r = typeof e == "string"
      , s = r ? cg[e] : (n = cg[e?.preset]) !== null && n !== void 0 ? n : null
      , o = s || e?.easing === "spring" || ["ease", "ease-in", "ease-out", "ease-in-out", "linear"].includes(e?.easing);
    return {
        skip: d4,
        easing: "spring",
        ...r ? {} : e,
        ...s ?? {},
        ...o ? {} : t
    }
}
  , l0e = (e, t) => e.includes("skipOpening:true") || t.skipOpening
  , eA = (e, t) => !e.includes("skipOpening:true") && !t.skipOpening
  , c0e = (e, t) => e.includes("skipClosing:true") || t.skipClosing
  , u0e = (e, t) => !e.includes("skipClosing:true") && !t.skipClosing
  , tA = e => e.includes("openness:closed.status:safe-to-unmount")
  , d0e = () => {
    let e = "false"
      , [t,n] = YO(h.useMemo( () => [{
        name: "staging",
        initial: "none",
        states: {
            none: {
                messages: {
                    OPEN: [{
                        guard: (m, v) => tA(m) && eA(m, v),
                        target: "opening"
                    }, {
                        guard: tA,
                        target: "open"
                    }],
                    OPEN_PREPARED: [{
                        guard: eA,
                        target: "opening"
                    }, {
                        target: "open"
                    }],
                    ACTUALLY_CLOSE: [{
                        guard: u0e,
                        target: "closing"
                    }],
                    ACTUALLY_STEP: "stepping",
                    GO_DOWN: [{
                        guard: (m, v) => !v.skipOpening,
                        target: "going-down"
                    }, {
                        target: "go-down"
                    }],
                    GO_UP: "going-up"
                }
            },
            open: {
                messages: {
                    NEXT: "none"
                }
            },
            opening: {
                messages: {
                    NEXT: "none"
                }
            },
            stepping: {
                messages: {
                    NEXT: "none"
                }
            },
            closing: {
                messages: {
                    NEXT: "none"
                }
            },
            "go-down": {
                messages: {
                    NEXT: "none"
                }
            },
            "going-down": {
                messages: {
                    NEXT: "none"
                }
            },
            "going-up": {
                messages: {
                    NEXT: "none"
                }
            }
        }
    }, {
        name: "longRunning",
        initial: e,
        states: {
            false: {
                messages: {
                    TO_TRUE: "true"
                }
            },
            true: {
                messages: {
                    TO_FALSE: "false"
                }
            }
        }
    }, {
        name: "openness",
        initial: "closed",
        states: {
            closed: {
                messages: {
                    READY_TO_OPEN: [{
                        guard: (m, v) => !v.skipOpening,
                        target: "opening"
                    }, {
                        target: "open"
                    }]
                },
                machines: {
                    name: "status",
                    initial: "safe-to-unmount",
                    states: {
                        pending: {
                            messages: {
                                OPEN: [{
                                    guard: l0e,
                                    target: "openness:closed.status:flushing-to-preparing-open"
                                }, {
                                    target: "openness:closed.status:flushing-to-preparing-opening"
                                }],
                                "": "safe-to-unmount"
                            }
                        },
                        "flushing-to-preparing-open": {
                            messages: {
                                "": "preparing-open"
                            }
                        },
                        "flushing-to-preparing-opening": {
                            messages: {
                                "": "preparing-opening"
                            }
                        },
                        "preparing-open": {},
                        "preparing-opening": {},
                        "safe-to-unmount": {}
                    }
                }
            },
            opening: {
                messages: {
                    NEXT: "open"
                }
            },
            open: {
                messages: {
                    ACTUALLY_CLOSE: [{
                        guard: c0e,
                        target: "openness:closed.status:pending"
                    }],
                    SWIPED_OUT: "openness:closed.status:pending",
                    READY_TO_CLOSE: [{
                        guard: (m, v) => !v.skipClosing,
                        target: "closing"
                    }]
                },
                machines: [{
                    name: "scroll",
                    initial: "ended",
                    states: {
                        ended: {
                            messages: {
                                SCROLL_START: "ongoing"
                            },
                            machines: [{
                                name: "afterPaintEffectsRun",
                                initial: "false",
                                states: {
                                    false: {
                                        messages: {
                                            OCCURRED: "true"
                                        }
                                    },
                                    true: {}
                                }
                            }]
                        },
                        ongoing: {
                            messages: {
                                SCROLL_END: "ended"
                            }
                        }
                    }
                }, {
                    name: "move",
                    initial: "ended",
                    states: {
                        ended: {
                            messages: {
                                MOVE_START: "ongoing"
                            }
                        },
                        ongoing: {
                            messages: {
                                MOVE_END: "ended"
                            }
                        }
                    }
                }, {
                    name: "swipe",
                    silentOnly: !0,
                    initial: "unstarted",
                    states: {
                        unstarted: {
                            messages: {
                                SWIPE_START: "ongoing"
                            }
                        },
                        ongoing: {
                            messages: {
                                SWIPE_END: "ended"
                            }
                        },
                        ended: {
                            messages: {
                                SWIPE_START: "ongoing",
                                SWIPE_RESET: "unstarted"
                            }
                        }
                    }
                }, {
                    name: "evaluateCloseMessage",
                    silentOnly: !0,
                    initial: "false",
                    states: {
                        false: {
                            messages: {
                                CLOSE: "true"
                            }
                        },
                        true: {
                            messages: {
                                CLOSE: "false"
                            }
                        }
                    }
                }, {
                    name: "evaluateStepMessage",
                    silentOnly: !0,
                    initial: "false",
                    states: {
                        false: {
                            messages: {
                                STEP: "true"
                            }
                        },
                        true: {
                            messages: {
                                STEP: "false"
                            }
                        }
                    }
                }]
            },
            closing: {
                messages: {
                    NEXT: "openness:closed.status:pending"
                }
            }
        }
    }, {
        name: "skipOpening",
        initial: "false",
        states: {
            true: {
                messages: {
                    TO_FALSE: "false"
                }
            },
            false: {
                messages: {
                    TO_TRUE: "true"
                }
            }
        }
    }, {
        name: "skipClosing",
        initial: "false",
        states: {
            true: {
                messages: {
                    TO_FALSE: "false"
                }
            },
            false: {
                messages: {
                    TO_TRUE: "true"
                }
            }
        }
    }, {
        name: "scrollContainerTouch",
        silentOnly: !0,
        initial: "ended",
        states: {
            ended: {
                messages: {
                    TOUCH_START: "ongoing"
                }
            },
            ongoing: {
                messages: {
                    TOUCH_END: "ended"
                }
            }
        }
    }, {
        name: "backStuck",
        silentOnly: !0,
        initial: "false",
        states: {
            false: {
                messages: {
                    STUCK_START: "true"
                }
            },
            true: {
                messages: {
                    STUCK_END: "false"
                }
            }
        }
    }, {
        name: "frontStuck",
        silentOnly: !0,
        initial: "false",
        states: {
            false: {
                messages: {
                    STUCK_START: "true"
                }
            },
            true: {
                messages: {
                    STUCK_END: "false"
                }
            }
        }
    }], [e]))
      , [r,s] = YO(h.useMemo( () => [{
        name: "active",
        initial: "false",
        states: {
            false: {
                messages: {
                    TO_TRUE: "true"
                }
            },
            true: {
                messages: {
                    TO_FALSE: "false"
                }
            }
        }
    }, {
        name: "position",
        initial: "out",
        states: {
            out: {
                messages: {
                    READY_TO_GO_FRONT: [{
                        guard: (m, v) => v.skipOpening,
                        target: "position:front.status:idle"
                    }, {
                        target: "position:front.status:opening"
                    }]
                }
            },
            front: {
                machines: [{
                    name: "status",
                    initial: "opening",
                    states: {
                        opening: {
                            messages: {
                                NEXT: "idle"
                            }
                        },
                        closing: {
                            messages: {
                                NEXT: "position:out"
                            }
                        },
                        idle: {
                            messages: {
                                READY_TO_GO_DOWN: [{
                                    guard: (m, v) => v.skipOpening,
                                    target: "position:covered.status:idle"
                                }, {
                                    target: "position:covered.status:going-down"
                                }],
                                READY_TO_GO_OUT: "closing",
                                GO_OUT: "position:out"
                            }
                        }
                    }
                }]
            },
            covered: {
                machines: [{
                    name: "status",
                    initial: "going-down",
                    states: {
                        "going-down": {
                            messages: {
                                NEXT: "idle"
                            }
                        },
                        "going-up": {
                            messages: {
                                NEXT: "indeterminate"
                            }
                        },
                        indeterminate: {
                            messages: {
                                GOTO_idle: "idle",
                                GOTO_front: "position:front.status:idle"
                            }
                        },
                        idle: {
                            messages: {
                                READY_TO_GO_DOWN: [{
                                    guard: (m, v) => v.skipOpening,
                                    target: "come-back"
                                }, {
                                    target: "going-down"
                                }],
                                READY_TO_GO_UP: "going-up",
                                GO_UP: "indeterminate"
                            }
                        },
                        "come-back": {
                            messages: {
                                "": "idle"
                            }
                        }
                    }
                }]
            }
        }
    }], []))
      , o = h.useMemo( () => r.matches("position:out") ? "out" : r.matches("position:front") ? "front" : r.matches("position:covered") ? "covered" : void 0, [r])
      , i = h.useMemo( () => r.matches("position:covered.status:idle") ? "idle" : r.matches("position:covered.status:going-down") ? "going-down" : r.matches("position:covered.status:going-up") ? "going-up" : null, [r])
      , a = js(t, "staging")
      , l = h.useMemo( () => a.getValues()[0], [a])
      , [c,u] = W1e(-1)
      , d = Hl()
      , f = Hl();
    return h.useMemo( () => ({
        titleId: d,
        descriptionId: f,
        staging: l,
        opennessState: t,
        sendToOpennessMachine: n,
        positionState: r,
        sendToPositionMachine: s,
        layerPosition: o,
        layerCovered: i,
        stackingIndex: c,
        assignStackingIndex: u
    }), [d, f, l, t, n, r, s, o, i, c, u])
}
  , mq = Ne.forwardRef( (e, t) => {
    let n, {forComponent: r, as: s, children: o, className: i, "data-silk": a, initialState: l, onPresentAutoFocus: c, onDismissAutoFocus: u, onTravelStatusChange: d, onTravelRangeChange: f, swipeDismissal: p=!0, swipe: m=!0, snapOutAcceleration: v="auto", snapToEndDetentsAcceleration: _="auto", onTravel: y, onTravelStart: b, onTravelEnd: S, detents: C, inertOutside: w=!0, nativeEdgeSwipePrevention: x=!1, onSwipeFromEdgeToGoBackAttempt: E, onClickOutside: T, onEscapeKeyDown: k, onFocusInside: A, nativeFocusScrollPrevention: O=!0, contentPlacement: M=null, tracks: I, swipeOvershoot: R=!0, swipeTrap: D, enteringAnimationSettings: P, exitingAnimationSettings: L, steppingAnimationSettings: N, id: B, ...H} = e, ye = r ?? Oa, Ie = h.useContext(ye) || {}, {license: be, StackContext: me, CustomSheetContext: ge, sheetRole: ce, open: Z, onOpenChange: ne, elementFocusedLastBeforeShowing: _e, onSafeToUnmountChange: ee, setLongRunning: oe, setStaging: te, defaultActiveDetent: ve, activeDetent: Ue, onActiveDetentChange: re, sheetId: W} = Ie, {titleId: X, descriptionId: Te, staging: se, opennessState: G, sendToOpennessMachine: F, positionState: ke, sendToPositionMachine: Ee, layerCovered: Y, stackingIndex: le, assignStackingIndex: Oe} = d0e(), ae = js(G, "staging"), {stackId: je, setSheetsCount: ot, updateSheetStagingDataInStack: St, removeSheetStagingDataInStack: Tt, updateSheetDataInStack: wt, removeSheetDataFromStack: ut, getPreviousSheetDataInStack: Mt} = me ? h.useContext(me) : {}, {ancestorPrimarySwipeTrapActiveOnYAxis: fn} = h.useContext(ro) || {}, Yt = pq(), jt = h.useRef(null), gn = jr(jt, Yt, t), kn = h.useRef(null), On = h.useRef(null), Ut = h.useRef(null), Os = h.useRef(null), hn = h.useRef(null), Pi = h.useRef(null), ud = h.useRef(null), dc = h.useRef([]), Br = h.useMemo( () => C ? typeof C == "string" ? [C, "var(--silk-aF)"] : [...C, "var(--silk-aF)"] : ["var(--silk-aF)"], [C]), Di = h.useRef(null);
    h.useEffect( () => {
        Di.current === null && Number.isInteger(Ue) && Ue > 0 && (Di.current = Ue)
    }
    , []);
    let Fn = h.useMemo( () => Number.isInteger(ve) ? ve : Number.isInteger(Ue) && Ue > 0 ? Ue : Di.current ? Di.current : 1, [Ue, ve])
      , {actualTrack: $e, actualPlacement: tn} = h.useMemo( () => {
        let j = {
            actualPlacement: null,
            actualTrack: null
        };
        return M && !I ? (j.actualPlacement = M,
        M !== "center" ? j.actualTrack = M : j.actualTrack = "bottom") : I && !M ? Array.isArray(I) ? (j.actualPlacement = "center",
        j.actualTrack = I.includes("left") ? "horizontal" : "vertical") : (j.actualPlacement = I,
        j.actualTrack = I) : I || M ? I && M && (j.actualPlacement = M,
        Array.isArray(I) ? j.actualTrack = I.includes("left") ? "horizontal" : "vertical" : j.actualTrack = I) : (j.actualPlacement = "bottom",
        j.actualTrack = "bottom"),
        [{
            state: "staging:opening",
            configTrack: P?.track
        }, {
            state: "staging:closing",
            configTrack: L?.track
        }].forEach( ({state: J, configTrack: Q}) => {
            G.matches(J) && Q && (Q === "top" && j.actualTrack === "bottom" || Q === "bottom" && j.actualTrack === "top" ? j.actualTrack = "vertical" : (Q === "left" && j.actualTrack === "right" || Q === "right" && j.actualTrack === "left") && (j.actualTrack = "horizontal"))
        }
        ),
        j
    }
    , [M, I, P?.track, L?.track, G]);
    h.useMemo( () => $e === "horizontal", [$e]);
    let s0 = h.useMemo( () => $e === "vertical", [$e]);
    h.useEffect( () => {
        if (M?.includes("top") && I && I !== "top" || M?.includes("bottom") && I && I !== "bottom" || !M?.includes("center") && I && I.includes("top") && I.includes("bottom") || M?.includes("left") && I && I !== "left" || M?.includes("right") && I && I !== "right" || !M?.includes("center") && I && I.includes("left") && I.includes("right"))
            throw Error(`'placement' prop value '${M}' cannot be used with 'tracks' prop value '${I}'.`)
    }
    , [M, I]);
    let $o = h.useMemo( () => P?.track || ($e === "horizontal" ? "right" : $e === "vertical" ? "bottom" : $e), [P?.track, $e])
      , qr = h.useMemo( () => Lb(P, cg.smooth), [P])
      , Se = h.useMemo( () => Lb(L, {
        easing: "spring",
        stiffness: 520,
        damping: 44,
        mass: 1
    }), [L])
      , Nt = h.useMemo( () => Lb(N ?? P, cg.smooth), [N, P])
      , ht = h.useMemo( () => ce === "alertdialog" || !p, [p, ce])
      , dt = ($e !== "horizontal" && $e !== "vertical" || !!ht) && !R
      , [nt,yt,$n,vn] = h.useMemo( () => {
        let j = !1
          , $ = !1
          , J = !1
          , Q = !1;
        return m && a0e ? ht && (C ? (J = !0,
        G.matches("openness:open") && !G.matches("staging:closing") && ($ = !0)) : G.matches("openness:open") && !G.matches("staging:closing") && (dt === !1 && aa() ? Q = !0 : j = !0)) : G.matches("openness:closed") || (j = !0),
        [j, $, J, Q]
    }
    , [m, G, ht, C, dt])
      , mo = h.useMemo( () => ae.getValues()[0] !== "none", [ae])
      , go = ["right", "left", "horizontal"].includes($e) ? "horizontal" : "vertical"
      , [Li,Ha] = h.useState(!1)
      , [za,Gr] = h.useState(!1)
      , $a = h.useMemo( () => !w && (w ? void 0 : Li !== !0), [w, Li])
      , Er = h.useMemo( () => dt === !0 ? _ === "auto" ? 10 : 1 : 0, [dt, _])
      , As = h.useRef(null);
    h.useEffect( () => (W && (As.current = tt.addSheet({
        id: W,
        stackId: je,
        stackingIndex: -1,
        sendToOpennessMachine: F
    })),
    () => {
        W && tt.attemptToRemoveSheetOrCleanup(W)
    }
    ), [F, W, je]),
    h.useEffect( () => (O && tt.addNativeFocusScrollPreventer(W),
    () => {
        O && tt.removeNativeFocusScrollPreventer(W)
    }
    ), [O, W]);
    let Ye = h.useMemo( () => Mt?.(W), [Mt, W])
      , [fc,Dz] = h.useState(null)
      , hc = h.useMemo( () => y && fc ? j => {
        fc(j),
        y(j)
    }
    : y && !fc ? y : !y && fc ? fc : null, [y, fc])
      , dd = h.useCallback( () => {
        S?.();
        let j = Zt.current.exactProgressValueAtDetents[Pt.current[0]];
        Ui.current = j,
        tt.updateSheetTravelProgress(W, j)
    }
    , [S, W])
      , Wo = h.useMemo( () => {
        let j;
        if (le.value > 0)
            j = hc ? ($, J) => {
                hc({
                    progress: $,
                    range: J,
                    progressAtDetents: Zt.current.exactProgressValueAtDetents
                });
                let Q = su($);
                As.current.aggregatedTravelCallback($, Q)
            }
            : $ => {
                let J = su($);
                As.current.aggregatedTravelCallback($, J)
            }
            ;
        else {
            let $ = tt.getAggregatedStackingCallbackForSheetsBelow(W);
            j = $ ? hc ? (J, Q) => {
                hc({
                    progress: J,
                    range: Q,
                    progressAtDetents: Zt.current.exactProgressValueAtDetents
                });
                let Ve = su(J);
                As.current.aggregatedTravelCallback(J, Ve),
                $(J, Ve)
            }
            : J => {
                let Q = su(J);
                As.current.aggregatedTravelCallback(J, Q),
                $(J, Q)
            }
            : () => {}
        }
        return j
    }
    , [le.value, hc, W])
      , fd = h.useRef(!1)
      , yE = h.useMemo( () => {
        let j;
        return $e === "bottom" || $e === "vertical" ? j = "translateY(-2px)" : $e === "top" ? j = "translateY(2px)" : $e === "right" || $e === "horizontal" ? j = "translateX(-2px)" : $e === "left" && (j = "translateX(2px)"),
        $ => {
            $ > 0 && $ < 1 && !fd.current ? (hn.current.style.setProperty("transform", j),
            fd.current = !0) : ($ > 1 || $ <= 0) && fd.current && (hn.current.style.removeProperty("transform"),
            fd.current = !1)
        }
    }
    , [$e])
      , jh = h.useMemo( () => vn ? j => yE(j) : Wo, [yE, vn, Wo])
      , [hd,Uh] = h.useState("both")
      , bE = QB(jt);
    h.useEffect( () => {
        var j, $;
        let J, Q, Ve;
        if (typeof D == "boolean")
            J = {
                x: D,
                y: D
            };
        else {
            let {x: Mn, y: lr} = D || {};
            J = {
                x: Mn,
                y: lr
            }
        }
        let Ze = (ln === "ios" || ln === "ipados") && w && !fn
          , pt = eq();
        go === "vertical" && (Q = J.x,
        Ve = !!Ze || !pt && ((j = J.y) === null || j === void 0 || j)),
        go === "horizontal" && (Ve = !!Ze || J.y,
        Q = ($ = J.x) === null || $ === void 0 || $),
        Ve = !!Ve || bE,
        Uh(Q && !Ve ? "horizontal" : !Q && Ve ? "vertical" : Q && Ve ? "both" : "none")
    }
    , [fn, w, D, bE, go]);
    let Zt = h.useRef({})
      , [CE,Lz] = h.useState(0)
      , [Fz,jz] = h.useState( () => () => ({
        top: null,
        bottom: null
    }))
      , o0 = h.useRef([])
      , Pt = h.useRef([0, 0])
      , Bh = h.useRef(0)
      , An = h.useRef(null)
      , i0 = h.useRef( () => {}
    )
      , qh = h.useRef(!1)
      , SE = h.useRef(!1)
      , a0 = h.useCallback(j => SE.current = j, [])
      , _r = kd( ({destinationDetent: j, trackToTravelOn: $=$e === "vertical" ? "bottom" : $e === "horizontal" ? "right" : $e, behavior: J="instant", runTravelCallbacksAndAnimations: Q=!0, runOnTravelStart: Ve=!0, animationConfig: Ze, rAFLoopEndCallback: pt, travelEndCallback: Mn}) => {
        o0e({
            destinationDetent: j,
            behavior: J,
            runTravelCallbacksAndAnimations: Q,
            runOnTravelStart: Ve,
            trackToTravelOn: $,
            animationConfig: Ze,
            rAFLoopEndCallback: pt,
            onTravel: hc,
            onTravelStart: b,
            onTravelEnd: () => {
                Mn?.(),
                dd()
            }
            ,
            segment: Pt,
            fullTravelCallback: Wo,
            sheetId: W,
            stackId: je,
            dimensions: Zt,
            snapBackAcceleratorTravelAxisSize: Er,
            actualSwipeOutDisabledWithDetent: yt,
            lastProgressValue: Ui,
            viewRef: jt,
            scrollContainerRef: Ut,
            contentWrapperRef: hn,
            currentDetent: Pt.current[0] === Pt.current[1] ? Pt.current[0] : null,
            setSegment: Yo,
            setProgrammaticScrollOngoing: a0,
            contentPlacement: tn,
            hasOppositeTracks: $e === "horizontal" || $e === "vertical"
        })
    }
    )
      , Uz = h.useCallback( () => {
        Pt.current[0] === Pt.current[1] && _r({
            runTravelCallbacksAndAnimations: !1,
            destinationDetent: Pt.current[0]
        })
    }
    , [W, $e, yt, vn, Er])
      , Bz = h.useCallback(j => {
        wt?.({
            sheetId: W,
            sendToOpennessMachine: F,
            sendToPositionMachine: Ee
        })
    }
    , [wt, W, F, Ee])
      , wE = h.useCallback( () => {
        ut?.(W)
    }
    , [ut, W])
      , EE = h.useMemo( () => ce === "alertdialog" ? () => {}
    : () => F({
        type: "CLOSE"
    }), [F, ce])
      , qz = h.useCallback( () => {
        tt.updateLayer({
            layerId: W,
            layerContextId: ge,
            layerStackContextId: me,
            inertOutside: w,
            onPresentAutoFocus: c,
            onDismissAutoFocus: u,
            dismissOverlayIfNotAlertDialog: EE,
            onClickOutside: T,
            onEscapeKeyDown: k,
            viewElement: jt.current,
            backdropElement: On.current,
            scrollContainerElement: Ut.current,
            elementFocusedLastBeforeShowing: _e.current
        })
    }
    , [W, ge, me, w, c, u, EE, T, k, _e])
      , xE = h.useCallback( () => {
        tt.removeLayer(W)
    }
    , [W])
      , Gz = h.useCallback( () => {
        let j = Q => ["ArrowDown", "ArrowUp", "PageDown", "PageUp", "End", "Home", " "].includes(Q.key)
          , $ = Q => {
            if (j(Q)) {
                var Ve, Ze;
                (Ve = Ut.current) === null || Ve === void 0 || Ve.style.setProperty("overflow", "hidden"),
                (Ze = Ut.current) === null || Ze === void 0 || Ze.style.setProperty("scroll-snap-type", "none")
            }
        }
          , J = Q => {
            if (j(Q)) {
                var Ve, Ze;
                (Ve = Ut.current) === null || Ve === void 0 || Ve.style.removeProperty("overflow"),
                (Ze = Ut.current) === null || Ze === void 0 || Ze.style.removeProperty("scroll-snap-type")
            }
        }
        ;
        return document.addEventListener("keydown", $),
        document.addEventListener("keyup", J),
        () => {
            document.removeEventListener("keydown", $),
            document.removeEventListener("keyup", J)
        }
    }
    , [])
      , pc = h.useCallback( () => {
        Oe(j => j + 1),
        tt.updateSheetStackingIndex(W, le.silent.value)
    }
    , [Oe, le.silent, W])
      , Fi = h.useCallback( () => {
        Oe(j => j - 1),
        tt.updateSheetStackingIndex(W, le.silent.value)
    }
    , [Oe, le.silent, W])
      , Gh = js(ke, "active");
    Tr("after-paint", Gh, {
        state: "active:true",
        callback: qz
    }),
    Tr("after-paint", Gh, {
        state: "active:true",
        callback: Gz
    }),
    He("after-paint", Gh, {
        state: "active:false",
        callback: xE
    });
    let mc = js(ke, "position")
      , ji = js(ke, "position:covered.status");
    vt(mc, {
        state: "position:out",
        transition: "READY_TO_GO_FRONT",
        callback: h.useCallback(j => {
            Ye?.sendToPositionMachine({
                type: "READY_TO_GO_DOWN",
                skipOpening: j.skipOpening
            }),
            pc()
        }
        , [pc, Ye])
    }),
    vt(ke, {
        state: "position:front.status:opening",
        transition: "NEXT",
        callback: h.useCallback( () => {
            Ye?.sendToPositionMachine("NEXT")
        }
        , [Ye])
    }),
    vt(ke, {
        state: "position:front.status:idle",
        transition: "READY_TO_GO_OUT",
        callback: h.useCallback( () => {
            Ye?.sendToPositionMachine("READY_TO_GO_UP")
        }
        , [Ye])
    }),
    vt(ke, {
        state: "position:front.status:idle",
        transition: "GO_OUT",
        callback: h.useCallback( () => {
            Wo?.(0, {
                start: 0,
                end: 0
            }),
            dd(),
            Ye?.sendToPositionMachine("GO_UP"),
            Fi()
        }
        , [Wo, dd, Ye, Fi])
    }),
    vt(ke, {
        state: "position:front.status:idle",
        transition: "READY_TO_GO_DOWN",
        callback: h.useCallback(j => {
            Ye?.sendToPositionMachine({
                type: "READY_TO_GO_DOWN",
                skipOpening: j.skipOpening
            }),
            pc()
        }
        , [pc, Ye])
    }),
    vt(ke, {
        state: "position:front.status:closing",
        transition: "NEXT",
        callback: h.useCallback( () => {
            Ye?.sendToPositionMachine("NEXT"),
            Fi()
        }
        , [Ye, Fi])
    }),
    vt(ji, {
        state: "position:covered.status:going-down",
        transition: "NEXT",
        callback: h.useCallback( () => {
            Ye?.sendToPositionMachine("NEXT")
        }
        , [Ye])
    }),
    vt(ji, {
        state: "position:covered.status:idle",
        transition: "READY_TO_GO_DOWN",
        callback: h.useCallback(j => {
            Ye?.sendToPositionMachine({
                type: "READY_TO_GO_DOWN",
                skipOpening: j.skipOpening
            }),
            pc()
        }
        , [pc, Ye])
    }),
    vt(ji, {
        state: "position:covered.status:idle",
        transition: "READY_TO_GO_UP",
        callback: h.useCallback( () => {
            Ye?.sendToPositionMachine("READY_TO_GO_UP")
        }
        , [Ye])
    }),
    vt(ji, {
        state: "position:covered.status:idle",
        transition: "GO_UP",
        callback: h.useCallback( () => {
            Ye?.sendToPositionMachine("GO_UP"),
            Fi()
        }
        , [Fi, Ye])
    }),
    He("immediate", ji, {
        state: "position:covered.status:come-back",
        callback: h.useCallback( () => Ee(""), [Ee])
    }),
    vt(ji, {
        state: "position:covered.status:going-up",
        transition: "NEXT",
        callback: h.useCallback( () => {
            Ye?.sendToPositionMachine("NEXT"),
            Fi()
        }
        , [Ye, Fi])
    }),
    He("immediate", ji, {
        state: "position:covered.status:indeterminate",
        callback: h.useCallback( () => {
            le.silent.value === 0 ? Ee("GOTO_front") : Ee("GOTO_idle")
        }
        , [le.silent, Ee])
    });
    let gc = h.useCallback( () => Ye?.sendToOpennessMachine({
        machine: "staging",
        type: "NEXT"
    }), [Ye])
      , Ko = h.useCallback( (j, {newState: $}) => {
        te($),
        St?.({
            sheetId: W,
            staging: $
        })
    }
    , [n, te, St, W])
      , pd = h.useCallback( (j, {newState: $}) => {
        d?.($)
    }
    , [d])
      , Yo = h.useMemo( () => {
        let j = $ => {
            Bh.current = $[1],
            queueMicrotask( () => {
                let J = $[0]
                  , Q = $[1];
                (J !== Pt.current[0] || Q !== Pt.current[1]) && (Pt.current = $,
                J === Q && (An.current === null && re ? re(Q) : J === An.current && (An.current = null)))
            }
            )
        }
        ;
        return f && dt === !1 ? j = $ => {
            Bh.current = $[1],
            queueMicrotask( () => {
                let J = $[0]
                  , Q = $[1];
                (J !== Pt.current[0] || Q !== Pt.current[1]) && (Pt.current = $,
                f({
                    start: J,
                    end: Q
                }),
                J === Q && (An.current === null && re ? re(Q) : J === An.current && (An.current = null)))
            }
            )
        }
        : dt === !0 && (j = $n ? $ => {
            Bh.current = $[1],
            queueMicrotask( () => {
                let J = $[0]
                  , Q = $[1];
                if (J !== Pt.current[0] || Q !== Pt.current[1]) {
                    let Ve = Br.length;
                    yt && J === 1 && Q === 1 ? F({
                        machine: "backStuck",
                        type: "STUCK_START"
                    }) : J === Ve && Q === Ve ? F({
                        machine: "frontStuck",
                        type: "STUCK_START"
                    }) : md.current ? F({
                        machine: "frontStuck",
                        type: "STUCK_END"
                    }) : Hh.current && F({
                        machine: "backStuck",
                        type: "STUCK_END"
                    }),
                    Pt.current = $,
                    f?.({
                        start: J,
                        end: Q
                    }),
                    J === Q && (An.current === null && re ? re(Q) : J === An.current && (An.current = null))
                }
            }
            )
        }
        : $ => {
            Bh.current = $[1],
            queueMicrotask( () => {
                let J = $[0]
                  , Q = $[1];
                if (J !== Pt.current[0] || Q !== Pt.current[1]) {
                    let Ve = Br.length;
                    J === Ve && Q === Ve ? F({
                        machine: "frontStuck",
                        type: "STUCK_START"
                    }) : md.current && F({
                        machine: "frontStuck",
                        type: "STUCK_END"
                    }),
                    Pt.current = $,
                    f?.({
                        start: J,
                        end: Q
                    }),
                    J === Q && (An.current === null && re ? re(Q) : J === An.current && (An.current = null))
                }
            }
            )
        }
        ),
        j
    }
    , [f, dt, re, $n, yt, Br.length, F])
      , Wa = h.useCallback(j => {
        let $ = {
            destinationDetent: j === "front" ? Zt.current.detentMarkers.length : 1,
            runTravelCallbacksAndAnimations: !1
        };
        if (_r($),
        aa()) {
            var J;
            (J = Ut.current) === null || J === void 0 || J.style.setProperty("overflow", "hidden"),
            setTimeout( () => {
                var Q;
                (Q = Ut.current) === null || Q === void 0 || Q.style.removeProperty("overflow")
            }
            , CSS.supports("overscroll-behavior", "none") ? 1 : 10)
        }
        qh.current = !1
    }
    , [_r])
      , TE = h.useCallback( (j, $) => {
        let J = Pt.current[0]
          , Q = $ ?? null;
        if (Q === null) {
            var Ve, Ze;
            Q = (j ?? "up") === "up" ? (Ve = Pt.current[0]) < Br.length ? Ve + 1 : 1 : (Ze = Pt.current[0]) > 1 ? Ze - 1 : Br.length
        }
        return Q === 0 || Q === J ? null : Q
    }
    , [Br])
      , kE = h.useCallback( ({direction: j, detent: $, behavior: J}) => {
        let Q = () => {
            let Ve = TE(j, $);
            Ve && F({
                type: "ACTUALLY_STEP",
                detent: Ve,
                behavior: J
            })
        }
        ;
        G.silent.matches("openness:open.scroll:ended.afterPaintEffectsRun:true") ? Q() : d0.current = Q
    }
    , [G.silent, TE, F])
      , OE = h.useCallback( (j, $) => {
        An.current = j,
        re?.(j),
        _r({
            destinationDetent: j,
            behavior: $ ?? (Nt.skip ? "instant" : "smooth"),
            animationConfig: Nt,
            travelEndCallback: () => F({
                machine: "staging",
                type: "NEXT"
            })
        })
    }
    , [re, _r, Nt, F])
      , AE = h.useCallback( (j, $, J, Q) => {
        let Ve;
        if (j === "auto") {
            let Ze = Q === "center" ? J + ($ - J) / 2 : J;
            Ve = oi === "chromium" ? Ze <= 1440 ? 70 + .25 * Ze : .3 * Ze : aa() ? ln === "ios" || ln === "ipados" ? Ze <= 716 ? 15 + .1 * Ze : .12 * Ze : .5 * Ze : 10
        } else if (typeof j == "function") {
            let Ze = parseInt(j(J), 10);
            Ve = Ze < 1 ? 1 : Ze > J / 2 ? J / 2 : Ze
        } else
            j === "initial" && (Ve = 1);
        return Ve
    }
    , [])
      , ME = h.useCallback( () => {
        if (jt.current) {
            let j = ($, J) => jt.current.style.setProperty($, J);
            j("--silk-aD", Zt.current.view.travelAxis.px),
            j("--silk-aE", Zt.current.view.crossAxis.px),
            j("--silk-aF", Zt.current.content.travelAxis.px),
            j("--silk-aG", Zt.current.content.crossAxis.px),
            j("--silk-aH", Zt.current.frontSpacer.travelAxis.px),
            j("--silk-aI", Zt.current.backSpacer.travelAxis.px),
            j("--silk-aJ", Zt.current.snapOutAccelerator.travelAxis.px),
            j("--silk-aK", Zt.current.detentMarkers[0].travelAxis.px)
        }
    }
    , [])
      , Vz = h.useCallback(j => {
        let $ = jt.current
          , J = Pi.current
          , Q = [];
        dc.current.forEach(Jt => {
            Q.push(window.getComputedStyle(Jt))
        }
        );
        let Ve = Jt => parseFloat(Jt)
          , Ze = Jt => parseInt(Jt, 10)
          , pt = Jt => $e === "right" || $e === "left" || $e === "horizontal" ? Jt === "travelAxis" ? "width" : "height" : Jt === "travelAxis" ? "height" : "width"
          , Mn = Jt => {
            let Zo, Za, _c, vo, et, yc;
            return Za = Ve(Zo = Jt.getPropertyValue(pt("travelAxis"))),
            _c = Ze(Zo),
            et = Ze(vo = Jt.getPropertyValue(pt("crossAxis"))),
            yc = Ze(vo),
            {
                travelAxis: {
                    px: Zo,
                    unitless: Za,
                    unitlessRoundedDown: _c
                },
                crossAxis: {
                    px: vo,
                    unitless: et,
                    unitlessRoundedDown: yc
                }
            }
        }
          , lr = () => {
            let Jt, Zo, Za = window.getComputedStyle(jt.current), _c = window.getComputedStyle(Pi.current), vo = 0;
            Lz(zt => zt + 1),
            Zt.current = {
                view: {
                    ...Mn(Za)
                },
                scroll: {},
                snapOutAccelerator: {
                    travelAxis: {}
                },
                frontSpacer: {
                    travelAxis: {}
                },
                backSpacer: {
                    travelAxis: {}
                },
                content: {
                    ...Mn(_c)
                },
                detentMarkers: [...Q.map( (zt, ps) => {
                    let Is = Mn(zt);
                    return ps !== Q.length - 1 && (vo += Is.travelAxis.unitless),
                    {
                        ...Is,
                        accumulatedOffsets: {
                            travelAxis: {
                                px: vo + "px",
                                unitless: vo,
                                unitlessRoundedDown: null
                            }
                        }
                    }
                }
                )],
                progressValueAtDetents: []
            };
            let et = Zt.current;
            et.scroll = et.view;
            let yc = AE(v, et.view.travelAxis.unitless, et.content.travelAxis.unitless, tn);
            et.snapOutAccelerator.travelAxis.px = yc + "px",
            et.snapOutAccelerator.travelAxis.unitless = yc,
            et.snapOutAccelerator.travelAxis.unitlessRoundedDown = Ze(yc);
            let s$ = et.detentMarkers.length
              , Wh = et.content.travelAxis.unitless - vo;
            et.detentMarkers[s$ - 1] = {
                travelAxis: {
                    px: Wh + "px",
                    unitless: Wh,
                    unitlessRoundedDown: null
                },
                crossAxis: {
                    px: "1px",
                    unitless: 1,
                    unitlessRoundedDown: 1
                },
                accumulatedOffsets: {
                    travelAxis: {
                        px: vo + Wh + "px",
                        unitless: vo + Wh,
                        unitlessRoundedDown: null
                    }
                }
            };
            let p0 = zt => ({
                before: zt(-2.1),
                exact: zt(0),
                after: zt(2.1)
            }), Kh = et.content.travelAxis.unitless, bc = [p0(zt => zt / Kh)], UE;
            et.detentMarkers.slice(0, -1).forEach(zt => {
                let ps = zt.accumulatedOffsets.travelAxis.unitless;
                bc.push(p0(Is => (ps + Is) / Kh))
            }
            ),
            bc.push(p0(zt => (Kh + zt) / Kh)),
            UE = bc[Fn];
            let BE = o0.current.length > 0 ? o0.current[Pt.current[1]] : 0
              , qE = function(zt, ps) {
                let Is = 0;
                for (let Gi = 1; Gi < ps.length; Gi++) {
                    let gd = ps[Gi];
                    Math.abs(gd - zt) < Math.abs(ps[Is] - zt) && (Is = Gi)
                }
                return Is
            }(BE ?? 1, bc.map(zt => zt.exact));
            Yo([qE, qE]),
            et.progressValueAtDetents = bc,
            et.exactProgressValueAtDetents = bc.map(zt => zt.exact),
            o0.current = et.progressValueAtDetents.map(zt => zt.exact),
            et.progressValueAtInitialDetent = UE,
            Jt = vn ? $e === "horizontal" || $e === "vertical" ? et.view.travelAxis.unitless / 2 + 1 : 1 : yt ? et.content.travelAxis.unitless - Zt.current.detentMarkers[0].travelAxis.unitless + Er : $e === "horizontal" || $e === "vertical" ? et.view.travelAxis.unitless / 2 + et.view.travelAxis.unitless - (et.view.travelAxis.unitless - et.content.travelAxis.unitless) / 2 + et.snapOutAccelerator.travelAxis.unitless : tn === "center" ? et.view.travelAxis.unitless - (et.view.travelAxis.unitless - et.content.travelAxis.unitless) / 2 + et.snapOutAccelerator.travelAxis.unitless : et.view.travelAxis.unitless - (et.view.travelAxis.unitless - et.content.travelAxis.unitless) + et.snapOutAccelerator.travelAxis.unitless,
            et.frontSpacer.travelAxis.unitless = Jt,
            et.frontSpacer.travelAxis.px = Jt + "px",
            Zo = dt === !0 && _ === "auto" ? et.view.travelAxis.unitless + Er : $e === "horizontal" || $e === "vertical" ? vn ? et.view.travelAxis.unitless / 2 : et.view.travelAxis.unitless / 2 + et.view.travelAxis.unitless - (et.view.travelAxis.unitless - et.content.travelAxis.unitless) / 2 + et.snapOutAccelerator.travelAxis.unitless : et.view.travelAxis.unitless,
            et.backSpacer.travelAxis.unitless = Zo,
            et.backSpacer.travelAxis.px = Zo + "px",
            ME(),
            jz( () => () => {
                let zt, ps;
                if (!jt.current)
                    return {
                        top: null,
                        bottom: null
                    };
                let Is = jt.current.getBoundingClientRect()
                  , Gi = Is.top
                  , gd = Is.bottom
                  , GE = s0 || $e === "top" || $e === "bottom"
                  , Yh = et.view[GE ? "travelAxis" : "crossAxis"].unitless
                  , Zh = et.content[GE ? "travelAxis" : "crossAxis"].unitless;
                return tn === "left" || tn === "right" || tn === "center" ? (zt = Gi + (Yh - Zh) / 2,
                ps = gd - (Yh - Zh) / 2) : tn === "top" ? (zt = Gi,
                ps = gd - (Yh - Zh)) : tn === "bottom" && (zt = Gi + (Yh - Zh),
                ps = gd),
                {
                    top: zt,
                    bottom: ps
                }
            }
            )
        }
        ;
        lr();
        let Ka = (Jt, Zo) => {
            let Za = new ResizeObserver(_c => {
                _c.forEach( () => Zo())
            }
            );
            return Za.observe(Jt, {
                box: "border-box"
            }),
            Za
        }
          , Bi = () => {
            lr(),
            _r({
                runTravelCallbacksAndAnimations: !1
            })
        }
          , hs = !0
          , qi = Ka($, () => {
            hs ? hs = !1 : Bi()
        }
        )
          , Ya = !0
          , Sn = Ka(J, () => {
            Ya ? (lr(),
            Ya = !1) : Bi()
        }
        );
        return () => {
            qi && $ && (qi.unobserve($),
            qi.disconnect()),
            Sn && J && (Sn.unobserve(J),
            Sn.disconnect())
        }
    }
    , [$e, AE, v, Fn, dt, ME, Er, _, _r, Yo, tn, yt, vn, Br])
      , IE = h.useCallback(j => {
        let $, J = 0, Q = j, Ve = 0;
        return Ze => {
            $ = Ze;
            let pt = Q - Ze;
            return J = pt,
            (pt === 0 || Math.abs(pt) < Math.abs(Ve / 2)) && G.silent.matches("scrollContainerTouch:ongoing") && ($ = Q - Ve / 2,
            J = Q - $),
            Math.abs(J) >= .1 && .35 > Math.abs(J) && ($ = J >= 0 ? Q - .1 : Q + .1,
            J = J >= 0 ? .1 : -.1),
            Ze <= 0 && ($ = 0),
            Q = $,
            Ve = J,
            $
        }
    }
    , [G.silent])
      , RE = h.useCallback( () => {
        var j;
        let $, J, Q = $e === "right" || $e === "left" || $e === "horizontal" ? "scrollLeft" : "scrollTop", Ve = Ut.current, Ze = Zt.current.snapOutAccelerator.travelAxis.unitless, pt = Zt.current.content.travelAxis.unitless, Mn = Zt.current.scroll.travelAxis.unitless, lr = IE((j = Ui.current) !== null && j !== void 0 ? j : Zt.current.progressValueAtDetents[Pt.current[1]].exact), Ka = $e === "right" || $e === "bottom", Bi = $e === "left" || $e === "top";
        if (Ka || Bi) {
            let hs;
            if (vn)
                hs = Bi ? Sn => 1 - Sn / pt : Sn => 1 + Sn / pt;
            else if (Ka)
                if (tn !== "center") {
                    let Sn = yt ? Zt.current.detentMarkers[0].travelAxis.unitless - Er : -Ze;
                    hs = Jt => (Jt + Sn) / pt
                } else {
                    let Sn = pt + (Mn - pt) / 2;
                    hs = Jt => (Jt - Ze) / Sn
                }
            else if (Bi)
                if (tn !== "center")
                    hs = Sn => (pt + Er - Sn) / pt;
                else {
                    let Sn = pt + (Mn - pt) / 2;
                    hs = Jt => (Sn + Er - Jt) / Sn
                }
            let qi = dt === !0 ? 1 : 10
              , Ya = dt === !0 && yt ? Zt.current.progressValueAtDetents[1].exact : 0;
            J = () => {
                $ = Ve[Q];
                let Sn = Math.min(Math.max(hs($), Ya), qi);
                return Math.min(Math.max(lr(Sn), Ya), qi)
            }
        } else if ($e === "horizontal" || $e === "vertical") {
            let hs = (Mn - pt) / 2
              , qi = vn ? 0 : Ze + Mn - hs
              , Ya = pt + hs;
            J = () => {
                $ = Ve[Q];
                let Sn = 1 - Math.abs($ - qi) / Ya;
                return Math.max(lr(Math.max(Sn, 0)), 0)
            }
        }
        return J
    }
    , [$e, IE, dt, vn, tn, yt, Er, CE])
      , Vh = h.useRef()
      , Hz = h.useCallback( () => {
        let j = Ut.current
          , $ = () => {
            F({
                machine: "openness:open.move",
                type: "MOVE_END"
            });
            for (let Q = 0; Q < Zt.current.progressValueAtDetents.length; Q++) {
                let Ve = Zt.current.progressValueAtDetents[Q].exact;
                Ui.current > Ve - .01 && Ui.current < Ve + .01 && (F({
                    machine: "openness:open.scroll",
                    type: "SCROLL_END"
                }),
                F({
                    machine: "openness:open.swipe",
                    type: "SWIPE_END"
                }))
            }
        }
          , J = () => {
            SE.current ? a0(!1) : (u0.current || F({
                machine: "openness:open.scroll",
                type: "SCROLL_START"
            }),
            md.current || Hh.current || (h0.current || F({
                machine: "openness:open.swipe",
                type: "SWIPE_START"
            }),
            f0.current || F({
                machine: "openness:open.move",
                type: "MOVE_START"
            }))),
            clearTimeout(Vh.current),
            Vh.current = setTimeout($, 200)
        }
        ;
        return j.addEventListener("scroll", J),
        () => {
            j.removeEventListener("scroll", J),
            clearTimeout(Vh.current)
        }
    }
    , [F, a0])
      , Ui = h.useRef(null)
      , zz = h.useCallback( () => {
        let j;
        if (jh) {
            let $ = Zt.current.progressValueAtDetents
              , J = $.length
              , Q = RE();
            j = i0e( () => {
                let Ve, Ze = Q();
                if (Ui.current !== Ze) {
                    for (let pt = 0; pt < J; pt++) {
                        let Mn = $[pt]
                          , lr = Mn.after;
                        Ze > lr && pt + 1 < J && Ze < $[pt + 1].before ? (Ve = {
                            start: pt,
                            end: pt + 1
                        },
                        Yo([pt, pt + 1])) : Ze > Mn.before && Ze < lr ? (Ve = {
                            start: pt,
                            end: pt
                        },
                        Yo([pt, pt])) : Ze <= 0 && (Ve = {
                            start: 0,
                            end: 0
                        },
                        Yo([0, 0]))
                    }
                    i0.current(Ze, Ve),
                    Ui.current = Ze
                }
            }
            )
        }
        return () => {
            j?.()
        }
    }
    , [Yo, jh, RE])
      , NE = h.useCallback(j => {
        let $ = 1e5
          , J = Q => {
            $ < Math.abs(Q.deltaY) ? window.removeEventListener("wheel", J, {
                passive: !1
            }) : Q.preventDefault(),
            $ = Math.abs(Q.deltaY)
        }
        ;
        return window.addEventListener("wheel", J, {
            passive: !1
        }),
        setTimeout( () => {
            j("SWIPED_OUT")
        }
        , 100),
        () => window.removeEventListener("wheel", J, {
            passive: !1
        })
    }
    , [])
      , $z = h.useCallback( (j, {send: $}) => {
        let J, Q = jt.current, Ve = Pi.current, Ze = Ut.current, pt = !1, Mn = () => pt = !0;
        window.addEventListener("wheel", Mn, {
            passive: !0,
            once: !0
        });
        let lr = new IntersectionObserver(function(Ka) {
            for (let Bi of Ka)
                Bi.isIntersecting || (Q.style.setProperty("pointer-events", "none", "important"),
                Q.style.setProperty("opacity", "0", "important"),
                Q.style.setProperty("position", "fixed", "important"),
                Q.style.setProperty("top", "-100px", "important"),
                Q.style.setProperty("left", "-100px", "important"),
                Ve.style.setProperty("pointer-events", "none", "important"),
                Ze.style.setProperty("width", "1px", "important"),
                Ze.style.setProperty("height", "1px", "important"),
                Ze.style.setProperty("clip-path", "inset(0)", "important"),
                requestAnimationFrame( () => {
                    pt ? J = NE($) : $("SWIPED_OUT")
                }
                ))
        }
        ,{
            root: Q,
            threshold: [0]
        });
        return lr.observe(Ve),
        () => {
            J?.(),
            window.removeEventListener("wheel", Mn, {
                passive: !0,
                once: !0
            }),
            lr && (lr.unobserve(Ve),
            lr.disconnect())
        }
    }
    , [NE])
      , Wz = h.useRef( () => 0)
      , Kz = h.useCallback( () => {
        let j = jt.current
          , $ = J => {
            Po({
                nativeEvent: J,
                defaultBehavior: {},
                handler: A
            })
        }
        ;
        return j?.addEventListener("focus", $, {
            capture: !0
        }),
        () => {
            j?.removeEventListener("focus", $, {
                capture: !0
            })
        }
    }
    , [A])
      , Yz = h.useCallback(j => {
        Ut.current.contains(j.target) && F({
            machine: "scrollContainerTouch",
            type: "TOUCH_START"
        })
    }
    , [F])
      , Zz = h.useCallback(j => {
        Ut.current.contains(j.target) && F({
            machine: "scrollContainerTouch",
            type: "TOUCH_END"
        })
    }
    , [F]);
    He("immediate", ae, {
        state: "staging:none",
        callback: Ko,
        params: {
            newState: "none"
        }
    }),
    vt(ae, {
        state: "staging:none",
        transition: "OPEN",
        callback: h.useCallback( () => Ye?.sendToOpennessMachine({
            machine: "staging",
            type: "GO_DOWN",
            skipOpening: qr?.skip
        }), [Ye, qr?.skip])
    }),
    vt(ae, {
        state: "staging:none",
        transition: "OPEN_PREPARED",
        callback: h.useCallback(j => Ye?.sendToOpennessMachine({
            machine: "staging",
            type: "GO_DOWN",
            skipOpening: j.skipOpening
        }), [Ye])
    }),
    vt(ae, {
        state: "staging:none",
        transition: "GO_DOWN",
        callback: h.useCallback(j => Ye?.sendToOpennessMachine({
            machine: "staging",
            type: "GO_DOWN",
            skipOpening: j.skipOpening
        }), [Ye])
    }),
    vt(ae, {
        state: "staging:none",
        transition: "ACTUALLY_CLOSE",
        callback: h.useCallback( () => Ye?.sendToOpennessMachine({
            machine: "staging",
            type: "GO_UP"
        }), [Ye])
    }),
    vt(ae, {
        state: "staging:none",
        transition: "GO_UP",
        callback: h.useCallback(j => Ye?.sendToOpennessMachine({
            machine: "staging",
            type: "GO_UP",
            skipClosing: j.skipClosing
        }), [Ye])
    }),
    He("immediate", ae, {
        state: "staging:open",
        callback: Ko,
        params: {
            newState: "open"
        }
    }),
    He("immediate", ae, {
        state: "staging:open",
        callback: h.useCallback( () => {
            F({
                machine: "longRunning",
                type: "TO_TRUE"
            })
        }
        , [F])
    }),
    He("immediate", ae, {
        state: "staging:open",
        callback: h.useCallback( () => {
            Z || ne == null || ne(!0)
        }
        , [Z, ne])
    }),
    He("after-paint", ae, {
        state: "staging:open",
        callback: h.useCallback( () => {
            requestAnimationFrame( () => {
                F({
                    machine: "openness",
                    type: "READY_TO_OPEN",
                    skipOpening: !0
                }),
                F({
                    machine: "staging",
                    type: "NEXT"
                })
            }
            )
        }
        , [F])
    }),
    vt(ae, {
        state: "staging:open",
        transition: "NEXT",
        callback: gc
    }),
    He("immediate", ae, {
        state: "staging:opening",
        callback: Ko,
        params: {
            newState: "opening"
        }
    }),
    He("immediate", ae, {
        state: "staging:opening",
        callback: h.useCallback( () => {
            F({
                machine: "longRunning",
                type: "TO_TRUE"
            })
        }
        , [F])
    }),
    He("immediate", ae, {
        state: "staging:opening",
        callback: h.useCallback( () => {
            Z || ne == null || ne(!0)
        }
        , [Z, ne])
    }),
    He("before-paint", ae, {
        state: "staging:opening",
        callback: h.useCallback( () => {
            b?.(),
            Wo(0, {
                start: 0,
                end: 0
            })
        }
        , [Wo, b])
    }),
    He("after-paint", ae, {
        state: "staging:opening",
        callback: h.useCallback( () => {
            requestAnimationFrame( () => {
                F({
                    machine: "openness",
                    type: "READY_TO_OPEN",
                    skipOpening: !1
                })
            }
            )
        }
        , [F])
    }),
    Tr("after-paint", ae, {
        state: "staging:opening",
        callback: h.useCallback( () => (I1e(W),
        () => R1e(W)), [W])
    }),
    vt(ae, {
        state: "staging:opening",
        transition: "NEXT",
        callback: gc
    }),
    He("immediate", ae, {
        state: "staging:stepping",
        callback: Ko,
        params: {
            newState: "stepping"
        }
    }),
    He("after-paint", ae, {
        state: "staging:stepping",
        callback: h.useCallback( ({detent: j, behavior: $}) => {
            d?.("stepping"),
            OE(j, $)
        }
        , [d, OE])
    }),
    zi("immediate", ae, {
        state: "staging:stepping",
        callback: h.useCallback( () => {
            d?.("idleInside")
        }
        , [d])
    }),
    He("immediate", ae, {
        state: "staging:closing",
        callback: Ko,
        params: {
            newState: "closing"
        }
    }),
    He("immediate", ae, {
        state: "staging:closing",
        callback: h.useCallback( () => {
            Z && ne?.(!1)
        }
        , [Z, ne])
    }),
    He("after-paint", ae, {
        state: "staging:closing",
        callback: h.useCallback( () => {
            F({
                machine: "openness",
                type: "READY_TO_CLOSE"
            })
        }
        , [F])
    }),
    vt(ae, {
        state: "staging:closing",
        transition: "NEXT",
        callback: gc
    }),
    He("immediate", ae, {
        state: "staging:go-down",
        callback: Ko,
        params: {
            newState: "go-down"
        }
    }),
    vt(ae, {
        state: "staging:go-down",
        transition: "NEXT",
        callback: gc
    }),
    He("immediate", ae, {
        state: "staging:going-down",
        callback: Ko,
        params: {
            newState: "going-down"
        }
    }),
    vt(ae, {
        state: "staging:going-down",
        transition: "NEXT",
        callback: gc
    }),
    He("immediate", ae, {
        state: "staging:going-up",
        callback: Ko,
        params: {
            newState: "going-up"
        }
    }),
    vt(ae, {
        state: "staging:going-up",
        transition: "NEXT",
        callback: gc
    });
    let Vr = js(G, "longRunning");
    He("immediate", Vr, {
        state: "longRunning:true",
        callback: h.useCallback( () => {
            _e.current === null && (_e.current = document.activeElement)
        }
        , [_e])
    }),
    He("immediate", Vr, {
        state: "longRunning:true",
        callback: h.useCallback( () => {
            oe(!0),
            ot?.(j => j + 1)
        }
        , [oe, ot])
    }),
    Tr("before-paint", Vr, {
        state: "longRunning:true",
        callback: Vz
    }),
    He("before-paint", Vr, {
        state: "longRunning:true",
        guard: !qr.skip,
        callback: h.useCallback( () => {
            _r({
                trackToTravelOn: $o,
                runTravelCallbacksAndAnimations: !1,
                destinationDetent: 0
            })
        }
        , [_r, $o])
    }),
    Tr("after-paint", Vr, {
        state: "longRunning:true",
        guard: x,
        callback: h.useCallback( () => K1e(kn, E), [E])
    }),
    Tr("after-paint", Vr, {
        state: "longRunning:true",
        callback: Bz
    }),
    He("immediate", Vr, {
        state: "longRunning:false",
        callback: h.useCallback( () => {
            oe(!1),
            ot?.(j => j - 1)
        }
        , [oe, ot])
    }),
    He("immediate", Vr, {
        state: "longRunning:false",
        callback: h.useCallback( () => {
            _e.current = null
        }
        , [_e])
    }),
    He("before-paint", Vr, {
        state: "longRunning:false",
        callback: h.useCallback( () => {
            tt.removeAllOutletPersistedStylesFromSheet(W)
        }
        , [W])
    }),
    He("after-paint", Vr, {
        state: "longRunning:false",
        callback: wE
    }),
    Tr("before-paint", Gh, {
        state: "active:true",
        callback: Uz
    });
    let Ht = js(G, "openness")
      , Ms = js(G, "openness:closed.status");
    He("immediate", Ht, {
        state: "openness:closed",
        callback: pd,
        params: {
            newState: "idleOutside"
        }
    }),
    He("immediate", Ht, {
        state: "openness:closed",
        callback: h.useCallback( () => {
            F({
                machine: "longRunning",
                type: "TO_FALSE"
            })
        }
        , [F])
    }),
    He("immediate", Ht, {
        state: "openness:closed",
        callback: h.useCallback( () => {
            Z && ne?.(!1)
        }
        , [Z, ne])
    }),
    He("immediate", Ht, {
        state: "openness:closed",
        callback: h.useCallback( () => {
            Ee({
                machine: "active",
                type: "TO_FALSE"
            })
        }
        , [Ee])
    }),
    He("after-paint", Ht, {
        state: "openness:closed",
        callback: h.useCallback( () => {
            clearTimeout(Vh.current),
            Ui.current = null,
            Yo([0, 0]),
            fd.current = !1,
            Oe(-1),
            qh.current = !1
        }
        , [Oe, Yo])
    }),
    vt(Ht, {
        state: "openness:closed",
        transition: "READY_TO_OPEN",
        callback: h.useCallback(j => {
            Ee({
                machine: "position",
                type: "READY_TO_GO_FRONT",
                skipOpening: j.skipOpening
            })
        }
        , [Ee])
    }),
    $1e(F, Ms, "openness:closed.status:pending", {
        delay: 3e3
    }),
    zi("immediate", Ms, {
        state: "openness:closed.status:pending",
        callback: h.useCallback( () => {
            F("SWIPE_RESET")
        }
        , [F])
    }),
    He("before-paint", Ms, {
        state: "openness:closed.status:flushing-to-preparing-opening",
        callback: h.useCallback( () => {
            F({
                machine: "openness:closed.status",
                type: ""
            })
        }
        , [F])
    }),
    He("before-paint", Ms, {
        state: "openness:closed.status:flushing-to-preparing-open",
        callback: h.useCallback( () => {
            F({
                machine: "openness:closed.status",
                type: ""
            })
        }
        , [F])
    }),
    He("after-paint", Ms, {
        state: "openness:closed.status:preparing-opening",
        callback: h.useCallback( () => {
            F({
                machine: "staging",
                type: "OPEN_PREPARED",
                skipOpening: !1
            })
        }
        , [F])
    }),
    He("after-paint", Ms, {
        state: "openness:closed.status:preparing-open",
        callback: h.useCallback( () => {
            F({
                machine: "staging",
                type: "OPEN_PREPARED",
                skipOpening: !0
            })
        }
        , [F])
    }),
    He("immediate", Ms, {
        state: "openness:closed.status:safe-to-unmount",
        callback: h.useCallback( () => {
            ee?.(!0)
        }
        , [ee])
    }),
    zi("immediate", Ms, {
        state: "openness:closed.status:safe-to-unmount",
        callback: h.useCallback( () => {
            ee?.(!1)
        }
        , [ee])
    }),
    He("immediate", Ht, {
        state: "openness:opening",
        callback: pd,
        params: {
            newState: "entering"
        }
    }),
    He("before-paint", Ht, {
        state: "openness:opening",
        callback: h.useCallback( () => {
            An.current = Fn,
            re?.(Fn),
            _r({
                trackToTravelOn: $o,
                destinationDetent: Fn,
                behavior: "smooth",
                animationConfig: qr,
                travelEndCallback: () => F("NEXT"),
                runOnTravelStart: !1
            })
        }
        , [$o, re, _r, Fn, qr, F])
    }),
    vt(Ht, {
        state: "openness:opening",
        transition: "NEXT",
        callback: h.useCallback( () => {
            Ee("NEXT"),
            F({
                machine: "staging",
                type: "NEXT"
            })
        }
        , [Ee, F])
    }),
    He("immediate", Ht, {
        state: "openness:open",
        callback: pd,
        params: {
            newState: "idleInside"
        }
    }),
    He("immediate", Ht, {
        state: "openness:open",
        callback: h.useCallback( () => {
            Ee({
                machine: "active",
                type: "TO_TRUE"
            })
        }
        , [Ee])
    }),
    He("before-paint", Ht, {
        state: "openness:open",
        guard: qr.skip,
        callback: h.useCallback( () => {
            An.current = Fn,
            re?.(Fn),
            _r({
                trackToTravelOn: $o,
                destinationDetent: Fn
            })
        }
        , [Fn, re, _r, $o])
    }),
    Tr("before-paint", Ht, {
        state: "openness:open",
        callback: h.useCallback( () => {
            if (aa() && ht) {
                var j;
                (j = Ut.current) === null || j === void 0 || j.style.setProperty("will-change", "transform"),
                requestAnimationFrame( () => {
                    var $;
                    return ($ = Ut.current) === null || $ === void 0 ? void 0 : $.style.removeProperty("will-change", "transform")
                }
                )
            }
        }
        , [ht]),
        params: {
            unusedDep: CE
        }
    }),
    Tr("before-paint", Ht, {
        state: "openness:open",
        guard: !nt,
        callback: Hz
    }),
    He("after-paint", ae, {
        state: "staging:open",
        guard: dt === !0 && _ === "auto",
        callback: h.useCallback( () => {
            Fn === Br.length ? F({
                machine: "frontStuck",
                type: "STUCK_START"
            }) : ht && Fn === 1 && F({
                machine: "backStuck",
                type: "STUCK_START"
            })
        }
        , [F, Fn, Br, ht])
    }),
    Tr("after-paint", Ht, {
        state: "openness:open",
        guard: !nt && !vn && !yt,
        callback: $z,
        params: {
            send: F
        }
    }),
    Tr("after-paint", Ht, {
        state: "openness:open",
        callback: Kz
    }),
    vt(Ht, {
        state: "openness:open",
        transition: "READY_TO_CLOSE",
        callback: h.useCallback( () => Ee("READY_TO_GO_OUT"), [Ee])
    }),
    vt(Ht, {
        state: "openness:open",
        transition: "ACTUALLY_CLOSE",
        callback: h.useCallback( () => {
            An.current = null,
            re?.(0),
            b?.(),
            Ee("GO_OUT")
        }
        , [re, b, Ee])
    }),
    vt(Ht, {
        state: "openness:open",
        transition: "SWIPED_OUT",
        callback: h.useCallback( () => {
            var j;
            (j = Ut.current) === null || j === void 0 || j.style.setProperty("scroll-snap-type", "none", "important"),
            An.current = null,
            re?.(0),
            Ee("GO_OUT")
        }
        , [re, Ee])
    }),
    zi("immediate", Ht, {
        state: "openness:open",
        callback: h.useCallback( () => {
            F("SWIPE_END")
        }
        , [F])
    });
    let l0 = js(G, "backStuck")
      , Hh = h.useRef(!1);
    vt(l0, {
        state: "backStuck:false",
        transition: "STUCK_START",
        callback: h.useCallback( () => Hh.current = !0, [])
    }),
    vt(l0, {
        state: "backStuck:true",
        transition: "STUCK_END",
        callback: h.useCallback( () => Hh.current = !1, [])
    }),
    vt(l0, {
        state: "backStuck:false",
        transition: "STUCK_START",
        guard: dt === !0 && _ === "auto",
        callback: h.useCallback( () => {
            G.silent.matches("scrollContainerTouch:ended") && Wa("back")
        }
        , [G.silent, Wa])
    });
    let c0 = js(G, "frontStuck")
      , md = h.useRef(!1);
    vt(c0, {
        state: "frontStuck:false",
        transition: "STUCK_START",
        callback: h.useCallback( () => md.current = !0, [])
    }),
    vt(c0, {
        state: "frontStuck:true",
        transition: "STUCK_END",
        callback: h.useCallback( () => md.current = !1, [])
    }),
    vt(c0, {
        state: "frontStuck:false",
        transition: "STUCK_START",
        guard: dt === !0 && _ === "auto",
        callback: h.useCallback( () => {
            G.silent.matches("openness:open") && G.silent.matches("scrollContainerTouch:ended") && Wa("front")
        }
        , [G.silent, Wa])
    }),
    He("immediate", G, {
        state: "scrollContainerTouch:ended",
        guard: dt === !0 && _ === "auto",
        callback: h.useCallback( () => {
            qh.current && setTimeout( () => {
                requestAnimationFrame( () => {
                    G.silent.matches("openness:open") && (G.silent.matches("backStuck:true") ? Wa("back") : G.silent.matches("frontStuck:true") && Wa("front"))
                }
                )
            }
            , 80)
        }
        , [G.silent, Wa])
    });
    let vc = js(G, "openness:open.scroll")
      , u0 = h.useRef(!1);
    He("immediate", vc, {
        state: "openness:open.scroll:ongoing",
        callback: h.useCallback( () => u0.current = !0, [])
    }),
    zi("immediate", vc, {
        state: "openness:open.scroll:ongoing",
        callback: h.useCallback( () => u0.current = !1, [])
    }),
    He("immediate", vc, {
        state: "openness:open.scroll:ongoing",
        callback: h.useCallback( () => {
            qh.current = !0
        }
        , [])
    }),
    Tr({
        start: "immediate",
        update: "before-paint"
    }, vc, {
        state: "openness:open.scroll:ongoing",
        callback: zz
    });
    let d0 = h.useRef( () => {}
    );
    He("after-paint", vc, {
        state: "openness:open.scroll:ended",
        callback: h.useCallback( () => {
            F({
                machine: "openness:open.scroll:ended.afterPaintEffectsRun",
                type: "OCCURRED"
            }),
            d0.current(),
            d0.current = () => {}
        }
        , [F])
    }),
    zi("immediate", vc, {
        state: "openness:open.scroll:ended",
        callback: h.useCallback( () => {
            F({
                machine: "openness:open.scroll:ended.afterPaintEffectsRun",
                type: "RESET"
            })
        }
        , [F])
    });
    let f0 = h.useRef(!1);
    He("immediate", G, {
        state: "openness:open.move:ongoing",
        callback: h.useCallback( () => {
            f0.current = !0,
            i0.current = jh
        }
        , [jh])
    }),
    zi("immediate", G, {
        state: "openness:open.move:ongoing",
        callback: h.useCallback( () => {
            f0.current = !1,
            i0.current = () => {}
        }
        , [])
    });
    let h0 = h.useRef(!1);
    He("immediate", G, {
        state: "openness:open.swipe:ongoing",
        callback: h.useCallback( () => h0.current = !0, [])
    }),
    zi("immediate", G, {
        state: "openness:open.swipe:ongoing",
        callback: h.useCallback( () => h0.current = !1, [])
    }),
    He("immediate", G, {
        state: "openness:open.swipe:ongoing",
        callback: h.useCallback( () => b?.(), [b])
    }),
    He("immediate", G, {
        state: "openness:open.swipe:ongoing",
        callback: pd,
        params: {
            newState: "stepping"
        }
    }),
    He("immediate", G, {
        state: "openness:open.swipe:ended",
        callback: h.useCallback( () => dd(), [dd])
    }),
    He("immediate", G, {
        state: "openness:open.swipe:ended",
        guard: typeof d == "function",
        callback: h.useCallback( () => {
            G.silent.matches("openness:open") && d("idleInside")
        }
        , [G.silent, d])
    });
    let PE = h.useCallback( () => {
        !mc.matches("position:front") || Pt.current[0] === 0 && Pt.current[1] === 0 || ht && Pt.current[0] !== Pt.current[1] ? Z === !1 && ne?.(!0) : F("ACTUALLY_CLOSE")
    }
    , [mc, F, Z, ne, ht]);
    vt(G, {
        state: "openness:open.evaluateCloseMessage:true",
        transition: "CLOSE",
        callback: PE
    }),
    vt(G, {
        state: "openness:open.evaluateCloseMessage:false",
        transition: "CLOSE",
        callback: PE
    }),
    vt(G, {
        state: "openness:open.evaluateStepMessage:true",
        transition: "STEP",
        callback: kE
    }),
    vt(G, {
        state: "openness:open.evaluateStepMessage:false",
        transition: "STEP",
        callback: kE
    }),
    He("immediate", Ht, {
        state: "openness:closing",
        callback: pd,
        params: {
            newState: "exiting"
        }
    }),
    He("before-paint", Ht, {
        state: "openness:closing",
        callback: h.useCallback( () => {
            An.current = 0,
            re?.(0),
            _r({
                trackToTravelOn: Se.track,
                destinationDetent: 0,
                behavior: "smooth",
                animationConfig: Se,
                travelEndCallback: () => F("NEXT")
            })
        }
        , [re, _r, Se, F])
    }),
    vt(Ht, {
        state: "openness:closing",
        transition: "NEXT",
        callback: h.useCallback( () => {
            Ee("NEXT"),
            F({
                machine: "staging",
                type: "NEXT"
            })
        }
        , [Ee, F])
    });
    let Jz = h.useCallback( () => F({
        machine: "skipOpening",
        type: qr.skip ? "TO_TRUE" : "TO_FALSE"
    }), [F, qr.skip]);
    Tr("after-paint", G, {
        state: "",
        callback: Jz
    });
    let Xz = h.useCallback( () => F({
        machine: "skipClosing",
        type: Se.skip ? "TO_TRUE" : "TO_FALSE"
    }), [F, Se.skip]);
    Tr("after-paint", G, {
        state: "",
        callback: Xz
    }),
    h.useEffect( () => {
        Z !== void 0 && F(Z ? "OPEN" : "CLOSE")
    }
    , [Z, F]);
    let Qz = kd( () => {
        wE(),
        Tt?.(W),
        tt.removeAllOutletPersistedStylesFromSheet(W)
    }
    )
      , DE = h.useRef(!0)
      , e$ = kd( () => {
        Z && ne?.(!1)
    }
    );
    h.useEffect( () => () => {
        !DE.current && (e$(),
        Ko(null, {
            newState: "none"
        }),
        Qz(),
        oe(!1),
        Vr.silent.matches("longRunning:true") && ot?.(j => j - 1))
    }
    , []),
    h.useEffect( () => () => DE.current = !1),
    h.useEffect( () => {
        Ue !== void 0 && Pt.current[0] !== Ue && Pt.current[1] !== Ue && An.current !== Ue && F({
            type: "STEP",
            activeDetent: Ue
        })
    }
    , [Ue, F]),
    h.useEffect( () => {
        let j = () => {
            var $;
            return ($ = Ut.current) === null || $ === void 0 ? void 0 : $.scrollTo(0, 0)
        }
        ;
        return window.addEventListener("unload", j),
        () => window.removeEventListener("unload", j)
    }
    , []);
    let LE = kd( (j, $) => {
        As.current && !Ht.matches("openness:closed") && Wo(j, $)
    }
    )
      , FE = kd(xE);
    h.useEffect( () => () => {
        LE(0, {
            start: 0,
            end: 0
        }),
        As.current && FE(),
        lq(null)
    }
    , [Vr.silent, ot, LE, FE]);
    let zh = Hn("Sheet", {
        staging: ae.getValues()[0],
        openness: Ht.getValues()[0],
        opennessClosedStatus: Ms.getValues()[0],
        position: mc.getValues()[0],
        positionCoveredStatus: ji.getValues()[0],
        placement: tn,
        track: $e,
        swipeDisabled: nt,
        swipeOutDisabledWithDetent: yt,
        swipeOvershootDisabled: dt,
        swipeTrap: hd,
        scrollContainerShouldBePassThrough: $a
    })
      , $h = h.useMemo( () => !Ms.matches(["openness:closed.status:flushing-to-preparing-open", "openness:closed.status:flushing-to-preparing-opening", "openness:closed.status:safe-to-unmount"]), [Ms])
      , t$ = h.useMemo( () => Ht.matches("openness:closed") && $h, [$h, Ht])
      , jE = h.useMemo( () => ae.matches(["staging:opening", "staging:open"]), [ae])
      , n$ = h.useMemo( () => $h || jE, [$h, jE])
      , r$ = h.useMemo( () => w && (mc.matches(["position:front", "position:covered"]) || se !== "none"), [w, mc, se]);
    return g.jsx(Ch, {
        genericContext: Oa,
        customContext: ge,
        value: Ie,
        children: g.jsx(ro.Provider, {
            value: {
                sheetContext: ye,
                titleId: X,
                descriptionId: Te,
                styleAttributes: zh,
                backdropRef: On,
                scrollContainerRef: Ut,
                frontSpacerRef: Os,
                contentWrapperRef: hn,
                contentRef: Pi,
                backSpacerRef: ud,
                detentMarkersRefs: dc,
                leftEdgeRef: kn,
                setBackdropSwipeable: Ha,
                setBleedingBackgroundPresent: Gr,
                detents: Br,
                longRunningState: Vr,
                staging: se,
                layerCovered: Y,
                placement: tn,
                track: $e,
                travelAxis: go,
                nativeEdgeSwipePrevention: x,
                bleedingBackgroundPresent: za,
                setBackdropTravelHandler: Dz,
                ancestorPrimarySwipeTrapActiveOnYAxis: hd === "vertical" || hd === "both",
                scrollContainerTouchStartHandler: Yz,
                scrollContainerTouchEndHandler: Zz,
                getContentCoordinatesWhenRestingOnLastDetent: Fz,
                getOffsetFromCurrentToNextDetent: Wz
            },
            children: n$ && g.jsxs("div", {
                id: W,
                ...zh("view", ["track", "staging", "openness", "opennessClosedStatus", "scrollContainerShouldBePassThrough"], {
                    className: i,
                    dataSilk: [a, "0ab", O && "0ah", mo && "0aj", t$ && "0ak", "0al"]
                }),
                ref: gn,
                "aria-labelledby": X,
                "aria-describedby": Te,
                ...H,
                role: ce,
                tabIndex: -1,
                children: [g.jsx(pi.Root, {
                    ...zh("primaryScrollTrapRoot", ["track", "scrollContainerShouldBePassThrough"]),
                    active: hd !== "none",
                    axis: hd,
                    children: g.jsx(pi.Stabiliser, {
                        children: o
                    })
                }), g.jsx(pi.Root, {
                    ...zh("secondaryScrollTrapRoot", ["scrollContainerShouldBePassThrough"]),
                    automaticallyDisabledForOptimisation: !1,
                    preventBodyScroll: r$
                })]
            })
        })
    })
}
);
mq.displayName = "Sheet.Anonymous";
class rd extends Ne.Component {
    static getDerivedStateFromError(t) {
        return {
            hasError: !0
        }
    }
    componentDidCatch(t) {
        console.error(t)
    }
    render() {
        return this.state.hasError ? g.jsx("h1", {
            children: "Something went wrong."
        }) : this.props.children
    }
    constructor(t) {
        super(t),
        this.state = {
            hasError: !1
        }
    }
}
let gq = Ne.forwardRef( (e, t) => {
    let {asChild: n, children: r, className: s, "data-silk": o, ...i} = e
      , a = n ? zn : "span"
      , l = Hn("VisuallyHidden", {});
    return g.jsx(a, {
        ...l("root", [], {
            className: s,
            dataSilk: [o]
        }),
        ...i,
        ref: t,
        children: r
    })
}
);
gq.displayName = "VisuallyHidden.Root";
let f0e = {
    Root: gq
}
  , V1 = Ne.createContext(null);
V1.displayName = "SheetStack.GenericContext";
let sf = []
  , h0e = (e, t) => {
    let n = () => {
        let[r,s] = function(a) {
            let l = 0
              , c = 0;
            for (; a; )
                l += a.offsetLeft,
                c += a.offsetTop,
                a = a.offsetParent;
            return [l, c]
        }(e)
          , o = {
            top: s + scrollY,
            bottom: Math.max(e.offsetHeight - (s + scrollY + innerHeight), 0),
            left: r + scrollX,
            right: Math.max(e.offsetWidth - (r + scrollX + innerWidth), 0),
            height: innerHeight,
            width: innerWidth
        }
          , i = o.top <= 0 && o.bottom <= 0 && o.left <= 0 && o.right <= 0 ? null : o;
        t(i)
    }
    ;
    sf.push({
        element: e,
        callback: n
    }),
    n(),
    sf.length === 1 && (rf = function(r, s) {
        let o;
        return function() {
            clearTimeout(o),
            o = window.setTimeout( () => {
                clearTimeout(o),
                r()
            }
            , 100)
        }
    }( () => {
        sf.forEach(r => r.callback())
    }
    ),
    window.addEventListener("scroll", rf),
    window.addEventListener("resize", rf))
}
  , p0e = e => {
    (sf = sf.filter(t => t.element !== e)).length || (window.removeEventListener("scroll", rf),
    window.removeEventListener("resize", rf))
}
  , h4 = (e, t) => {
    let n = h.useId()
      , r = h.useRef(null)
      , s = jr(r, t)
      , {sheetId: o, stackId: i, sheetsCount: a, travelAnimation: l, stackingAnimation: c, style: u} = e
      , {sheetId: d, longRunning: f} = H1(o)
      , [p,m] = h.useState(null)
      , {willChangesValuesString: v, outletTransformedOnAnimation: _, nonAnimatedTravelStyles: y, nonAnimatedStackingStyles: b, clippedToViewport: S} = h.useMemo( () => {
        let k = []
          , A = {}
          , O = {}
          , M = !1
          , I = !1;
        return [l, c].forEach( (R, D) => {
            if (R) {
                let P = R.hasOwnProperty("properties") ? R.properties : R;
                Object.entries(P).forEach( ([L,N]) => {
                    !N || (L === "clipBoundary" && (I = !0),
                    typeof N == "string" && (D === 0 ? A[L] = N : O[L] = N),
                    iq.includes(L) || L === "transform" ? k.includes("transform") || (k.push("transform"),
                    M = !0) : L !== "opacity" || k.includes("opacity") || k.push("opacity"))
                }
                )
            }
        }
        ),
        {
            willChangesValuesString: k.join(", "),
            outletTransformedOnAnimation: M,
            nonAnimatedTravelStyles: A,
            nonAnimatedStackingStyles: O,
            clippedToViewport: I
        }
    }
    , [c, l])
      , {modifiedTravelAnimation: C, modifiedNonAnimatedTravelStyles: w, modifiedStackingAnimation: x, modifiedNonAnimatedStackingStyles: E} = h.useMemo( () => {
        let k;
        if (p) {
            let {top: D, bottom: P, left: L, right: N} = p;
            k = `${D - .1}px ${N}px ${P}px ${L}px`
        }
        let A = (D, P) => {
            let L, N, B;
            if (!D)
                return [];
            let {top: H, left: ye, height: Ie, width: be} = p || {}
              , me = D.hasOwnProperty("properties") ? D.properties : D
              , ge = me.clipBoundary
              , ce = me.clipBorderRadius
              , Z = me.clipTransformOrigin;
            if (ge && (Z || (Z = "50% 50% 0"),
            B = Z.split(" ").map(ve => ve === "top" || ve === "left" ? "0%" : ve === "bottom" || ve === "right" ? "100%" : ve).map( (ve, Ue) => {
                if (Ue === 0) {
                    let re = ve;
                    return ve.includes("%") ? re = ve.replace(/\b\d+%/, W => parseFloat(W) / 100 * be + "px") : ve === "0" && (re = "0px"),
                    "calc(" + ye + "px + " + re + ")"
                }
                if (Ue === 1) {
                    let re = ve;
                    return ve.includes("%") ? re = ve.replace(/\b\d+%/, W => parseFloat(W) / 100 * Ie + "px") : ve === "0" && (re = "0px"),
                    "calc(" + H + "px + " + re + ")"
                }
            }
            ).join(" ")),
            ge)
                if (ge === "layout-viewport")
                    if (k) {
                        if (typeof ce == "string")
                            L = `inset(${k} round ${ce})`;
                        else if (Array.isArray(ce)) {
                            let ee = `inset(${k} round `;
                            L = ({tween: oe}) => ee + oe(...ce) + ")"
                        } else if (typeof ce == "function") {
                            let ee = `inset(${k} round `;
                            L = oe => ee + ce(oe) + ")"
                        } else
                            L = `inset(${k})`;
                        N = "0.001px"
                    } else
                        N = ce ?? null;
                else if (typeof ge == "function")
                    if (k) {
                        if (typeof ce == "string")
                            L = ee => ge(ee) !== "none" ? `inset(${k} round ${ce})` : "none";
                        else if (Array.isArray(ce)) {
                            let ee = `inset(${k} round `;
                            L = oe => ge(oe) !== "none" ? ee + oe.tween(...ce) + ")" : "none"
                        } else if (typeof ce == "function") {
                            let ee = `inset(${k} round `;
                            L = oe => ge(oe) !== "none" ? ee + ce(oe) + ")" : "none"
                        } else
                            L = ee => ge(ee) !== "none" ? `inset(${k})` : "none";
                        N = "0.001px"
                    } else
                        ce && (N = ee => {
                            if (ge(ee) === "layout-viewport")
                                return ce
                        }
                        );
                else
                    ge === "none" && (L = "none",
                    N = ce ?? null);
            else {
                let ee = {
                    ...me
                }
                  , oe = {
                    ...P
                };
                return delete ee.clipBoundary,
                delete ee.clipBorderRadius,
                delete ee.clipTransformOrigin,
                delete oe.clipBoundary,
                delete oe.clipBorderRadius,
                delete oe.clipTransformOrigin,
                [ee, oe]
            }
            let ne = {
                ...me
            }
              , _e = {
                ...P
            };
            return delete ne.clipBoundary,
            delete ne.clipBorderRadius,
            delete ne.clipTransformOrigin,
            delete _e.clipBoundary,
            delete _e.clipBorderRadius,
            delete _e.clipTransformOrigin,
            typeof L == "string" ? _e.clipPath = L : ne.clipPath = L,
            typeof N == "string" ? _e.borderRadius = N : ne.borderRadius = N,
            typeof B == "string" && (_e.transformOrigin = B),
            [ne, _e]
        }
          , [O,M] = A(l, y)
          , [I,R] = A(c, b);
        return {
            modifiedTravelAnimation: O,
            modifiedNonAnimatedTravelStyles: M,
            modifiedStackingAnimation: I,
            modifiedNonAnimatedStackingStyles: R
        }
    }
    , [p, b, y, c, l]);
    En( () => {
        let k = r.current
          , A = n && S && (!i && f || i && a >= 1);
        if (A)
            return h0e(k, m),
            () => {
                A && p0e(k)
            }
    }
    , [n, S, f, i, a]);
    let T = h.useMemo( () => i ? {
        ...u,
        ...a >= 1 ? E : {},
        willChange: a >= 1 ? v + (u?.willChange ? ", " + u?.willChange : "") : u?.willChange
    } : {
        ...u,
        ...f ? w : {},
        ...a >= 1 ? E : {},
        willChange: f ? v + (u?.willChange ? ", " + u?.willChange : "") : u?.willChange
    }, [i, u, w, E, f, a, v]);
    return En( () => {
        let k, A = tt.findActualFixedComponentsInsideOutlet(r.current);
        if (A.length)
            return _ && (k = (O => {
                let M = () => {
                    A.forEach(R => {
                        if (!R.element || R.compensated)
                            return;
                        let D = 0
                          , P = 0
                          , L = R.element.style.transform
                          , N = window.getComputedStyle(R.element)
                          , B = N.getPropertyValue("--silk-fixed-side")
                          , H = N.getPropertyValue("transform");
                        tt.updateFixedComponent({
                            id: R.id,
                            initialInlineCSSTransform: L,
                            compensated: !0
                        }),
                        D = B.includes("bottom") ? -1 * (r.current.offsetHeight - (scrollY + window.innerHeight)) : scrollY,
                        P = B.includes("right") ? -1 * (r.current.offsetWidth - (scrollX + window.innerWidth)) : scrollX,
                        (Math.abs(D) !== 0 || Math.abs(P) !== 0) && R.element.style.setProperty("transform", (H !== "none" ? H + " " : "") + "translateX(" + P + "px) translateY(" + D + "px)")
                    }
                    )
                }
                  , I = () => {
                    window.removeEventListener("resize", M),
                    window.removeEventListener("scroll", M),
                    A.forEach(R => {
                        R.element && R.compensated && (R.initialInlineCSSTransform ? (R.element.style.setProperty("transform", R.initialInlineCSSTransform),
                        tt.updateFixedComponent({
                            id: R.id,
                            initialInlineCSSTransform: void 0,
                            compensated: !1
                        })) : (R.element.style.removeProperty("transform"),
                        tt.updateFixedComponent({
                            id: R.id,
                            compensated: !1
                        })))
                    }
                    )
                }
                ;
                return O ? (M(),
                window.addEventListener("resize", M),
                window.addEventListener("scroll", M)) : I(),
                I
            }
            )(i ? a > 0 : f)),
            k
    }
    , [f, n, _, a, i]),
    En( () => (tt.addOutletToSheet(d, n),
    () => tt.removeOutletFromSheet(d, n)), [n, d]),
    En( () => {
        let k = r.current;
        return C && tt.addAnimationToSheetOrStack({
            sheetId: d,
            type: "travel",
            element: k,
            config: C
        }),
        x && tt.addAnimationToSheetOrStack({
            sheetId: i ? null : d,
            stackId: i,
            type: "stacking",
            element: k,
            config: x
        }),
        () => {
            C && tt.removeAnimationFromSheetOrStack({
                sheetId: d,
                type: "travel",
                element: k
            }),
            x && tt.removeAnimationFromSheetOrStack({
                sheetId: i ? null : d,
                stackId: i,
                type: "stacking",
                element: k
            })
        }
    }
    , [d, i, C, x]),
    {
        ref: r,
        outletId: n,
        styleValue: T,
        composedRef: s
    }
}
  , H1 = e => h.useContext(e ?? Oa) || {};
rd.displayName = "Sheet.ErrorBoundary",
zn.displayName = "Sheet.Slot.Root";
let sc = Ne.forwardRef( (e, t) => {
    let {asChild: n, forComponent: r, travelAnimation: s, stackingAnimation: o, style: i, className: a, ...l} = e
      , {staging: c, StackContext: u} = H1(r)
      , d = u ?? Ne.createContext(null)
      , {sheetsCount: f} = h.useContext(d) || {}
      , {styleValue: p, composedRef: m} = h4({
        sheetId: r,
        sheetsCount: f,
        travelAnimation: s,
        stackingAnimation: o,
        style: i
    }, t)
      , v = h.useMemo( () => c !== "none", [c])
      , _ = n ? zn : "div"
      , y = Hn("Sheet", {});
    return g.jsx(_, {
        style: p,
        ...y("outlet", [], {
            className: a,
            dataSilk: [v && "0aj"]
        }),
        ...l,
        ref: m
    })
}
);
sc.displayName = "Sheet.Outlet";
let p4 = Ne.forwardRef( ({asChild: e, ...t}, n) => {
    let r = e ? zn : "button"
      , {forComponent: s, className: o, "data-silk": i, onPress: a, onClick: l, children: c, action: u="present", travelAnimation: d, stackingAnimation: f, ...p} = t
      , {sheetRole: m, sheetId: v, open: _, onOpenChange: y, elementFocusedLastBeforeShowing: b} = H1(s)
      , S = tt.findSheet(v)
      , C = h.useRef(null)
      , w = jr(C, n)
      , x = h.useMemo( () => (m === "dialog" || m === "alertdialog") && u === "present" ? "dialog" : void 0, [u, m])
      , E = h.useMemo( () => u === "present" || u === "dismiss" ? _ : void 0, [u, _])
      , T = Hn("Sheet", {});
    return g.jsx(sc, {
        forComponent: s,
        asChild: !0,
        travelAnimation: d,
        stackingAnimation: f,
        children: g.jsx(r, {
            ...T("trigger", [], {
                className: o,
                dataSilk: [i]
            }),
            onClick: k => {
                var A, O;
                let {forceFocus: M, runAction: I} = Po({
                    nativeEvent: k,
                    defaultBehavior: {
                        forceFocus: !0,
                        runAction: !0
                    },
                    handler: a
                });
                M && ((A = C.current) === null || A === void 0 || A.focus({
                    preventScroll: !0
                })),
                I && (u === "present" ? (b.current = C.current,
                y(!0)) : u === "dismiss" ? y(!1) : (u === "step" || u.type === "step") && (S == null || (O = S.sendToOpennessMachine) === null || O === void 0 || O.call(S, {
                    type: "STEP",
                    direction: u === "step" ? "up" : u.direction,
                    detent: u === "step" ? null : u.detent
                }))),
                l?.(k)
            }
            ,
            "aria-haspopup": x,
            "aria-controls": v,
            "aria-expanded": E,
            ref: w,
            ...p,
            children: c
        })
    })
}
);
p4.displayName = "Sheet.Trigger";
let vq = Ne.forwardRef( (e, t) => {
    let {children: n, className: r, action: s="step", ...o} = e
      , {detents: i} = h.useContext(ro) || {}
      , a = i.length === 1 && s !== "dismiss"
      , l = Hn("Sheet", {});
    return g.jsx(p4, {
        ...l("handle", [], {
            className: r
        }),
        action: s,
        disabled: a,
        ...o,
        ref: t,
        children: g.jsx(f0e.Root, {
            children: n ?? (s === "dismiss" ? "Dismiss" : "Cycle")
        })
    })
}
);
vq.displayName = "Sheet.Handle";
let _q = e => {
    var t;
    let[n,r] = h.useState(!1);
    return h.useEffect( () => (r(!0),
    () => r(!1)), []),
    n ? fl.createPortal(e.children, (t = e.container) !== null && t !== void 0 ? t : document.body) : null
}
;
_q.displayName = "Sheet.Portal";
let m0e = ({rootRef: e}) => (h.useEffect( () => {
    let t = e.current;
    if (!t)
        return;
    getComputedStyle(t).getPropertyValue("--silk-aY").trim() !== "1" && console.warn("The CSS styles for Silk are not found. Please refer to the documentation on how to import them.")
}
, [e]),
null)
  , yq = Ne.forwardRef( (e, t) => {
    let {className: n, "data-silk": r, license: s, sheetRole: o, componentId: i, forComponent: a, defaultPresented: l, presented: c, onPresentedChange: u, defaultActiveDetent: d, activeDetent: f, onActiveDetentChange: p, onSafeToUnmountChange: m, ...v} = e
      , _ = h.useRef(null)
      , y = jr(_, t)
      , b = l != null && l
      , [S,C] = h.useState(b)
      , w = c !== void 0 && u !== void 0
      , x = h.useMemo( () => w ? c : S, [w, c, S])
      , E = h.useMemo( () => w ? u : C, [w, u, C])
      , T = h.useRef(null)
      , [k,A] = h.useState(!b)
      , O = h.useCallback(H => {
        m?.(H),
        A(H)
    }
    , [m])
      , [M,I] = h.useState(x)
      , [R,D] = h.useState("none")
      , P = a === "closest" ? V1 : a
      , L = Hl()
      , N = {
        license: s,
        StackContext: P,
        CustomSheetContext: i,
        sheetId: L,
        sheetRole: o,
        open: x,
        onOpenChange: E,
        onSafeToUnmountChange: O,
        defaultActiveDetent: d,
        activeDetent: f,
        onActiveDetentChange: p,
        safeToUnmount: k,
        longRunning: M,
        setLongRunning: I,
        staging: R,
        setStaging: D,
        elementFocusedLastBeforeShowing: T,
        ...v
    }
      , B = Hn("Sheet");
    return g.jsxs(rd, {
        children: [g.jsx(m0e, {
            rootRef: _
        }), g.jsx(Ch, {
            genericContext: Oa,
            customContext: i,
            value: N,
            children: g.jsx(sc, {
                ...B("root", [], {
                    className: n,
                    dataSilk: [r]
                }),
                ref: y,
                ...v
            })
        })]
    })
}
);
yq.displayName = "Sheet.Root";
let bq = Ne.forwardRef( (e, t) => {
    let {forComponent: n} = e
      , {open: r, safeToUnmount: s} = H1(n);
    return (r || !s) && g.jsx(mq, {
        ...e,
        ref: t
    })
}
);
bq.displayName = "Sheet.View";
let Cq = Ne.forwardRef( ({asChild: e, swipeable: t=!0, ...n}, r) => {
    let {longRunningState: s, backdropRef: o, styleAttributes: i, setBackdropSwipeable: a, setBackdropTravelHandler: l} = h.useContext(ro) || {}
      , {className: c, "data-silk": u, children: d, travelAnimation: f, stackingAnimation: p, themeColorDimming: m=!1, ...v} = n
      , _ = jr(o, r);
    h.useEffect( () => (a(t),
    () => {
        a(!1)
    }
    ), [a, t]);
    let y = h.useMemo( () => ({
        opacity: ({progress: x}) => Math.min(.33 * x, .33),
        ...f
    }), [f])
      , [b,S] = h.useState(y)
      , C = Hl()
      , w = h.useRef(0);
    return En( () => {
        let x = !1
          , E = () => {
            x && tt.removeThemeColorDimmingOverlay(C)
        }
        ;
        if (s.matches("longRunning:true")) {
            let T;
            if (!(x = !!(aa() && !C1e() && m === "auto" && y.opacity && tt.getAndStoreUnderlyingThemeColorAsRGBArray())))
                return;
            let {opacity: k, ...A} = y;
            if (S({
                opacity: "ignore",
                ...A
            }),
            Array.isArray(k)) {
                let[O,M] = k;
                T = ({progress: I}) => O + (M - O) * I
            } else
                typeof k == "function" && (T = k,
                S({
                    opacity: "ignore",
                    ...A
                }));
            if (T && o && l) {
                let O = window.getComputedStyle(o.current).backgroundColor
                  , M = tt.updateThemeColorDimmingOverlay({
                    abortRemoval: !0,
                    dimmingOverlayId: C,
                    color: O,
                    alpha: w.current
                })
                  , I = R => {
                    var D;
                    let P = T(R);
                    tt.updateThemeColorDimmingOverlayAlphaValue(M, P),
                    (D = o.current) === null || D === void 0 || D.style.setProperty("opacity", P),
                    w.current = P
                }
                ;
                l( () => I)
            }
        }
        return s.matches("longRunning:false") && E(),
        () => {
            E()
        }
    }
    , [s, C, o, l, m, f, y]),
    g.jsx(sc, {
        ...i("backdrop", ["scrollContainerShouldBePassThrough"], {
            className: c,
            dataSilk: [u]
        }),
        travelAnimation: b,
        stackingAnimation: p,
        ...v,
        ref: _,
        asChild: e,
        children: d
    })
}
);
Cq.displayName = "Sheet.Backdrop";
let Sq = Ne.forwardRef( (e, t) => {
    var n;
    let {asChild: r, children: s, className: o, "data-silk": i, travelAnimation: a, stackingAnimation: l, style: c, ...u} = e
      , d = r ? zn : "div"
      , {StackContext: f} = h.useContext(Oa) || {}
      , p = f ?? Ne.createContext(null)
      , {sheetsCount: m} = h.useContext(p) || {}
      , {styleValue: v, composedRef: _} = h4({
        sheetId: Oa,
        sheetsCount: m,
        travelAnimation: a,
        stackingAnimation: l,
        style: c
    }, t)
      , {scrollContainerRef: y, frontSpacerRef: b, contentWrapperRef: S, contentRef: C, backSpacerRef: w, detentMarkersRefs: x, leftEdgeRef: E, nativeEdgeSwipePrevention: T, scrollContainerTouchStartHandler: k, scrollContainerTouchEndHandler: A, styleAttributes: O, detents: M, bleedingBackgroundPresent: I} = h.useContext(ro) || {}
      , R = jr(C, _);
    return g.jsxs("div", {
        ...O("scrollContainer", ["track", "swipeDisabled", "swipeOvershootDisabled", "staging", "positionCoveredStatus", "scrollContainerShouldBePassThrough", "swipeTrap"], {
            dataSilk: ["0ac"]
        }),
        ref: y,
        onTouchStart: k,
        onTouchEnd: A,
        children: [g.jsx("div", {
            ...O("frontSpacer", ["track"]),
            ref: b
        }), g.jsxs("div", {
            ...O("contentWrapper", ["placement", "track", "swipeOvershootDisabled", "swipeOutDisabledWithDetent", "staging", "position"]),
            ref: S,
            children: [g.jsx(d, {
                ...O("content", ["track", "placement", "scrollContainerShouldBePassThrough"], {
                    className: o,
                    dataSilk: [i, I && "0af"]
                }),
                style: v,
                ...u,
                ref: R,
                children: s
            }), T && g.jsx("div", {
                ...O("leftEdge", ["track"]),
                ref: E
            })]
        }), g.jsx("div", {
            ...O("backSpacer", ["track"]),
            ref: w,
            children: M.map( (D, P) => g.jsx("div", {
                ref: L => {
                    x.current.length > M.length && (x.current = x.current.slice(0, M.length)),
                    x.current[P] = L
                }
                ,
                ...O("detentMarker", ["track", "swipeOutDisabledWithDetent"]),
                style: {
                    "--silk-aA": (n = M[P - 1]) !== null && n !== void 0 ? n : "0px",
                    "--silk-aB": D,
                    "--silk-aC": P
                }
            }, P))
        })]
    })
}
);
Sq.displayName = "Sheet.Content";
let g0e = Ne.forwardRef( ({asChild: e, ...t}, n) => {
    let {className: r, "data-silk": s, ...o} = t
      , {staging: i, placement: a, track: l, setBleedingBackgroundPresent: c} = h.useContext(ro) || {};
    h.useEffect( () => (c(!0),
    () => {
        c(!1)
    }
    ), [c]);
    let u = l === "horizontal" || l === "vertical"
      , d = Hn("Sheet", {
        staging: i,
        placement: a,
        track: l,
        bleedDisabled: u
    });
    return g.jsx(sc, {
        asChild: e,
        ...d("bleedingBackground", ["staging", "placement", "track", "bleedDisabled"], {
            className: r,
            dataSilk: [s]
        }),
        ...o,
        ref: n
    })
}
);
g0e.displayName = "Sheet.BleedingBackground";
let v0e = Ne.forwardRef( (e, t) => {
    let {className: n, "data-silk": r, ...s} = e
      , {travelAxis: o} = h.useContext(ro) || {}
      , i = h.useMemo( () => o === "vertical" ? "horizontal" : "vertical", [o])
      , [a,l] = h.useState(!1);
    h.useEffect( () => l(aa()), []);
    let c = Hn("SpecialWrapper");
    return g.jsx(pi.Root, {
        ...c("root", [], {
            className: n,
            dataSilk: [r]
        }),
        active: a,
        axis: i,
        ...s,
        ref: t
    })
}
);
v0e.displayName = "Sheet.SpecialWrapper.Root";
let _0e = Ne.forwardRef( (e, t) => g.jsx(pi.Stabiliser, {
    ...e,
    ref: t
}));
_0e.displayName = "Sheet.SpecialWrapper.Content";
let wq = Ne.forwardRef( (e, t) => {
    let {asChild: n, travelAnimation: r, stackingAnimation: s, ...o} = e
      , i = n ? zn : "h2"
      , {titleId: a} = h.useContext(ro);
    return g.jsx(sc, {
        asChild: !0,
        travelAnimation: r,
        stackingAnimation: s,
        children: g.jsx(i, {
            id: a,
            ref: t,
            ...o
        })
    })
}
);
wq.displayName = "Sheet.Title";
let y0e = Ne.forwardRef( (e, t) => {
    let {asChild: n, travelAnimation: r, stackingAnimation: s, ...o} = e
      , {descriptionId: i} = h.useContext(ro)
      , a = n ? zn : "p";
    return g.jsx(sc, {
        asChild: !0,
        travelAnimation: r,
        stackingAnimation: s,
        children: g.jsx(a, {
            id: i,
            ...o,
            ref: t
        })
    })
}
);
y0e.displayName = "Sheet.Description";
let la = {
    Root: yq,
    Trigger: p4,
    View: bq,
    Backdrop: Cq,
    Content: Sq,
    Handle: vq,
    Portal: _q,
    Title: wq
};
rd.displayName = "SheetStack.ErrorBoundary";
let b0e = Ne.forwardRef( (e, t) => {
    let {componentId: n, className: r, "data-silk": s, asChild: o, ...i} = e
      , a = h.useId();
    En( () => (tt.addSheetStack({
        id: a
    }),
    () => tt.removeSheetStack(a)), [a]);
    let[l,c] = h.useState([])
      , u = h.useCallback(E => {
        c(T => {
            let k, A = T.findIndex(O => O.sheetId === E.sheetId);
            return A !== -1 ? (k = [...T])[A] = E : k = [...T, E],
            k
        }
        )
    }
    , [])
      , d = h.useCallback(E => {
        c(T => T.filter(k => k.sheetId !== E))
    }
    , [])
      , f = h.useCallback(E => {
        let T = l.findIndex(k => k.sheetId === E);
        return T === -1 ? l[l.length - 1] : l[T - 1]
    }
    , [l])
      , [p,m] = h.useState(0);
    En( () => {
        p === 0 && tt.removeAllOutletPersistedStylesFromStack(a)
    }
    , [p, a]);
    let[v,_] = h.useState([])
      , y = h.useCallback(E => {
        _(T => {
            let k = T.findIndex(A => A.sheetId === E.sheetId);
            if (k === -1)
                return [...T, E];
            {
                let A = [...T];
                return A[k] = E,
                A
            }
        }
        )
    }
    , [])
      , b = h.useCallback(E => {
        _(T => T.filter(k => k.sheetId !== E))
    }
    , [])
      , S = h.useMemo( () => v.some(E => E.staging !== "none") ? "not-none" : "none", [v])
      , C = h.useMemo( () => ({
        stackId: a,
        sheetsCount: p,
        setSheetsCount: m,
        updateSheetStagingDataInStack: y,
        removeSheetStagingDataInStack: b,
        sheetsInStackMergedStaging: S,
        updateSheetDataInStack: u,
        removeSheetDataFromStack: d,
        getPreviousSheetDataInStack: f
    }), [a, p, y, b, S, u, d, f])
      , w = o ? zn : "div"
      , x = Hn("SheetStack");
    return g.jsx(rd, {
        children: g.jsx(Ch, {
            genericContext: V1,
            customContext: n,
            value: C,
            children: g.jsx(w, {
                ...x("root", [], {
                    className: r,
                    dataSilk: [s]
                }),
                ref: t,
                ...i
            })
        })
    })
}
);
b0e.displayName = "SheetStack.Root";
let C0e = Ne.forwardRef( (e, t) => {
    let {forComponent: n="closest", asChild: r, stackingAnimation: s, style: o, className: i, ...a} = e
      , l = n === "closest" ? V1 : n
      , {stackId: c, sheetsCount: u, sheetsInStackMergedStaging: d} = h.useContext(l);
    En( () => {
        tt.addSheetStack({
            id: c
        })
    }
    , [c]);
    let {styleValue: f, composedRef: p} = h4({
        sheetsCount: u,
        stackId: c,
        stackingAnimation: s,
        style: o
    }, t)
      , m = h.useMemo( () => d !== "none", [d])
      , v = Hn("SheetStack", {})
      , _ = r ? zn : "div";
    return g.jsx(_, {
        style: f,
        ...v("outlet", [], {
            className: i,
            dataSilk: [m && "0aj"]
        }),
        ...a,
        ref: p
    })
}
);
C0e.displayName = "SheetStack.Outlet";
let m4 = Ne.createContext(null);
m4.displayName = "Scroll.GenericContext";
let z1 = Ne.createContext({
    contentRef: null
});
z1.displayName = "Scroll.Anonymous";
let Eq = e => h.useContext(e ?? m4) || {}
  , S0e = ln === "android" ? 102 : 54
  , Fb = d4 || ln === "android" ? "instant" : "smooth"
  , w0e = (e, t, n=300) => {
    let r, s = e.scrollTop, o = () => {
        clearTimeout(r),
        e.removeEventListener("scroll", i),
        t()
    }
    , i = () => {
        let a = e.scrollTop;
        if (a > s) {
            o();
            return
        }
        s = a,
        clearTimeout(r),
        r = setTimeout(o, n)
    }
    ;
    r = setTimeout(o, n),
    e.addEventListener("scroll", i)
}
  , jb = e => {
    if (!e)
        return {
            top: 0,
            bottom: 0
        };
    let t = e.getBoundingClientRect()
      , n = window.getComputedStyle(e)
      , r = t.top + parseFloat(n.borderTopWidth)
      , s = t.bottom - parseFloat(n.borderBottomWidth);
    return {
        top: r,
        bottom: s
    }
}
  , nA = () => {
    let e = window.visualViewport.height
      , t = window.visualViewport.offsetTop;
    return {
        top: t,
        bottom: t + e
    }
}
  , E0e = (e, t) => Math.abs(Math.min(e + t, 0))
  , x0e = (e, t) => Math.max(e - t, 0)
  , rA = (e, t, n) => {
    e.style.setProperty("height", t + "px"),
    n.current = t
}
  , T0e = ({scrollContainer: e, elementTop: t, elementBottom: n, behavior: r, scrollMarginTop: s, scrollMarginBottom: o, scrollPortTop: i, scrollPortBottom: a, visualViewportTop: l, visualViewportBottom: c, beforeScrollCallback: u}) => {
    if (!e)
        return;
    let d = t - Math.max(i, l)
      , f = Math.min(a, c) - n;
    if (d < s) {
        let p = Math.max(-e.scrollTop, d - s);
        p !== 0 && (u(),
        e.scrollBy({
            top: p,
            behavior: r
        }))
    } else if (f < o) {
        let p = e.scrollHeight - e.clientHeight - e.scrollTop
          , m = Math.min(p, o - f);
        m !== 0 && (u(),
        e.scrollBy({
            top: m,
            behavior: r
        }))
    }
}
;
rd.displayName = "Scroll.ErrorBoundary";
let xq = Ne.forwardRef( (e, t) => {
    let {asChild: n, className: r, componentId: s, componentRef: o, "data-silk": i, ...a} = e
      , l = n ? zn : "div"
      , c = h.useRef( () => {}
    )
      , u = h.useCallback( (...v) => {
        let _ = c.current;
        return _(...v)
    }
    , [])
      , d = h.useRef( () => {}
    )
      , f = h.useCallback( (...v) => {
        let _ = d.current;
        return _(...v)
    }
    , [])
      , p = h.useMemo( () => ({
        componentRef: o,
        scrollToRef: c,
        scrollTo: u,
        scrollByRef: d,
        scrollBy: f
    }), [o, f, u])
      , m = Hn("Scroll", {});
    return g.jsx(rd, {
        children: g.jsx(Ch, {
            genericContext: m4,
            customContext: s,
            value: p,
            children: g.jsx(l, {
                ...m("root", [], {
                    className: r,
                    dataSilk: [i]
                }),
                ...a,
                ref: t
            })
        })
    })
}
);
xq.displayName = "Scroll.Root";
let wp = null
  , Tq = () => {
    let e = h.useRef(null);
    En( () => {
        wp === null && e.current && (wp = e.current.offsetWidth - e.current.clientWidth,
        document.body.style.setProperty("--ua-scrollbar-thickness", wp + "px"))
    }
    , []);
    let t = Hn("Scroll")
      , n = g.jsx("div", {
        ...t("UAScrollbarMeasurer"),
        ref: e
    });
    return wp === null ? typeof window < "u" ? fl.createPortal(n, document.body) : g.jsx(g.Fragment, {
        children: n
    }) : null
}
;
Tq.displayName = "Scroll.Anonymous";
let Ep = (e, t, n, r=!1) => typeof e == "boolean" ? e : typeof e?.[t] == "boolean" ? e[t] : typeof e?.[n] == "boolean" ? e[n] : r
  , kq = Ne.forwardRef( (e, t) => {
    let {asChild: n, children: r, className: s, "data-silk": o, forComponent: i, axis: a="y", pageScroll: l=!1, nativePageScrollReplacement: c=!1, safeArea: u="visual-viewport", scrollGestureTrap: d=!1, scrollGestureOvershoot: f=!0, scrollGesture: p="auto", onScrollStart: m, onScroll: v, onScrollEnd: _, onFocusInside: y, nativeFocusScrollPrevention: b=!0, scrollAnimationSettings: S={
        skip: "auto"
    }, scrollAnchoring: C=!0, scrollSnapType: w="none", scrollPadding: x="auto", scrollTimelineName: E="none", nativeScrollbar: T=!0, ...k} = e
      , [A,O,M,I] = h.useMemo( () => {
        let Se = Ep(d, "xStart", "x")
          , Nt = Ep(d, "xEnd", "x")
          , ht = Ep(d, "yStart", "y")
          , dt = Ep(d, "yEnd", "y")
          , nt = Se
          , yt = Nt
          , $n = ht
          , vn = dt;
        return a === "y" ? yt = nt = Se !== Nt || Se : vn = $n = ht !== dt || ht,
        [nt, yt, $n, vn]
    }
    , [d, a])
      , R = h.useMemo( () => A !== O, [O, A])
      , D = h.useMemo( () => M !== I, [I, M])
      , P = h.useMemo( () => {
        if (w === "proximity") {
            if (a === "y")
                return "proximityY";
            if (a === "x")
                return "proximityX"
        } else {
            if (w !== "mandatory")
                return "none";
            if (a === "y")
                return "mandatoryY";
            if (a === "x")
                return "mandatoryX"
        }
    }
    , [a, w])
      , L = n ? zn : "div"
      , N = h.useRef(null)
      , B = jr(N, t)
      , H = h.useRef(null)
      , ye = h.useRef(null)
      , Ie = h.useRef(null)
      , be = h.useRef(null)
      , me = h.useRef(null)
      , ge = h.useRef(null)
      , ce = Hl()
      , {componentRef: Z, scrollToRef: ne, scrollByRef: _e} = Eq(i) || {}
      , {getContentCoordinatesWhenRestingOnLastDetent: ee, contentRef: oe} = h.useContext(ro) || {}
      , te = h.useMemo( () => p === !1 || p !== "auto", [p])
      , [ve,Ue] = h.useState(!1)
      , [re,W] = h.useState(!1);
    En( () => {
        l && (Se => {
            let Nt = "data-silk-native-page-scroll-replaced"
              , ht = document.documentElement.getAttribute(Nt);
            if (!l && ht !== "true")
                return;
            let dt = window.matchMedia("(display-mode: standalone)").matches || window.navigator.standalone;
            if (Se !== !0 && (Se !== "auto" || (ln === "android" || ln === "ios" || ln === "ipados") && !dt)) {
                var yt, $n;
                W(!1);
                let vn = new Event("silk-page-scroll-data-change");
                if (document.dispatchEvent(vn),
                ht === "false")
                    return;
                let mo = ($n = (yt = H.current) === null || yt === void 0 ? void 0 : yt.scrollTop) !== null && $n !== void 0 ? $n : 0;
                document.documentElement.setAttribute(Nt, "false"),
                ht === "true" && window.scrollTo(0, mo)
            } else {
                W(!0),
                H.current;
                let vn = new Event("silk-page-scroll-data-change");
                if (document.dispatchEvent(vn),
                ht === "true")
                    return;
                let mo = window.pageYOffset;
                if (document.documentElement.setAttribute(Nt, "true"),
                !H.current)
                    return;
                H.current.scrollTop = mo
            }
        }
        )(c)
    }
    , [l, c]);
    let[X,Te] = h.useState(!0)
      , [se,G] = h.useState(!0);
    En( () => {
        let Se = H.current
          , Nt = ye.current
          , ht = Ie.current
          , dt = be.current
          , nt = new ResizeObserver( () => {
            Se && (a === "y" && Se.scrollHeight > Se.clientHeight ? Te(!0) : Te(!1),
            a === "x" && Se.scrollWidth > Se.clientWidth ? G(!0) : G(!1))
        }
        );
        return Se && Nt && ht && dt && (nt.observe(Se, {
            box: "border-box"
        }),
        nt.observe(Nt, {
            box: "border-box"
        }),
        nt.observe(ht, {
            box: "border-box"
        }),
        nt.observe(dt, {
            box: "border-box"
        })),
        () => {
            nt && nt.disconnect()
        }
    }
    , [a, te]);
    let[F,ke] = h.useState(!1);
    En( () => {
        ke(X || se ? !0 : () => !1)
    }
    , [X, se]);
    let[Ee,Y] = h.useState(!1);
    h.useEffect( () => {
        Y(eq())
    }
    , []);
    let le = h.useRef(!1)
      , Oe = h.useRef(!1)
      , ae = R || D
      , [je,ot] = h.useState(A)
      , [St,Tt] = h.useState(M);
    h.useEffect( () => {
        let Se;
        if (ae) {
            let Nt = me.current
              , ht = ge.current;
            if (!Nt || !ht)
                return;
            (Se = new IntersectionObserver(dt => {
                for (let nt of dt)
                    nt.target === Nt ? nt.isIntersecting ? (le.current = !0,
                    a === "x" ? ot(A) : Tt(M)) : le.current = !1 : nt.target === ht && (nt.isIntersecting ? (Oe.current = !0,
                    a === "x" ? ot(O) : Tt(I)) : Oe.current = !1),
                    le.current && Oe.current && (a === "x" ? ot(!1) : Tt(!1))
            }
            ,{
                root: H.current,
                rootMargin: "0px",
                threshold: [1]
            })).observe(Nt),
            Se.observe(ht)
        }
        return () => {
            Se && Se.disconnect()
        }
    }
    , [O, A, I, M, a, ae]);
    let wt = h.useRef(!1)
      , ut = h.useRef()
      , Mt = h.useRef("")
      , fn = h.useRef(void 0);
    h.useEffect( () => {
        let Se = H.current;
        if (!Se)
            return;
        let Nt = dt => {
            Fn.current = !1,
            Po({
                nativeEvent: dt,
                defaultBehavior: {},
                handler: _
            });
            let nt = document.activeElement;
            (ln == "ios" || ln == "ipados") && nt && _l(nt) && (fn.current === void 0 && (Mt.current = nt.style.getPropertyValue("opacity"),
            nt.style.setProperty("opacity", "0.9999", "important")),
            clearTimeout(fn.current),
            fn.current = void 0,
            fn.current = setTimeout( () => {
                Mt.current === "" ? nt.style.removeProperty("opacity") : nt.style.setProperty("opacity", Mt.current),
                fn.current = void 0
            }
            , 55))
        }
          , ht = dt => {
            if (!wt.current) {
                let {dismissKeyboard: nt} = Po({
                    nativeEvent: dt,
                    defaultBehavior: {
                        dismissKeyboard: !1
                    },
                    handler: m
                });
                nt && !wt.current && !Fn.current && lg() && Se.focus({
                    preventScroll: !0
                })
            }
            clearTimeout(ut.current),
            ut.current = setTimeout( () => {
                wt.current = !1,
                Ue(!1),
                "onscrollend"in window || Nt(null)
            }
            , 90),
            wt.current = !0,
            Ue(!0)
        }
        ;
        return Se.addEventListener("scroll", ht),
        "onscrollend"in window && Se.addEventListener("scrollend", Nt),
        () => {
            Se.removeEventListener("scroll", ht),
            "onscrollend"in window && Se.removeEventListener("scrollend", Nt)
        }
    }
    , [_, m]),
    h.useEffect( () => (b && tt.addNativeFocusScrollPreventer(ce),
    () => {
        b && tt.removeNativeFocusScrollPreventer(ce)
    }
    ), [b, ce]);
    let Yt = h.useMemo( () => l && !re, [re, l])
      , jt = h.useMemo( () => a === "y" ? Yt ? () => window.scrollY : () => {
        var Se;
        return (Se = H.current) === null || Se === void 0 ? void 0 : Se.scrollTop
    }
    : Yt ? () => window.scrollX : () => {
        var Se;
        return (Se = H.current) === null || Se === void 0 ? void 0 : Se.scrollLeft
    }
    , [a, Yt])
      , gn = h.useMemo( () => a === "y" ? Yt ? () => document.body.scrollHeight - window.innerHeight : () => {
        let Se = H.current;
        return Se?.scrollHeight - Se?.offsetHeight
    }
    : Yt ? () => document.body.scrollWidth - window.innerWidth : () => {
        let Se = H.current;
        return Se?.scrollWidth - Se?.offsetWidth
    }
    , [a, Yt])
      , kn = h.useCallback( () => jt() / gn(), [jt, gn])
      , On = h.useCallback(Se => {
        v?.({
            progress: kn(),
            distance: jt(),
            availableDistance: gn(),
            nativeEvent: Se
        })
    }
    , [kn, jt, gn, v]);
    h.useEffect( () => (Yt && v && document.addEventListener("scroll", On),
    () => {
        Yt && v && document.removeEventListener("scroll", On)
    }
    ), [Yt, v, On]);
    let Ut = h.useCallback( (Se, {progress: Nt, distance: ht, animationSettings: dt={
        skip: "default"
    }}) => {
        let nt = ht ?? (Nt ?? NaN) * gn();
        if (isNaN(nt))
            return;
        let yt = dt?.skip
          , $n = Yt ? window : H.current;
        $n?.[Se === "to" ? "scrollTo" : "scrollBy"]({
            [a === "y" ? "top" : "left"]: nt,
            behavior: yt === !0 ? "instant" : yt === !1 ? "smooth" : yt === "default" ? "auto" : d4 ? "instant" : "smooth"
        })
    }
    , [a, gn, Yt])
      , Os = h.useCallback(Se => Ut("to", Se), [Ut])
      , hn = h.useCallback(Se => Ut("by", Se), [Ut]);
    h.useEffect( () => {
        ne.current = Os,
        _e.current = hn
    }
    , [hn, _e, Os, ne]),
    h.useImperativeHandle(Z, () => ({
        getProgress: kn,
        getDistance: jt,
        getAvailableDistance: gn,
        scrollTo: Os,
        scrollBy: hn
    }), [gn, jt, kn, Os, hn]);
    let Pi = h.useRef(!1)
      , ud = h.useRef()
      , dc = h.useRef()
      , Br = h.useRef(0)
      , Di = h.useRef(0)
      , Fn = h.useRef(!1)
      , $e = h.useCallback( ({scrollIntoPlace: Se=!0, scrollBehavior: Nt, safeViewport: ht="visual-viewport"}) => {
        let dt, nt;
        if (!H.current || !ye.current || !be.current || !Ie.current || a !== "y" || ht === "none" || oe?.current && ee().top === null || !oe?.current && ee)
            return;
        if (oe?.current) {
            let {top: Gr, bottom: $a} = jb(H.current)
              , Er = oe.current.getBoundingClientRect()
              , As = Er.top
              , Ye = Er.bottom;
            dt = ee().top + (Gr - As),
            nt = ee().bottom - (Ye - $a)
        } else {
            let {top: Gr, bottom: $a} = jb(H.current);
            dt = Gr,
            nt = $a
        }
        let {top: yt, bottom: $n} = nA()
          , vn = Math.min(nt, ht === "visual-viewport" ? $n : window.innerHeight)
          , mo = E0e(dt, ht === "visual-viewport" ? yt : 0)
          , go = x0e(nt, ht === "visual-viewport" ? $n : window.innerHeight);
        if (1 > Math.abs(Br.current - mo) && 1 > Math.abs(Di.current - go))
            return;
        let Li = -1 * (vn - be.current.getBoundingClientRect().top)
          , Ha = H.current.offsetHeight - ye.current.offsetHeight >= 0
          , za = () => {
            rA(Ie.current, mo, Br),
            rA(be.current, go, Di)
        }
        ;
        if (Nt === "smooth" && (Li < 0 || Ha) ? Se && (Fn.current = !0,
        Ha ? H.current.scrollTo({
            top: 0,
            behavior: Nt
        }) : H.current.scrollBy({
            top: Li,
            behavior: Nt
        }),
        Di.current = go,
        w0e(H.current, () => {
            H.current && Ha && H.current.scrollTo({
                top: 0,
                behavior: "instant"
            }),
            za()
        }
        )) : za(),
        !Se)
            return {
                spacersHeightSetter: za,
                verticalScrollOffsetRequired: Li
            }
    }
    , [a, ee, oe])
      , tn = h.useCallback( () => $e({
        scrollBehavior: Fb,
        safeViewport: u
    }), [u, $e]);
    En( () => {
        tn()
    }
    , [tn]),
    h.useEffect( () => {
        let Se = H.current
          , Nt = nt => {
            clearTimeout(ud.current),
            clearTimeout(dc.current);
            let yt = nt.target;
            if (yt === Se)
                return;
            let {scrollIntoView: $n} = Po({
                nativeEvent: nt,
                defaultBehavior: {
                    scrollIntoView: !0
                },
                handler: y
            });
            if (!_l(yt) || eS(yt))
                return;
            let vn = yt.getBoundingClientRect().top - 0
              , mo = yt.getBoundingClientRect().bottom - 0
              , {top: go, bottom: Li} = jb(H.current)
              , Ha = go - 0
              , za = Li - 0
              , Gr = () => {
                if (clearTimeout(ud.current),
                clearTimeout(dc.current),
                !lg())
                    return;
                Pi.current = !0;
                let {top: $a, bottom: Er} = nA()
                  , {spacersHeightSetter: As= () => {}
                } = $e({
                    scrollIntoPlace: !1,
                    scrollBehavior: "smooth",
                    safeViewport: u
                }) || {};
                As(),
                $n && T0e({
                    scrollContainer: H.current,
                    behavior: Fb,
                    scrollMarginTop: 64,
                    scrollMarginBottom: S0e,
                    elementTop: vn,
                    elementBottom: mo,
                    scrollPortTop: Ha,
                    scrollPortBottom: za,
                    visualViewportTop: $a,
                    visualViewportBottom: Er,
                    beforeScrollCallback: () => Fn.current = !0
                }),
                visualViewport.removeEventListener("resize", Gr)
            }
            ;
            Pi.current ? (Gr(),
            visualViewport.addEventListener("resize", Gr),
            ud.current = setTimeout( () => {
                visualViewport.removeEventListener("resize", Gr)
            }
            , 900)) : (visualViewport.addEventListener("resize", Gr),
            dc.current = setTimeout( () => {
                visualViewport.removeEventListener("resize", Gr),
                Gr()
            }
            , 900))
        }
          , ht = nt => {
            let yt = nt.target;
            !_l(yt) || eS(yt) || _l(nt.relatedTarget) || (Pi.current = !1,
            $e({
                scrollBehavior: Fb,
                safeViewport: u === "none" ? "none" : "layout-viewport"
            }))
        }
          , dt = () => {
            var nt;
            (nt = H.current) === null || nt === void 0 || nt.removeEventListener("scroll", tn),
            setTimeout( () => {
                tn(),
                setTimeout( () => {
                    var yt;
                    (yt = H.current) === null || yt === void 0 || yt.addEventListener("scroll", tn, {
                        once: !0
                    })
                }
                , 200)
            }
            , 1),
            setTimeout( () => tn, 350)
        }
        ;
        return Se?.addEventListener("focus", Nt, {
            capture: !0
        }),
        Se?.addEventListener("blur", ht, {
            capture: !0
        }),
        visualViewport.addEventListener("resize", dt),
        Se?.addEventListener("scroll", tn, {
            once: !0
        }),
        () => {
            Se?.removeEventListener("focus", Nt, {
                capture: !0
            }),
            Se?.removeEventListener("blur", ht, {
                capture: !0
            }),
            visualViewport.removeEventListener("resize", dt),
            Se?.removeEventListener("scroll", tn)
        }
    }
    , [y, u, $e, tn]);
    let s0 = QB(H)
      , $o = h.useMemo( () => l && !re, [re, l])
      , qr = Hn("Scroll", {
        axis: a,
        scrollTrapX: je,
        scrollTrapY: !Ee && St || s0 && !$o,
        scrollGestureOvershoot: f,
        scrollDisabled: te,
        pageScroll: l,
        nativePageScrollReplacement: c,
        overflowX: se,
        overflowY: X,
        skipScrollAnimation: S?.skip,
        scrollAnchoring: C,
        scrollSnapType: P,
        nativeScrollbar: T,
        scrollOngoing: ve
    });
    return g.jsxs(z1.Provider, {
        value: {
            contentRef: ye,
            axis: a,
            styleAttributes: qr,
            nativeFocusScrollPrevention: b,
            swipeTrapIncapable: $o,
            focusable: F,
            pageScroll: l,
            nativePageScrollReplacement: c,
            scrollContainerRef: H,
            swipeTrapObserverRequired: ae,
            startScrollSpyRef: me,
            endScrollSpyRef: ge,
            startSpacerRef: Ie,
            endSpacerRef: be,
            scrollHandler: On,
            scrollPadding: x,
            scrollTimelineName: E
        },
        children: [l && c !== !0 && g.jsx("style", {
            dangerouslySetInnerHTML: {
                __html: `
                            html[data-silk-native-page-scroll-replaced="false"] > body {
                                scroll-padding: ${x};
                                scroll-timeline-axis: ${E} ${a};
                            }
                        `
            }
        }), l && c === !0 && g.jsx("script", {
            id: "silk-scroll-nativePageScrollReplacement-true",
            dangerouslySetInnerHTML: {
                __html: `
                            document.documentElement.setAttribute("data-silk-native-page-scroll-replaced", "true");
                        `
            }
        }), l && c === !1 && g.jsx("script", {
            id: "silk-scroll-nativePageScrollReplacement-false",
            dangerouslySetInnerHTML: {
                __html: `
                            document.documentElement.setAttribute("data-silk-native-page-scroll-replaced", "false");
                        `
            }
        }), l && c === "auto" && g.jsx("script", {
            id: "silk-scroll-nativePageScrollReplacement-auto",
            dangerouslySetInnerHTML: {
                __html: `
                            const standalone =
                                window.matchMedia('(display-mode: standalone)').matches || window.navigator.standalone;
                            const mobile = window.navigator.userAgent?.match(/android|iPhone|iPad/i);

                            document.documentElement.setAttribute("data-standalone", !!standalone);
                            document.documentElement.setAttribute("data-silk-native-page-scroll-replaced", !(mobile && !standalone));
                        `
            }
        }), g.jsx(Tq, {}), g.jsx(L, {
            ...qr("view", ["axis", "pageScroll", "skipScrollAnimation", "scrollOngoing"], {
                className: s,
                dataSilk: [o]
            }),
            ...k,
            ref: B,
            children: r
        })]
    })
}
);
kq.displayName = "Scroll.View";
let iS = Ne.forwardRef( ({side: e, ...t}, n) => {
    let {axis: r} = h.useContext(z1) || {}
      , s = Hn("Scroll", {
        side: e,
        axis: r
    });
    return g.jsx("div", {
        ...s("spy", ["side", "axis"]),
        ref: n,
        ...t
    })
}
);
iS.displayName = "Scroll.Anonymous";
let Oq = Ne.forwardRef( (e, t) => {
    let {asChild: n, className: r, "data-silk": s, ...o} = e
      , i = n ? zn : "div"
      , {contentRef: a, styleAttributes: l, nativeFocusScrollPrevention: c, swipeTrapIncapable: u, focusable: d, axis: f, pageScroll: p, nativePageScrollReplacement: m, scrollContainerRef: v, swipeTrapObserverRequired: _, startScrollSpyRef: y, endScrollSpyRef: b, startSpacerRef: S, endSpacerRef: C, scrollHandler: w, scrollPadding: x, scrollTimelineName: E} = h.useContext(z1) || {}
      , T = jr(a, t);
    return g.jsxs("div", {
        ...l("scrollContainer", ["axis", "pageScroll", "scrollTrapX", "scrollTrapY", "scrollGestureOvershoot", "scrollDisabled", "overflowX", "overflowY", "skipScrollAnimation", "scrollAnchoring", "scrollSnapType", "nativeScrollbar"], {
            dataSilk: [s, "0ad", c && "0ah", u && "0ai"]
        }),
        style: {
            scrollPadding: x,
            scrollTimeline: E + " " + f
        },
        tabIndex: d ? 0 : c ? -1 : void 0,
        role: p && !m ? void 0 : "region",
        onScroll: w,
        ref: v,
        children: [_ && g.jsx(iS, {
            side: "start",
            ref: y
        }), f === "y" && g.jsx("div", {
            ref: S,
            ...l("startSpacer", ["axis", "pageScroll"])
        }), g.jsx(i, {
            ...l("content", ["axis", "scrollTrapX", "scrollTrapY", "overflowX", "overflowY"], {
                className: r,
                dataSilk: [s]
            }),
            ...o,
            ref: T
        }), f === "y" && g.jsx("div", {
            ref: C,
            ...l("endSpacer", ["axis", "pageScroll"])
        }), _ && g.jsx(iS, {
            side: "end",
            ref: b
        })]
    })
}
);
Oq.displayName = "Scroll.Content";
let k0e = Ne.forwardRef( ({asChild: e, ...t}, n) => {
    let r = e ? zn : "button"
      , {forComponent: s, onPress: o, onClick: i, children: a, action: l, ...c} = t
      , {type: u, ...d} = l || {}
      , {scrollTo: f, scrollBy: p} = Eq(s)
      , m = h.useRef(null)
      , v = jr(m, n);
    return g.jsx(r, {
        onClick: _ => {
            var y;
            let {forceFocus: b, runAction: S} = Po({
                nativeEvent: _,
                defaultBehavior: {
                    forceFocus: !0,
                    runAction: !0
                },
                handler: o
            });
            if (b && ((y = m.current) === null || y === void 0 || y.focus({
                preventScroll: !0
            })),
            S) {
                if (u === "scroll-to")
                    return f(d);
                if (u === "scroll-by")
                    return p(d)
            }
            i?.(_)
        }
        ,
        ref: v,
        ...c,
        children: a
    })
}
);
k0e.displayName = "Sheet.Trigger";
let Ub = {
    Root: xq,
    View: kq,
    Content: Oq
}
  , O0e = e => h.useContext(e ?? Oa) || {}
  , Aq = Ne.forwardRef( (e, t) => {
    let {asChild: n, className: r, "data-silk": s, timing: o, forComponent: i, tabIndex: a, ...l} = e
      , c = n ? zn : "div"
      , {sheetId: u} = i ? O0e(i) : {}
      , d = u ?? "any"
      , f = h.useCallback(S => {
        tt.addAutoFocusTarget({
            layerId: d,
            element: S,
            timing: o
        })
    }
    , [d, o])
      , p = h.useCallback(S => {
        tt.removeAutoFocusTarget(S)
    }
    , [])
      , m = h.useRef(null)
      , v = h.useCallback(S => {
        S ? f(S) : p(m.current),
        m.current = S
    }
    , [f, p])
      , _ = h.useRef(!0);
    h.useEffect( () => (m.current && !_.current && f(m.current),
    _.current = !1,
    () => {
        m.current && p(m.current)
    }
    ), [f, p]);
    let y = jr(v, t)
      , b = Hn("AutoFocusTarget", {});
    return g.jsx(c, {
        ...b("root", [], {
            className: r,
            dataSilk: [s]
        }),
        ...n || Number.isInteger(a) ? {} : {
            tabIndex: -1
        },
        ...l,
        ref: y
    })
}
);
Aq.displayName = "AutoFocusTarget.Root";
let A0e = {
    Root: Aq
}
  , M0e = Ne.forwardRef( (e, t) => {
    let {asChild: n, disabled: r=!1, children: s, contentGetter: o, forComponent: i, ...a} = e
      , l = h.useRef(null)
      , c = jr(l, t)
      , u = h.useMemo( () => !!s, [s]);
    return h.useEffect( () => {
        let d, f;
        if (!r) {
            let p, m = !1;
            if (u && l.current ? p = l.current : o && (p = ag(o)) && (m = !0),
            p) {
                let v = Array.isArray(i) ? i : i ? [i] : [];
                d = tt.addIsland({
                    componentId: v,
                    element: p
                }),
                m && (f = new MutationObserver( () => {
                    ag(o) || (tt.removeIsland(d),
                    f.disconnect())
                }
                )).observe(p.parentElement, {
                    childList: !0
                })
            }
        }
        return () => {
            r || (tt.removeIsland(d),
            f?.disconnect())
        }
    }
    , [t, r, u, o, i]),
    s ? g.jsx(pi.Root, {
        active: !r,
        asChild: n,
        "data-silk": "0ag",
        ...a,
        ref: c,
        children: s
    }) : null
}
);
M0e.displayName = "Island.Root";
let I0e = Ne.forwardRef( (e, t) => {
    let {asChild: n, children: r, ...s} = e;
    return g.jsx(pi.Stabiliser, {
        asChild: n,
        ...s,
        ref: t,
        children: r
    })
}
);
I0e.displayName = "Island.Content";
let R0e = Ne.forwardRef( ({asChild: e, children: t, contentGetter: n, disabled: r=!1, selfManagedInertOutside: s=!0, ...o}, i) => {
    let a = Hl()
      , l = h.useRef(null)
      , c = jr(l, i)
      , u = e ? zn : "div"
      , d = h.useMemo( () => !!t, [t]);
    return En( () => {
        let f;
        if (!r && a) {
            let p, m = !1;
            d && l.current ? p = l.current : n && (p = ag(n)) && (m = !0),
            p && (tt.updateLayer({
                external: !0,
                layerId: a,
                viewElement: p,
                inertOutside: s,
                onPresentAutoFocus: {
                    focus: !1
                },
                onDismissAutoFocus: {
                    focus: !1
                },
                defaultClickOutsideAction: () => {}
                ,
                defaultEscapeKeyDownAction: () => {}
            }),
            m && (f = new MutationObserver( () => {
                ag(n) || (tt.removeLayer(a),
                f.disconnect())
            }
            )).observe(p.parentElement, {
                childList: !0
            }))
        }
        return () => {
            !r && a && (tt.removeLayer(a),
            f?.disconnect())
        }
    }
    , [d, n, r, a, s]),
    g.jsx(u, {
        ref: c,
        ...o,
        children: t
    })
}
);
R0e.displayName = "ExternalOverlay.Root";
const Mq = en( () => ({
    anySheetOpen$: Ct(!1)
}));
function N0e(e) {
    "use forget";
    const t = De.c(12);
    let n, r;
    t[0] !== e ? ({children: n, ...r} = e,
    t[0] = e,
    t[1] = n,
    t[2] = r) : (n = t[1],
    r = t[2]);
    const s = ue();
    let o;
    t[3] !== s ? (o = Mq(s),
    t[3] = s,
    t[4] = o) : o = t[4];
    const i = o;
    let a;
    t[5] !== r || t[6] !== i.anySheetOpen$ ? (a = c => {
        i.anySheetOpen$.set(c),
        r.onPresentedChange?.(c)
    }
    ,
    t[5] = r,
    t[6] = i.anySheetOpen$,
    t[7] = a) : a = t[7];
    let l;
    return t[8] !== n || t[9] !== r || t[10] !== a ? (l = g.jsx(la.Root, {
        license: "commercial",
        "data-content-sheet-root": !0,
        ...r,
        onPresentedChange: a,
        children: n
    }),
    t[8] = n,
    t[9] = r,
    t[10] = a,
    t[11] = l) : l = t[11],
    l
}
function P0e(e) {
    "use forget";
    const t = De.c(23);
    let n, r, s, o, i;
    t[0] !== e ? ({children: n, className: r, onTravel: o, onCloseComplete: s, ...i} = e,
    t[0] = e,
    t[1] = n,
    t[2] = r,
    t[3] = s,
    t[4] = o,
    t[5] = i) : (n = t[1],
    r = t[2],
    s = t[3],
    o = t[4],
    i = t[5]);
    const a = h.useRef(null)
      , l = f1()
      , c = l ? "center" : "bottom"
      , [u,d] = h.useState(null)
      , f = ue();
    let p;
    t[6] !== f ? (p = Mq(f),
    t[6] = f,
    t[7] = p) : p = t[7];
    const m = p;
    let v;
    t[8] !== s || t[9] !== o || t[10] !== m ? (v = w => {
        const {progress: x, ...E} = w;
        if (!a.current)
            return o?.({
                progress: x,
                ...E
            });
        x < .999 ? d(null) : x === 0 ? (m.anySheetOpen$.set(!1),
        s?.()) : (m.anySheetOpen$.set(!0),
        d("opened")),
        o?.({
            progress: x,
            ...E
        })
    }
    ,
    t[8] = s,
    t[9] = o,
    t[10] = m,
    t[11] = v) : v = t[11];
    const _ = v
      , y = `view-${l}`;
    let b;
    t[12] !== r ? (b = we("top-0 bottom-[initial] h-[max(100dvh,100%)] [--sheet-radius:16px] sm:h-full", r),
    t[12] = r,
    t[13] = b) : b = t[13];
    let S;
    t[14] === Symbol.for("react.memo_cache_sentinel") ? (S = {
        focus: !1
    },
    t[14] = S) : S = t[14];
    let C;
    return t[15] !== n || t[16] !== c || t[17] !== i || t[18] !== y || t[19] !== b || t[20] !== _ || t[21] !== u ? (C = g.jsx(la.View, {
        className: b,
        "data-sheet-travel-state": u,
        "data-ignore-for-page-load": !0,
        contentPlacement: c,
        tracks: "bottom",
        swipeOvershoot: !1,
        nativeEdgeSwipePrevention: !1,
        onTravel: _,
        onDismissAutoFocus: S,
        ref: a,
        ...i,
        children: n
    }, y),
    t[15] = n,
    t[16] = c,
    t[17] = i,
    t[18] = y,
    t[19] = b,
    t[20] = _,
    t[21] = u,
    t[22] = C) : C = t[22],
    C
}
function D0e(e) {
    "use forget";
    const t = De.c(2)
      , n = h.useRef(null);
    let r;
    return t[0] !== e ? (r = g.jsx(la.Backdrop, {
        ref: n,
        ...e
    }),
    t[0] = e,
    t[1] = r) : r = t[1],
    r
}
function L0e(e) {
    "use forget";
    const t = De.c(15);
    let n, r, s, o, i;
    t[0] !== e ? ({children: n, size: i, className: r, ref: s, ...o} = e,
    t[0] = e,
    t[1] = n,
    t[2] = r,
    t[3] = s,
    t[4] = o,
    t[5] = i) : (n = t[1],
    r = t[2],
    s = t[3],
    o = t[4],
    i = t[5]);
    const a = i === void 0 ? "fill" : i
      , l = a === "fit" && "h-min max-h-[calc(100%-max(env(safe-area-inset-top),6px))]"
      , c = a === "fill" && "h-[calc(100%-max(env(safe-area-inset-top),6px))] sm:h-[calc(100%-4rem)]";
    let u;
    t[6] !== r || t[7] !== l || t[8] !== c ? (u = we("max-w-md [border-radius:var(--sheet-radius)_var(--sheet-radius)_0_0] pb-4 focus:outline-hidden sm:w-[calc(800px-1.25rem)] sm:[border-radius:var(--sheet-radius)]", l, c, r),
    t[6] = r,
    t[7] = l,
    t[8] = c,
    t[9] = u) : u = t[9];
    let d;
    return t[10] !== n || t[11] !== s || t[12] !== o || t[13] !== u ? (d = g.jsx(la.Content, {
        className: u,
        ...o,
        ref: s,
        children: n
    }),
    t[10] = n,
    t[11] = s,
    t[12] = o,
    t[13] = u,
    t[14] = d) : d = t[14],
    d
}
const mi = {
    Root: N0e,
    Portal: la.Portal,
    View: P0e,
    Backdrop: D0e,
    Content: L0e,
    Trigger: la.Trigger,
    Handle: la.Handle,
    Title: la.Title
};
function F0e({children: e, className: t, ...n}) {
    return g.jsx(Ub.Root, {
        asChild: !0,
        children: g.jsx(Ub.View, {
            className: we("min-h-0", t),
            safeArea: "visual-viewport",
            scrollTimelineName: "--sheet-scroller",
            ...n,
            children: g.jsx(Ub.Content, {
                className: "align-content-start grid",
                tabIndex: -1,
                children: e
            })
        })
    })
}
function j0e({className: e, children: t, handle: n="auto", ...r}) {
    const s = f1()
      , o = n === "auto" ? !s : n;
    return g.jsxs(mi.Content, {
        className: we("bg-token-bg-primary content-sheet popup shadow-long @container/sheet-content grid [--padding:1rem]", o ? "grid-rows-[min-content_min-content_1fr_min-content]" : "grid-rows-[min-content_1fr_min-content]", e),
        ...r,
        children: [o && g.jsx(A0e.Root, {
            timing: "present",
            className: "flex justify-center focus-visible:outline-none",
            children: g.jsx(U0e, {})
        }), t]
    })
}
function U0e(e) {
    "use forget";
    const t = De.c(8);
    let n, r;
    t[0] !== e ? ({className: n, ...r} = e,
    t[0] = e,
    t[1] = n,
    t[2] = r) : (n = t[1],
    r = t[2]);
    let s;
    t[3] !== n ? (s = we("bg-token-bg-secondary! dark:bg-token-bg-tertiary! col-start-1 col-end-[-1] mt-1.5 h-1 self-start justify-self-center rounded-full select-none", n),
    t[3] = n,
    t[4] = s) : s = t[4];
    let o;
    return t[5] !== r || t[6] !== s ? (o = g.jsx(mi.Handle, {
        className: s,
        ...r
    }),
    t[5] = r,
    t[6] = s,
    t[7] = o) : o = t[7],
    o
}
function B0e(e) {
    "use forget";
    const t = De.c(9);
    let n, r;
    t[0] !== e ? ({children: n, ...r} = e,
    t[0] = e,
    t[1] = n,
    t[2] = r) : (n = t[1],
    r = t[2]);
    let s;
    t[3] !== r.className ? (s = we("min-h-header-height relative grid grid-cols-[1fr_min-content] items-center justify-between gap-3 py-2.5 ps-4 pe-2 select-none", r.className),
    t[3] = r.className,
    t[4] = s) : s = t[4];
    let o;
    return t[5] !== n || t[6] !== r || t[7] !== s ? (o = g.jsx("header", {
        ...r,
        className: s,
        children: n
    }),
    t[5] = n,
    t[6] = r,
    t[7] = s,
    t[8] = o) : o = t[8],
    o
}
function q0e(e) {
    "use forget";
    const t = De.c(5);
    let n;
    t[0] !== e.className ? (n = we("text-token-text-primary m-0 w-full min-w-0 overflow-hidden text-lg font-normal overflow-ellipsis whitespace-nowrap [text-box-trim:trim-both]", e.className),
    t[0] = e.className,
    t[1] = n) : n = t[1];
    let r;
    return t[2] !== e || t[3] !== n ? (r = g.jsx(mi.Title, {
        ...e,
        className: n
    }),
    t[2] = e,
    t[3] = n,
    t[4] = r) : r = t[4],
    r
}
function G0e(e) {
    "use forget";
    const t = De.c(5);
    let n;
    t[0] !== e.className ? (n = we("z-10 grid grid-flow-col justify-end gap-3 px-[var(--padding)] pt-4", e.className),
    t[0] = e.className,
    t[1] = n) : n = t[1];
    let r;
    return t[2] !== e || t[3] !== n ? (r = g.jsx("footer", {
        ...e,
        className: n
    }),
    t[2] = e,
    t[3] = n,
    t[4] = r) : r = t[4],
    r
}
const V0e = c1e(an, e => g.jsx(mi.Trigger, {
    action: "dismiss",
    asChild: !0,
    children: e
}));
function H0e(e) {
    "use forget";
    const t = De.c(12);
    let n, r, s, o;
    t[0] !== e ? ({fullBleed: s, className: r, children: n, ...o} = e,
    t[0] = e,
    t[1] = n,
    t[2] = r,
    t[3] = s,
    t[4] = o) : (n = t[1],
    r = t[2],
    s = t[3],
    o = t[4]);
    const i = !s && "px-(--thread-content-margin)";
    let a;
    t[5] !== r || t[6] !== i ? (a = we(i, r),
    t[5] = r,
    t[6] = i,
    t[7] = a) : a = t[7];
    let l;
    return t[8] !== n || t[9] !== o || t[10] !== a ? (l = g.jsx("section", {
        "data-content-sheet-section": !0,
        className: a,
        ...o,
        children: n
    }),
    t[8] = n,
    t[9] = o,
    t[10] = a,
    t[11] = l) : l = t[11],
    l
}
function z0e(e) {
    "use forget";
    const t = De.c(9);
    let n, r;
    t[0] !== e ? ({children: n, ...r} = e,
    t[0] = e,
    t[1] = n,
    t[2] = r) : (n = t[1],
    r = t[2]);
    const s = f1()
      , i = ine() || s;
    let a;
    t[3] !== i ? (a = {
        preset: "snappy",
        skip: i
    },
    t[3] = i,
    t[4] = a) : a = t[4];
    const l = a;
    let c;
    return t[5] !== l || t[6] !== n || t[7] !== r ? (c = g.jsx(mi.View, {
        enteringAnimationSettings: l,
        exitingAnimationSettings: l,
        ...r,
        children: n
    }),
    t[5] = l,
    t[6] = n,
    t[7] = r,
    t[8] = c) : c = t[8],
    c
}
function $0e(e) {
    "use forget";
    const t = De.c(9);
    let n, r;
    t[0] !== e ? ({className: n, ...r} = e,
    t[0] = e,
    t[1] = n,
    t[2] = r) : (n = t[1],
    r = t[2]);
    const o = f1() && "before:starting:backdrop-blur-0 fixed inset-0 z-50 bg-transparent opacity-100! before:absolute before:inset-0 before:bg-gray-200/50 before:backdrop-blur-[1px] before:transition before:duration-250 before:starting:opacity-0";
    let i;
    t[3] !== n || t[4] !== o ? (i = we(o, n),
    t[3] = n,
    t[4] = o,
    t[5] = i) : i = t[5];
    let a;
    return t[6] !== r || t[7] !== i ? (a = g.jsx(mi.Backdrop, {
        themeColorDimming: !1,
        className: i,
        ...r
    }),
    t[6] = r,
    t[7] = i,
    t[8] = a) : a = t[8],
    a
}
const To = {
    Root: mi.Root,
    Trigger: mi.Trigger,
    Portal: mi.Portal,
    View: z0e,
    Backdrop: $0e,
    Content: j0e,
    HeaderBar: B0e,
    Title: q0e,
    FooterBar: G0e,
    DismissAction: V0e,
    ScrollRoot: F0e,
    ContentSection: H0e
}
  , W0e = e => h.createElement("svg", {
    width: 20,
    height: 20,
    viewBox: "0 0 20 20",
    fill: "currentColor",
    xmlns: "http://www.w3.org/2000/svg",
    ...e
}, h.createElement("path", {
    fillRule: "evenodd",
    clipRule: "evenodd",
    d: "M10.667 2.08496C15.0382 2.08509 18.582 5.62875 18.582 10C18.582 14.3713 15.0382 17.9149 10.667 17.915C6.29566 17.915 2.75195 14.3713 2.75195 10C2.75195 5.62867 6.29566 2.08496 10.667 2.08496ZM13.7588 6.74805C13.4585 6.53673 13.0434 6.60897 12.832 6.90918L9.35059 11.8545L7.82617 10.1777L7.72559 10.0879C7.47599 9.90563 7.12443 9.91699 6.88672 10.1328C6.64884 10.3491 6.60354 10.6989 6.76172 10.9648L6.8418 11.0723L8.9248 13.3643L8.97852 13.417C9.10977 13.532 9.28278 13.592 9.45898 13.5811C9.66011 13.5683 9.84489 13.4646 9.96094 13.2998L13.9199 7.6748C14.131 7.37468 14.0586 6.95952 13.7588 6.74805Z"
}))
  , g4 = e => h.createElement("svg", {
    width: 16,
    height: 16,
    viewBox: "0 0 16 16",
    fill: "currentColor",
    xmlns: "http://www.w3.org/2000/svg",
    ...e
}, h.createElement("path", {
    d: "M12.0961 2.91371C12.3297 2.68688 12.6984 2.64794 12.9779 2.83852C13.2571 3.02905 13.3554 3.38601 13.2299 3.68618L13.1615 3.81118L6.91152 12.9772C6.79412 13.1494 6.60631 13.2604 6.39882 13.2799C6.19137 13.2994 5.98565 13.226 5.83828 13.0788L2.08828 9.32875L1.99843 9.2184C1.81921 8.94677 1.84928 8.57767 2.08828 8.33852C2.3274 8.0994 2.69648 8.06947 2.96816 8.24868L3.07851 8.33852L6.23085 11.4909L12.0053 3.02211L12.0961 2.91371Z"
}))
  , K0e = e => h.createElement("svg", {
    width: 20,
    height: 20,
    viewBox: "0 0 20 20",
    fill: "currentColor",
    xmlns: "http://www.w3.org/2000/svg",
    ...e
}, h.createElement("path", {
    fillRule: "evenodd",
    clipRule: "evenodd",
    d: "M10 2.08496C14.3713 2.08496 17.915 5.62867 17.915 10C17.915 14.3713 14.3713 17.915 10 17.915C5.62867 17.915 2.08496 14.3713 2.08496 10C2.08496 5.62867 5.62867 2.08496 10 2.08496ZM10 3.41504C6.3632 3.41504 3.41504 6.3632 3.41504 10C3.41504 13.6368 6.3632 16.585 10 16.585C13.6368 16.585 16.585 13.6368 16.585 10C16.585 6.3632 13.6368 3.41504 10 3.41504Z"
}))
  , Y0e = {
    threshold: 1,
    rootMargin: "0%"
};
function Z0e({target: e, onChange: t, options: n=Y0e}) {
    if (!e)
        return;
    const r = new IntersectionObserver(o => {
        const i = Array.isArray(r.thresholds) ? r.thresholds : [r.thresholds];
        o.forEach(a => {
            const l = a.isIntersecting && i.some(c => a.intersectionRatio >= c);
            t(l, a)
        }
        )
    }
    ,n);
    function s() {
        r.disconnect()
    }
    return r.observe(e),
    s
}
function J0e({setIsScrolledToEdge: e, className: t, options: n}) {
    return g.jsx("div", {
        "aria-hidden": !0,
        "data-edge": !0,
        className: we("pointer-events-none h-px w-px", t),
        ref: r => Z0e({
            target: r,
            onChange: s => e(!s),
            options: n
        })
    })
}
const X0e = ({isOpen: e, onClose: t}) => {
    const n = h.useRef(null)
      , r = n.current?.ownerDocument.body ?? null;
    return h.useEffect( () => {
        if (!r || !e)
            return;
        const s = o => {
            (!o.relatedTarget || o.relatedTarget instanceof HTMLElement && !r.contains(o.relatedTarget)) && t()
        }
        ;
        return r.addEventListener("blur", s, {
            capture: !0
        }),
        () => r.removeEventListener("blur", s, {
            capture: !0
        })
    }
    , [e, r]),
    {
        triggerRef: n,
        container: r
    }
}
;
var Q0e = function(e) {
    if (typeof document > "u")
        return null;
    var t = Array.isArray(e) ? e[0] : e;
    return t.ownerDocument.body
}
  , Pc = new WeakMap
  , xp = new WeakMap
  , Tp = {}
  , Bb = 0
  , Iq = function(e) {
    return e && (e.host || Iq(e.parentNode))
}
  , eve = function(e, t) {
    return t.map(function(n) {
        if (e.contains(n))
            return n;
        var r = Iq(n);
        return r && e.contains(r) ? r : (console.error("aria-hidden", n, "in not contained inside", e, ". Doing nothing"),
        null)
    }).filter(function(n) {
        return !!n
    })
}
  , tve = function(e, t, n, r) {
    var s = eve(t, Array.isArray(e) ? e : [e]);
    Tp[n] || (Tp[n] = new WeakMap);
    var o = Tp[n]
      , i = []
      , a = new Set
      , l = new Set(s)
      , c = function(d) {
        !d || a.has(d) || (a.add(d),
        c(d.parentNode))
    };
    s.forEach(c);
    var u = function(d) {
        !d || l.has(d) || Array.prototype.forEach.call(d.children, function(f) {
            if (a.has(f))
                u(f);
            else
                try {
                    var p = f.getAttribute(r)
                      , m = p !== null && p !== "false"
                      , v = (Pc.get(f) || 0) + 1
                      , _ = (o.get(f) || 0) + 1;
                    Pc.set(f, v),
                    o.set(f, _),
                    i.push(f),
                    v === 1 && m && xp.set(f, !0),
                    _ === 1 && f.setAttribute(n, "true"),
                    m || f.setAttribute(r, "true")
                } catch (y) {
                    console.error("aria-hidden: cannot operate on ", f, y)
                }
        })
    };
    return u(t),
    a.clear(),
    Bb++,
    function() {
        i.forEach(function(d) {
            var f = Pc.get(d) - 1
              , p = o.get(d) - 1;
            Pc.set(d, f),
            o.set(d, p),
            f || (xp.has(d) || d.removeAttribute(r),
            xp.delete(d)),
            p || d.removeAttribute(n)
        }),
        Bb--,
        Bb || (Pc = new WeakMap,
        Pc = new WeakMap,
        xp = new WeakMap,
        Tp = {})
    }
}
  , nve = function(e, t, n) {
    n === void 0 && (n = "data-aria-hidden");
    var r = Array.from(Array.isArray(e) ? e : [e])
      , s = Q0e(e);
    return s ? (r.push.apply(r, Array.from(s.querySelectorAll("[aria-live], script"))),
    tve(r, s, n, "aria-hidden")) : function() {
        return null
    }
}
  , aS = ["Enter", " "]
  , rve = ["ArrowDown", "PageUp", "Home"]
  , Rq = ["ArrowUp", "PageDown", "End"]
  , sve = [...rve, ...Rq]
  , ove = {
    ltr: [...aS, "ArrowRight"],
    rtl: [...aS, "ArrowLeft"]
}
  , ive = {
    ltr: ["ArrowLeft"],
    rtl: ["ArrowRight"]
}
  , Sh = "Menu"
  , [Pf,ave,lve] = yF(Sh)
  , [oc,Nq] = $u(Sh, [lve, T1, S1])
  , wh = T1()
  , Pq = S1()
  , [Dq,qa] = oc(Sh)
  , [cve,Eh] = oc(Sh)
  , Lq = e => {
    const {__scopeMenu: t, open: n=!1, children: r, dir: s, onOpenChange: o, modal: i=!0} = e
      , a = wh(t)
      , [l,c] = h.useState(null)
      , u = h.useRef(!1)
      , d = xs(o)
      , f = _w(s);
    return h.useEffect( () => {
        const p = () => {
            u.current = !0,
            document.addEventListener("pointerdown", m, {
                capture: !0,
                once: !0
            }),
            document.addEventListener("pointermove", m, {
                capture: !0,
                once: !0
            })
        }
          , m = () => u.current = !1;
        return document.addEventListener("keydown", p, {
            capture: !0
        }),
        () => {
            document.removeEventListener("keydown", p, {
                capture: !0
            }),
            document.removeEventListener("pointerdown", m, {
                capture: !0
            }),
            document.removeEventListener("pointermove", m, {
                capture: !0
            })
        }
    }
    , []),
    g.jsx(Mw, {
        ...a,
        children: g.jsx(Dq, {
            scope: t,
            open: n,
            onOpenChange: d,
            content: l,
            onContentChange: c,
            children: g.jsx(cve, {
                scope: t,
                onClose: h.useCallback( () => d(!1), [d]),
                isUsingKeyboardRef: u,
                dir: f,
                modal: i,
                children: r
            })
        })
    })
}
;
Lq.displayName = Sh;
var uve = "MenuAnchor"
  , v4 = h.forwardRef( (e, t) => {
    const {__scopeMenu: n, ...r} = e
      , s = wh(n);
    return g.jsx(cj, {
        ...s,
        ...r,
        ref: t
    })
}
);
v4.displayName = uve;
var _4 = "MenuPortal"
  , [dve,Fq] = oc(_4, {
    forceMount: void 0
})
  , jq = e => {
    const {__scopeMenu: t, forceMount: n, children: r, container: s} = e
      , o = qa(_4, t);
    return g.jsx(dve, {
        scope: t,
        forceMount: n,
        children: g.jsx(co, {
            present: n || o.open,
            children: g.jsx(rh, {
                asChild: !0,
                container: s,
                children: r
            })
        })
    })
}
;
jq.displayName = _4;
var ws = "MenuContent"
  , [fve,y4] = oc(ws)
  , Uq = h.forwardRef( (e, t) => {
    const n = Fq(ws, e.__scopeMenu)
      , {forceMount: r=n.forceMount, ...s} = e
      , o = qa(ws, e.__scopeMenu)
      , i = Eh(ws, e.__scopeMenu);
    return g.jsx(Pf.Provider, {
        scope: e.__scopeMenu,
        children: g.jsx(co, {
            present: r || o.open,
            children: g.jsx(Pf.Slot, {
                scope: e.__scopeMenu,
                children: i.modal ? g.jsx(hve, {
                    ...s,
                    ref: t
                }) : g.jsx(pve, {
                    ...s,
                    ref: t
                })
            })
        })
    })
}
)
  , hve = h.forwardRef( (e, t) => {
    const n = qa(ws, e.__scopeMenu)
      , r = h.useRef(null)
      , s = xn(t, r);
    return h.useEffect( () => {
        const o = r.current;
        if (o)
            return nve(o)
    }
    , []),
    g.jsx(b4, {
        ...e,
        ref: s,
        trapFocus: n.open,
        disableOutsidePointerEvents: n.open,
        disableOutsideScroll: !0,
        onFocusOutside: Qe(e.onFocusOutside, o => o.preventDefault(), {
            checkForDefaultPrevented: !1
        }),
        onDismiss: () => n.onOpenChange(!1)
    })
}
)
  , pve = h.forwardRef( (e, t) => {
    const n = qa(ws, e.__scopeMenu);
    return g.jsx(b4, {
        ...e,
        ref: t,
        trapFocus: !1,
        disableOutsidePointerEvents: !1,
        disableOutsideScroll: !1,
        onDismiss: () => n.onOpenChange(!1)
    })
}
)
  , b4 = h.forwardRef( (e, t) => {
    const {__scopeMenu: n, loop: r=!1, trapFocus: s, onOpenAutoFocus: o, onCloseAutoFocus: i, disableOutsidePointerEvents: a, onEntryFocus: l, onEscapeKeyDown: c, onPointerDownOutside: u, onFocusOutside: d, onInteractOutside: f, onDismiss: p, disableOutsideScroll: m, ...v} = e
      , _ = qa(ws, n)
      , y = Eh(ws, n)
      , b = wh(n)
      , S = Pq(n)
      , C = ave(n)
      , [w,x] = h.useState(null)
      , E = h.useRef(null)
      , T = xn(t, E, _.onContentChange)
      , k = h.useRef(0)
      , A = h.useRef("")
      , O = h.useRef(0)
      , M = h.useRef(null)
      , I = h.useRef("right")
      , R = h.useRef(0)
      , D = m ? u6 : h.Fragment
      , P = m ? {
        as: xu,
        allowPinchZoom: !0
    } : void 0
      , L = B => {
        const H = A.current + B
          , ye = C().filter(Z => !Z.disabled)
          , Ie = document.activeElement
          , be = ye.find(Z => Z.ref.current === Ie)?.textValue
          , me = ye.map(Z => Z.textValue)
          , ge = Tve(me, H, be)
          , ce = ye.find(Z => Z.textValue === ge)?.ref.current;
        (function Z(ne) {
            A.current = ne,
            window.clearTimeout(k.current),
            ne !== "" && (k.current = window.setTimeout( () => Z(""), 1e3))
        }
        )(H),
        ce && setTimeout( () => ce.focus())
    }
    ;
    h.useEffect( () => () => window.clearTimeout(k.current), []),
    uD();
    const N = h.useCallback(B => I.current === M.current?.side && Ove(B, M.current?.area), []);
    return g.jsx(fve, {
        scope: n,
        searchRef: A,
        onItemEnter: h.useCallback(B => {
            N(B) && B.preventDefault()
        }
        , [N]),
        onItemLeave: h.useCallback(B => {
            N(B) || (E.current?.focus(),
            x(null))
        }
        , [N]),
        onTriggerLeave: h.useCallback(B => {
            N(B) && B.preventDefault()
        }
        , [N]),
        pointerGraceTimerRef: O,
        onPointerGraceIntentChange: h.useCallback(B => {
            M.current = B
        }
        , []),
        children: g.jsx(D, {
            ...P,
            children: g.jsx(c6, {
                asChild: !0,
                trapped: s,
                onMountAutoFocus: Qe(o, B => {
                    B.preventDefault(),
                    E.current?.focus({
                        preventScroll: !0
                    })
                }
                ),
                onUnmountAutoFocus: i,
                children: g.jsx(nh, {
                    asChild: !0,
                    disableOutsidePointerEvents: a,
                    onEscapeKeyDown: c,
                    onPointerDownOutside: u,
                    onFocusOutside: d,
                    onInteractOutside: f,
                    onDismiss: p,
                    children: g.jsx(TF, {
                        asChild: !0,
                        ...S,
                        dir: y.dir,
                        orientation: "vertical",
                        loop: r,
                        currentTabStopId: w,
                        onCurrentTabStopIdChange: x,
                        onEntryFocus: Qe(l, B => {
                            y.isUsingKeyboardRef.current || B.preventDefault()
                        }
                        ),
                        preventScrollOnEntryFocus: !0,
                        children: g.jsx(uj, {
                            role: "menu",
                            "aria-orientation": "vertical",
                            "data-state": nG(_.open),
                            "data-radix-menu-content": "",
                            dir: y.dir,
                            ...b,
                            ...v,
                            ref: T,
                            style: {
                                outline: "none",
                                ...v.style
                            },
                            onKeyDown: Qe(v.onKeyDown, B => {
                                const ye = B.target.closest("[data-radix-menu-content]") === B.currentTarget
                                  , Ie = B.ctrlKey || B.altKey || B.metaKey
                                  , be = B.key.length === 1;
                                ye && (B.key === "Tab" && B.preventDefault(),
                                !Ie && be && L(B.key));
                                const me = E.current;
                                if (B.target !== me || !sve.includes(B.key))
                                    return;
                                B.preventDefault();
                                const ce = C().filter(Z => !Z.disabled).map(Z => Z.ref.current);
                                Rq.includes(B.key) && ce.reverse(),
                                Eve(ce)
                            }
                            ),
                            onBlur: Qe(e.onBlur, B => {
                                B.currentTarget.contains(B.target) || (window.clearTimeout(k.current),
                                A.current = "")
                            }
                            ),
                            onPointerMove: Qe(e.onPointerMove, Df(B => {
                                const H = B.target
                                  , ye = R.current !== B.clientX;
                                if (B.currentTarget.contains(H) && ye) {
                                    const Ie = B.clientX > R.current ? "right" : "left";
                                    I.current = Ie,
                                    R.current = B.clientX
                                }
                            }
                            ))
                        })
                    })
                })
            })
        })
    })
}
);
Uq.displayName = ws;
var mve = "MenuGroup"
  , C4 = h.forwardRef( (e, t) => {
    const {__scopeMenu: n, ...r} = e;
    return g.jsx(Vt.div, {
        role: "group",
        ...r,
        ref: t
    })
}
);
C4.displayName = mve;
var gve = "MenuLabel"
  , Bq = h.forwardRef( (e, t) => {
    const {__scopeMenu: n, ...r} = e;
    return g.jsx(Vt.div, {
        ...r,
        ref: t
    })
}
);
Bq.displayName = gve;
var ug = "MenuItem"
  , sA = "menu.itemSelect"
  , $1 = h.forwardRef( (e, t) => {
    const {disabled: n=!1, onSelect: r, ...s} = e
      , o = h.useRef(null)
      , i = Eh(ug, e.__scopeMenu)
      , a = y4(ug, e.__scopeMenu)
      , l = xn(t, o)
      , c = h.useRef(!1)
      , u = () => {
        const d = o.current;
        if (!n && d) {
            const f = new CustomEvent(sA,{
                bubbles: !0,
                cancelable: !0
            });
            d.addEventListener(sA, p => r?.(p), {
                once: !0
            }),
            oD(d, f),
            f.defaultPrevented ? c.current = !1 : i.onClose()
        }
    }
    ;
    return g.jsx(qq, {
        ...s,
        ref: l,
        disabled: n,
        onClick: Qe(e.onClick, u),
        onPointerDown: d => {
            e.onPointerDown?.(d),
            c.current = !0
        }
        ,
        onPointerUp: Qe(e.onPointerUp, d => {
            c.current || d.currentTarget?.click()
        }
        ),
        onKeyDown: Qe(e.onKeyDown, d => {
            const f = a.searchRef.current !== "";
            n || f && d.key === " " || aS.includes(d.key) && (d.currentTarget.click(),
            d.preventDefault())
        }
        )
    })
}
);
$1.displayName = ug;
var qq = h.forwardRef( (e, t) => {
    const {__scopeMenu: n, disabled: r=!1, textValue: s, ...o} = e
      , i = y4(ug, n)
      , a = Pq(n)
      , l = h.useRef(null)
      , c = xn(t, l)
      , [u,d] = h.useState(!1)
      , [f,p] = h.useState("");
    return h.useEffect( () => {
        const m = l.current;
        m && p((m.textContent ?? "").trim())
    }
    , [o.children]),
    g.jsx(Pf.ItemSlot, {
        scope: n,
        disabled: r,
        textValue: s ?? f,
        children: g.jsx(kF, {
            asChild: !0,
            ...a,
            focusable: !r,
            children: g.jsx(Vt.div, {
                role: "menuitem",
                "data-highlighted": u ? "" : void 0,
                "aria-disabled": r || void 0,
                "data-disabled": r ? "" : void 0,
                ...o,
                ref: c,
                onPointerMove: Qe(e.onPointerMove, Df(m => {
                    r ? i.onItemLeave(m) : (i.onItemEnter(m),
                    m.defaultPrevented || m.currentTarget.focus({
                        preventScroll: !0
                    }))
                }
                )),
                onPointerLeave: Qe(e.onPointerLeave, Df(m => i.onItemLeave(m))),
                onFocus: Qe(e.onFocus, () => d(!0)),
                onBlur: Qe(e.onBlur, () => d(!1))
            })
        })
    })
}
)
  , vve = "MenuCheckboxItem"
  , Gq = h.forwardRef( (e, t) => {
    const {checked: n=!1, onCheckedChange: r, ...s} = e;
    return g.jsx(Wq, {
        scope: e.__scopeMenu,
        checked: n,
        children: g.jsx($1, {
            role: "menuitemcheckbox",
            "aria-checked": dg(n) ? "mixed" : n,
            ...s,
            ref: t,
            "data-state": E4(n),
            onSelect: Qe(s.onSelect, () => r?.(dg(n) ? !0 : !n), {
                checkForDefaultPrevented: !1
            })
        })
    })
}
);
Gq.displayName = vve;
var Vq = "MenuRadioGroup"
  , [_ve,yve] = oc(Vq, {
    value: void 0,
    onValueChange: () => {}
})
  , Hq = h.forwardRef( (e, t) => {
    const {value: n, onValueChange: r, ...s} = e
      , o = xs(r);
    return g.jsx(_ve, {
        scope: e.__scopeMenu,
        value: n,
        onValueChange: o,
        children: g.jsx(C4, {
            ...s,
            ref: t
        })
    })
}
);
Hq.displayName = Vq;
var zq = "MenuRadioItem"
  , $q = h.forwardRef( (e, t) => {
    const {value: n, ...r} = e
      , s = yve(zq, e.__scopeMenu)
      , o = n === s.value;
    return g.jsx(Wq, {
        scope: e.__scopeMenu,
        checked: o,
        children: g.jsx($1, {
            role: "menuitemradio",
            "aria-checked": o,
            ...r,
            ref: t,
            "data-state": E4(o),
            onSelect: Qe(r.onSelect, () => s.onValueChange?.(n), {
                checkForDefaultPrevented: !1
            })
        })
    })
}
);
$q.displayName = zq;
var S4 = "MenuItemIndicator"
  , [Wq,bve] = oc(S4, {
    checked: !1
})
  , Kq = h.forwardRef( (e, t) => {
    const {__scopeMenu: n, forceMount: r, ...s} = e
      , o = bve(S4, n);
    return g.jsx(co, {
        present: r || dg(o.checked) || o.checked === !0,
        children: g.jsx(Vt.span, {
            ...s,
            ref: t,
            "data-state": E4(o.checked)
        })
    })
}
);
Kq.displayName = S4;
var Cve = "MenuSeparator"
  , Yq = h.forwardRef( (e, t) => {
    const {__scopeMenu: n, ...r} = e;
    return g.jsx(Vt.div, {
        role: "separator",
        "aria-orientation": "horizontal",
        ...r,
        ref: t
    })
}
);
Yq.displayName = Cve;
var Sve = "MenuArrow"
  , Zq = h.forwardRef( (e, t) => {
    const {__scopeMenu: n, ...r} = e
      , s = wh(n);
    return g.jsx(dj, {
        ...s,
        ...r,
        ref: t
    })
}
);
Zq.displayName = Sve;
var w4 = "MenuSub"
  , [wve,Jq] = oc(w4)
  , Xq = e => {
    const {__scopeMenu: t, children: n, open: r=!1, onOpenChange: s} = e
      , o = qa(w4, t)
      , i = wh(t)
      , [a,l] = h.useState(null)
      , [c,u] = h.useState(null)
      , d = xs(s);
    return h.useEffect( () => (o.open === !1 && d(!1),
    () => d(!1)), [o.open, d]),
    g.jsx(Mw, {
        ...i,
        children: g.jsx(Dq, {
            scope: t,
            open: r,
            onOpenChange: d,
            content: c,
            onContentChange: u,
            children: g.jsx(wve, {
                scope: t,
                contentId: Ro(),
                triggerId: Ro(),
                trigger: a,
                onTriggerChange: l,
                children: n
            })
        })
    })
}
;
Xq.displayName = w4;
var zd = "MenuSubTrigger"
  , Qq = h.forwardRef( (e, t) => {
    const n = qa(zd, e.__scopeMenu)
      , r = Eh(zd, e.__scopeMenu)
      , s = Jq(zd, e.__scopeMenu)
      , o = y4(zd, e.__scopeMenu)
      , i = h.useRef(null)
      , {pointerGraceTimerRef: a, onPointerGraceIntentChange: l} = o
      , c = {
        __scopeMenu: e.__scopeMenu
    }
      , u = h.useCallback( () => {
        i.current && window.clearTimeout(i.current),
        i.current = null
    }
    , []);
    return h.useEffect( () => u, [u]),
    h.useEffect( () => {
        const d = a.current;
        return () => {
            window.clearTimeout(d),
            l(null)
        }
    }
    , [a, l]),
    g.jsx(v4, {
        asChild: !0,
        ...c,
        children: g.jsx(qq, {
            id: s.triggerId,
            "aria-haspopup": "menu",
            "aria-expanded": n.open,
            "aria-controls": s.contentId,
            "data-state": nG(n.open),
            ...e,
            ref: Hg(t, s.onTriggerChange),
            onClick: d => {
                e.onClick?.(d),
                !(e.disabled || d.defaultPrevented) && (d.currentTarget.focus(),
                n.open || n.onOpenChange(!0))
            }
            ,
            onPointerMove: Qe(e.onPointerMove, Df(d => {
                o.onItemEnter(d),
                !d.defaultPrevented && !e.disabled && !n.open && !i.current && (o.onPointerGraceIntentChange(null),
                i.current = window.setTimeout( () => {
                    n.onOpenChange(!0),
                    u()
                }
                , 100))
            }
            )),
            onPointerLeave: Qe(e.onPointerLeave, Df(d => {
                u();
                const f = n.content?.getBoundingClientRect();
                if (f) {
                    const p = n.content?.dataset.side
                      , m = p === "right"
                      , v = m ? -5 : 5
                      , _ = f[m ? "left" : "right"]
                      , y = f[m ? "right" : "left"];
                    o.onPointerGraceIntentChange({
                        area: [{
                            x: d.clientX + v,
                            y: d.clientY
                        }, {
                            x: _,
                            y: f.top
                        }, {
                            x: y,
                            y: f.top
                        }, {
                            x: y,
                            y: f.bottom
                        }, {
                            x: _,
                            y: f.bottom
                        }],
                        side: p
                    }),
                    window.clearTimeout(a.current),
                    a.current = window.setTimeout( () => o.onPointerGraceIntentChange(null), 300)
                } else {
                    if (o.onTriggerLeave(d),
                    d.defaultPrevented)
                        return;
                    o.onPointerGraceIntentChange(null)
                }
            }
            )),
            onKeyDown: Qe(e.onKeyDown, d => {
                const f = o.searchRef.current !== "";
                e.disabled || f && d.key === " " || ove[r.dir].includes(d.key) && (n.onOpenChange(!0),
                n.content?.focus(),
                d.preventDefault())
            }
            )
        })
    })
}
);
Qq.displayName = zd;
var eG = "MenuSubContent"
  , tG = h.forwardRef( (e, t) => {
    const n = Fq(ws, e.__scopeMenu)
      , {forceMount: r=n.forceMount, ...s} = e
      , o = qa(ws, e.__scopeMenu)
      , i = Eh(ws, e.__scopeMenu)
      , a = Jq(eG, e.__scopeMenu)
      , l = h.useRef(null)
      , c = xn(t, l);
    return g.jsx(Pf.Provider, {
        scope: e.__scopeMenu,
        children: g.jsx(co, {
            present: r || o.open,
            children: g.jsx(Pf.Slot, {
                scope: e.__scopeMenu,
                children: g.jsx(b4, {
                    id: a.contentId,
                    "aria-labelledby": a.triggerId,
                    align: "start",
                    ...s,
                    ref: c,
                    side: i.dir === "rtl" ? "left" : "right",
                    disableOutsidePointerEvents: !1,
                    disableOutsideScroll: !1,
                    trapFocus: !1,
                    onOpenAutoFocus: u => {
                        i.isUsingKeyboardRef.current && l.current?.focus(),
                        u.preventDefault()
                    }
                    ,
                    onCloseAutoFocus: u => u.preventDefault(),
                    onFocusOutside: Qe(e.onFocusOutside, u => {
                        u.target !== a.trigger && o.onOpenChange(!1)
                    }
                    ),
                    onEscapeKeyDown: Qe(e.onEscapeKeyDown, u => {
                        i.onClose(),
                        u.preventDefault()
                    }
                    ),
                    onKeyDown: Qe(e.onKeyDown, u => {
                        const d = u.currentTarget.contains(u.target)
                          , f = ive[i.dir].includes(u.key);
                        d && f && (o.onOpenChange(!1),
                        a.trigger?.focus(),
                        u.preventDefault())
                    }
                    )
                })
            })
        })
    })
}
);
tG.displayName = eG;
function nG(e) {
    return e ? "open" : "closed"
}
function dg(e) {
    return e === "indeterminate"
}
function E4(e) {
    return dg(e) ? "indeterminate" : e ? "checked" : "unchecked"
}
function Eve(e) {
    const t = document.activeElement;
    for (const n of e)
        if (n === t || (n.focus(),
        document.activeElement !== t))
            return
}
function xve(e, t) {
    return e.map( (n, r) => e[(t + r) % e.length])
}
function Tve(e, t, n) {
    const s = t.length > 1 && Array.from(t).every(c => c === t[0]) ? t[0] : t
      , o = n ? e.indexOf(n) : -1;
    let i = xve(e, Math.max(o, 0));
    s.length === 1 && (i = i.filter(c => c !== n));
    const l = i.find(c => c.toLowerCase().startsWith(s.toLowerCase()));
    return l !== n ? l : void 0
}
function kve(e, t) {
    const {x: n, y: r} = e;
    let s = !1;
    for (let o = 0, i = t.length - 1; o < t.length; i = o++) {
        const a = t[o].x
          , l = t[o].y
          , c = t[i].x
          , u = t[i].y;
        l > r != u > r && n < (c - a) * (r - l) / (u - l) + a && (s = !s)
    }
    return s
}
function Ove(e, t) {
    if (!t)
        return !1;
    const n = {
        x: e.clientX,
        y: e.clientY
    };
    return kve(n, t)
}
function Df(e) {
    return t => t.pointerType === "mouse" ? e(t) : void 0
}
var Ave = Lq
  , Mve = v4
  , Ive = jq
  , Rve = Uq
  , Nve = C4
  , Pve = Bq
  , Dve = $1
  , Lve = Gq
  , Fve = Hq
  , jve = $q
  , Uve = Kq
  , Bve = Yq
  , qve = Zq
  , Gve = Xq
  , Vve = Qq
  , Hve = tG
  , x4 = "DropdownMenu"
  , [zve,IOe] = $u(x4, [Nq])
  , vr = Nq()
  , [$ve,rG] = zve(x4)
  , sG = e => {
    const {__scopeDropdownMenu: t, children: n, dir: r, open: s, defaultOpen: o, onOpenChange: i, modal: a=!0} = e
      , l = vr(t)
      , c = h.useRef(null)
      , [u=!1,d] = Ql({
        prop: s,
        defaultProp: o,
        onChange: i
    });
    return g.jsx($ve, {
        scope: t,
        triggerId: Ro(),
        triggerRef: c,
        contentId: Ro(),
        open: u,
        onOpenChange: d,
        onOpenToggle: h.useCallback( () => d(f => !f), [d]),
        modal: a,
        children: g.jsx(Ave, {
            ...l,
            open: u,
            onOpenChange: d,
            dir: r,
            modal: a,
            children: n
        })
    })
}
;
sG.displayName = x4;
var oG = "DropdownMenuTrigger"
  , iG = h.forwardRef( (e, t) => {
    const {__scopeDropdownMenu: n, disabled: r=!1, ...s} = e
      , o = rG(oG, n)
      , i = vr(n);
    return g.jsx(Mve, {
        asChild: !0,
        ...i,
        children: g.jsx(Vt.button, {
            type: "button",
            id: o.triggerId,
            "aria-haspopup": "menu",
            "aria-expanded": o.open,
            "aria-controls": o.open ? o.contentId : void 0,
            "data-state": o.open ? "open" : "closed",
            "data-disabled": r ? "" : void 0,
            disabled: r,
            ...s,
            ref: Hg(t, o.triggerRef),
            onPointerDown: Qe(e.onPointerDown, a => {
                !r && a.button === 0 && a.ctrlKey === !1 && (o.onOpenToggle(),
                o.open || a.preventDefault())
            }
            ),
            onKeyDown: Qe(e.onKeyDown, a => {
                r || (["Enter", " "].includes(a.key) && o.onOpenToggle(),
                a.key === "ArrowDown" && o.onOpenChange(!0),
                ["Enter", " ", "ArrowDown"].includes(a.key) && a.preventDefault())
            }
            )
        })
    })
}
);
iG.displayName = oG;
var Wve = "DropdownMenuPortal"
  , aG = e => {
    const {__scopeDropdownMenu: t, ...n} = e
      , r = vr(t);
    return g.jsx(Ive, {
        ...r,
        ...n
    })
}
;
aG.displayName = Wve;
var lG = "DropdownMenuContent"
  , cG = h.forwardRef( (e, t) => {
    const {__scopeDropdownMenu: n, ...r} = e
      , s = rG(lG, n)
      , o = vr(n)
      , i = h.useRef(!1);
    return g.jsx(Rve, {
        id: s.contentId,
        "aria-labelledby": s.triggerId,
        ...o,
        ...r,
        ref: t,
        onCloseAutoFocus: Qe(e.onCloseAutoFocus, a => {
            i.current || s.triggerRef.current?.focus(),
            i.current = !1,
            a.preventDefault()
        }
        ),
        onInteractOutside: Qe(e.onInteractOutside, a => {
            const l = a.detail.originalEvent
              , c = l.button === 0 && l.ctrlKey === !0
              , u = l.button === 2 || c;
            (!s.modal || u) && (i.current = !0)
        }
        ),
        style: {
            ...e.style,
            "--radix-dropdown-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
            "--radix-dropdown-menu-content-available-width": "var(--radix-popper-available-width)",
            "--radix-dropdown-menu-content-available-height": "var(--radix-popper-available-height)",
            "--radix-dropdown-menu-trigger-width": "var(--radix-popper-anchor-width)",
            "--radix-dropdown-menu-trigger-height": "var(--radix-popper-anchor-height)"
        }
    })
}
);
cG.displayName = lG;
var Kve = "DropdownMenuGroup"
  , uG = h.forwardRef( (e, t) => {
    const {__scopeDropdownMenu: n, ...r} = e
      , s = vr(n);
    return g.jsx(Nve, {
        ...s,
        ...r,
        ref: t
    })
}
);
uG.displayName = Kve;
var Yve = "DropdownMenuLabel"
  , dG = h.forwardRef( (e, t) => {
    const {__scopeDropdownMenu: n, ...r} = e
      , s = vr(n);
    return g.jsx(Pve, {
        ...s,
        ...r,
        ref: t
    })
}
);
dG.displayName = Yve;
var Zve = "DropdownMenuItem"
  , fG = h.forwardRef( (e, t) => {
    const {__scopeDropdownMenu: n, ...r} = e
      , s = vr(n);
    return g.jsx(Dve, {
        ...s,
        ...r,
        ref: t
    })
}
);
fG.displayName = Zve;
var Jve = "DropdownMenuCheckboxItem"
  , hG = h.forwardRef( (e, t) => {
    const {__scopeDropdownMenu: n, ...r} = e
      , s = vr(n);
    return g.jsx(Lve, {
        ...s,
        ...r,
        ref: t
    })
}
);
hG.displayName = Jve;
var Xve = "DropdownMenuRadioGroup"
  , pG = h.forwardRef( (e, t) => {
    const {__scopeDropdownMenu: n, ...r} = e
      , s = vr(n);
    return g.jsx(Fve, {
        ...s,
        ...r,
        ref: t
    })
}
);
pG.displayName = Xve;
var Qve = "DropdownMenuRadioItem"
  , mG = h.forwardRef( (e, t) => {
    const {__scopeDropdownMenu: n, ...r} = e
      , s = vr(n);
    return g.jsx(jve, {
        ...s,
        ...r,
        ref: t
    })
}
);
mG.displayName = Qve;
var e_e = "DropdownMenuItemIndicator"
  , gG = h.forwardRef( (e, t) => {
    const {__scopeDropdownMenu: n, ...r} = e
      , s = vr(n);
    return g.jsx(Uve, {
        ...s,
        ...r,
        ref: t
    })
}
);
gG.displayName = e_e;
var t_e = "DropdownMenuSeparator"
  , vG = h.forwardRef( (e, t) => {
    const {__scopeDropdownMenu: n, ...r} = e
      , s = vr(n);
    return g.jsx(Bve, {
        ...s,
        ...r,
        ref: t
    })
}
);
vG.displayName = t_e;
var n_e = "DropdownMenuArrow"
  , r_e = h.forwardRef( (e, t) => {
    const {__scopeDropdownMenu: n, ...r} = e
      , s = vr(n);
    return g.jsx(qve, {
        ...s,
        ...r,
        ref: t
    })
}
);
r_e.displayName = n_e;
var s_e = e => {
    const {__scopeDropdownMenu: t, children: n, open: r, onOpenChange: s, defaultOpen: o} = e
      , i = vr(t)
      , [a=!1,l] = Ql({
        prop: r,
        defaultProp: o,
        onChange: s
    });
    return g.jsx(Gve, {
        ...i,
        open: a,
        onOpenChange: l,
        children: n
    })
}
  , o_e = "DropdownMenuSubTrigger"
  , _G = h.forwardRef( (e, t) => {
    const {__scopeDropdownMenu: n, ...r} = e
      , s = vr(n);
    return g.jsx(Vve, {
        ...s,
        ...r,
        ref: t
    })
}
);
_G.displayName = o_e;
var i_e = "DropdownMenuSubContent"
  , yG = h.forwardRef( (e, t) => {
    const {__scopeDropdownMenu: n, ...r} = e
      , s = vr(n);
    return g.jsx(Hve, {
        ...s,
        ...r,
        ref: t,
        style: {
            ...e.style,
            "--radix-dropdown-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
            "--radix-dropdown-menu-content-available-width": "var(--radix-popper-available-width)",
            "--radix-dropdown-menu-content-available-height": "var(--radix-popper-available-height)",
            "--radix-dropdown-menu-trigger-width": "var(--radix-popper-anchor-width)",
            "--radix-dropdown-menu-trigger-height": "var(--radix-popper-anchor-height)"
        }
    })
}
);
yG.displayName = i_e;
var bG = sG
  , T4 = iG
  , a_e = aG
  , l_e = cG
  , c_e = uG
  , u_e = dG
  , W1 = fG
  , CG = hG
  , d_e = pG
  , f_e = mG
  , h_e = gG
  , p_e = vG
  , m_e = s_e
  , g_e = _G
  , v_e = yG;
const __e = ja.button`
text-token-text-primary border border-transparent inline-flex h-9 items-center justify-center gap-1 rounded-lg bg-white px-3 text-sm dark:transparent dark:bg-transparent
leading-none outline-hidden cursor-pointer
hover:bg-token-main-surface-secondary dark:hover:bg-token-main-surface-secondary
keyboard-focused:bg-token-main-surface-secondary
radix-state-active:text-token-text-secondary
radix-disabled:cursor-auto radix-disabled:bg-transparent radix-disabled:text-token-text-tertiary dark:radix-disabled:bg-transparent
data-no-hover-bg:hover:bg-transparent dark:data-no-hover-bg:hover:bg-transparent
`
  , ROe = "z-50 max-w-xs rounded-2xl popover bg-token-main-surface-primary dark:bg-[#353535] shadow-long will-change-[opacity,transform] radix-side-bottom:animate-slideUpAndFade radix-side-left:animate-slideRightAndFade radix-side-right:animate-slideLeftAndFade radix-side-top:animate-slideDownAndFade py-1.5 select-none"
  , SG = ja.div`z-50 max-w-xs rounded-2xl popover bg-token-main-surface-primary dark:bg-[#353535] shadow-long will-change-[opacity,transform] radix-side-bottom:animate-slideUpAndFade radix-side-left:animate-slideRightAndFade radix-side-right:animate-slideLeftAndFade radix-side-top:animate-slideDownAndFade py-1.5 select-none data-[unbound-width]:min-w-[unset] data-[custom-padding]:py-0`
  , NOe = ja.div`popover overflow-auto rounded-2xl dark:bg-[#353535] bg-clip-padding bg-token-main-surface-primary p-2 shadow-long`
  , Ur = h.createContext({
    activeDetent$: Ct(void 0),
    fullyExpanded$: Ct(!1),
    mode: "dropdown",
    open$: Ct(!1)
})
  , k4 = h.createContext({})
  , wG = 6
  , EG = function(t) {
    "use forget";
    const n = De.c(64);
    let r, s, o, i, a, l, c, u, d, f, p, m, v, _;
    n[0] !== t ? ({children: s, className: o, style: p, size: m, align: r, addBottomGradient: v, sheetContentClassName: f, ref: u, sheetSize: _, onCloseAutoFocus: i, onEscapeKeyDown: a, onPointerDownOutside: c, onFocusOutside: l, ...d} = t,
    n[0] = t,
    n[1] = r,
    n[2] = s,
    n[3] = o,
    n[4] = i,
    n[5] = a,
    n[6] = l,
    n[7] = c,
    n[8] = u,
    n[9] = d,
    n[10] = f,
    n[11] = p,
    n[12] = m,
    n[13] = v,
    n[14] = _) : (r = n[1],
    s = n[2],
    o = n[3],
    i = n[4],
    a = n[5],
    l = n[6],
    c = n[7],
    u = n[8],
    d = n[9],
    f = n[10],
    p = n[11],
    m = n[12],
    v = n[13],
    _ = n[14]);
    const y = m === void 0 ? "default" : m
      , b = v === void 0 ? !1 : v
      , S = _ === void 0 ? "fit" : _
      , {detents: C, mode: w} = h.use(Ur)
      , [x,E] = h.useState(!1)
      , T = h.useRef(!1)
      , k = h.useRef(!1)
      , A = h.useRef(!1);
    if (w === "sheet") {
        let ne;
        n[15] === Symbol.for("react.memo_cache_sentinel") ? (ne = g.jsx(To.Backdrop, {}),
        n[15] = ne) : ne = n[15];
        let _e;
        n[16] !== s || n[17] !== f ? (_e = g.jsx(To.ScrollRoot, {
            children: g.jsx(To.ContentSection, {
                "data-content-sheet-content-section": !0,
                className: f,
                children: s
            })
        }),
        n[16] = s,
        n[17] = f,
        n[18] = _e) : _e = n[18];
        let ee;
        n[19] !== o || n[20] !== u || n[21] !== d || n[22] !== S || n[23] !== p || n[24] !== _e ? (ee = g.jsx(To.Content, {
            size: S,
            ref: u,
            className: o,
            style: p,
            ...d,
            children: _e
        }),
        n[19] = o,
        n[20] = u,
        n[21] = d,
        n[22] = S,
        n[23] = p,
        n[24] = _e,
        n[25] = ee) : ee = n[25];
        let oe;
        return n[26] !== C || n[27] !== ee ? (oe = g.jsxs(To.View, {
            detents: C,
            children: [ne, ee]
        }),
        n[26] = C,
        n[27] = ee,
        n[28] = oe) : oe = n[28],
        oe
    }
    const O = d.alignOffset ? `${d.alignOffset}px` : void 0;
    let M;
    n[29] !== O ? (M = {
        "--radix-align-offset": O
    },
    n[29] = O,
    n[30] = M) : M = n[30];
    const I = M
      , R = r ?? "start";
    let D;
    n[31] !== I || n[32] !== p ? (D = {
        ...I,
        ...p
    },
    n[31] = I,
    n[32] = p,
    n[33] = D) : D = n[33];
    const P = y === "default"
      , L = y === "large"
      , N = y === "small"
      , B = y === "medium"
      , H = y === "auto";
    let ye;
    n[34] !== o || n[35] !== N || n[36] !== B || n[37] !== H || n[38] !== P || n[39] !== L ? (ye = we("[--trigger-width:calc(var(--radix-dropdown-menu-trigger-width)-2*var(--radix-align-offset))]", {
        "min-w-[max(var(--trigger-width),min(280px,95vw))]": P,
        "min-w-[max(var(--trigger-width),min(350px,95vw))]": L,
        "min-w-[max(var(--trigger-width),min(125px,95vw))]": N,
        "min-w-[max(var(--trigger-width),min(200px,95vw))]": B,
        "min-w-(--trigger-width)": H
    }, "max-h-[var(--radix-dropdown-menu-content-available-height)] overflow-y-auto select-none", o),
    n[34] = o,
    n[35] = N,
    n[36] = B,
    n[37] = H,
    n[38] = P,
    n[39] = L,
    n[40] = ye) : ye = n[40];
    let Ie;
    n[41] !== i ? (Ie = ne => {
        const _e = T.current
          , ee = k.current
          , oe = A.current;
        T.current = !1,
        k.current = !1,
        A.current = !1,
        !oe && !_e && !ee && i?.(ne)
    }
    ,
    n[41] = i,
    n[42] = Ie) : Ie = n[42];
    let be;
    n[43] !== a ? (be = ne => {
        a?.(ne),
        T.current = !0
    }
    ,
    n[43] = a,
    n[44] = be) : be = n[44];
    let me;
    n[45] !== c ? (me = ne => {
        c?.(ne),
        k.current = !0
    }
    ,
    n[45] = c,
    n[46] = me) : me = n[46];
    let ge;
    n[47] !== l ? (ge = ne => {
        l?.(ne),
        A.current = !0
    }
    ,
    n[47] = l,
    n[48] = ge) : ge = n[48];
    let ce;
    n[49] !== b || n[50] !== x ? (ce = b && g.jsxs(g.Fragment, {
        children: [g.jsx(J0e, {
            setIsScrolledToEdge: E
        }, "dropdownBottomEdgeScrollObserver"), g.jsx("div", {
            className: "pointer-events-none absolute start-0 end-0 bottom-0 h-20 transition-opacity duration-100",
            style: {
                background: "linear-gradient(to bottom, rgba(255, 255, 255, 0), var(--main-surface-primary))",
                opacity: x ? 1 : 0
            }
        })]
    }),
    n[49] = b,
    n[50] = x,
    n[51] = ce) : ce = n[51];
    let Z;
    return n[52] !== s || n[53] !== u || n[54] !== d || n[55] !== ye || n[56] !== Ie || n[57] !== be || n[58] !== me || n[59] !== ge || n[60] !== ce || n[61] !== R || n[62] !== D ? (Z = g.jsx(sae, {
        children: g.jsxs(SG, {
            ref: u,
            $as: l_e,
            sideOffset: 4,
            align: R,
            collisionPadding: wG,
            style: D,
            className: ye,
            onCloseAutoFocus: Ie,
            onEscapeKeyDown: be,
            onPointerDownOutside: me,
            onFocusOutside: ge,
            ...d,
            children: [s, ce]
        })
    }),
    n[52] = s,
    n[53] = u,
    n[54] = d,
    n[55] = ye,
    n[56] = Ie,
    n[57] = be,
    n[58] = me,
    n[59] = ge,
    n[60] = ce,
    n[61] = R,
    n[62] = D,
    n[63] = Z) : Z = n[63],
    Z
};
function y_e(e) {
    "use forget";
    const t = De.c(13);
    let n, r;
    t[0] !== e ? ({ref: r, ...n} = e,
    t[0] = e,
    t[1] = n,
    t[2] = r) : (n = t[1],
    r = t[2]);
    const {mode: s} = h.use(Ur);
    let o;
    t[3] !== n ? (o = l => {
        l.stopPropagation(),
        n.onFocusCapture?.(l)
    }
    ,
    t[3] = n,
    t[4] = o) : o = t[4];
    const i = o;
    if (s === "sheet") {
        let l;
        return t[5] !== i || t[6] !== n || t[7] !== r ? (l = g.jsx(To.Trigger, {
            asChild: !0,
            children: g.jsx("button", {
                ref: r,
                onFocusCapture: i,
                ...n
            })
        }),
        t[5] = i,
        t[6] = n,
        t[7] = r,
        t[8] = l) : l = t[8],
        l
    }
    let a;
    return t[9] !== i || t[10] !== n || t[11] !== r ? (a = g.jsx(__e, {
        $as: T4,
        ref: r,
        ...n,
        onFocusCapture: i
    }),
    t[9] = i,
    t[10] = n,
    t[11] = r,
    t[12] = a) : a = t[12],
    a
}
function b_e(e) {
    "use forget";
    const t = De.c(20);
    let n, r, s, o;
    t[0] !== e ? ({ref: o, onClick: r, onFocusCapture: s, ...n} = e,
    t[0] = e,
    t[1] = n,
    t[2] = r,
    t[3] = s,
    t[4] = o) : (n = t[1],
    r = t[2],
    s = t[3],
    o = t[4]);
    const {mode: i, open$: a} = h.use(Ur)
      , l = is(a);
    let c;
    t[5] !== r ? (c = m => {
        m.preventDefault(),
        r?.(m)
    }
    ,
    t[5] = r,
    t[6] = c) : c = t[6];
    const u = c;
    let d;
    t[7] !== s ? (d = m => {
        m.stopPropagation(),
        s?.(m)
    }
    ,
    t[7] = s,
    t[8] = d) : d = t[8];
    const f = d;
    if (i === "sheet") {
        const m = l ? "open" : "closed"
          , v = u;
        let _;
        return t[9] !== f || t[10] !== n || t[11] !== o || t[12] !== m || t[13] !== v ? (_ = g.jsx(To.Trigger, {
            ref: o,
            "data-state": m,
            onFocusCapture: f,
            onClick: v,
            ...n
        }),
        t[9] = f,
        t[10] = n,
        t[11] = o,
        t[12] = m,
        t[13] = v,
        t[14] = _) : _ = t[14],
        _
    }
    let p;
    return t[15] !== u || t[16] !== f || t[17] !== n || t[18] !== o ? (p = g.jsx(T4, {
        ref: o,
        onClick: u,
        onFocusCapture: f,
        ...n
    }),
    t[15] = u,
    t[16] = f,
    t[17] = n,
    t[18] = o,
    t[19] = p) : p = t[19],
    p
}
function xG({children: e}) {
    const {mode: t} = h.use(Ur)
      , n = wj();
    return t === "sheet" ? g.jsx(To.Portal, {
        ...n,
        children: e
    }) : g.jsx(a_e, {
        ...n,
        children: e
    })
}
function ic({onPointerMove: e, onPointerLeave: t, ...n}) {
    return {
        ...n,
        onPointerMove: r => {
            e?.(r),
            oA(r)
        }
        ,
        onPointerLeave: r => {
            t?.(r),
            oA(r)
        }
    }
}
const oA = e => {
    if (!e.defaultPrevented && e.pointerType !== "touch") {
        const t = e.currentTarget.ownerDocument.activeElement;
        t && fse(t, "data-hold-focus") && e.preventDefault()
    }
}
  , TG = e => {
    const {disabled: t, ref: n, onSelect: r, ...s} = e
      , [o,i] = Ne.useState(!1);
    return g.jsx("div", {
        role: "menuitem",
        "data-highlighted": o ? "" : void 0,
        "aria-disabled": t || void 0,
        "data-disabled": t ? "" : void 0,
        ref: n,
        ...s,
        onFocus: a => {
            i(!0),
            e.onFocus?.(a)
        }
        ,
        onBlur: a => {
            i(!1),
            e.onBlur?.(a)
        }
        ,
        onSelect: a => {
            r?.(a.nativeEvent)
        }
        ,
        children: e.children
    })
}
  , C_e = e => {
    const {mode: t} = h.use(Ur);
    return g.jsx(ki, {
        as: t === "sheet" ? TG : W1,
        hasManagedFocus: !0,
        ...ic(e)
    })
}
  , S_e = e => {
    const {mode: t} = h.use(Ur)
      , n = t === "sheet" ? TG : W1;
    return g.jsx(n, {
        asChild: !0,
        ...ic({}),
        children: g.jsx(ki, {
            ...e
        })
    })
}
;
function w_e({className: e, noMargin: t, ...n}) {
    return g.jsx(p_e, {
        className: we("bg-token-border-default h-px", !t && "mx-4 my-1", e),
        ...n
    })
}
const E_e = ({separator: e=!0, className: t, ...n}) => {
    const {mode: r} = h.use(Ur)
      , s = g.jsx(c_e, {
        className: we("empty:hidden [:not(:has(div:not([role=group])))]:hidden", e && "before:bg-token-border-default content-sheet:before:my-3 content-sheet:before:mx-6 before:mx-4 before:my-1 before:block before:h-px first:before:hidden [&:nth-child(1_of_:has(div:not([role=group])))]:before:hidden", t),
        ...n
    });
    return r === "sheet" ? g.jsx(tw, {
        name: "DropdownGroup",
        fallback: g.jsx(g.Fragment, {}),
        children: s
    }) : s
}
;
function x_e(e) {
    const {children: t, value: n, defaultValue: r, defaultChecked: s, ...o} = e
      , i = o
      , {onRadioGroupChange: a} = h.use(k4);
    return g.jsxs("label", {
        ...i,
        children: [t, g.jsx("input", {
            type: "radio",
            className: "sr-only",
            value: n,
            defaultValue: r,
            defaultChecked: s,
            onChange: l => {
                a?.(l.target.value)
            }
        })]
    })
}
const T_e = e => {
    "use forget";
    const t = De.c(7)
      , {mode: n} = h.use(Ur)
      , r = n === "sheet" ? x_e : f_e
      , s = n === "sheet" ? "large" : e.size;
    let o;
    t[0] === Symbol.for("react.memo_cache_sentinel") ? (o = g.jsx(kG, {}),
    t[0] = o) : o = t[0];
    let i;
    t[1] !== e ? (i = ic(e),
    t[1] = e,
    t[2] = i) : i = t[2];
    let a;
    return t[3] !== r || t[4] !== s || t[5] !== i ? (a = g.jsx(ki, {
        as: r,
        hasManagedFocus: !0,
        size: s,
        trailingColor: "primary",
        trailing: o,
        ...i
    }),
    t[3] = r,
    t[4] = s,
    t[5] = i,
    t[6] = a) : a = t[6],
    a
}
;
function kG() {
    return g.jsxs(g.Fragment, {
        children: [g.jsx(h_e, {
            children: g.jsx(g4, {
                className: "icon-sm"
            })
        }), g.jsx("div", {
            className: "icon-sm group-radix-state-checked:hidden"
        })]
    })
}
const k_e = Ne.forwardRef(function(t, n) {
    const {className: r, ...s} = t;
    return g.jsx(SG, {
        ref: n,
        $as: v_e,
        className: we("mt-2 max-h-[calc(100vh-300px)] min-w-[100px] overflow-auto", r),
        sideOffset: 2,
        alignOffset: t.align === "end" ? -6 : -14,
        collisionPadding: wG,
        ...s
    })
})
  , O_e = e => g.jsx(ki, {
    subMenu: !0,
    as: g_e,
    hasManagedFocus: !0,
    ...ic(e)
});
function POe({triggerButton: e, children: t, size: n="default", open: r, onOpenChange: s, onCloseAutoFocus: o, contentAlign: i, side: a, sideOffset: l=0, alignOffset: c=0, contentClassName: u, testId: d, tooltip: f, contentRef: p, modal: m=!1}) {
    const [v,_] = h.useState(r ?? !1)
      , y = r !== void 0
      , b = lne()
      , S = E => {
        y || _(E),
        s?.(E)
    }
      , {triggerRef: C} = X0e({
        isOpen: !!v || !!r,
        onClose: () => S(!1)
    })
      , w = g.jsx(T4, {
        asChild: !0,
        ref: C,
        "data-testid": d ? `${d}-button` : void 0,
        children: e
    })
      , x = f ? g.jsx(ls, {
        label: f,
        disabled: !b,
        triggerAs: null,
        children: w
    }) : w;
    return g.jsxs(bG, {
        modal: m,
        open: r ?? v,
        onOpenChange: S,
        children: [x, g.jsx(xG, {
            children: g.jsx(EG, {
                ref: p,
                size: n,
                align: i,
                alignOffset: c,
                side: a,
                sideOffset: l,
                className: u,
                onCloseAutoFocus: o,
                onClick: E => {
                    E.stopPropagation()
                }
                ,
                children: t
            })
        })]
    })
}
function A_e(e) {
    return g.jsx(_se, {
        as: u_e,
        ...e
    })
}
function M_e(e) {
    "use forget";
    const t = De.c(15)
      , {children: n, className: r} = e
      , {open$: s, activeDetent$: o, detents: i, fullyExpanded$: a} = h.use(Ur)
      , l = is(s)
      , c = is(o);
    let u;
    t[0] !== o || t[1] !== i || t[2] !== a || t[3] !== e ? (u = p => {
        if (o.set(p),
        e.onActiveDetentChange?.(p),
        i && i.length > 0) {
            const m = p === i?.length + 1;
            a.set(m)
        }
    }
    ,
    t[0] = o,
    t[1] = i,
    t[2] = a,
    t[3] = e,
    t[4] = u) : u = t[4];
    let d;
    t[5] !== s || t[6] !== e ? (d = p => {
        s.set(p),
        e.onOpenChange?.(p)
    }
    ,
    t[5] = s,
    t[6] = e,
    t[7] = d) : d = t[7];
    let f;
    return t[8] !== c || t[9] !== n || t[10] !== r || t[11] !== l || t[12] !== u || t[13] !== d ? (f = g.jsx(To.Root, {
        activeDetent: c,
        className: r,
        onActiveDetentChange: u,
        onPresentedChange: d,
        presented: l,
        children: n
    }),
    t[8] = c,
    t[9] = n,
    t[10] = r,
    t[11] = l,
    t[12] = u,
    t[13] = d,
    t[14] = f) : f = t[14],
    f
}
function I_e(e) {
    "use forget";
    const t = De.c(14);
    let n, r, s, o, i, a;
    t[0] !== e ? ({className: n, detents: r, mode: s, open: o, open$: i, ...a} = e,
    t[0] = e,
    t[1] = n,
    t[2] = r,
    t[3] = s,
    t[4] = o,
    t[5] = i,
    t[6] = a) : (n = t[1],
    r = t[2],
    s = t[3],
    o = t[4],
    i = t[5],
    a = t[6]);
    let l;
    return t[7] !== n || t[8] !== r || t[9] !== s || t[10] !== o || t[11] !== i || t[12] !== a ? (l = g.jsx(oae, {
        children: s === "sheet" && i ? g.jsx(Ur, {
            value: {
                mode: s ?? "dropdown",
                open$: i,
                detents: r,
                activeDetent$: Ct(void 0),
                fullyExpanded$: Ct(!1)
            },
            children: g.jsx(M_e, {
                className: n,
                ...a
            })
        }) : g.jsx(bG, {
            ...a,
            open: o
        })
    }),
    t[7] = n,
    t[8] = r,
    t[9] = s,
    t[10] = o,
    t[11] = i,
    t[12] = a,
    t[13] = l) : l = t[13],
    l
}
function R_e(e) {
    const {children: t, container: n, ...r} = e
      , {mode: s} = h.use(Ur)
      , o = s === "sheet" ? To.Portal : xG;
    return g.jsx(o, {
        ...r,
        container: n,
        children: t
    })
}
function N_e(e) {
    "use forget";
    const t = De.c(16);
    let n, r, s, o;
    t[0] !== e ? ({children: n, defaultValue: s, defaultChecked: r, ...o} = e,
    t[0] = e,
    t[1] = n,
    t[2] = r,
    t[3] = s,
    t[4] = o) : (n = t[1],
    r = t[2],
    s = t[3],
    o = t[4]);
    const i = o
      , {onRadioGroupChange: a} = h.use(k4);
    let l;
    t[5] !== a || t[6] !== o ? (l = d => {
        d.preventDefault(),
        d.stopPropagation(),
        o.onCheckedChange?.(d.target.checked),
        a?.(d.target.value)
    }
    ,
    t[5] = a,
    t[6] = o,
    t[7] = l) : l = t[7];
    let c;
    t[8] !== r || t[9] !== s || t[10] !== l ? (c = g.jsx("input", {
        type: "checkbox",
        className: "sr-only",
        defaultValue: s,
        defaultChecked: r,
        onChange: l
    }),
    t[8] = r,
    t[9] = s,
    t[10] = l,
    t[11] = c) : c = t[11];
    let u;
    return t[12] !== n || t[13] !== i || t[14] !== c ? (u = g.jsxs("label", {
        ...i,
        children: [n, c]
    }),
    t[12] = n,
    t[13] = i,
    t[14] = c,
    t[15] = u) : u = t[15],
    u
}
const P_e = e => {
    const {mode: t} = h.use(Ur);
    return g.jsx(ki, {
        as: t === "sheet" ? N_e : CG,
        hasManagedFocus: !0,
        onSelect: n => {
            n.preventDefault()
        }
        ,
        onClick: n => {
            n.stopPropagation()
        }
        ,
        trailingColor: "primary",
        trailing: g.jsx(_F, {
            size: "small",
            disabled: e.disabled,
            checked: e.checked === !0,
            "aria-hidden": !0
        }),
        ...ic(e)
    })
}
;
function D_e({checked: e, onCheckedChange: t, children: n, onClick: r, className: s, ...o}) {
    const i = a => {
        a.preventDefault()
    }
    ;
    return g.jsx(CG, {
        checked: e,
        onCheckedChange: t,
        onSelect: i,
        onClick: r,
        className: we(s, "mx-2 flex cursor-pointer items-center rounded-md p-3 text-sm", "hover:bg-token-main-surface-secondary keyboard-focused:bg-token-main-surface-secondary", "radix-disabled:pointer-events-none radix-disabled:opacity-50 focus:outline-none", "radix-state-open:bg-token-main-surface-secondary"),
        ...o,
        children: g.jsxs("div", {
            className: "flex w-full flex-row items-center justify-between",
            children: [n, e ? g.jsx(W0e, {
                className: "icon-sm text-token-text-primary"
            }) : g.jsx(K0e, {
                className: "icon-sm text-token-text-tertiary"
            })]
        })
    })
}
function L_e(e) {
    return g.jsx(W1, {
        asChild: !0,
        ...ic({}),
        children: g.jsx(gse, {
            ...e
        })
    })
}
const F_e = e => g.jsx(W1, {
    asChild: !0,
    onSelect: t => {
        t.preventDefault()
    }
    ,
    ...ic({}),
    children: g.jsx(bse, {
        ...e
    })
});
function j_e(e) {
    const {open$: t} = h.use(Ur);
    return g.jsx(k4, {
        value: {
            onRadioGroupChange: n => {
                e.onValueChange?.(n),
                t.set(!1)
            }
        },
        children: g.jsx("section", {
            ...e
        })
    })
}
function U_e(e) {
    "use forget";
    const t = De.c(3)
      , {mode: n} = h.use(Ur)
      , r = n === "sheet" ? j_e : d_e;
    let s;
    return t[0] !== r || t[1] !== e ? (s = g.jsx(r, {
        ...e
    }),
    t[0] = r,
    t[1] = e,
    t[2] = s) : s = t[2],
    s
}
function B_e(e) {
    return g.jsx(pw, {
        as: "button",
        ...e
    })
}
function q_e(e) {
    return g.jsx(pw, {
        ...e,
        as: "button",
        row: !0
    })
}
const Dt = {
    Root: I_e,
    Trigger: y_e,
    BasicTrigger: b_e,
    Portal: R_e,
    Content: EG,
    Item: C_e,
    ItemAs: S_e,
    HeaderItem: B_e,
    HeaderItemRow: q_e,
    HeaderItemAs: pw,
    Separator: w_e,
    Group: E_e,
    RadioGroup: U_e,
    RadioItem: T_e,
    RadioItemCheck: kG,
    Sub: m_e,
    SubContent: k_e,
    SubMenuTrigger: O_e,
    Label: A_e,
    CheckboxItem: P_e,
    MultiSelectCheckboxItem: D_e,
    LinkItem: L_e,
    InputItem: F_e,
    Shimmer: yse
}
  , G_e = e => h.createElement("svg", {
    width: 20,
    height: 20,
    viewBox: "0 0 20 20",
    fill: "currentColor",
    xmlns: "http://www.w3.org/2000/svg",
    ...e
}, h.createElement("path", {
    d: "M15.498 8.50159C16.3254 8.50159 16.9959 9.17228 16.9961 9.99963C16.9961 10.8271 16.3256 11.4987 15.498 11.4987C14.6705 11.4987 14 10.8271 14 9.99963C14.0002 9.17228 14.6706 8.50159 15.498 8.50159Z"
}), h.createElement("path", {
    d: "M4.49805 8.50159C5.32544 8.50159 5.99689 9.17228 5.99707 9.99963C5.99707 10.8271 5.32555 11.4987 4.49805 11.4987C3.67069 11.4985 3 10.827 3 9.99963C3.00018 9.17239 3.6708 8.50176 4.49805 8.50159Z"
}), h.createElement("path", {
    d: "M10.0003 8.50159C10.8276 8.50176 11.4982 9.17239 11.4984 9.99963C11.4984 10.827 10.8277 11.4985 10.0003 11.4987C9.17283 11.4987 8.50131 10.8271 8.50131 9.99963C8.50149 9.17228 9.17294 8.50159 10.0003 8.50159Z"
}))
  , V_e = e => h.createElement("svg", {
    width: 20,
    height: 20,
    viewBox: "0 0 20 20",
    fill: "currentColor",
    xmlns: "http://www.w3.org/2000/svg",
    ...e
}, h.createElement("path", {
    d: "M15.2146 18.1227L15.2439 18.2546C15.2809 18.5616 15.0985 18.8629 14.7937 18.9645C14.4889 19.0661 14.1622 18.9345 14.0076 18.6667L13.9529 18.5436L13.1189 16.0436L13.7498 15.8337L14.3806 15.6227L15.2146 18.1227ZM4.5027 8.72526C4.7467 8.45076 5.16765 8.4256 5.44215 8.6696C5.71651 8.91359 5.74073 9.33361 5.49684 9.60807L4.70875 10.4958C3.51378 11.8401 3.57361 13.8831 4.84547 15.1549L4.96656 15.2702C6.24396 16.4291 8.20223 16.4494 9.50465 15.2917L10.3914 14.5026L10.5007 14.4245C10.7685 14.2694 11.1173 14.318 11.3308 14.5583C11.5746 14.8327 11.5495 15.2528 11.2752 15.4967L10.3875 16.2858C8.57532 17.8963 5.85141 17.8686 4.07399 16.2565L3.90504 16.0954C2.13524 14.3256 2.05179 11.4827 3.71461 9.61198L4.5027 8.72526ZM13.5398 15.2028C13.8881 15.0867 14.2643 15.2745 14.3806 15.6227L13.1189 16.0436C13.0028 15.6953 13.1915 15.319 13.5398 15.2028ZM15.2029 13.5397C15.3191 13.1914 15.6953 13.0028 16.0437 13.1188L18.5437 13.9528L18.6668 14.0075C18.9346 14.1621 19.0662 14.4888 18.9646 14.7936C18.863 15.0985 18.5617 15.2808 18.2547 15.2438L18.1228 15.2145L15.6228 14.3805C15.2746 14.2642 15.0868 13.888 15.2029 13.5397ZM9.79078 3.56315C11.6599 2.0583 14.3811 2.19057 16.0955 3.90495L16.2566 4.07389C17.8168 5.79411 17.893 8.40087 16.4363 10.2096L16.2859 10.3874L15.4968 11.2751L15.3982 11.3659C15.1506 11.5514 14.7987 11.5441 14.5584 11.3307C14.2839 11.0867 14.2587 10.6658 14.5027 10.3913L15.2918 9.50456L15.4002 9.37663C16.4472 8.07662 16.3919 6.20274 15.2703 4.96647L15.155 4.84538C13.9229 3.6132 11.967 3.51839 10.6238 4.60026L10.4959 4.70866L9.60816 5.49674C9.3337 5.74063 8.91368 5.71642 8.66969 5.44206C8.42569 5.16756 8.45085 4.7466 8.72535 4.5026L9.61207 3.71452L9.79078 3.56315ZM1.74586 4.75651L1.87672 4.78581L4.37672 5.61881L4.49977 5.67448C4.76767 5.82912 4.89925 6.15572 4.79762 6.46061C4.69588 6.76536 4.39471 6.94789 4.08766 6.91081L3.9568 6.88053L1.4568 6.04753L1.33375 5.99186C1.06603 5.83724 0.93447 5.51146 1.0359 5.20671C1.13755 4.90175 1.43868 4.71938 1.74586 4.75651ZM5.2068 1.03581C5.51155 0.934377 5.83733 1.06594 5.99195 1.33366L6.04762 1.45671L6.88063 3.95671L6.9109 4.08756C6.94798 4.39462 6.76546 4.69579 6.4607 4.79753C6.15582 4.89916 5.82921 4.76758 5.67457 4.49967L5.61891 4.37663L4.7859 1.87663L4.7566 1.74577C4.71947 1.43859 4.90184 1.13746 5.2068 1.03581Z"
}))
  , H_e = ["https:", "mailto:", "tel:"]
  , z_e = e => {
    if (e === void 0)
        return;
    let t;
    try {
        t = new URL(e,"https://chatgpt.com")
    } catch {
        return
    }
    if (H_e.includes(t.protocol))
        return t.href
}
  , O4 = "-"
  , $_e = e => {
    const t = K_e(e)
      , {conflictingClassGroups: n, conflictingClassGroupModifiers: r} = e;
    return {
        getClassGroupId: i => {
            const a = i.split(O4);
            return a[0] === "" && a.length !== 1 && a.shift(),
            OG(a, t) || W_e(i)
        }
        ,
        getConflictingClassGroupIds: (i, a) => {
            const l = n[i] || [];
            return a && r[i] ? [...l, ...r[i]] : l
        }
    }
}
  , OG = (e, t) => {
    if (e.length === 0)
        return t.classGroupId;
    const n = e[0]
      , r = t.nextPart.get(n)
      , s = r ? OG(e.slice(1), r) : void 0;
    if (s)
        return s;
    if (t.validators.length === 0)
        return;
    const o = e.join(O4);
    return t.validators.find( ({validator: i}) => i(o))?.classGroupId
}
  , iA = /^\[(.+)\]$/
  , W_e = e => {
    if (iA.test(e)) {
        const t = iA.exec(e)[1]
          , n = t?.substring(0, t.indexOf(":"));
        if (n)
            return "arbitrary.." + n
    }
}
  , K_e = e => {
    const {theme: t, classGroups: n} = e
      , r = {
        nextPart: new Map,
        validators: []
    };
    for (const s in n)
        lS(n[s], r, s, t);
    return r
}
  , lS = (e, t, n, r) => {
    e.forEach(s => {
        if (typeof s == "string") {
            const o = s === "" ? t : aA(t, s);
            o.classGroupId = n;
            return
        }
        if (typeof s == "function") {
            if (Y_e(s)) {
                lS(s(r), t, n, r);
                return
            }
            t.validators.push({
                validator: s,
                classGroupId: n
            });
            return
        }
        Object.entries(s).forEach( ([o,i]) => {
            lS(i, aA(t, o), n, r)
        }
        )
    }
    )
}
  , aA = (e, t) => {
    let n = e;
    return t.split(O4).forEach(r => {
        n.nextPart.has(r) || n.nextPart.set(r, {
            nextPart: new Map,
            validators: []
        }),
        n = n.nextPart.get(r)
    }
    ),
    n
}
  , Y_e = e => e.isThemeGetter
  , Z_e = e => {
    if (e < 1)
        return {
            get: () => {}
            ,
            set: () => {}
        };
    let t = 0
      , n = new Map
      , r = new Map;
    const s = (o, i) => {
        n.set(o, i),
        t++,
        t > e && (t = 0,
        r = n,
        n = new Map)
    }
    ;
    return {
        get(o) {
            let i = n.get(o);
            if (i !== void 0)
                return i;
            if ((i = r.get(o)) !== void 0)
                return s(o, i),
                i
        },
        set(o, i) {
            n.has(o) ? n.set(o, i) : s(o, i)
        }
    }
}
  , cS = "!"
  , uS = ":"
  , J_e = uS.length
  , X_e = e => {
    const {prefix: t, experimentalParseClassName: n} = e;
    let r = s => {
        const o = [];
        let i = 0, a = 0, l = 0, c;
        for (let m = 0; m < s.length; m++) {
            let v = s[m];
            if (i === 0 && a === 0) {
                if (v === uS) {
                    o.push(s.slice(l, m)),
                    l = m + J_e;
                    continue
                }
                if (v === "/") {
                    c = m;
                    continue
                }
            }
            v === "[" ? i++ : v === "]" ? i-- : v === "(" ? a++ : v === ")" && a--
        }
        const u = o.length === 0 ? s : s.substring(l)
          , d = Q_e(u)
          , f = d !== u
          , p = c && c > l ? c - l : void 0;
        return {
            modifiers: o,
            hasImportantModifier: f,
            baseClassName: d,
            maybePostfixModifierPosition: p
        }
    }
    ;
    if (t) {
        const s = t + uS
          , o = r;
        r = i => i.startsWith(s) ? o(i.substring(s.length)) : {
            isExternal: !0,
            modifiers: [],
            hasImportantModifier: !1,
            baseClassName: i,
            maybePostfixModifierPosition: void 0
        }
    }
    if (n) {
        const s = r;
        r = o => n({
            className: o,
            parseClassName: s
        })
    }
    return r
}
  , Q_e = e => e.endsWith(cS) ? e.substring(0, e.length - 1) : e.startsWith(cS) ? e.substring(1) : e
  , eye = e => {
    const t = Object.fromEntries(e.orderSensitiveModifiers.map(r => [r, !0]));
    return r => {
        if (r.length <= 1)
            return r;
        const s = [];
        let o = [];
        return r.forEach(i => {
            i[0] === "[" || t[i] ? (s.push(...o.sort(), i),
            o = []) : o.push(i)
        }
        ),
        s.push(...o.sort()),
        s
    }
}
  , tye = e => ({
    cache: Z_e(e.cacheSize),
    parseClassName: X_e(e),
    sortModifiers: eye(e),
    ...$_e(e)
})
  , nye = /\s+/
  , rye = (e, t) => {
    const {parseClassName: n, getClassGroupId: r, getConflictingClassGroupIds: s, sortModifiers: o} = t
      , i = []
      , a = e.trim().split(nye);
    let l = "";
    for (let c = a.length - 1; c >= 0; c -= 1) {
        const u = a[c]
          , {isExternal: d, modifiers: f, hasImportantModifier: p, baseClassName: m, maybePostfixModifierPosition: v} = n(u);
        if (d) {
            l = u + (l.length > 0 ? " " + l : l);
            continue
        }
        let _ = !!v
          , y = r(_ ? m.substring(0, v) : m);
        if (!y) {
            if (!_) {
                l = u + (l.length > 0 ? " " + l : l);
                continue
            }
            if (y = r(m),
            !y) {
                l = u + (l.length > 0 ? " " + l : l);
                continue
            }
            _ = !1
        }
        const b = o(f).join(":")
          , S = p ? b + cS : b
          , C = S + y;
        if (i.includes(C))
            continue;
        i.push(C);
        const w = s(y, _);
        for (let x = 0; x < w.length; ++x) {
            const E = w[x];
            i.push(S + E)
        }
        l = u + (l.length > 0 ? " " + l : l)
    }
    return l
}
;
function sye() {
    let e = 0, t, n, r = "";
    for (; e < arguments.length; )
        (t = arguments[e++]) && (n = AG(t)) && (r && (r += " "),
        r += n);
    return r
}
const AG = e => {
    if (typeof e == "string")
        return e;
    let t, n = "";
    for (let r = 0; r < e.length; r++)
        e[r] && (t = AG(e[r])) && (n && (n += " "),
        n += t);
    return n
}
;
function oye(e, ...t) {
    let n, r, s, o = i;
    function i(l) {
        const c = t.reduce( (u, d) => d(u), e());
        return n = tye(c),
        r = n.cache.get,
        s = n.cache.set,
        o = a,
        a(l)
    }
    function a(l) {
        const c = r(l);
        if (c)
            return c;
        const u = rye(l, n);
        return s(l, u),
        u
    }
    return function() {
        return o(sye.apply(null, arguments))
    }
}
const In = e => {
    const t = n => n[e] || [];
    return t.isThemeGetter = !0,
    t
}
  , MG = /^\[(?:(\w[\w-]*):)?(.+)\]$/i
  , IG = /^\((?:(\w[\w-]*):)?(.+)\)$/i
  , iye = /^\d+\/\d+$/
  , aye = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/
  , lye = /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/
  , cye = /^(rgba?|hsla?|hwb|(ok)?(lab|lch)|color-mix)\(.+\)$/
  , uye = /^(inset_)?-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/
  , dye = /^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\(.+\)$/
  , Dc = e => iye.test(e)
  , mt = e => !!e && !Number.isNaN(Number(e))
  , $i = e => !!e && Number.isInteger(Number(e))
  , qb = e => e.endsWith("%") && mt(e.slice(0, -1))
  , Xo = e => aye.test(e)
  , fye = () => !0
  , hye = e => lye.test(e) && !cye.test(e)
  , RG = () => !1
  , pye = e => uye.test(e)
  , mye = e => dye.test(e)
  , gye = e => !Le(e) && !Fe(e)
  , vye = e => sd(e, DG, RG)
  , Le = e => MG.test(e)
  , nl = e => sd(e, LG, hye)
  , Gb = e => sd(e, Sye, mt)
  , lA = e => sd(e, NG, RG)
  , _ye = e => sd(e, PG, mye)
  , kp = e => sd(e, FG, pye)
  , Fe = e => IG.test(e)
  , Od = e => od(e, LG)
  , yye = e => od(e, wye)
  , cA = e => od(e, NG)
  , bye = e => od(e, DG)
  , Cye = e => od(e, PG)
  , Op = e => od(e, FG, !0)
  , sd = (e, t, n) => {
    const r = MG.exec(e);
    return r ? r[1] ? t(r[1]) : n(r[2]) : !1
}
  , od = (e, t, n=!1) => {
    const r = IG.exec(e);
    return r ? r[1] ? t(r[1]) : n : !1
}
  , NG = e => e === "position" || e === "percentage"
  , PG = e => e === "image" || e === "url"
  , DG = e => e === "length" || e === "size" || e === "bg-size"
  , LG = e => e === "length"
  , Sye = e => e === "number"
  , wye = e => e === "family-name"
  , FG = e => e === "shadow"
  , Eye = () => {
    const e = In("color")
      , t = In("font")
      , n = In("text")
      , r = In("font-weight")
      , s = In("tracking")
      , o = In("leading")
      , i = In("breakpoint")
      , a = In("container")
      , l = In("spacing")
      , c = In("radius")
      , u = In("shadow")
      , d = In("inset-shadow")
      , f = In("text-shadow")
      , p = In("drop-shadow")
      , m = In("blur")
      , v = In("perspective")
      , _ = In("aspect")
      , y = In("ease")
      , b = In("animate")
      , S = () => ["auto", "avoid", "all", "avoid-page", "page", "left", "right", "column"]
      , C = () => ["center", "top", "bottom", "left", "right", "top-left", "left-top", "top-right", "right-top", "bottom-right", "right-bottom", "bottom-left", "left-bottom"]
      , w = () => [...C(), Fe, Le]
      , x = () => ["auto", "hidden", "clip", "visible", "scroll"]
      , E = () => ["auto", "contain", "none"]
      , T = () => [Fe, Le, l]
      , k = () => [Dc, "full", "auto", ...T()]
      , A = () => [$i, "none", "subgrid", Fe, Le]
      , O = () => ["auto", {
        span: ["full", $i, Fe, Le]
    }, $i, Fe, Le]
      , M = () => [$i, "auto", Fe, Le]
      , I = () => ["auto", "min", "max", "fr", Fe, Le]
      , R = () => ["start", "end", "center", "between", "around", "evenly", "stretch", "baseline", "center-safe", "end-safe"]
      , D = () => ["start", "end", "center", "stretch", "center-safe", "end-safe"]
      , P = () => ["auto", ...T()]
      , L = () => [Dc, "auto", "full", "dvw", "dvh", "lvw", "lvh", "svw", "svh", "min", "max", "fit", ...T()]
      , N = () => [e, Fe, Le]
      , B = () => [...C(), cA, lA, {
        position: [Fe, Le]
    }]
      , H = () => ["no-repeat", {
        repeat: ["", "x", "y", "space", "round"]
    }]
      , ye = () => ["auto", "cover", "contain", bye, vye, {
        size: [Fe, Le]
    }]
      , Ie = () => [qb, Od, nl]
      , be = () => ["", "none", "full", c, Fe, Le]
      , me = () => ["", mt, Od, nl]
      , ge = () => ["solid", "dashed", "dotted", "double"]
      , ce = () => ["normal", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "hue", "saturation", "color", "luminosity"]
      , Z = () => [mt, qb, cA, lA]
      , ne = () => ["", "none", m, Fe, Le]
      , _e = () => ["none", mt, Fe, Le]
      , ee = () => ["none", mt, Fe, Le]
      , oe = () => [mt, Fe, Le]
      , te = () => [Dc, "full", ...T()];
    return {
        cacheSize: 500,
        theme: {
            animate: ["spin", "ping", "pulse", "bounce"],
            aspect: ["video"],
            blur: [Xo],
            breakpoint: [Xo],
            color: [fye],
            container: [Xo],
            "drop-shadow": [Xo],
            ease: ["in", "out", "in-out"],
            font: [gye],
            "font-weight": ["thin", "extralight", "light", "normal", "medium", "semibold", "bold", "extrabold", "black"],
            "inset-shadow": [Xo],
            leading: ["none", "tight", "snug", "normal", "relaxed", "loose"],
            perspective: ["dramatic", "near", "normal", "midrange", "distant", "none"],
            radius: [Xo],
            shadow: [Xo],
            spacing: ["px", mt],
            text: [Xo],
            "text-shadow": [Xo],
            tracking: ["tighter", "tight", "normal", "wide", "wider", "widest"]
        },
        classGroups: {
            aspect: [{
                aspect: ["auto", "square", Dc, Le, Fe, _]
            }],
            container: ["container"],
            columns: [{
                columns: [mt, Le, Fe, a]
            }],
            "break-after": [{
                "break-after": S()
            }],
            "break-before": [{
                "break-before": S()
            }],
            "break-inside": [{
                "break-inside": ["auto", "avoid", "avoid-page", "avoid-column"]
            }],
            "box-decoration": [{
                "box-decoration": ["slice", "clone"]
            }],
            box: [{
                box: ["border", "content"]
            }],
            display: ["block", "inline-block", "inline", "flex", "inline-flex", "table", "inline-table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row-group", "table-row", "flow-root", "grid", "inline-grid", "contents", "list-item", "hidden"],
            sr: ["sr-only", "not-sr-only"],
            float: [{
                float: ["right", "left", "none", "start", "end"]
            }],
            clear: [{
                clear: ["left", "right", "both", "none", "start", "end"]
            }],
            isolation: ["isolate", "isolation-auto"],
            "object-fit": [{
                object: ["contain", "cover", "fill", "none", "scale-down"]
            }],
            "object-position": [{
                object: w()
            }],
            overflow: [{
                overflow: x()
            }],
            "overflow-x": [{
                "overflow-x": x()
            }],
            "overflow-y": [{
                "overflow-y": x()
            }],
            overscroll: [{
                overscroll: E()
            }],
            "overscroll-x": [{
                "overscroll-x": E()
            }],
            "overscroll-y": [{
                "overscroll-y": E()
            }],
            position: ["static", "fixed", "absolute", "relative", "sticky"],
            inset: [{
                inset: k()
            }],
            "inset-x": [{
                "inset-x": k()
            }],
            "inset-y": [{
                "inset-y": k()
            }],
            start: [{
                start: k()
            }],
            end: [{
                end: k()
            }],
            top: [{
                top: k()
            }],
            right: [{
                right: k()
            }],
            bottom: [{
                bottom: k()
            }],
            left: [{
                left: k()
            }],
            visibility: ["visible", "invisible", "collapse"],
            z: [{
                z: [$i, "auto", Fe, Le]
            }],
            basis: [{
                basis: [Dc, "full", "auto", a, ...T()]
            }],
            "flex-direction": [{
                flex: ["row", "row-reverse", "col", "col-reverse"]
            }],
            "flex-wrap": [{
                flex: ["nowrap", "wrap", "wrap-reverse"]
            }],
            flex: [{
                flex: [mt, Dc, "auto", "initial", "none", Le]
            }],
            grow: [{
                grow: ["", mt, Fe, Le]
            }],
            shrink: [{
                shrink: ["", mt, Fe, Le]
            }],
            order: [{
                order: [$i, "first", "last", "none", Fe, Le]
            }],
            "grid-cols": [{
                "grid-cols": A()
            }],
            "col-start-end": [{
                col: O()
            }],
            "col-start": [{
                "col-start": M()
            }],
            "col-end": [{
                "col-end": M()
            }],
            "grid-rows": [{
                "grid-rows": A()
            }],
            "row-start-end": [{
                row: O()
            }],
            "row-start": [{
                "row-start": M()
            }],
            "row-end": [{
                "row-end": M()
            }],
            "grid-flow": [{
                "grid-flow": ["row", "col", "dense", "row-dense", "col-dense"]
            }],
            "auto-cols": [{
                "auto-cols": I()
            }],
            "auto-rows": [{
                "auto-rows": I()
            }],
            gap: [{
                gap: T()
            }],
            "gap-x": [{
                "gap-x": T()
            }],
            "gap-y": [{
                "gap-y": T()
            }],
            "justify-content": [{
                justify: [...R(), "normal"]
            }],
            "justify-items": [{
                "justify-items": [...D(), "normal"]
            }],
            "justify-self": [{
                "justify-self": ["auto", ...D()]
            }],
            "align-content": [{
                content: ["normal", ...R()]
            }],
            "align-items": [{
                items: [...D(), {
                    baseline: ["", "last"]
                }]
            }],
            "align-self": [{
                self: ["auto", ...D(), {
                    baseline: ["", "last"]
                }]
            }],
            "place-content": [{
                "place-content": R()
            }],
            "place-items": [{
                "place-items": [...D(), "baseline"]
            }],
            "place-self": [{
                "place-self": ["auto", ...D()]
            }],
            p: [{
                p: T()
            }],
            px: [{
                px: T()
            }],
            py: [{
                py: T()
            }],
            ps: [{
                ps: T()
            }],
            pe: [{
                pe: T()
            }],
            pt: [{
                pt: T()
            }],
            pr: [{
                pr: T()
            }],
            pb: [{
                pb: T()
            }],
            pl: [{
                pl: T()
            }],
            m: [{
                m: P()
            }],
            mx: [{
                mx: P()
            }],
            my: [{
                my: P()
            }],
            ms: [{
                ms: P()
            }],
            me: [{
                me: P()
            }],
            mt: [{
                mt: P()
            }],
            mr: [{
                mr: P()
            }],
            mb: [{
                mb: P()
            }],
            ml: [{
                ml: P()
            }],
            "space-x": [{
                "space-x": T()
            }],
            "space-x-reverse": ["space-x-reverse"],
            "space-y": [{
                "space-y": T()
            }],
            "space-y-reverse": ["space-y-reverse"],
            size: [{
                size: L()
            }],
            w: [{
                w: [a, "screen", ...L()]
            }],
            "min-w": [{
                "min-w": [a, "screen", "none", ...L()]
            }],
            "max-w": [{
                "max-w": [a, "screen", "none", "prose", {
                    screen: [i]
                }, ...L()]
            }],
            h: [{
                h: ["screen", "lh", ...L()]
            }],
            "min-h": [{
                "min-h": ["screen", "lh", "none", ...L()]
            }],
            "max-h": [{
                "max-h": ["screen", "lh", ...L()]
            }],
            "font-size": [{
                text: ["base", n, Od, nl]
            }],
            "font-smoothing": ["antialiased", "subpixel-antialiased"],
            "font-style": ["italic", "not-italic"],
            "font-weight": [{
                font: [r, Fe, Gb]
            }],
            "font-stretch": [{
                "font-stretch": ["ultra-condensed", "extra-condensed", "condensed", "semi-condensed", "normal", "semi-expanded", "expanded", "extra-expanded", "ultra-expanded", qb, Le]
            }],
            "font-family": [{
                font: [yye, Le, t]
            }],
            "fvn-normal": ["normal-nums"],
            "fvn-ordinal": ["ordinal"],
            "fvn-slashed-zero": ["slashed-zero"],
            "fvn-figure": ["lining-nums", "oldstyle-nums"],
            "fvn-spacing": ["proportional-nums", "tabular-nums"],
            "fvn-fraction": ["diagonal-fractions", "stacked-fractions"],
            tracking: [{
                tracking: [s, Fe, Le]
            }],
            "line-clamp": [{
                "line-clamp": [mt, "none", Fe, Gb]
            }],
            leading: [{
                leading: [o, ...T()]
            }],
            "list-image": [{
                "list-image": ["none", Fe, Le]
            }],
            "list-style-position": [{
                list: ["inside", "outside"]
            }],
            "list-style-type": [{
                list: ["disc", "decimal", "none", Fe, Le]
            }],
            "text-alignment": [{
                text: ["left", "center", "right", "justify", "start", "end"]
            }],
            "placeholder-color": [{
                placeholder: N()
            }],
            "text-color": [{
                text: N()
            }],
            "text-decoration": ["underline", "overline", "line-through", "no-underline"],
            "text-decoration-style": [{
                decoration: [...ge(), "wavy"]
            }],
            "text-decoration-thickness": [{
                decoration: [mt, "from-font", "auto", Fe, nl]
            }],
            "text-decoration-color": [{
                decoration: N()
            }],
            "underline-offset": [{
                "underline-offset": [mt, "auto", Fe, Le]
            }],
            "text-transform": ["uppercase", "lowercase", "capitalize", "normal-case"],
            "text-overflow": ["truncate", "text-ellipsis", "text-clip"],
            "text-wrap": [{
                text: ["wrap", "nowrap", "balance", "pretty"]
            }],
            indent: [{
                indent: T()
            }],
            "vertical-align": [{
                align: ["baseline", "top", "middle", "bottom", "text-top", "text-bottom", "sub", "super", Fe, Le]
            }],
            whitespace: [{
                whitespace: ["normal", "nowrap", "pre", "pre-line", "pre-wrap", "break-spaces"]
            }],
            break: [{
                break: ["normal", "words", "all", "keep"]
            }],
            wrap: [{
                wrap: ["break-word", "anywhere", "normal"]
            }],
            hyphens: [{
                hyphens: ["none", "manual", "auto"]
            }],
            content: [{
                content: ["none", Fe, Le]
            }],
            "bg-attachment": [{
                bg: ["fixed", "local", "scroll"]
            }],
            "bg-clip": [{
                "bg-clip": ["border", "padding", "content", "text"]
            }],
            "bg-origin": [{
                "bg-origin": ["border", "padding", "content"]
            }],
            "bg-position": [{
                bg: B()
            }],
            "bg-repeat": [{
                bg: H()
            }],
            "bg-size": [{
                bg: ye()
            }],
            "bg-image": [{
                bg: ["none", {
                    linear: [{
                        to: ["t", "tr", "r", "br", "b", "bl", "l", "tl"]
                    }, $i, Fe, Le],
                    radial: ["", Fe, Le],
                    conic: [$i, Fe, Le]
                }, Cye, _ye]
            }],
            "bg-color": [{
                bg: N()
            }],
            "gradient-from-pos": [{
                from: Ie()
            }],
            "gradient-via-pos": [{
                via: Ie()
            }],
            "gradient-to-pos": [{
                to: Ie()
            }],
            "gradient-from": [{
                from: N()
            }],
            "gradient-via": [{
                via: N()
            }],
            "gradient-to": [{
                to: N()
            }],
            rounded: [{
                rounded: be()
            }],
            "rounded-s": [{
                "rounded-s": be()
            }],
            "rounded-e": [{
                "rounded-e": be()
            }],
            "rounded-t": [{
                "rounded-t": be()
            }],
            "rounded-r": [{
                "rounded-r": be()
            }],
            "rounded-b": [{
                "rounded-b": be()
            }],
            "rounded-l": [{
                "rounded-l": be()
            }],
            "rounded-ss": [{
                "rounded-ss": be()
            }],
            "rounded-se": [{
                "rounded-se": be()
            }],
            "rounded-ee": [{
                "rounded-ee": be()
            }],
            "rounded-es": [{
                "rounded-es": be()
            }],
            "rounded-tl": [{
                "rounded-tl": be()
            }],
            "rounded-tr": [{
                "rounded-tr": be()
            }],
            "rounded-br": [{
                "rounded-br": be()
            }],
            "rounded-bl": [{
                "rounded-bl": be()
            }],
            "border-w": [{
                border: me()
            }],
            "border-w-x": [{
                "border-x": me()
            }],
            "border-w-y": [{
                "border-y": me()
            }],
            "border-w-s": [{
                "border-s": me()
            }],
            "border-w-e": [{
                "border-e": me()
            }],
            "border-w-t": [{
                "border-t": me()
            }],
            "border-w-r": [{
                "border-r": me()
            }],
            "border-w-b": [{
                "border-b": me()
            }],
            "border-w-l": [{
                "border-l": me()
            }],
            "divide-x": [{
                "divide-x": me()
            }],
            "divide-x-reverse": ["divide-x-reverse"],
            "divide-y": [{
                "divide-y": me()
            }],
            "divide-y-reverse": ["divide-y-reverse"],
            "border-style": [{
                border: [...ge(), "hidden", "none"]
            }],
            "divide-style": [{
                divide: [...ge(), "hidden", "none"]
            }],
            "border-color": [{
                border: N()
            }],
            "border-color-x": [{
                "border-x": N()
            }],
            "border-color-y": [{
                "border-y": N()
            }],
            "border-color-s": [{
                "border-s": N()
            }],
            "border-color-e": [{
                "border-e": N()
            }],
            "border-color-t": [{
                "border-t": N()
            }],
            "border-color-r": [{
                "border-r": N()
            }],
            "border-color-b": [{
                "border-b": N()
            }],
            "border-color-l": [{
                "border-l": N()
            }],
            "divide-color": [{
                divide: N()
            }],
            "outline-style": [{
                outline: [...ge(), "none", "hidden"]
            }],
            "outline-offset": [{
                "outline-offset": [mt, Fe, Le]
            }],
            "outline-w": [{
                outline: ["", mt, Od, nl]
            }],
            "outline-color": [{
                outline: N()
            }],
            shadow: [{
                shadow: ["", "none", u, Op, kp]
            }],
            "shadow-color": [{
                shadow: N()
            }],
            "inset-shadow": [{
                "inset-shadow": ["none", d, Op, kp]
            }],
            "inset-shadow-color": [{
                "inset-shadow": N()
            }],
            "ring-w": [{
                ring: me()
            }],
            "ring-w-inset": ["ring-inset"],
            "ring-color": [{
                ring: N()
            }],
            "ring-offset-w": [{
                "ring-offset": [mt, nl]
            }],
            "ring-offset-color": [{
                "ring-offset": N()
            }],
            "inset-ring-w": [{
                "inset-ring": me()
            }],
            "inset-ring-color": [{
                "inset-ring": N()
            }],
            "text-shadow": [{
                "text-shadow": ["none", f, Op, kp]
            }],
            "text-shadow-color": [{
                "text-shadow": N()
            }],
            opacity: [{
                opacity: [mt, Fe, Le]
            }],
            "mix-blend": [{
                "mix-blend": [...ce(), "plus-darker", "plus-lighter"]
            }],
            "bg-blend": [{
                "bg-blend": ce()
            }],
            "mask-clip": [{
                "mask-clip": ["border", "padding", "content", "fill", "stroke", "view"]
            }, "mask-no-clip"],
            "mask-composite": [{
                mask: ["add", "subtract", "intersect", "exclude"]
            }],
            "mask-image-linear-pos": [{
                "mask-linear": [mt]
            }],
            "mask-image-linear-from-pos": [{
                "mask-linear-from": Z()
            }],
            "mask-image-linear-to-pos": [{
                "mask-linear-to": Z()
            }],
            "mask-image-linear-from-color": [{
                "mask-linear-from": N()
            }],
            "mask-image-linear-to-color": [{
                "mask-linear-to": N()
            }],
            "mask-image-t-from-pos": [{
                "mask-t-from": Z()
            }],
            "mask-image-t-to-pos": [{
                "mask-t-to": Z()
            }],
            "mask-image-t-from-color": [{
                "mask-t-from": N()
            }],
            "mask-image-t-to-color": [{
                "mask-t-to": N()
            }],
            "mask-image-r-from-pos": [{
                "mask-r-from": Z()
            }],
            "mask-image-r-to-pos": [{
                "mask-r-to": Z()
            }],
            "mask-image-r-from-color": [{
                "mask-r-from": N()
            }],
            "mask-image-r-to-color": [{
                "mask-r-to": N()
            }],
            "mask-image-b-from-pos": [{
                "mask-b-from": Z()
            }],
            "mask-image-b-to-pos": [{
                "mask-b-to": Z()
            }],
            "mask-image-b-from-color": [{
                "mask-b-from": N()
            }],
            "mask-image-b-to-color": [{
                "mask-b-to": N()
            }],
            "mask-image-l-from-pos": [{
                "mask-l-from": Z()
            }],
            "mask-image-l-to-pos": [{
                "mask-l-to": Z()
            }],
            "mask-image-l-from-color": [{
                "mask-l-from": N()
            }],
            "mask-image-l-to-color": [{
                "mask-l-to": N()
            }],
            "mask-image-x-from-pos": [{
                "mask-x-from": Z()
            }],
            "mask-image-x-to-pos": [{
                "mask-x-to": Z()
            }],
            "mask-image-x-from-color": [{
                "mask-x-from": N()
            }],
            "mask-image-x-to-color": [{
                "mask-x-to": N()
            }],
            "mask-image-y-from-pos": [{
                "mask-y-from": Z()
            }],
            "mask-image-y-to-pos": [{
                "mask-y-to": Z()
            }],
            "mask-image-y-from-color": [{
                "mask-y-from": N()
            }],
            "mask-image-y-to-color": [{
                "mask-y-to": N()
            }],
            "mask-image-radial": [{
                "mask-radial": [Fe, Le]
            }],
            "mask-image-radial-from-pos": [{
                "mask-radial-from": Z()
            }],
            "mask-image-radial-to-pos": [{
                "mask-radial-to": Z()
            }],
            "mask-image-radial-from-color": [{
                "mask-radial-from": N()
            }],
            "mask-image-radial-to-color": [{
                "mask-radial-to": N()
            }],
            "mask-image-radial-shape": [{
                "mask-radial": ["circle", "ellipse"]
            }],
            "mask-image-radial-size": [{
                "mask-radial": [{
                    closest: ["side", "corner"],
                    farthest: ["side", "corner"]
                }]
            }],
            "mask-image-radial-pos": [{
                "mask-radial-at": C()
            }],
            "mask-image-conic-pos": [{
                "mask-conic": [mt]
            }],
            "mask-image-conic-from-pos": [{
                "mask-conic-from": Z()
            }],
            "mask-image-conic-to-pos": [{
                "mask-conic-to": Z()
            }],
            "mask-image-conic-from-color": [{
                "mask-conic-from": N()
            }],
            "mask-image-conic-to-color": [{
                "mask-conic-to": N()
            }],
            "mask-mode": [{
                mask: ["alpha", "luminance", "match"]
            }],
            "mask-origin": [{
                "mask-origin": ["border", "padding", "content", "fill", "stroke", "view"]
            }],
            "mask-position": [{
                mask: B()
            }],
            "mask-repeat": [{
                mask: H()
            }],
            "mask-size": [{
                mask: ye()
            }],
            "mask-type": [{
                "mask-type": ["alpha", "luminance"]
            }],
            "mask-image": [{
                mask: ["none", Fe, Le]
            }],
            filter: [{
                filter: ["", "none", Fe, Le]
            }],
            blur: [{
                blur: ne()
            }],
            brightness: [{
                brightness: [mt, Fe, Le]
            }],
            contrast: [{
                contrast: [mt, Fe, Le]
            }],
            "drop-shadow": [{
                "drop-shadow": ["", "none", p, Op, kp]
            }],
            "drop-shadow-color": [{
                "drop-shadow": N()
            }],
            grayscale: [{
                grayscale: ["", mt, Fe, Le]
            }],
            "hue-rotate": [{
                "hue-rotate": [mt, Fe, Le]
            }],
            invert: [{
                invert: ["", mt, Fe, Le]
            }],
            saturate: [{
                saturate: [mt, Fe, Le]
            }],
            sepia: [{
                sepia: ["", mt, Fe, Le]
            }],
            "backdrop-filter": [{
                "backdrop-filter": ["", "none", Fe, Le]
            }],
            "backdrop-blur": [{
                "backdrop-blur": ne()
            }],
            "backdrop-brightness": [{
                "backdrop-brightness": [mt, Fe, Le]
            }],
            "backdrop-contrast": [{
                "backdrop-contrast": [mt, Fe, Le]
            }],
            "backdrop-grayscale": [{
                "backdrop-grayscale": ["", mt, Fe, Le]
            }],
            "backdrop-hue-rotate": [{
                "backdrop-hue-rotate": [mt, Fe, Le]
            }],
            "backdrop-invert": [{
                "backdrop-invert": ["", mt, Fe, Le]
            }],
            "backdrop-opacity": [{
                "backdrop-opacity": [mt, Fe, Le]
            }],
            "backdrop-saturate": [{
                "backdrop-saturate": [mt, Fe, Le]
            }],
            "backdrop-sepia": [{
                "backdrop-sepia": ["", mt, Fe, Le]
            }],
            "border-collapse": [{
                border: ["collapse", "separate"]
            }],
            "border-spacing": [{
                "border-spacing": T()
            }],
            "border-spacing-x": [{
                "border-spacing-x": T()
            }],
            "border-spacing-y": [{
                "border-spacing-y": T()
            }],
            "table-layout": [{
                table: ["auto", "fixed"]
            }],
            caption: [{
                caption: ["top", "bottom"]
            }],
            transition: [{
                transition: ["", "all", "colors", "opacity", "shadow", "transform", "none", Fe, Le]
            }],
            "transition-behavior": [{
                transition: ["normal", "discrete"]
            }],
            duration: [{
                duration: [mt, "initial", Fe, Le]
            }],
            ease: [{
                ease: ["linear", "initial", y, Fe, Le]
            }],
            delay: [{
                delay: [mt, Fe, Le]
            }],
            animate: [{
                animate: ["none", b, Fe, Le]
            }],
            backface: [{
                backface: ["hidden", "visible"]
            }],
            perspective: [{
                perspective: [v, Fe, Le]
            }],
            "perspective-origin": [{
                "perspective-origin": w()
            }],
            rotate: [{
                rotate: _e()
            }],
            "rotate-x": [{
                "rotate-x": _e()
            }],
            "rotate-y": [{
                "rotate-y": _e()
            }],
            "rotate-z": [{
                "rotate-z": _e()
            }],
            scale: [{
                scale: ee()
            }],
            "scale-x": [{
                "scale-x": ee()
            }],
            "scale-y": [{
                "scale-y": ee()
            }],
            "scale-z": [{
                "scale-z": ee()
            }],
            "scale-3d": ["scale-3d"],
            skew: [{
                skew: oe()
            }],
            "skew-x": [{
                "skew-x": oe()
            }],
            "skew-y": [{
                "skew-y": oe()
            }],
            transform: [{
                transform: [Fe, Le, "", "none", "gpu", "cpu"]
            }],
            "transform-origin": [{
                origin: w()
            }],
            "transform-style": [{
                transform: ["3d", "flat"]
            }],
            translate: [{
                translate: te()
            }],
            "translate-x": [{
                "translate-x": te()
            }],
            "translate-y": [{
                "translate-y": te()
            }],
            "translate-z": [{
                "translate-z": te()
            }],
            "translate-none": ["translate-none"],
            accent: [{
                accent: N()
            }],
            appearance: [{
                appearance: ["none", "auto"]
            }],
            "caret-color": [{
                caret: N()
            }],
            "color-scheme": [{
                scheme: ["normal", "dark", "light", "light-dark", "only-dark", "only-light"]
            }],
            cursor: [{
                cursor: ["auto", "default", "pointer", "wait", "text", "move", "help", "not-allowed", "none", "context-menu", "progress", "cell", "crosshair", "vertical-text", "alias", "copy", "no-drop", "grab", "grabbing", "all-scroll", "col-resize", "row-resize", "n-resize", "e-resize", "s-resize", "w-resize", "ne-resize", "nw-resize", "se-resize", "sw-resize", "ew-resize", "ns-resize", "nesw-resize", "nwse-resize", "zoom-in", "zoom-out", Fe, Le]
            }],
            "field-sizing": [{
                "field-sizing": ["fixed", "content"]
            }],
            "pointer-events": [{
                "pointer-events": ["auto", "none"]
            }],
            resize: [{
                resize: ["none", "", "y", "x"]
            }],
            "scroll-behavior": [{
                scroll: ["auto", "smooth"]
            }],
            "scroll-m": [{
                "scroll-m": T()
            }],
            "scroll-mx": [{
                "scroll-mx": T()
            }],
            "scroll-my": [{
                "scroll-my": T()
            }],
            "scroll-ms": [{
                "scroll-ms": T()
            }],
            "scroll-me": [{
                "scroll-me": T()
            }],
            "scroll-mt": [{
                "scroll-mt": T()
            }],
            "scroll-mr": [{
                "scroll-mr": T()
            }],
            "scroll-mb": [{
                "scroll-mb": T()
            }],
            "scroll-ml": [{
                "scroll-ml": T()
            }],
            "scroll-p": [{
                "scroll-p": T()
            }],
            "scroll-px": [{
                "scroll-px": T()
            }],
            "scroll-py": [{
                "scroll-py": T()
            }],
            "scroll-ps": [{
                "scroll-ps": T()
            }],
            "scroll-pe": [{
                "scroll-pe": T()
            }],
            "scroll-pt": [{
                "scroll-pt": T()
            }],
            "scroll-pr": [{
                "scroll-pr": T()
            }],
            "scroll-pb": [{
                "scroll-pb": T()
            }],
            "scroll-pl": [{
                "scroll-pl": T()
            }],
            "snap-align": [{
                snap: ["start", "end", "center", "align-none"]
            }],
            "snap-stop": [{
                snap: ["normal", "always"]
            }],
            "snap-type": [{
                snap: ["none", "x", "y", "both"]
            }],
            "snap-strictness": [{
                snap: ["mandatory", "proximity"]
            }],
            touch: [{
                touch: ["auto", "none", "manipulation"]
            }],
            "touch-x": [{
                "touch-pan": ["x", "left", "right"]
            }],
            "touch-y": [{
                "touch-pan": ["y", "up", "down"]
            }],
            "touch-pz": ["touch-pinch-zoom"],
            select: [{
                select: ["none", "text", "all", "auto"]
            }],
            "will-change": [{
                "will-change": ["auto", "scroll", "contents", "transform", Fe, Le]
            }],
            fill: [{
                fill: ["none", ...N()]
            }],
            "stroke-w": [{
                stroke: [mt, Od, nl, Gb]
            }],
            stroke: [{
                stroke: ["none", ...N()]
            }],
            "forced-color-adjust": [{
                "forced-color-adjust": ["auto", "none"]
            }]
        },
        conflictingClassGroups: {
            overflow: ["overflow-x", "overflow-y"],
            overscroll: ["overscroll-x", "overscroll-y"],
            inset: ["inset-x", "inset-y", "start", "end", "top", "right", "bottom", "left"],
            "inset-x": ["right", "left"],
            "inset-y": ["top", "bottom"],
            flex: ["basis", "grow", "shrink"],
            gap: ["gap-x", "gap-y"],
            p: ["px", "py", "ps", "pe", "pt", "pr", "pb", "pl"],
            px: ["pr", "pl"],
            py: ["pt", "pb"],
            m: ["mx", "my", "ms", "me", "mt", "mr", "mb", "ml"],
            mx: ["mr", "ml"],
            my: ["mt", "mb"],
            size: ["w", "h"],
            "font-size": ["leading"],
            "fvn-normal": ["fvn-ordinal", "fvn-slashed-zero", "fvn-figure", "fvn-spacing", "fvn-fraction"],
            "fvn-ordinal": ["fvn-normal"],
            "fvn-slashed-zero": ["fvn-normal"],
            "fvn-figure": ["fvn-normal"],
            "fvn-spacing": ["fvn-normal"],
            "fvn-fraction": ["fvn-normal"],
            "line-clamp": ["display", "overflow"],
            rounded: ["rounded-s", "rounded-e", "rounded-t", "rounded-r", "rounded-b", "rounded-l", "rounded-ss", "rounded-se", "rounded-ee", "rounded-es", "rounded-tl", "rounded-tr", "rounded-br", "rounded-bl"],
            "rounded-s": ["rounded-ss", "rounded-es"],
            "rounded-e": ["rounded-se", "rounded-ee"],
            "rounded-t": ["rounded-tl", "rounded-tr"],
            "rounded-r": ["rounded-tr", "rounded-br"],
            "rounded-b": ["rounded-br", "rounded-bl"],
            "rounded-l": ["rounded-tl", "rounded-bl"],
            "border-spacing": ["border-spacing-x", "border-spacing-y"],
            "border-w": ["border-w-x", "border-w-y", "border-w-s", "border-w-e", "border-w-t", "border-w-r", "border-w-b", "border-w-l"],
            "border-w-x": ["border-w-r", "border-w-l"],
            "border-w-y": ["border-w-t", "border-w-b"],
            "border-color": ["border-color-x", "border-color-y", "border-color-s", "border-color-e", "border-color-t", "border-color-r", "border-color-b", "border-color-l"],
            "border-color-x": ["border-color-r", "border-color-l"],
            "border-color-y": ["border-color-t", "border-color-b"],
            translate: ["translate-x", "translate-y", "translate-none"],
            "translate-none": ["translate", "translate-x", "translate-y", "translate-z"],
            "scroll-m": ["scroll-mx", "scroll-my", "scroll-ms", "scroll-me", "scroll-mt", "scroll-mr", "scroll-mb", "scroll-ml"],
            "scroll-mx": ["scroll-mr", "scroll-ml"],
            "scroll-my": ["scroll-mt", "scroll-mb"],
            "scroll-p": ["scroll-px", "scroll-py", "scroll-ps", "scroll-pe", "scroll-pt", "scroll-pr", "scroll-pb", "scroll-pl"],
            "scroll-px": ["scroll-pr", "scroll-pl"],
            "scroll-py": ["scroll-pt", "scroll-pb"],
            touch: ["touch-x", "touch-y", "touch-pz"],
            "touch-x": ["touch"],
            "touch-y": ["touch"],
            "touch-pz": ["touch"]
        },
        conflictingClassGroupModifiers: {
            "font-size": ["leading"]
        },
        orderSensitiveModifiers: ["*", "**", "after", "backdrop", "before", "details-content", "file", "first-letter", "first-line", "marker", "placeholder", "selection"]
    }
}
  , xye = oye(Eye);
function DOe({href: e, target: t="_blank", children: n, ...r}) {
    return g.jsx("a", {
        href: z_e(e),
        target: t,
        rel: "noopener",
        alt: e,
        ...r,
        children: n
    })
}
function uA(e) {
    "use forget";
    const t = De.c(14);
    let n, r, s, o, i;
    t[0] !== e ? ({className: r, openNewTab: o, children: n, underline: i, ...s} = e,
    t[0] = e,
    t[1] = n,
    t[2] = r,
    t[3] = s,
    t[4] = o,
    t[5] = i) : (n = t[1],
    r = t[2],
    s = t[3],
    o = t[4],
    i = t[5]);
    const a = o === void 0 ? !1 : o
      , c = (i === void 0 ? !0 : i) && "underline";
    let u;
    t[6] !== r || t[7] !== c ? (u = xye("cursor-pointer font-normal", c, r),
    t[6] = r,
    t[7] = c,
    t[8] = u) : u = t[8];
    const d = a ? "_blank" : "_self";
    let f;
    return t[9] !== n || t[10] !== s || t[11] !== u || t[12] !== d ? (f = g.jsx("a", {
        rel: "noopener",
        className: u,
        target: d,
        ...s,
        children: n
    }),
    t[9] = n,
    t[10] = s,
    t[11] = u,
    t[12] = d,
    t[13] = f) : f = t[13],
    f
}
function LOe(e, t, n) {
    const r = Math.floor((e.getTime() - t.getTime()) / 1e3);
    if (r < 60)
        return n.formatMessage({
            id: "hr1xff",
            defaultMessage: "{diffInSecs}s"
        }, {
            diffInSecs: r
        });
    if (r < 60 * 10) {
        const o = Math.floor(r / 60)
          , i = r % 60;
        return n.formatMessage({
            id: "7KZ91/",
            defaultMessage: "{mins}m {secs}s"
        }, {
            mins: o,
            secs: i
        })
    }
    if (r < 60 * 60) {
        const o = Math.floor(r / 60);
        return n.formatMessage({
            id: "IkyEWY",
            defaultMessage: "{mins}m"
        }, {
            mins: o
        })
    }
    const s = Math.floor(r / (60 * 60));
    if (r < 60 * 60 * 10) {
        const o = Math.floor(r % 3600 / 60);
        return n.formatMessage({
            id: "z9qVYm",
            defaultMessage: "{hours}h {mins}m"
        }, {
            hours: s,
            mins: o
        })
    }
    return n.formatMessage({
        id: "vAHzUw",
        defaultMessage: "{hours}h"
    }, {
        hours: s
    })
}
const Tye = ({givenDate: e, now: t, intl: n, format: r="abbreviated"}) => {
    const s = Math.floor((t.getTime() - e.getTime()) / 1e3);
    if (s < 60)
        return r === "abbreviated" ? n.formatMessage({
            id: "hepLPr",
            defaultMessage: "{seconds}s ago"
        }, {
            seconds: s
        }) : n.formatMessage({
            id: "cLJFUT",
            defaultMessage: "{seconds} seconds ago"
        }, {
            seconds: s
        });
    if (s < 3600) {
        const o = Math.floor(s / 60);
        return r === "abbreviated" ? n.formatMessage({
            id: "ZyHv9I",
            defaultMessage: "{minutes}m ago"
        }, {
            minutes: o
        }) : n.formatMessage({
            id: "RfRx5t",
            defaultMessage: "{minutes} minutes ago"
        }, {
            minutes: o
        })
    } else if (s < 86400) {
        const o = Math.floor(s / 3600);
        return r === "abbreviated" ? n.formatMessage({
            id: "2p4Gd3",
            defaultMessage: "{hours}h ago"
        }, {
            hours: o
        }) : n.formatMessage({
            id: "0d1QfF",
            defaultMessage: "{hours} hours ago"
        }, {
            hours: o
        })
    } else {
        const o = Math.floor(s / 86400);
        return r === "abbreviated" ? n.formatMessage({
            id: "KPjpqR",
            defaultMessage: "{days}d ago"
        }, {
            days: o
        }) : n.formatMessage({
            id: "n68thd",
            defaultMessage: "{days} days ago"
        }, {
            days: o
        })
    }
}
;
function K1({percentage: e, thickness: t=1 / 12, className: n, outerCircleClassName: r, sizeOverride: s, transitionDuration: o, transitionTimingFunction: i, onTransitionEnd: a}) {
    const l = s ?? 120
      , c = l * t
      , d = (l - c) / 2 - c - 2;
    return g.jsxs("svg", {
        width: l,
        height: l,
        viewBox: `0 0 ${l} ${l}`,
        className: n,
        children: [g.jsxs("g", {
            style: {
                transformOrigin: "50% 50%",
                animation: "spin 1s linear infinite"
            },
            className: r,
            children: [g.jsx("path", {
                fill: "url(#b)",
                fillOpacity: ".7",
                fillRule: "evenodd",
                d: `
        M${l} ${l / 2}
        A${l / 2} ${l / 2} 0 1 0 0 ${l / 2}
        A${l / 2} ${l / 2} 0 0 0 ${l} ${l / 2}
        Z
        M${l * .1042} ${l / 2}
        A${l * .3956} ${l * .3956} 0 1 0 ${l - l * .1042} ${l / 2}
        A${l * .3956} ${l * .3956} 0 0 0 ${l * .1042} ${l / 2}
        Z
      `,
                clipRule: "evenodd"
            }), g.jsx("defs", {
                children: g.jsxs("radialGradient", {
                    id: "b",
                    cx: "0",
                    cy: "0",
                    r: "1",
                    gradientTransform: `matrix(${l / 2 - l * .0625} 0 0 ${l / 2 - l * .0625} ${l * .0625} ${l / 2})`,
                    gradientUnits: "userSpaceOnUse",
                    children: [g.jsx("stop", {
                        stopColor: "#0285FF"
                    }), g.jsx("stop", {
                        offset: "1",
                        stopColor: "#0285FF",
                        stopOpacity: ".3"
                    })]
                })
            })]
        }), g.jsx("path", {
            className: "origin-[50%_50%] transition-[stroke-dashoffset]",
            d: e === 100 ? `M ${l / 2} ${l / 2}
         m 0 -${d}
         a ${d} ${d} 0 1 1 0 ${2 * d}
         a ${d} ${d} 0 1 1 0 -${2 * d}
         Z` : `M ${l / 2} ${l / 2}
         L ${l / 2} ${l / 2 - d}
         A ${d} ${d} 0 ${e > 50 ? 1 : 0} 1
         ${l / 2 + d * Math.sin(2 * Math.PI * e / 100)}
         ${l / 2 - d * Math.cos(2 * Math.PI * e / 100)}
         Z`,
            fill: "currentColor",
            style: {
                transitionDuration: o,
                transitionTimingFunction: i
            },
            onTransitionEnd: a
        })]
    })
}
function A4() {
    const e = ue();
    return un(e).isElectron
}
function kye({children: e}) {
    return g.jsx(ls, {
        label: g.jsx(de, {
            id: "8yqd2N",
            defaultMessage: "Temporarily unavailable"
        }),
        children: e
    })
}
const Oye = e => h.createElement("svg", {
    width: 20,
    height: 20,
    viewBox: "0 0 20 20",
    fill: "currentColor",
    xmlns: "http://www.w3.org/2000/svg",
    ...e
}, h.createElement("path", {
    d: "M11.2475 18.25C10.6975 18.25 10.175 18.1455 9.67999 17.9365C9.18499 17.7275 8.74499 17.436 8.35999 17.062C7.94199 17.205 7.50749 17.2765 7.05649 17.2765C6.31949 17.2765 5.63749 17.095 5.01049 16.732C4.38349 16.369 3.87749 15.874 3.49249 15.247C3.11849 14.62 2.93149 13.9215 2.93149 13.1515C2.93149 12.8325 2.97549 12.486 3.06349 12.112C2.62349 11.705 2.28249 11.2375 2.04049 10.7095C1.79849 10.1705 1.67749 9.6095 1.67749 9.0265C1.67749 8.4325 1.80399 7.8605 2.05699 7.3105C2.30999 6.7605 2.66199 6.2875 3.11299 5.8915C3.57499 5.4845 4.10849 5.204 4.71349 5.05C4.83449 4.423 5.08749 3.862 5.47249 3.367C5.86849 2.861 6.35249 2.465 6.92449 2.179C7.49649 1.893 8.10699 1.75 8.75599 1.75C9.30599 1.75 9.82849 1.8545 10.3235 2.0635C10.8185 2.2725 11.2585 2.564 11.6435 2.938C12.0615 2.795 12.496 2.7235 12.947 2.7235C13.684 2.7235 14.366 2.905 14.993 3.268C15.62 3.631 16.1205 4.126 16.4945 4.753C16.8795 5.38 17.072 6.0785 17.072 6.8485C17.072 7.1675 17.028 7.514 16.94 7.888C17.38 8.295 17.721 8.768 17.963 9.307C18.205 9.835 18.326 10.3905 18.326 10.9735C18.326 11.5675 18.1995 12.1395 17.9465 12.6895C17.6935 13.2395 17.336 13.718 16.874 14.125C16.423 14.521 15.895 14.796 15.29 14.95C15.169 15.577 14.9105 16.138 14.5145 16.633C14.1295 17.139 13.651 17.535 13.079 17.821C12.507 18.107 11.8965 18.25 11.2475 18.25ZM7.17199 16.1875C7.72199 16.1875 8.20049 16.072 8.60749 15.841L11.7095 14.059C11.8195 13.982 11.8745 13.8775 11.8745 13.7455V12.3265L7.88149 14.62C7.63949 14.763 7.39749 14.763 7.15549 14.62L4.03699 12.8215C4.03699 12.8545 4.03149 12.893 4.02049 12.937C4.02049 12.981 4.02049 13.047 4.02049 13.135C4.02049 13.696 4.15249 14.213 4.41649 14.686C4.69149 15.148 5.07099 15.511 5.55499 15.775C6.03899 16.05 6.57799 16.1875 7.17199 16.1875ZM7.33699 13.498C7.40299 13.531 7.46349 13.5475 7.51849 13.5475C7.57349 13.5475 7.62849 13.531 7.68349 13.498L8.92099 12.7885L4.94449 10.4785C4.70249 10.3355 4.58149 10.121 4.58149 9.835V6.2545C4.03149 6.4965 3.59149 6.8705 3.26149 7.3765C2.93149 7.8715 2.76649 8.4215 2.76649 9.0265C2.76649 9.5655 2.90399 10.0825 3.17899 10.5775C3.45399 11.0725 3.81149 11.4465 4.25149 11.6995L7.33699 13.498ZM11.2475 17.161C11.8305 17.161 12.3585 17.029 12.8315 16.765C13.3045 16.501 13.6785 16.138 13.9535 15.676C14.2285 15.214 14.366 14.697 14.366 14.125V10.561C14.366 10.429 14.311 10.33 14.201 10.264L12.947 9.538V14.1415C12.947 14.4275 12.826 14.642 12.584 14.785L9.46549 16.5835C10.0045 16.9685 10.5985 17.161 11.2475 17.161ZM11.8745 11.122V8.878L10.01 7.822L8.12899 8.878V11.122L10.01 12.178L11.8745 11.122ZM7.05649 5.8585C7.05649 5.5725 7.17749 5.358 7.41949 5.215L10.538 3.4165C9.99899 3.0315 9.40499 2.839 8.75599 2.839C8.17299 2.839 7.64499 2.971 7.17199 3.235C6.69899 3.499 6.32499 3.862 6.04999 4.324C5.78599 4.786 5.65399 5.303 5.65399 5.875V9.4225C5.65399 9.5545 5.70899 9.659 5.81899 9.736L7.05649 10.462V5.8585ZM15.4385 13.7455C15.9885 13.5035 16.423 13.1295 16.742 12.6235C17.072 12.1175 17.237 11.5675 17.237 10.9735C17.237 10.4345 17.0995 9.9175 16.8245 9.4225C16.5495 8.9275 16.192 8.5535 15.752 8.3005L12.6665 6.5185C12.6005 6.4745 12.54 6.458 12.485 6.469C12.43 6.469 12.375 6.4855 12.32 6.5185L11.0825 7.2115L15.0755 9.538C15.1965 9.604 15.2845 9.692 15.3395 9.802C15.4055 9.901 15.4385 10.022 15.4385 10.165V13.7455ZM12.122 5.3635C12.364 5.2095 12.606 5.2095 12.848 5.3635L15.983 7.195C15.983 7.118 15.983 7.019 15.983 6.898C15.983 6.37 15.851 5.8695 15.587 5.3965C15.334 4.9125 14.9655 4.5275 14.4815 4.2415C14.0085 3.9555 13.4585 3.8125 12.8315 3.8125C12.2815 3.8125 11.803 3.928 11.396 4.159L8.29399 5.941C8.18399 6.018 8.12899 6.1225 8.12899 6.2545V7.6735L12.122 5.3635Z"
}))
  , Aye = () => {
    const [e,t] = h.useState(!1)
      , n = ir();
    return !n?.data.profilePictureUrl || e ? g.jsx("span", {
        className: "bg-tertiary rounded-xl border-[0.5px] p-2 shadow-sm",
        children: g.jsx(Oye, {
            className: "h-8 w-8"
        })
    }) : g.jsx("span", {
        className: "h-12 w-12 overflow-hidden rounded-xl border-[0.5px] bg-black shadow-sm",
        children: g.jsx("img", {
            src: n.data.profilePictureUrl,
            alt: n.data.name ?? "",
            onError: () => t(!0)
        })
    })
}
  , Mye = ({title: e, connectorIcon: t, connectorDeveloper: n, onClose: r}) => g.jsxs(g.Fragment, {
    children: [g.jsx("div", {
        className: "flex justify-end pb-6",
        children: g.jsx(E6, {
            onClick: r
        })
    }), g.jsxs("div", {
        className: "flex flex-col items-center",
        children: [g.jsxs("div", {
            className: "flex items-center gap-2.5",
            children: [g.jsx(Aye, {}), g.jsxs("div", {
                className: "flex gap-1",
                children: [g.jsx("span", {
                    className: "h-1.5 w-1.5 rounded-full bg-gray-200"
                }), g.jsx("span", {
                    className: "h-1.5 w-1.5 rounded-full bg-gray-200"
                }), g.jsx("span", {
                    className: "h-1.5 w-1.5 rounded-full bg-gray-200"
                })]
            }), t]
        }), g.jsx("div", {
            className: "pt-4 text-center text-2xl font-semibold",
            children: e
        }), n && g.jsx("div", {
            className: "text-token-text-tertiary pt-1 text-sm",
            children: g.jsx(de, {
                ...Iye.developedBy,
                values: {
                    developer: n
                }
            })
        })]
    })]
})
  , Iye = xt({
    developedBy: {
        id: "yPpO4G",
        defaultMessage: "Developed by {developer}"
    }
})
  , Rye = e => h.createElement("svg", {
    width: 20,
    height: 20,
    viewBox: "0 0 20 20",
    fill: "currentColor",
    xmlns: "http://www.w3.org/2000/svg",
    ...e
}, h.createElement("path", {
    d: "M9.99512 12.3145C10.4837 12.3145 10.8701 12.6847 10.8701 13.1572C10.87 13.6296 10.4836 14 9.99512 14C9.50661 14 9.12021 13.6296 9.12012 13.1572C9.12012 12.6848 9.50655 12.3145 9.99512 12.3145Z"
}), h.createElement("path", {
    d: "M10.001 6C10.4785 6.00018 10.7792 6.29538 10.7793 6.78906C10.7793 6.83198 10.7788 6.89653 10.7734 6.9502L10.6934 10.666C10.6772 11.1222 10.4407 11.3906 9.99512 11.3906C9.54959 11.3906 9.31355 11.1222 9.30273 10.666L9.2168 6.9502C9.21679 6.89653 9.21094 6.83198 9.21094 6.78906C9.21102 6.29522 9.51782 6 10.001 6Z"
}), h.createElement("path", {
    fillRule: "evenodd",
    clipRule: "evenodd",
    d: "M10 2.08496C14.3713 2.08496 17.915 5.62867 17.915 10C17.915 14.3713 14.3713 17.915 10 17.915C5.62867 17.915 2.08496 14.3713 2.08496 10C2.08496 5.62867 5.62867 2.08496 10 2.08496ZM10 3.41504C6.3632 3.41504 3.41504 6.3632 3.41504 10C3.41504 13.6368 6.3632 16.585 10 16.585C13.6368 16.585 16.585 13.6368 16.585 10C16.585 6.3632 13.6368 3.41504 10 3.41504Z"
}))
  , Nye = e => h.createElement("svg", {
    width: 24,
    height: 24,
    viewBox: "0 0 24 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ...e
}, h.createElement("path", {
    d: "M21.0461 12.2099C21.0461 11.5553 20.9874 10.9259 20.8783 10.3217H12.1846V13.8966H17.1524C16.9342 15.0462 16.2797 16.0197 15.2979 16.6742V18.9987H18.2937C20.0391 17.3875 21.0461 15.0211 21.0461 12.2099Z",
    fill: "#4285F4"
}), h.createElement("path", {
    d: "M12.1844 21.2307C14.6767 21.2307 16.7662 20.4084 18.2935 18.9986L15.2977 16.6741C14.4753 17.2279 13.4264 17.5636 12.1844 17.5636C9.78441 17.5636 7.74525 15.944 7.01518 13.7622H3.94385V16.1454C5.46273 19.158 8.57602 21.2307 12.1844 21.2307Z",
    fill: "#34A853"
}), h.createElement("path", {
    d: "M7.01516 13.7539C6.83054 13.2 6.72145 12.6126 6.72145 12C6.72145 11.3874 6.83054 10.8 7.01516 10.2462V7.86295H3.94382C3.31445 9.10491 2.95361 10.5063 2.95361 12C2.95361 13.4937 3.31445 14.8951 3.94382 16.1371L6.33544 14.2741L7.01516 13.7539Z",
    fill: "#FBBC05"
}), h.createElement("path", {
    d: "M12.1844 6.44475C13.5439 6.44475 14.7522 6.91469 15.7173 7.82098L18.3606 5.17762C16.7578 3.68391 14.6767 2.76923 12.1844 2.76923C8.57602 2.76923 5.46273 4.84196 3.94385 7.86294L7.01518 10.2462C7.74525 8.06434 9.78441 6.44475 12.1844 6.44475Z",
    fill: "#EA4335"
}))
  , Pye = e => h.createElement("svg", {
    width: 20,
    height: 20,
    viewBox: "0 0 20 20",
    fill: "currentColor",
    xmlns: "http://www.w3.org/2000/svg",
    ...e
}, h.createElement("path", {
    d: "M10 9.25C10.4142 9.25002 10.75 9.5858 10.75 10V13.333C10.75 13.7472 10.4142 14.083 10 14.083C9.58579 14.083 9.25 13.7472 9.25 13.333V10C9.25 9.58579 9.58579 9.25 10 9.25Z"
}), h.createElement("path", {
    d: "M10 5.83301C10.5293 5.83303 10.958 6.26273 10.958 6.79199C10.9578 7.3211 10.5291 7.74998 10 7.75C9.47084 7.75 9.04217 7.32111 9.04199 6.79199C9.04199 6.26272 9.47073 5.83301 10 5.83301Z"
}), h.createElement("path", {
    fillRule: "evenodd",
    clipRule: "evenodd",
    d: "M10 2.08496C14.3713 2.08496 17.915 5.62867 17.915 10C17.915 14.3713 14.3713 17.915 10 17.915C5.62867 17.915 2.08496 14.3713 2.08496 10C2.08496 5.62867 5.62867 2.08496 10 2.08496ZM10 3.41504C6.3632 3.41504 3.41504 6.3632 3.41504 10C3.41504 13.6368 6.3632 16.585 10 16.585C13.6368 16.585 16.585 13.6368 16.585 10C16.585 6.3632 13.6368 3.41504 10 3.41504Z"
}))
  , M4 = ({footerContent: e, primaryButton: t, secondaryButton: n}) => !e && !t && !n ? null : g.jsxs("div", {
    className: "border-token-border-default flex items-center justify-between border-t p-6",
    children: [g.jsxs("div", {
        children: [e, " "]
    }), g.jsxs("div", {
        className: "flex gap-2",
        children: [n, t]
    })]
})
  , Dye = e => h.createElement("svg", {
    width: 16,
    height: 16,
    viewBox: "0 0 16 16",
    fill: "currentColor",
    xmlns: "http://www.w3.org/2000/svg",
    "data-rtl-flip": "",
    ...e
}, h.createElement("path", {
    d: "M6.80073 3.27765C7.05872 3.10739 7.40946 3.13571 7.63667 3.36261C7.89637 3.62231 7.89637 4.04432 7.63667 4.30402L4.60542 7.33527H13L13.1337 7.34894C13.4368 7.4109 13.665 7.6789 13.665 8.00031C13.6648 8.32162 13.4368 8.58979 13.1337 8.65168L13 8.66535H4.6064L7.63667 11.6966L7.72163 11.8011C7.89202 12.0592 7.86389 12.4098 7.63667 12.637C7.40942 12.8641 7.05879 12.8924 6.80073 12.722L6.69624 12.637L2.52925 8.47003C2.26993 8.21036 2.26982 7.78921 2.52925 7.5296L6.69624 3.36261L6.80073 3.27765Z"
}))
  , Lye = e => h.createElement("svg", {
    width: 16,
    height: 16,
    viewBox: "0 0 16 16",
    fill: "currentColor",
    xmlns: "http://www.w3.org/2000/svg",
    "data-rtl-flip": "",
    ...e
}, h.createElement("path", {
    d: "M8.36328 3.36261C8.59049 3.13571 8.94123 3.10739 9.19922 3.27765L9.30371 3.36261L13.4707 7.5296L13.5557 7.6341C13.7259 7.89208 13.6976 8.24282 13.4707 8.47003L9.30371 12.637C9.04407 12.8967 8.62299 12.8966 8.36328 12.637C8.10358 12.3773 8.10358 11.9563 8.36328 11.6966L11.3936 8.66535H3C2.63284 8.66535 2.33514 8.36743 2.33496 8.00031C2.33496 7.63304 2.63273 7.33527 3 7.33527H11.3945L8.36328 4.30402L8.27832 4.19953C8.10759 3.94137 8.13592 3.58997 8.36328 3.36261Z"
}))
  , jG = e => h.createElement("svg", {
    width: 24,
    height: 24,
    viewBox: "0 0 24 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ...e
}, h.createElement("g", {
    clipPath: "url(#clip0_5645_180)"
}, h.createElement("path", {
    d: "M12.2328 13.3571C15.3153 13.3571 17.8142 10.9267 17.8142 7.92857C17.8142 4.93045 15.3153 2.5 12.2328 2.5C9.15024 2.5 6.65137 4.93045 6.65137 7.92857C6.65137 10.9267 9.15024 13.3571 12.2328 13.3571Z",
    fill: "#036C70"
}), h.createElement("path", {
    d: "M16.8834 17.8815C19.709 17.8815 21.9997 15.6536 21.9997 12.9053C21.9997 10.157 19.709 7.92911 16.8834 7.92911C14.0577 7.92911 11.7671 10.157 11.7671 12.9053C11.7671 15.6536 14.0577 17.8815 16.8834 17.8815Z",
    fill: "#1A9BA1"
}), h.createElement("path", {
    d: "M12.93 21.4996C15.1135 21.4996 16.8835 19.778 16.8835 17.6543C16.8835 15.5307 15.1135 13.8091 12.93 13.8091C10.7466 13.8091 8.97656 15.5307 8.97656 17.6543C8.97656 19.778 10.7466 21.4996 12.93 21.4996Z",
    fill: "#37C6D0"
}), h.createElement("path", {
    opacity: .1,
    d: "M13.1628 7.39878V17.0526C13.1605 17.388 12.9515 17.6894 12.6326 17.8171C12.5311 17.8589 12.4219 17.8804 12.3117 17.8804H8.98144C8.9768 17.8035 8.9768 17.7312 8.9768 17.6543C8.97525 17.5787 8.97835 17.5032 8.9861 17.4281C9.07123 15.982 9.98715 14.7061 11.3535 14.1302V13.2888C8.31257 12.8201 6.23802 10.0424 6.71991 7.0847C6.72326 7.06422 6.72671 7.04375 6.73029 7.0233C6.75344 6.87073 6.78607 6.71966 6.82797 6.57092H12.3117C12.781 6.57266 13.1611 6.94229 13.1628 7.39878Z",
    fill: "currentColor"
}), h.createElement("path", {
    opacity: .2,
    d: "M11.8467 7.02365H6.73038C6.21354 9.97603 8.25531 12.7769 11.2908 13.2796C11.3827 13.2948 11.475 13.3078 11.5676 13.3185C10.1257 13.9835 9.07503 15.8722 8.98573 17.4284C8.97799 17.5036 8.97488 17.5791 8.97642 17.6546C8.97642 17.7315 8.97642 17.8039 8.98107 17.8808C8.98946 18.0329 9.00968 18.1841 9.04153 18.3332H11.8462C12.1911 18.3309 12.5009 18.1276 12.6322 17.8175C12.6752 17.7187 12.6973 17.6125 12.6973 17.5053V7.85151C12.6956 7.3952 12.3158 7.02564 11.8467 7.02365Z",
    fill: "currentColor"
}), h.createElement("path", {
    opacity: .2,
    d: "M11.8466 7.02365H6.73034C6.21361 9.97631 8.25569 12.7773 11.2915 13.2799C11.3536 13.2902 11.4158 13.2995 11.4783 13.3077C10.0829 14.0206 9.07361 15.9048 8.98616 17.4284H11.8466C12.3152 17.425 12.6942 17.0563 12.6978 16.6006V7.85151C12.696 7.39502 12.316 7.02539 11.8466 7.02365Z",
    fill: "currentColor"
}), h.createElement("path", {
    opacity: .2,
    d: "M11.3814 7.02365H6.73019C6.24226 9.81099 8.03799 12.4952 10.8558 13.1905C9.78883 14.3762 9.13442 15.8594 8.98601 17.4284H11.3814C11.8507 17.4267 12.2307 17.057 12.2325 16.6006V7.85151C12.2323 7.3944 11.8513 7.0239 11.3814 7.02365Z",
    fill: "currentColor"
}), h.createElement("path", {
    d: "M2.85256 7.02365H11.38C11.8509 7.02365 12.2326 7.3949 12.2326 7.85287V16.1468C12.2326 16.6048 11.8509 16.976 11.38 16.976H2.85256C2.3817 16.976 2 16.6048 2 16.1468V7.85287C2 7.3949 2.3817 7.02365 2.85256 7.02365Z",
    fill: "url(#paint0_linear_5645_180)"
}), h.createElement("path", {
    d: "M5.80776 11.8985C5.60797 11.7696 5.44108 11.598 5.31985 11.3968C5.20239 11.1865 5.14385 10.9499 5.15008 10.7106C5.13962 10.3866 5.25202 10.0702 5.46589 9.82165C5.69064 9.57277 5.98113 9.38847 6.30589 9.28874C6.67602 9.17025 7.0637 9.11186 7.45333 9.11593C7.96573 9.09772 8.47741 9.1674 8.96496 9.32177V10.3622C8.75312 10.2374 8.52238 10.1458 8.28124 10.0908C8.01958 10.0284 7.7511 9.99712 7.4817 9.99762C7.19761 9.98748 6.91534 10.0456 6.65984 10.1668C6.46259 10.2496 6.33467 10.4383 6.33426 10.6472C6.33346 10.774 6.38352 10.896 6.4738 10.9874C6.58043 11.0952 6.70656 11.1829 6.84589 11.2462C7.00093 11.3213 7.23349 11.4211 7.54357 11.5457C7.57771 11.5562 7.61099 11.5692 7.6431 11.5846C7.94828 11.7006 8.24269 11.8418 8.5231 12.0067C8.73546 12.134 8.91368 12.3086 9.04311 12.516C9.1758 12.7512 9.24011 13.0171 9.22915 13.2851C9.2443 13.6177 9.13968 13.945 8.93334 14.2107C8.72767 14.4549 8.45269 14.6349 8.14264 14.7282C7.77795 14.8394 7.39733 14.8931 7.01519 14.8874C6.67234 14.8889 6.32999 14.8617 5.99194 14.806C5.70651 14.7606 5.42796 14.6809 5.16264 14.5689V13.4719C5.41625 13.6481 5.69959 13.7798 5.99985 13.861C6.2991 13.9517 6.61017 14.0001 6.92357 14.0048C7.21363 14.0227 7.50318 13.9629 7.76078 13.832C7.94123 13.733 8.05098 13.5454 8.04637 13.3439C8.04757 13.2037 7.99055 13.069 7.88823 12.9702C7.76098 12.8487 7.61366 12.7489 7.45242 12.6748C7.26638 12.5843 6.99242 12.4651 6.63056 12.317C6.34269 12.2044 6.06706 12.0643 5.80776 11.8985Z",
    fill: "white"
})), h.createElement("defs", null, h.createElement("linearGradient", {
    id: "paint0_linear_5645_180",
    x1: 3.7776,
    y1: 6.37572,
    x2: 10.1808,
    y2: 17.7779,
    gradientUnits: "userSpaceOnUse"
}, h.createElement("stop", {
    stopColor: "#058F92"
}), h.createElement("stop", {
    offset: .5,
    stopColor: "#038489"
}), h.createElement("stop", {
    offset: 1,
    stopColor: "#026D71"
})), h.createElement("clipPath", {
    id: "clip0_5645_180"
}, h.createElement("rect", {
    width: 20,
    height: 19,
    fill: "white",
    transform: "translate(2 2.5)"
}))))
  , Fye = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20width='107'%20height='106'%20fill='none'%3e%3cg%20clip-path='url(%23a)'%3e%3cg%20filter='url(%23b)'%3e%3cpath%20fill='%23fff'%20d='M81.81%2053c0-15.464-12.535-28-28-28-15.463%200-28%2012.536-28%2028s12.537%2028%2028%2028c15.465%200%2028-12.536%2028-28Z'%20/%3e%3cpath%20stroke='%23000'%20stroke-linejoin='bevel'%20stroke-opacity='.1'%20d='M81.81%2053c0-15.464-12.535-28-28-28-15.463%200-28%2012.536-28%2028s12.537%2028%2028%2028c15.465%200%2028-12.536%2028-28Z'%20/%3e%3c/g%3e%3cpath%20fill='%23000'%20d='M49.287%2048.12v-3.905c0-.263.075-.45.337-.601l7.246-4.205c.977-.563%202.216-.826%203.417-.826%204.58%200%207.471%203.53%207.471%207.321%200%20.3%200%20.714-.075%201.051l-7.584-4.43c-.375-.225-.788-.263-1.239%200l-9.573%205.594ZM66.03%2061.972V53.3c0-.488-.187-.825-.638-1.088l-9.611-5.594%203.379-1.953a.717.717%200%200%201%20.675%200l7.284%204.205c2.065%201.202%203.492%203.83%203.492%206.345%200%202.966-1.802%205.707-4.58%206.758Zm-18.734-7.471-3.342-1.99c-.262-.15-.338-.338-.338-.6v-8.373c0-4.092%203.117-7.171%207.36-7.171a7.23%207.23%200%200%201%204.504%201.577l-7.546%204.392c-.45.263-.638.601-.638%201.09v11.075Zm6.533%203.754-4.543-2.553v-5.406l4.543-2.553%204.505%202.553v5.406l-4.505%202.553Zm2.815%2011.376a7.23%207.23%200%200%201-4.505-1.577l7.546-4.392c.45-.263.639-.601.639-1.09V51.499l3.379%201.99c.262.15.337.338.337.6v8.373c0%204.093-3.153%207.171-7.396%207.171Zm-8.86-8.297L40.5%2057.13c-2.065-1.202-3.491-3.83-3.491-6.345%200-3.004%201.84-5.707%204.618-6.758v8.71c0%20.488.187.826.638%201.09l9.574%205.556-3.38%201.952a.718.718%200%200%201-.675%200Zm-.45%206.082c-4.318%200-7.472-3.229-7.472-7.246%200-.375.038-.75.075-1.089l7.546%204.355c.451.263.826.263%201.277%200l9.574-5.556v3.904c0%20.263-.075.451-.338.601l-7.246%204.205c-.976.563-2.215.826-3.417.826Zm9.31%204.243c4.506%200%208.26-3.23%209.086-7.51%204.205-1.05%206.908-4.955%206.908-8.935%200-2.628-1.126-5.143-3.191-6.983.188-.788.338-1.614.338-2.403%200-5.294-4.318-9.273-9.274-9.273a9.197%209.197%200%200%200-3.003.525c-1.69-1.69-3.98-2.74-6.533-2.74-4.505%200-8.26%203.228-9.086%207.508-4.205%201.052-6.908%204.956-6.908%208.936%200%202.628%201.127%205.144%203.191%206.983-.187.789-.337%201.615-.337%202.403%200%205.294%204.317%209.274%209.273%209.274a9.2%209.2%200%200%200%203.004-.526c1.69%201.69%203.98%202.74%206.532%202.74Z'%20/%3e%3c/g%3e%3cdefs%3e%3cclipPath%20id='a'%3e%3cpath%20fill='%23fff'%20d='M.81%200h106v106H.81z'%20/%3e%3c/clipPath%3e%3cfilter%20id='b'%20width='105'%20height='105'%20x='1.311'%20y='4.5'%20color-interpolation-filters='sRGB'%20filterUnits='userSpaceOnUse'%20%3e%3cfeFlood%20flood-opacity='0'%20result='BackgroundImageFix'%20/%3e%3cfeColorMatrix%20in='SourceAlpha'%20result='hardAlpha'%20values='0%200%200%200%200%200%200%200%200%200%200%200%200%200%200%200%200%200%20127%200'%20/%3e%3cfeOffset%20dy='4'%20/%3e%3cfeGaussianBlur%20stdDeviation='12'%20/%3e%3cfeComposite%20in2='hardAlpha'%20operator='out'%20/%3e%3cfeColorMatrix%20values='0%200%200%200%200%200%200%200%200%200%200%200%200%200%200%200%200%200%200.06%200'%20/%3e%3cfeBlend%20in2='BackgroundImageFix'%20result='effect1_dropShadow_1235_2762'%20/%3e%3cfeBlend%20in='SourceGraphic'%20in2='effect1_dropShadow_1235_2762'%20result='shape'%20/%3e%3c/filter%3e%3c/defs%3e%3c/svg%3e";
function UG({children: e, className: t, style: n, ...r}) {
    return g.jsx("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 24 24",
        fill: "currentColor",
        className: t,
        ...r,
        style: n,
        children: e
    })
}
const jye = ({className: e}) => g.jsx("svg", {
    width: "18",
    height: "18",
    viewBox: "0 0 18 18",
    fill: "none",
    className: e,
    xmlns: "http://www.w3.org/2000/svg",
    children: g.jsx("path", {
        d: "M15.75 12V5.99999C15.7497 5.73694 15.6803 5.4786 15.5487 5.25086C15.417 5.02312 15.2278 4.83401 15 4.70249L9.75 1.70249C9.52197 1.57084 9.26331 1.50153 9 1.50153C8.73669 1.50153 8.47803 1.57084 8.25 1.70249L3 4.70249C2.7722 4.83401 2.58299 5.02312 2.45135 5.25086C2.31971 5.4786 2.25027 5.73694 2.25 5.99999V12C2.25027 12.263 2.31971 12.5214 2.45135 12.7491C2.58299 12.9769 2.7722 13.166 3 13.2975L8.25 16.2975C8.47803 16.4291 8.73669 16.4985 9 16.4985C9.26331 16.4985 9.52197 16.4291 9.75 16.2975L15 13.2975C15.2278 13.166 15.417 12.9769 15.5487 12.7491C15.6803 12.5214 15.7497 12.263 15.75 12Z",
        fill: "currentColor",
        stroke: "currentColor",
        strokeWidth: "2",
        strokeLinecap: "round",
        strokeLinejoin: "round"
    })
})
  , Uye = "ChatGPT"
  , I4 = ({className: e}) => g.jsxs("svg", {
    width: "24",
    height: "24",
    viewBox: "0 0 24 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    className: e,
    children: [g.jsx("text", {
        x: "-9999",
        y: "-9999",
        children: Uye
    }), g.jsx("path", {
        d: "M9.20509 8.76511V6.50545C9.20509 6.31513 9.27649 6.17234 9.44293 6.0773L13.9861 3.46088C14.6046 3.10413 15.342 2.93769 16.103 2.93769C18.9573 2.93769 20.7651 5.14983 20.7651 7.50454C20.7651 7.67098 20.7651 7.86129 20.7412 8.05161L16.0316 5.2924C15.7462 5.12596 15.4607 5.12596 15.1753 5.2924L9.20509 8.76511ZM19.8135 17.5659V12.1664C19.8135 11.8333 19.6708 11.5955 19.3854 11.429L13.4152 7.95633L15.3656 6.83833C15.5321 6.74328 15.6749 6.74328 15.8413 6.83833L20.3845 9.45474C21.6928 10.216 22.5728 11.8333 22.5728 13.4031C22.5728 15.2108 21.5025 16.8758 19.8135 17.5657V17.5659ZM7.80173 12.8088L5.8513 11.6671C5.68486 11.5721 5.61346 11.4293 5.61346 11.239V6.00613C5.61346 3.46111 7.56389 1.53433 10.2042 1.53433C11.2033 1.53433 12.1307 1.86743 12.9159 2.46202L8.2301 5.17371C7.94475 5.34015 7.80195 5.57798 7.80195 5.91109V12.809L7.80173 12.8088ZM12 15.2349L9.20509 13.6651V10.3351L12 8.76534L14.7947 10.3351V13.6651L12 15.2349ZM13.7958 22.4659C12.7967 22.4659 11.8693 22.1328 11.0841 21.5382L15.7699 18.8265C16.0553 18.6601 16.198 18.4222 16.198 18.0891V11.1912L18.1723 12.3329C18.3388 12.4279 18.4102 12.5707 18.4102 12.761V17.9939C18.4102 20.5389 16.4359 22.4657 13.7958 22.4657V22.4659ZM8.15848 17.1617L3.61528 14.5452C2.30696 13.784 1.42701 12.1667 1.42701 10.5969C1.42701 8.76534 2.52115 7.12414 4.20987 6.43428V11.8574C4.20987 12.1905 4.35266 12.4284 4.63802 12.5948L10.5846 16.0436L8.63415 17.1617C8.46771 17.2567 8.32492 17.2567 8.15848 17.1617ZM7.897 21.0625C5.20919 21.0625 3.23488 19.0407 3.23488 16.5432C3.23488 16.3529 3.25875 16.1626 3.2824 15.9723L7.96817 18.6839C8.25352 18.8504 8.53911 18.8504 8.82446 18.6839L14.7947 15.2351V17.4948C14.7947 17.6851 14.7233 17.8279 14.5568 17.9229L10.0136 20.5393C9.39518 20.8961 8.6578 21.0625 7.89677 21.0625H7.897ZM13.7958 23.8929C16.6739 23.8929 19.0762 21.8474 19.6235 19.1357C22.2874 18.4459 24 15.9484 24 13.4034C24 11.7383 23.2865 10.121 22.002 8.95542C22.121 8.45588 22.1924 7.95633 22.1924 7.45702C22.1924 4.0557 19.4331 1.51045 16.2458 1.51045C15.6037 1.51045 14.9852 1.60549 14.3668 1.81968C13.2963 0.773071 11.8215 0.107086 10.2042 0.107086C7.32606 0.107086 4.92383 2.15256 4.37653 4.86425C1.7126 5.55411 0 8.05161 0 10.5966C0 12.2617 0.713506 13.879 1.99795 15.0446C1.87904 15.5441 1.80764 16.0436 1.80764 16.543C1.80764 19.9443 4.56685 22.4895 7.75421 22.4895C8.39632 22.4895 9.01478 22.3945 9.63324 22.1803C10.7035 23.2269 12.1783 23.8929 13.7958 23.8929Z",
        fill: "currentColor"
    })]
});
function Bye({className: e}) {
    const t = gt();
    return g.jsx("img", {
        src: Fye,
        alt: t.formatMessage({
            id: "VJmCc9",
            defaultMessage: "ChatGPT logo"
        }),
        className: e
    })
}
const qye = ({className: e}) => g.jsx("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 1180 320",
    width: "118",
    height: "32",
    fill: "currentColor",
    className: e,
    children: g.jsx("path", {
        d: "M367.44 153.84c0 52.32 33.6 88.8 80.16 88.8s80.16-36.48 80.16-88.8-33.6-88.8-80.16-88.8-80.16 36.48-80.16 88.8zm129.6 0c0 37.44-20.4 61.68-49.44 61.68s-49.44-24.24-49.44-61.68 20.4-61.68 49.44-61.68 49.44 24.24 49.44 61.68zM614.27 242.64c35.28 0 55.44-29.76 55.44-65.52s-20.16-65.52-55.44-65.52c-16.32 0-28.32 6.48-36.24 15.84V114h-28.8v169.2h28.8v-56.4c7.92 9.36 19.92 15.84 36.24 15.84zm-36.96-69.12c0-23.76 13.44-36.72 31.2-36.72 20.88 0 32.16 16.32 32.16 40.32s-11.28 40.32-32.16 40.32c-17.76 0-31.2-13.2-31.2-36.48zM747.65 242.64c25.2 0 45.12-13.2 54-35.28L776.93 198c-3.84 12.96-15.12 20.16-29.28 20.16-18.48 0-31.44-13.2-33.6-34.8h88.32v-9.6c0-34.56-19.44-62.16-55.92-62.16s-60 28.56-60 65.52c0 38.88 25.2 65.52 61.2 65.52zm-1.44-106.8c18.24 0 26.88 12 27.12 25.92h-57.84c4.32-17.04 15.84-25.92 30.72-25.92zM823.98 240h28.8v-73.92c0-18 13.2-27.6 26.16-27.6 15.84 0 22.08 11.28 22.08 26.88V240h28.8v-83.04c0-27.12-15.84-45.36-42.24-45.36-16.32 0-27.6 7.44-34.8 15.84V114h-28.8zM1014.17 67.68 948.89 240h30.48l14.64-39.36h74.4l14.88 39.36h30.96l-65.28-172.32zm16.8 34.08 27.36 72h-54.24zM1163.69 68.18h-30.72V240.5h30.72zM297.06 130.97a79.712 79.712 0 0 0-6.85-65.48c-17.46-30.4-52.56-46.04-86.84-38.68A79.747 79.747 0 0 0 143.24 0C108.2-.08 77.11 22.48 66.33 55.82a79.754 79.754 0 0 0-53.31 38.67c-17.59 30.32-13.58 68.54 9.92 94.54a79.712 79.712 0 0 0 6.85 65.48c17.46 30.4 52.56 46.04 86.84 38.68a79.687 79.687 0 0 0 60.13 26.8c35.06.09 66.16-22.49 76.94-55.86a79.754 79.754 0 0 0 53.31-38.67c17.57-30.32 13.55-68.51-9.94-94.51zM176.78 299.08a59.77 59.77 0 0 1-38.39-13.88c.49-.26 1.34-.73 1.89-1.07l63.72-36.8a10.36 10.36 0 0 0 5.24-9.07v-89.83l26.93 15.55c.29.14.48.42.52.74v74.39c-.04 33.08-26.83 59.9-59.91 59.97zM47.94 244.05a59.71 59.71 0 0 1-7.15-40.18c.47.28 1.3.79 1.89 1.13l63.72 36.8c3.23 1.89 7.23 1.89 10.47 0l77.79-44.92v31.1c.02.32-.13.63-.38.83L129.87 266c-28.69 16.52-65.33 6.7-81.92-21.95zM31.17 104.96c7-12.16 18.05-21.46 31.21-26.29 0 .55-.03 1.52-.03 2.2v73.61c-.02 3.74 1.98 7.21 5.23 9.06l77.79 44.91L118.44 224c-.27.18-.61.21-.91.08l-64.42-37.22c-28.63-16.58-38.45-53.21-21.95-81.89zm221.26 51.49-77.79-44.92 26.93-15.54c.27-.18.61-.21.91-.08l64.42 37.19c28.68 16.57 38.51 53.26 21.94 81.94a59.94 59.94 0 0 1-31.2 26.28v-75.81c.03-3.74-1.96-7.2-5.2-9.06zm26.8-40.34c-.47-.29-1.3-.79-1.89-1.13l-63.72-36.8a10.375 10.375 0 0 0-10.47 0l-77.79 44.92V92c-.02-.32.13-.63.38-.83l64.41-37.16c28.69-16.55 65.37-6.7 81.91 22a59.95 59.95 0 0 1 7.15 40.1zm-168.51 55.43-26.94-15.55a.943.943 0 0 1-.52-.74V80.86c.02-33.12 26.89-59.96 60.01-59.94 14.01 0 27.57 4.92 38.34 13.88-.49.26-1.33.73-1.89 1.07L116 72.67a10.344 10.344 0 0 0-5.24 9.06l-.04 89.79zM125.35 140 160 119.99l34.65 20V180L160 200l-34.65-20z"
    })
})
  , Gye = e => g.jsxs(UG, {
    viewBox: "0 0 36 36",
    fill: "none",
    ...e,
    children: [g.jsx("circle", {
        cx: "18",
        cy: "18",
        r: "18",
        fill: "#3c46ff"
    }), g.jsx("path", {
        fillRule: "evenodd",
        clipRule: "evenodd",
        d: "m7.358 14.641 5.056-5.055A2 2 0 0 1 13.828 9h8.343a2 2 0 0 1 1.414.586l5.056 5.055a2 2 0 0 1 .055 2.771l-9.226 9.996a2 2 0 0 1-2.94 0l-9.227-9.996a2 2 0 0 1 .055-2.77Zm6.86-1.939-.426 1.281a2.07 2.07 0 0 1-1.31 1.31l-1.28.426a.296.296 0 0 0 0 .561l1.28.428a2.07 2.07 0 0 1 1.31 1.309l.427 1.28c.09.27.471.27.56 0l.428-1.28a2.07 2.07 0 0 1 1.309-1.31l1.281-.427a.296.296 0 0 0 0-.56l-1.281-.428a2.07 2.07 0 0 1-1.309-1.309l-.427-1.28a.296.296 0 0 0-.561 0z",
        fill: "#fff"
    })]
})
  , Vye = ({className: e}) => g.jsxs("svg", {
    width: "24",
    height: "24",
    viewBox: "0 0 24 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    className: e,
    children: [g.jsx("rect", {
        x: "2",
        y: "6",
        width: "5",
        height: "12",
        rx: "2",
        stroke: "currentColor",
        strokeWidth: "2"
    }), g.jsx("path", {
        d: "M2 12H1",
        stroke: "currentColor",
        strokeWidth: "2",
        strokeLinecap: "round",
        strokeLinejoin: "round"
    }), g.jsx("path", {
        d: "M22 12H23",
        stroke: "currentColor",
        strokeWidth: "2",
        strokeLinecap: "round",
        strokeLinejoin: "round"
    }), g.jsx("rect", {
        x: "17",
        y: "6",
        width: "5",
        height: "12",
        rx: "2",
        stroke: "currentColor",
        strokeWidth: "2"
    }), g.jsx("path", {
        d: "M7 12L12 12",
        stroke: "currentColor",
        strokeWidth: "2",
        strokeLinecap: "round",
        strokeLinejoin: "round"
    }), g.jsx("path", {
        d: "M16 12H17",
        stroke: "currentColor",
        strokeWidth: "2",
        strokeLinecap: "round",
        strokeLinejoin: "round"
    }), g.jsx("path", {
        d: "M9 3L15 21",
        stroke: "currentColor",
        strokeWidth: "2",
        strokeLinecap: "round",
        strokeLinejoin: "round"
    })]
})
  , Hye = ({className: e}) => g.jsx("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    width: "16",
    height: "14",
    fill: "none",
    className: e,
    children: g.jsx("path", {
        fill: "currentColor",
        stroke: "currentColor",
        strokeLinecap: "round",
        strokeLinejoin: "round",
        d: "M6.9 1.6 1.2 11a1.3 1.3 0 0 0 1.2 2h11.2a1.3 1.3 0 0 0 1.2-2L9 1.6a1.3 1.3 0 0 0-2.2 0Z"
    })
})
  , zye = ({className: e}) => g.jsxs("svg", {
    width: "24",
    height: "24",
    viewBox: "0 0 24 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    className: e,
    children: [g.jsx("path", {
        d: "M8.78158 8.60266L9.8188 5.49098C10.037 4.83634 10.963 4.83634 11.1812 5.49098L12.2184 8.60266C12.7187 10.1035 13.8965 11.2813 15.3973 11.7816L18.509 12.8188C19.1637 13.037 19.1637 13.963 18.509 14.1812L15.3973 15.2184C13.8965 15.7187 12.7187 16.8965 12.2184 18.3973L11.1812 21.509C10.963 22.1637 10.037 22.1637 9.8188 21.509L8.78158 18.3973C8.28128 16.8965 7.10354 15.7187 5.60266 15.2184L2.49098 14.1812C1.83634 13.963 1.83634 13.037 2.49098 12.8188L5.60266 11.7816C7.10354 11.2813 8.28128 10.1035 8.78158 8.60266Z",
        fill: "currentColor"
    }), g.jsx("path", {
        d: "M17.1913 3.69537L17.6794 2.23105C17.7821 1.92298 18.2179 1.92298 18.3206 2.23105L18.8087 3.69537C19.0441 4.40167 19.5983 4.9559 20.3046 5.19133L21.769 5.67944C22.077 5.78213 22.077 6.21787 21.769 6.32056L20.3046 6.80867C19.5983 7.0441 19.0441 7.59833 18.8087 8.30463L18.3206 9.76895C18.2179 10.077 17.7821 10.077 17.6794 9.76895L17.1913 8.30463C16.9559 7.59833 16.4017 7.0441 15.6954 6.80867L14.231 6.32056C13.923 6.21787 13.923 5.78213 14.231 5.67944L15.6954 5.19133C16.4017 4.9559 16.9559 4.40167 17.1913 3.69537Z",
        fill: "currentColor"
    })]
})
  , FOe = Object.freeze(Object.defineProperty({
    __proto__: null,
    GPT4FilledIcon: zye,
    Hexagon: jye,
    IconBase: UG,
    NoModelTrainingIcon: Vye,
    OpenaiLockup: qye,
    OpenaiLogo: I4,
    OpenaiLogoConditionalSvg: Bye,
    TriangleIcon: Hye,
    WorkspaceDefaultAvatar: Gye
}, Symbol.toStringTag, {
    value: "Module"
}))
  , BG = () => g.jsx(Y1, {
    ConnectorIcon: td
})
  , $ye = () => g.jsx(Y1, {
    ConnectorIcon: F1
})
  , Wye = () => g.jsx(Y1, {
    ConnectorIcon: MB
})
  , Kye = () => g.jsx(Y1, {
    ConnectorIcon: jG
})
  , Y1 = ({ConnectorIcon: e}) => g.jsxs("div", {
    className: "-mb-2 flex items-center justify-center gap-4 ps-2.5 pt-4",
    children: [g.jsx(I4, {
        className: "h-12 w-12"
    }), g.jsxs("div", {
        className: "text-token-text-secondary",
        children: [g.jsx(Dye, {
            className: "icon-sm me-1.5"
        }), g.jsx(Lye, {
            className: "icon-sm ms-1.5"
        })]
    }), g.jsx(e, {
        width: 48,
        height: 48
    })]
})
  , jOe = e => {
    switch (e) {
    case "google_drive_oauth":
    case "google_drive_dwd":
        return g.jsx(BG, {});
    case "slack":
        return g.jsx($ye, {});
    case "github":
        return g.jsx(Wye, {});
    case "sharepoint":
        return g.jsx(Kye, {});
    default:
        return null
    }
}
  , qG = new BroadcastChannel("oauth_channel")
  , UOe = e => {
    qG.postMessage(e)
}
;
async function GG({connectionId: e, connectorType: t, redirectTo: n, location: r, isReconnect: s, intl: o, isAdminQuickstartFlow: i=!1, accountId: a}) {
    const l = window.open("about:blank", "_blank");
    if (!l)
        throw new Error(o.formatMessage(Ap.popupBlocked));
    if (i && !a)
        throw new Error(o.formatMessage(Ap.somethingWentWrong));
    const c = Ot()
      , u = Xe(c, "4153230103");
    let d;
    try {
        d = await (i ? ka.admin_request_connect_quickstart(a ?? "", e, n) : ka.user_request_connect(e, n, u))
    } catch {
        throw l.close(),
        new Error(o.formatMessage(Ap.somethingWentWrong))
    }
    return V.logEventWithStatsig("Contextual Answers User OAuth Initiated", "chatgpt_contextual_answers_user_oauth_initiated", {
        connectorType: t,
        location: r,
        isReconnect: s,
        isAdminQuickstartFlow: i
    }),
    l.location.href = d.oauth_flow_url,
    new Promise(f => {
        const p = m => {
            const {error: v, errorDesc: _, errorType: y, pluginId: b, success: S} = m.data;
            if (m.origin === window.location.origin && !(d.plugin_id && d.plugin_id !== b))
                if (S)
                    V.logEventWithStatsig("Contextual Answers User OAuth Completed", "chatgpt_contextual_answers_user_oauth_completed", {
                        connectorType: t,
                        isAdminQuickstartFlow: i
                    }),
                    f({
                        success: !0,
                        message: o.formatMessage(Ap.connectedDriveSyncDesc)
                    });
                else {
                    V.logEventWithStatsig("Contextual Answers User OAuth Failed", "chatgpt_contextual_answers_user_oauth_failed", {
                        connectorType: t,
                        errorType: y,
                        isAdminQuickstartFlow: i
                    });
                    const C = `${v}${_ ? `: ${_}` : ""}`;
                    f({
                        errorType: y,
                        success: S,
                        message: C
                    })
                }
        }
        ;
        qG.addEventListener("message", p, !1),
        l.addEventListener("beforeunload", () => {
            window.removeEventListener("message", p, !1)
        }
        )
    }
    )
}
const Ap = xt({
    popupBlocked: {
        id: "67rWk2",
        defaultMessage: "Popup blocked. Please allow popups for this site."
    },
    connectedDriveSyncDesc: {
        id: "CACallback.connectedDriveSyncDesc.2",
        defaultMessage: "Google Drive is now connected and syncing."
    },
    somethingWentWrong: {
        id: "RvtOjD",
        defaultMessage: "Encountered an error connecting your account. Please try again later."
    }
})
  , Yye = $g( () => he( () => import("./ff7hu7wi6whn0zne.js"), __vite__mapDeps([6, 1, 7, 8, 9, 10, 11, 12])).then(e => e.GoogleRedirectContent))
  , R4 = {
    type: "success",
    size: "custom",
    className: "max-w-xl",
    showCloseButton: !0,
    shouldIgnoreClickOutside: !0,
    hideSeparator: !0,
    noPadding: !0,
    title: g.jsx(BG, {})
}
  , Zye = ({onClose: e, isAdminFlow: t, isAdminQuickstartFlow: n=!1, connectionId: r, location: s, accountId: o, onSuccess: i, excludeModalWrapper: a=!1}) => {
    const l = o4()?.enabled ?? !1
      , c = !t && l
      , [u,d] = h.useState(c ? "cta" : "disclaimer")
      , [f,p] = h.useState()
      , m = gt()
      , v = h.useCallback( () => {
        i?.(),
        e?.()
    }
    , [e, i])
      , _ = {
        connectionId: r,
        connectorType: "google_drive_oauth",
        location: s,
        isAdminQuickstartFlow: n,
        accountId: o,
        onSuccess: v,
        onError: y => {
            p(y),
            d("error")
        }
    };
    switch (u) {
    case "disclaimer":
        return g.jsx(Jye, {
            isOpen: !0,
            onClose: e,
            excludeModalWrapper: a,
            isAdminFlow: t,
            isAdminQuickstartFlow: n,
            secondaryButton: g.jsx(Xd, {
                title: m.formatMessage(Wc.cancel),
                color: "secondary",
                onClick: e
            }),
            primaryButton: g.jsx(Xd, {
                color: "primary",
                onClick: () => d("cta"),
                children: m.formatMessage(Wc.continue)
            })
        });
    case "cta":
        return c ? g.jsx(Qye, {
            onClose: e,
            isReconnect: !1,
            excludeModalWrapper: a,
            ..._
        }) : g.jsx(Xye, {
            isOpen: !0,
            onClose: e,
            excludeModalWrapper: a,
            secondaryButton: g.jsx(Xd, {
                title: m.formatMessage(Wc.back),
                color: "secondary",
                onClick: () => d("disclaimer")
            }),
            primaryButton: g.jsx(dA, {
                label: m.formatMessage(Wc.loginWithGoogle),
                ..._
            })
        });
    case "error":
        return c ? g.jsx(tbe, {
            onClose: e,
            error: f,
            excludeModalWrapper: a,
            isReconnect: !0,
            ..._
        }) : g.jsx(ebe, {
            isOpen: !0,
            onClose: e,
            error: f,
            excludeModalWrapper: a,
            primaryButton: g.jsx(dA, {
                label: m.formatMessage(Wc.reconnect),
                isReconnect: !0,
                ..._
            })
        })
    }
}
;
function Jye({isOpen: e, onClose: t, excludeModalWrapper: n, secondaryButton: r, primaryButton: s, isAdminFlow: o, isAdminQuickstartFlow: i}) {
    const a = g.jsxs(g.Fragment, {
        children: [g.jsxs("div", {
            className: "px-6 pt-4 pb-10",
            children: [g.jsx("div", {
                className: "text-xl font-medium",
                children: g.jsx(de, {
                    id: "zjbSLP",
                    defaultMessage: "Connect your organizationâ€™s Google Drive "
                })
            }), g.jsx("div", {
                className: "text-md text-token-text-secondary mt-3",
                children: i ? g.jsx(de, {
                    id: "YCbpE/",
                    defaultMessage: "Linking ChatGPT to Google Drive gives you more tailored answers based on your organization's context. Once you connect, others in your org can too."
                }) : g.jsx(de, {
                    id: "+hD78k",
                    defaultMessage: "{userText}Connecting ChatGPT to Google Drive helps you get more personalized, up-to-date answersâ€”grounded in your organizationâ€™s content. ChatGPT semantically searches your Drive and only surfaces content youâ€™re authorized to view.",
                    values: {
                        userText: !o && g.jsx(de, {
                            id: "kg6Qe+",
                            defaultMessage: "Your admin has enabled internal knowledge for your workspace. "
                        })
                    }
                })
            }), g.jsx("div", {
                className: "mt-6 text-lg font-medium",
                children: g.jsx(de, {
                    id: "x/LOXH",
                    defaultMessage: "What to expect"
                })
            }), g.jsxs("ul", {
                className: "text-md text-token-text-secondary ms-6 mt-4",
                children: [g.jsx("li", {
                    className: "mb-2 list-disc",
                    children: g.jsx(de, {
                        id: "iBETBV",
                        defaultMessage: "Continuous sync: Your documents, spreadsheets, and presentations stay up to date in ChatGPT."
                    })
                }), g.jsx("li", {
                    className: "mb-2 list-disc",
                    children: g.jsx(de, {
                        id: "u/D1Mk",
                        defaultMessage: "Privacy first: ChatGPT always respects your Google Drive permissions â€” it can only access what you can."
                    })
                }), g.jsx("li", {
                    className: "list-disc",
                    children: g.jsx(de, {
                        id: "uHiJ04",
                        defaultMessage: "Youâ€™re in control: Disconnect anytime to instantly revoke access."
                    })
                })]
            }), i && g.jsxs("div", {
                className: "bg-token-main-surface-secondary text-token-text-primary mt-6 flex w-full flex-row items-center gap-4 rounded-xl p-4",
                children: [g.jsx(Pu, {
                    className: "icon-lg"
                }), g.jsx("span", {
                    className: "text-token-text-secondary text-sm",
                    children: g.jsx(de, {
                        id: "k5y2IZ",
                        defaultMessage: "<b>Note</b>: Only users with the <i>same</i> Google Workspace domain can connect. Your email should look like <code>example.com</code> â€” personal accounts wonâ€™t work. Be sure youâ€™re using the right one.",
                        values: {
                            b: l => g.jsx("strong", {
                                children: l
                            }),
                            i: l => g.jsx("em", {
                                children: l
                            }),
                            code: l => g.jsx("code", {
                                children: l
                            })
                        }
                    })
                })]
            })]
        }), g.jsx(M4, {
            secondaryButton: r,
            primaryButton: s
        })]
    });
    return n ? a : g.jsx(Ti, {
        ...R4,
        isOpen: e,
        onClose: t,
        testId: "modal-gdrive-disclaimer",
        children: a
    })
}
function Xye({isOpen: e, onClose: t, excludeModalWrapper: n, secondaryButton: r, primaryButton: s}) {
    const o = g.jsxs(g.Fragment, {
        children: [g.jsxs("div", {
            className: "px-6 pt-4 pb-10",
            children: [g.jsx("div", {
                className: "mb-3 text-xl font-medium",
                children: g.jsx(de, {
                    id: "X4Rl7H",
                    defaultMessage: "Allow full access"
                })
            }), g.jsx("div", {
                children: g.jsx(de, {
                    id: "laPpDC",
                    defaultMessage: "<b>Important:</b> In the next step, make sure to keep all boxes checked. ChatGPT requires access to the full list of Google permissions.",
                    values: {
                        b: i => g.jsx("strong", {
                            children: i
                        })
                    }
                })
            })]
        }), g.jsx(M4, {
            secondaryButton: r,
            primaryButton: s
        })]
    });
    return n ? o : g.jsx(Ti, {
        ...R4,
        isOpen: e,
        onClose: t,
        testId: "modal-gdrive-cta",
        children: o
    })
}
function Qye({onClose: e, excludeModalWrapper: t, ...n}) {
    const {loading: r, initiateOAuthFlow: s} = N4(n)
      , o = g.jsx(Yye, {
        connectorIcon: g.jsx("div", {
            className: "rounded-xl border-[0.5px] bg-white p-2 shadow-sm",
            children: g.jsx(td, {
                height: 32,
                width: 32
            })
        }),
        connectorName: "Google Drive",
        onClose: e,
        isConnecting: r,
        onContinue: () => s()
    });
    return t ? o : g.jsx(Ti, {
        rootClassName: "z-100",
        testId: "modal-gdrive-cta-slurm",
        type: "success",
        isOpen: !0,
        onClose: e,
        size: "custom",
        className: "max-w-[400px]",
        children: o
    })
}
const VG = ({intl: e, error: t}) => {
    let n, r;
    switch (t?.errorType) {
    case "ca/oauth_api_access_error":
        {
            n = e.formatMessage({
                id: "LrBpzI",
                defaultMessage: "Permissions required"
            }),
            r = e.formatMessage({
                id: "E0lVhb",
                defaultMessage: "In order to sync your drive you must give ChatGPT the appropriate permissions. Please try again and select all the required checkboxes."
            });
            break
        }
    case "ca/oauth_missing_user_info_domain":
        {
            n = e.formatMessage({
                id: "CDqa2q",
                defaultMessage: "Cannot connect this account"
            }),
            r = e.formatMessage({
                id: "6Can6p",
                defaultMessage: "The Google account you are trying to connect does not belong to a Google Workspace domain. Google accounts that do not belong to a Google Workspace (such as personal Gmail accounts) are not eligible to connect to this specific feature at this time."
            });
            break
        }
    case "ca/oauth_has_existing_linked_openai_account":
        {
            n = e.formatMessage({
                id: "QSfIDZ",
                defaultMessage: "This Google account is already connected to a different ChatGPT account"
            }),
            r = e.formatMessage({
                id: "Z9Bj8k",
                defaultMessage: "The Google account you are trying to link is already connected to a different ChatGPT user for this Google Drive connection."
            });
            break
        }
    case "ca/oauth_connection_not_allowed":
        {
            n = e.formatMessage({
                id: "I3ekm6",
                defaultMessage: "Your ChatGPT account is not enabled for this connection"
            }),
            r = e.formatMessage({
                id: "0Vbazl",
                defaultMessage: "Your ChatGPT administrator has not enabled this connection for your account."
            });
            break
        }
    default:
        n = e.formatMessage({
            id: "ojfL45",
            defaultMessage: "Something went wrong"
        }),
        r = t?.message ?? e.formatMessage({
            id: "5MOzf8",
            defaultMessage: "We were unable to connect your Google account. Please check your settings and try again."
        })
    }
    return {
        title: n,
        body: r
    }
}
;
function ebe({isOpen: e, onClose: t, excludeModalWrapper: n, primaryButton: r, error: s}) {
    const o = gt()
      , {title: i, body: a} = VG({
        intl: o,
        error: s
    })
      , l = g.jsxs(g.Fragment, {
        children: [g.jsxs("div", {
            className: "px-6 pt-4 pb-10",
            children: [g.jsxs("div", {
                className: "mb-3 flex items-center gap-2 text-xl font-medium",
                children: [g.jsx(Rye, {
                    className: "icon-lg"
                }), i]
            }), g.jsx("div", {
                children: a
            })]
        }), g.jsx(M4, {
            primaryButton: r
        })]
    });
    return n ? l : g.jsx(Ti, {
        ...R4,
        isOpen: e,
        onClose: t,
        testId: "modal-gdrive-error",
        children: l
    })
}
function tbe({onClose: e, error: t, excludeModalWrapper: n, ...r}) {
    const s = gt()
      , {title: o, body: i} = VG({
        intl: s,
        error: t
    })
      , {loading: a, initiateOAuthFlow: l} = N4(r)
      , c = g.jsxs(g.Fragment, {
        children: [g.jsx(Mye, {
            onClose: e,
            connectorIcon: g.jsx("div", {
                className: "rounded-xl border-[0.5px] bg-white p-2 shadow-sm",
                children: g.jsx(td, {
                    height: 32,
                    width: 32
                })
            }),
            title: o
        }), g.jsxs("div", {
            className: "border-token-border-default text-token-text-secondary mt-8 mb-6 flex items-center gap-4 rounded-xl border p-4 text-sm",
            children: [g.jsx(Pye, {
                className: "icon-lg"
            }), i]
        }), g.jsx(an, {
            className: "w-full",
            size: "large",
            onClick: () => l(),
            loading: a,
            children: s.formatMessage(Wc.reconnect)
        })]
    });
    return n ? c : g.jsx(Ti, {
        testId: "modal-gdrive-error-slurm",
        rootClassName: "z-100",
        type: "success",
        isOpen: !0,
        onClose: e,
        size: "custom",
        className: "max-w-[400px]",
        children: c
    })
}
const N4 = ({connectorType: e, connectionId: t, location: n, isReconnect: r=!1, isAdminQuickstartFlow: s, accountId: o, onSuccess: i, onError: a}) => {
    const [l,c] = h.useState(!1)
      , u = gt()
      , d = Tn()
      , f = h.useCallback(async () => {
        try {
            c(!0);
            const {message: p, errorType: m, success: v} = await GG({
                connectorType: e,
                connectionId: t,
                location: n,
                isReconnect: r,
                intl: u,
                isAdminQuickstartFlow: s,
                accountId: o
            });
            v ? (d.success(p),
            i?.()) : (d.danger(p, {
                toastId: "google_drive_oauth_flow",
                loggingTitle: "Failed to initiate OAuth flow",
                loggingDescription: p
            }),
            a?.({
                errorType: m,
                message: p
            }))
        } catch (p) {
            a?.(),
            p instanceof Error && d.danger(p.message, {
                toastId: "google_drive_oauth_flow",
                loggingTitle: "Failed to initiate OAuth flow",
                loggingDescription: p.message
            })
        } finally {
            c(!1)
        }
    }
    , [e, t, n, r, u, s, o, d, i, a]);
    return {
        loading: l,
        initiateOAuthFlow: f
    }
}
  , dA = ({label: e, ...t}) => {
    const {loading: n, initiateOAuthFlow: r} = N4(t);
    return g.jsx(Xd, {
        loading: n,
        onClick: r,
        color: "primary",
        children: g.jsxs("div", {
            className: "flex items-center gap-2",
            children: [g.jsx(Nye, {}), e]
        })
    })
}
  , Wc = xt({
    back: {
        id: "RDaXnk",
        defaultMessage: "Back"
    },
    cancel: {
        id: "CfN1/v",
        defaultMessage: "Cancel"
    },
    continue: {
        id: "XGnWba",
        defaultMessage: "Continue"
    },
    loginWithGoogle: {
        id: "9ImAmL",
        defaultMessage: "Log in with Google"
    },
    reconnect: {
        id: "0qUCBD",
        defaultMessage: "Reconnect"
    },
    encounteredError: {
        id: "FNXFnS",
        defaultMessage: "Encountered an error connecting your account. Please try again later."
    }
})
  , nbe = ({connectorType: e, connectionId: t, location: n, refetch: r, renderButton: s}) => {
    const o = gt()
      , [i,a] = h.useState(!1)
      , l = Tn()
      , c = A4()
      , u = fhe()
      , d = e === "google_drive_oauth"
      , f = h.useCallback(async () => {
        try {
            a(!0),
            await GG({
                connectorType: e,
                connectionId: t,
                location: n,
                intl: o
            })
        } catch (y) {
            y instanceof Error ? l.danger(y.message, {
                toastId: "ca_oauth_button"
            }) : l.danger(o.formatMessage({
                id: "FNXFnS",
                defaultMessage: "Encountered an error connecting your account. Please try again later."
            }), {
                toastId: "ca_oauth_button",
                loggingTitle: "Encountered an error connecting your account.",
                loggingDescription: "Error message shown when a user tries to link their account but it fails."
            })
        } finally {
            a(!1),
            r?.()
        }
    }
    , [t, e, o, n, r, l])
      , [p,m] = h.useState(!1)
      , v = s({
        disabled: c || u,
        isLoading: i,
        onClick: () => {
            d ? m(!0) : f()
        }
    })
      , _ = v;
    return c ? g.jsx(ls, {
        label: o.formatMessage(rbe.gdriveTooltip),
        children: v
    }) : u ? g.jsx(kye, {
        children: v
    }) : g.jsxs(g.Fragment, {
        children: [_, p && g.jsx(Zye, {
            isAdminFlow: !1,
            onClose: () => m(!1),
            connectionId: t,
            location: n,
            onSuccess: r
        })]
    })
}
  , rbe = xt({
    gdriveTooltip: {
        id: "9DbE+w",
        defaultMessage: "Cannot connect, please use the web version instead"
    }
})
  , HG = ({startDate: e, now: t, scale: n}) => {
    const r = t.getTime() - e.getTime();
    if (r <= 0)
        return 0;
    const s = r / n
      , o = Math.min(1, Math.log1p(s * 9) / Math.log1p(10));
    return Math.round(o * 100)
}
  , zG = (e=1e3) => {
    const [t,n] = h.useState(new Date);
    return h.useEffect( () => {
        const r = setInterval( () => {
            n(new Date)
        }
        , e);
        return () => clearInterval(r)
    }
    , [e]),
    t
}
  , sbe = ({connection: e}) => {
    const t = gt()
      , n = zG()
      , r = e.user_connection_details.initialized_at
      , s = r ? HG({
        startDate: new Date(r),
        now: n,
        scale: 1e3 * 60 * 60 * 3
    }) / 2 : 25;
    return g.jsx(ls, {
        label: t.formatMessage({
            id: "69GKr/",
            defaultMessage: "Syncing may take 8 hours or longer"
        }),
        side: "right",
        children: g.jsxs("div", {
            className: "text-caption-regular text-token-text-tertiary flex items-center gap-2 grayscale",
            children: [g.jsx(K1, {
                sizeOverride: 18,
                percentage: s
            }), g.jsx(de, {
                id: "fYaL40",
                defaultMessage: "Syncing"
            })]
        })
    })
}
  , obe = ({className: e, connection: t, ignoreLabel: n=!1}) => {
    const r = gt()
      , s = zG()
      , o = t.user_connection_details.initialized_at
      , i = o ? HG({
        startDate: new Date(o),
        now: s,
        scale: 1e3 * 60 * 60 * 6
    }) / 2 + 50 : 75;
    return g.jsx(ls, {
        label: r.formatMessage({
            id: "lsQnba",
            defaultMessage: "Last 30 days synced"
        }),
        secondaryLabel: r.formatMessage({
            id: "j+cskE",
            defaultMessage: "Full sync can take up to few days"
        }),
        side: "right",
        children: g.jsxs("div", {
            className: we("text-caption-regular text-token-text-tertiary flex items-center gap-2", e),
            children: [g.jsx(K1, {
                sizeOverride: 18,
                percentage: i,
                className: "text-blue-400"
            }), !n && g.jsx(de, {
                id: "k4otrZ",
                defaultMessage: "Partially synced"
            })]
        })
    })
}
  , ibe = ({connection: e, location: t, inactiveButtonOverride: n}) => {
    const [r,s] = h.useState(new Date);
    h.useEffect( () => {
        const l = setInterval( () => {
            s(new Date)
        }
        , 1e3);
        return () => clearInterval(l)
    }
    , []);
    const {refetch: o} = _h({
        skip: !0
    })
      , i = gt();
    switch (e.user_connection_details.activation_status) {
    case "activated":
        {
            const l = e.user_connection_details.last_delta_sync_completed_at ?? e.user_connection_details.last_full_sync_completed_at;
            return l ? g.jsx("div", {
                className: "text-body-small-regular",
                children: Tye({
                    now: r,
                    givenDate: new Date(l),
                    intl: i
                })
            }) : g.jsxs("div", {
                className: "text-caption-regular text-token-text-tertiary flex items-center gap-2 grayscale",
                children: [g.jsx(g4, {
                    className: "icon-sm"
                }), g.jsx(de, {
                    id: "SWdiTP",
                    defaultMessage: "Synced"
                })]
            })
        }
    case "activating":
        return g.jsx(sbe, {
            connection: e
        });
    case "partially_activated":
        return g.jsx(obe, {
            connection: e
        });
    case "inactive":
        return n || g.jsx(abe, {
            connection: e,
            refetch: o,
            location: t
        })
    }
}
  , fA = "https://help.openai.com/en/articles/10929079-google-workspace-admin-managed-setup#h_856676fdde"
  , $G = ({displayName: e, connectorType: t}) => g.jsx(ls, {
    withArrow: !0,
    interactive: !0,
    label: g.jsx(uA, {
        openNewTab: !0,
        underline: !1,
        href: fA,
        children: g.jsx(de, {
            id: "H0Humf",
            defaultMessage: "We were unable to connect your account to {connector_name}. Click to learn more.",
            values: {
                connector_name: t === "google_drive_dwd" ? "Google Drive" : e
            }
        })
    }),
    sideOffset: 0,
    children: g.jsx(uA, {
        className: "hover:bg-token-interactive-bg-secondary-hover block rounded-full p-2",
        href: fA,
        openNewTab: !0,
        children: g.jsx(Pu, {
            className: "icon"
        })
    })
})
  , BOe = ({connection: e}) => {
    switch (e.user_connection_details.auth_status) {
    case "admin_connected":
        return g.jsx(de, {
            id: "Isczat",
            defaultMessage: "Connected"
        });
    case "admin_managed_disconnected":
        return g.jsx($G, {
            displayName: e.connection_display_info.display_name,
            connectorType: e.user_connection_details.knowledge_connector_type
        });
    case "not_connected":
        return g.jsx(de, {
            id: "9ZiK24",
            defaultMessage: "Connect"
        });
    case "user_connected":
        return g.jsx(K1, {
            sizeOverride: 18,
            percentage: 0,
            className: "text-blue-400"
        })
    }
}
  , abe = ({connection: e, refetch: t, location: n}) => {
    const r = h.useMemo( () => {
        switch (e.user_connection_details.auth_status) {
        case "admin_connected":
            return g.jsx(an, {
                disabled: !0,
                size: "small",
                color: "ghost",
                children: g.jsx(de, {
                    id: "Isczat",
                    defaultMessage: "Connected"
                })
            });
        case "admin_managed_disconnected":
            return g.jsx($G, {
                displayName: e.connection_display_info.display_name
            });
        case "not_connected":
            return g.jsx(lbe, {
                connection: e,
                location: n,
                refetch: t
            });
        case "user_connected":
            return g.jsx(K1, {
                sizeOverride: 18,
                percentage: 0,
                className: "text-blue-400"
            })
        }
    }
    , [e, n, t]);
    return g.jsx(g.Fragment, {
        children: r
    })
}
  , lbe = ({connection: e, location: t, refetch: n}) => {
    const r = ({disabled: s, isLoading: o, onClick: i}) => g.jsx(an, {
        size: "small",
        disabled: s,
        loading: o,
        onClick: i,
        color: "secondary",
        children: g.jsx(de, {
            id: "9ZiK24",
            defaultMessage: "Connect"
        })
    });
    return g.jsx(nbe, {
        connectorType: e.user_connection_details.knowledge_connector_type,
        connectionId: e.user_connection_details.connection_instance_id,
        location: t,
        refetch: n,
        renderButton: r
    })
}
  , cbe = ["admin_connected", "admin_managed_disconnected"];
function ube({connection: e, refetch: t}) {
    const n = Tn()
      , [r,s] = h.useState(!1);
    if (cbe.includes(e.user_connection_details.auth_status))
        return null;
    const o = async () => {
        try {
            s(!0),
            await ka.user_disconnect(e.user_connection_details.connection_instance_id),
            n.success("Successfully disconnected your account.")
        } catch {
            n.danger("Encountered an error disconnecting your account. Please try again later.", {
                toastId: "ca_disconnect_button"
            })
        } finally {
            s(!1),
            t?.()
        }
    }
    ;
    return g.jsxs(Dt.Root, {
        children: [g.jsx(Dt.BasicTrigger, {
            children: g.jsx("button", {
                type: "button",
                className: "text-token-text-secondary focus-visible:bg-token-surface-hover enabled:hover:bg-token-surface-hover disabled:text-token-text-quaternary h-8 rounded-lg px-2 focus-visible:outline-0",
                children: g.jsx(G_e, {
                    className: "icon-sm"
                })
            })
        }), g.jsx(Dt.Portal, {
            children: g.jsx(Dt.Content, {
                size: "small",
                align: "end",
                children: g.jsx(Dt.Item, {
                    disabled: r,
                    onClick: o,
                    icon: g.jsx(V_e, {}),
                    color: "danger",
                    children: g.jsx(de, {
                        id: "iHFV22",
                        defaultMessage: "Disconnect"
                    })
                })
            })
        })]
    })
}
const xh = () => {
    const e = nc();
    return At({
        queryKey: ["user_connection_status"],
        queryFn: ka.user_connection_status,
        enabled: e
    })
}
  , dbe = new Set(["gdrive_sync_connector", "sharepoint_sync_connector", "github_sync_connector"]);
function qOe() {
    const e = ue()
      , t = Xe(e, "2509278897")
      , {data: n, isLoading: r, refetch: s} = xh()
      , o = h.useMemo( () => t ? n?.connection_statuses.filter(i => !dbe.has(i.user_connection_details.connection_type)) : n?.connection_statuses, [n, t]);
    return h.useEffect( () => {
        V.logEventWithStatsig("Contextual Answers User Settings Modal Shown", "chatgpt_contextual_answers_user_settings_modal_shown")
    }
    , []),
    t && !o?.length ? null : g.jsx(dae, {
        description: g.jsx(de, {
            id: "yjIap+",
            defaultMessage: "These connectors are only available to a limited number of users."
        }),
        title: g.jsx(de, {
            id: "5C8Bnt",
            defaultMessage: "Beta connectors"
        }),
        children: g.jsx("div", {
            className: "border-b",
            children: r ? g.jsx("div", {
                className: "p-2",
                children: g.jsx(o1e, {
                    lines: 4
                })
            }) : o?.length ? g.jsx("div", {
                children: o.map(i => g.jsx(fae, {
                    children: g.jsx(jge, {
                        icon: g.jsx("img", {
                            src: i.connection_display_info.icon_url ?? "",
                            alt: i.connection_display_info.display_name,
                            className: "icon-lg"
                        }),
                        title: i.connection_display_info.display_name,
                        statusIndicator: g.jsxs("div", {
                            className: "flex items-center gap-2",
                            children: [g.jsx(ibe, {
                                connection: i,
                                location: "user_settings"
                            }), i.user_connection_details?.activation_status !== "inactive" && g.jsx(ube, {
                                connection: i,
                                refetch: s
                            })]
                        })
                    })
                }, i.user_connection_details.connection_instance_id))
            }) : g.jsx("p", {
                className: "text-token-text-secondary my-2",
                children: g.jsx(de, {
                    id: "nzXh59",
                    defaultMessage: "No connections found."
                })
            })
        })
    })
}
const WG = e => h.createElement("svg", {
    width: 24,
    height: 24,
    viewBox: "0 0 24 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ...e
}, h.createElement("path", {
    d: "M3.31302 16.7412C3.11928 17.0571 2.90169 17.4237 2.71689 17.7158C2.63737 17.8502 2.61375 18.0104 2.65109 18.162C2.68844 18.3136 2.78377 18.4445 2.91659 18.5266L6.79145 20.9111C6.85879 20.9527 6.93372 20.9804 7.01189 20.9928C7.09007 21.0051 7.1699 21.0017 7.24676 20.9828C7.32361 20.964 7.39593 20.93 7.45952 20.8829C7.5231 20.8358 7.57667 20.7765 7.6171 20.7084C7.77209 20.4491 7.9718 20.1123 8.18938 19.7516C9.72443 17.2181 11.2684 17.5281 14.0523 18.8574L17.8944 20.6846C17.9664 20.7189 18.0446 20.7383 18.1243 20.7419C18.204 20.7454 18.2836 20.7329 18.3583 20.7051C18.4331 20.6773 18.5015 20.6348 18.5596 20.5801C18.6176 20.5253 18.6641 20.4595 18.6962 20.3865L20.5413 16.2136C20.6039 16.0703 20.6078 15.9082 20.552 15.7621C20.4963 15.6161 20.3854 15.4977 20.2432 15.4327C19.4324 15.0511 17.8199 14.2911 16.3683 13.5906C11.1462 11.0541 6.708 11.218 3.31302 16.7412Z",
    fill: "#1868DB"
}), h.createElement("path", {
    d: "M20.6871 7.27164C20.8808 6.95569 21.0984 6.58907 21.2832 6.29696C21.3627 6.16259 21.3864 6.00239 21.349 5.85079C21.3117 5.69919 21.2163 5.56829 21.0835 5.48622L17.2086 3.10169C17.1408 3.056 17.0643 3.02476 16.9839 3.00991C16.9034 2.99506 16.8208 2.99692 16.7411 3.01537C16.6615 3.03382 16.5864 3.06847 16.5207 3.11717C16.455 3.16586 16.4 3.22756 16.3592 3.29842C16.2042 3.55773 16.0045 3.89455 15.7869 4.25521C14.2518 6.78877 12.7078 6.47878 9.92391 5.14941L6.09376 3.3312C6.02173 3.29692 5.94356 3.27744 5.86387 3.27392C5.78419 3.2704 5.7046 3.28291 5.62984 3.3107C5.55507 3.3385 5.48664 3.38101 5.4286 3.43573C5.37057 3.49045 5.3241 3.55627 5.29196 3.62927L3.44693 7.8022C3.38427 7.94545 3.38041 8.10758 3.43616 8.25366C3.49192 8.39973 3.60283 8.51806 3.745 8.58313C4.55574 8.96466 6.16827 9.72473 7.61986 10.4252C12.8539 12.9587 17.2921 12.7888 20.6871 7.27164Z",
    fill: "#1868DB"
}))
  , KG = e => h.createElement("svg", {
    width: 24,
    height: 24,
    viewBox: "0 0 24 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ...e
}, h.createElement("path", {
    d: "M20.248 3H11.5801C11.5801 4.03775 11.9923 5.03299 12.7261 5.76679C13.4599 6.50058 14.4552 6.91283 15.4929 6.91283H17.0896V8.45439C17.091 10.6134 18.8409 12.3633 20.9999 12.3647V3.75198C20.9999 3.33667 20.6633 3 20.248 3Z",
    fill: "#1868DB"
}), h.createElement("path", {
    d: "M15.9594 7.31897H7.2915C7.29289 9.47801 9.04279 11.2279 11.2018 11.2293H12.7985V12.7759C12.8013 14.9349 14.5523 16.6837 16.7114 16.6837V8.07095C16.7114 7.65564 16.3747 7.31897 15.9594 7.31897Z",
    fill: "#1868DB"
}), h.createElement("path", {
    d: "M11.6679 11.6353H3C3 13.7963 4.75183 15.5481 6.91283 15.5481H8.51455V17.0897C8.51593 19.2468 10.2628 20.9959 12.4199 21V12.3873C12.4199 11.972 12.0832 11.6353 11.6679 11.6353Z",
    fill: "#1868DB"
}))
  , fbe = e => h.createElement("svg", {
    width: 24,
    height: 24,
    viewBox: "0 0 24 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ...e
}, h.createElement("path", {
    d: "M10.2176 2.46545L10.1154 2.52723C9.95295 2.62551 9.7999 2.73539 9.65708 2.85546L9.95168 2.64823H12.4521L12.9067 6.0902L10.6338 8.36303L8.36102 9.94282V11.7645C8.36102 13.0368 9.026 14.2166 10.1145 14.8755L12.5071 16.3238L7.45189 19.2727H6.4769L4.65967 18.1727C3.57121 17.5139 2.90625 16.334 2.90625 15.0617V8.93605C2.90625 7.66332 3.57164 6.48318 4.66065 5.82447L10.1154 2.525C10.1492 2.50455 10.1833 2.4847 10.2176 2.46545Z",
    fill: "url(#paint0_radial_376_5370)"
}), h.createElement("path", {
    d: "M10.2176 2.46545L10.1154 2.52723C9.95295 2.62551 9.7999 2.73539 9.65708 2.85546L9.95168 2.64823H12.4521L12.9067 6.0902L10.6338 8.36303L8.36102 9.94282V11.7645C8.36102 13.0368 9.026 14.2166 10.1145 14.8755L12.5071 16.3238L7.45189 19.2727H6.4769L4.65967 18.1727C3.57121 17.5139 2.90625 16.334 2.90625 15.0617V8.93605C2.90625 7.66332 3.57164 6.48318 4.66065 5.82447L10.1154 2.525C10.1492 2.50455 10.1833 2.4847 10.2176 2.46545Z",
    fill: "url(#paint1_linear_376_5370)"
}), h.createElement("path", {
    d: "M15.6331 9.72668V11.7633C15.6331 13.0356 14.9681 14.2154 13.8797 14.8743L8.4249 18.176C7.30903 18.8515 5.92066 18.8758 4.78516 18.2492L10.1135 21.4744C11.2711 22.1752 12.722 22.1752 13.8797 21.4744L19.3344 18.1726C20.4229 17.5138 21.0878 16.334 21.0878 15.0616V13.5905L20.6333 12.9086L15.6331 9.72668Z",
    fill: "url(#paint2_radial_376_5370)"
}), h.createElement("path", {
    d: "M15.6331 9.72668V11.7633C15.6331 13.0356 14.9681 14.2154 13.8797 14.8743L8.4249 18.176C7.30903 18.8515 5.92066 18.8758 4.78516 18.2492L10.1135 21.4744C11.2711 22.1752 12.722 22.1752 13.8797 21.4744L19.3344 18.1726C20.4229 17.5138 21.0878 16.334 21.0878 15.0616V13.5905L20.6333 12.9086L15.6331 9.72668Z",
    fill: "url(#paint3_linear_376_5370)"
}), h.createElement("path", {
    d: "M19.3347 5.82441L13.88 2.52494C12.7587 1.8467 11.3624 1.82569 10.2241 2.46191L10.1157 2.52746C9.02672 3.18618 8.36133 4.36629 8.36133 5.63904V9.95008L10.1157 8.88885C11.2729 8.18896 12.7228 8.18896 13.88 8.88885L19.3347 12.1883C20.3897 12.8265 21.0471 13.9539 21.0872 15.1808C21.0885 15.1412 21.0891 15.1015 21.0891 15.0617V8.93599C21.0891 7.66326 20.4237 6.48312 19.3347 5.82441Z",
    fill: "url(#paint4_radial_376_5370)"
}), h.createElement("path", {
    d: "M19.3347 5.82441L13.88 2.52494C12.7587 1.8467 11.3624 1.82569 10.2241 2.46191L10.1157 2.52746C9.02672 3.18618 8.36133 4.36629 8.36133 5.63904V9.95008L10.1157 8.88885C11.2729 8.18896 12.7228 8.18896 13.88 8.88885L19.3347 12.1883C20.3897 12.8265 21.0471 13.9539 21.0872 15.1808C21.0885 15.1412 21.0891 15.1015 21.0891 15.0617V8.93599C21.0891 7.66326 20.4237 6.48312 19.3347 5.82441Z",
    fill: "url(#paint5_linear_376_5370)"
}), h.createElement("defs", null, h.createElement("radialGradient", {
    id: "paint0_radial_376_5370",
    cx: 0,
    cy: 0,
    r: 1,
    gradientUnits: "userSpaceOnUse",
    gradientTransform: "translate(9.00587 5.92579) rotate(110.528) scale(15.1669 26.4541)"
}, h.createElement("stop", {
    offset: .06441,
    stopColor: "#AE7FE2"
}), h.createElement("stop", {
    offset: 1,
    stopColor: "#0078D4"
})), h.createElement("linearGradient", {
    id: "paint1_linear_376_5370",
    x1: 9.04828,
    y1: 18.3037,
    x2: 6.88428,
    y2: 14.5609,
    gradientUnits: "userSpaceOnUse"
}, h.createElement("stop", {
    stopColor: "#114A8B"
}), h.createElement("stop", {
    offset: 1,
    stopColor: "#0078D4",
    stopOpacity: 0
})), h.createElement("radialGradient", {
    id: "paint2_radial_376_5370",
    cx: 0,
    cy: 0,
    r: 1,
    gradientUnits: "userSpaceOnUse",
    gradientTransform: "translate(5.82811 17.6139) rotate(-8.36717) scale(14.1144 9.32348)"
}, h.createElement("stop", {
    offset: .133928,
    stopColor: "#D59DFF"
}), h.createElement("stop", {
    offset: 1,
    stopColor: "#5E438F"
})), h.createElement("linearGradient", {
    id: "paint3_linear_376_5370",
    x1: 19.4317,
    y1: 12.6254,
    x2: 17.1128,
    y2: 15.9504,
    gradientUnits: "userSpaceOnUse"
}, h.createElement("stop", {
    stopColor: "#493474"
}), h.createElement("stop", {
    offset: 1,
    stopColor: "#8C66BA",
    stopOpacity: 0
})), h.createElement("radialGradient", {
    id: "paint4_radial_376_5370",
    cx: 0,
    cy: 0,
    r: 1,
    gradientUnits: "userSpaceOnUse",
    gradientTransform: "translate(19.7505 13.1378) rotate(-165.772) scale(11.329 19.0713)"
}, h.createElement("stop", {
    offset: .0584996,
    stopColor: "#50E6FF"
}), h.createElement("stop", {
    offset: 1,
    stopColor: "#436DCD"
})), h.createElement("linearGradient", {
    id: "paint5_linear_376_5370",
    x1: 8.80489,
    y1: 2.47938,
    x2: 12.2191,
    y2: 2.47938,
    gradientUnits: "userSpaceOnUse"
}, h.createElement("stop", {
    stopColor: "#2D3F80"
}), h.createElement("stop", {
    offset: 1,
    stopColor: "#436DCD",
    stopOpacity: 0
}))))
  , hbe = e => h.createElement("svg", {
    width: 24,
    height: 24,
    viewBox: "0 0 24 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ...e
}, h.createElement("path", {
    d: "M4 4C4 2.89543 4.89543 2 6 2H14L20 8V20C20 21.1046 19.1046 22 18 22H6C4.89543 22 4 21.1046 4 20V4Z",
    fill: "#4285F4"
}), h.createElement("path", {
    d: "M14 2L20 8H16C14.8954 8 14 7.10457 14 6V2Z",
    fill: "#1967D2"
}), h.createElement("path", {
    d: "M8 13.75C8 13.6119 8.11193 13.5 8.25 13.5H15.75C15.8881 13.5 16 13.6119 16 13.75V14.75C16 14.8881 15.8881 15 15.75 15H8.25C8.11193 15 8 14.8881 8 14.75V13.75ZM8 16.75C8 16.6119 8.11193 16.5 8.25 16.5H13.75C13.8881 16.5 14 16.6119 14 16.75V17.75C14 17.8881 13.8881 18 13.75 18H8.25C8.11193 18 8 17.8881 8 17.75V16.75Z",
    fill: "white"
}), h.createElement("path", {
    d: "M8 10.75C8 10.6119 8.11193 10.5 8.25 10.5H15.75C15.8881 10.5 16 10.6119 16 10.75V11.75C16 11.8881 15.8881 12 15.75 12H8.25C8.11193 12 8 11.8881 8 11.75V10.75Z",
    fill: "white"
}))
  , pbe = e => h.createElement("svg", {
    width: 24,
    height: 24,
    viewBox: "0 0 24 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ...e
}, h.createElement("path", {
    d: "M4 4C4 2.89543 4.89543 2 6 2H14L20 8V20C20 21.1046 19.1046 22 18 22H6C4.89543 22 4 21.1046 4 20V4Z",
    fill: "#34A853"
}), h.createElement("path", {
    d: "M14 2L20 8H16C14.8954 8 14 7.10457 14 6V2Z",
    fill: "#188038"
}), h.createElement("path", {
    d: "M7.5 10.5C7.22386 10.5 7 10.7239 7 11V17.5C7 17.7761 7.22386 18 7.5 18H16.5C16.7761 18 17 17.7761 17 17.5V11C17 10.7239 16.7761 10.5 16.5 10.5H7.5ZM11.25 16.5L8.5 16.5V14.75L11.25 14.75V16.5ZM11.25 13.75H8.5V12H11.25V13.75ZM15.5 16.5H12.75V14.75L15.5 14.75V16.5ZM15.5 13.75H12.75V12H15.5V13.75Z",
    fill: "white"
}))
  , mbe = e => h.createElement("svg", {
    width: 24,
    height: 24,
    viewBox: "0 0 24 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ...e
}, h.createElement("path", {
    d: "M4 4C4 2.89543 4.89543 2 6 2H14L20 8V20C20 21.1046 19.1046 22 18 22H6C4.89543 22 4 21.1046 4 20V4Z",
    fill: "#F4B400"
}), h.createElement("path", {
    d: "M14 2L20 8H16C14.8954 8 14 7.10457 14 6V2Z",
    fill: "#9D7607"
}), h.createElement("path", {
    fillRule: "evenodd",
    clipRule: "evenodd",
    d: "M7 11.25C7 10.8358 7.33579 10.5 7.75 10.5H16.25C16.6642 10.5 17 10.8358 17 11.25V17.25C17 17.6642 16.6642 18 16.25 18H7.75C7.33579 18 7 17.6642 7 17.25V11.25ZM8.5 12.5V16H15.5V12.5H8.5Z",
    fill: "white"
}))
  , gbe = e => h.createElement("svg", {
    width: 24,
    height: 24,
    viewBox: "0 0 24 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ...e
}, h.createElement("path", {
    d: "M13.5574 11.5349L5.65039 10.1395V20.4498C5.65039 20.9206 6.03209 21.3023 6.50295 21.3023H20.1467C20.6175 21.3023 20.9992 20.9206 20.9992 20.4498V16.6512L13.5574 11.5349Z",
    fill: "#185C37"
}), h.createElement("path", {
    d: "M13.5574 2.69763H6.50295C6.03209 2.69763 5.65039 3.07933 5.65039 3.55019V7.34879L13.5574 12L17.7434 13.3953L20.9992 12V7.34879L13.5574 2.69763Z",
    fill: "#21A366"
}), h.createElement("path", {
    d: "M5.65039 7.34888H13.5574V12H5.65039V7.34888Z",
    fill: "#107C41"
}), h.createElement("path", {
    opacity: .1,
    d: "M11.3095 6.41858H5.65039V18.0465H11.3095C11.7797 18.045 12.1605 17.6641 12.162 17.1939V7.27114C12.1605 6.80092 11.7797 6.42011 11.3095 6.41858Z",
    fill: "#282828"
}), h.createElement("path", {
    opacity: .2,
    d: "M10.8443 6.88379H5.65039V18.5117H10.8443C11.3146 18.5102 11.6954 18.1294 11.6969 17.6591V7.73634C11.6954 7.26613 11.3146 6.88532 10.8443 6.88379Z",
    fill: "#282828"
}), h.createElement("path", {
    opacity: .2,
    d: "M10.8443 6.88379H5.65039V17.5815H10.8443C11.3146 17.5799 11.6954 17.1991 11.6969 16.7289V7.73634C11.6954 7.26613 11.3146 6.88532 10.8443 6.88379Z",
    fill: "#282828"
}), h.createElement("path", {
    opacity: .2,
    d: "M10.3792 6.88379H5.65039V17.5815H10.3792C10.8494 17.5799 11.2303 17.1991 11.2318 16.7289V7.73634C11.2303 7.26613 10.8494 6.88532 10.3792 6.88379Z",
    fill: "#282828"
}), h.createElement("path", {
    d: "M1.85256 6.88379H10.38C10.8508 6.88379 11.2326 7.26549 11.2326 7.73635V16.2638C11.2326 16.7346 10.8508 17.1163 10.38 17.1163H1.85256C1.3817 17.1163 1 16.7346 1 16.2638V7.73635C1 7.26549 1.3817 6.88379 1.85256 6.88379Z",
    fill: "url(#paint0_linear_376_5372)"
}), h.createElement("path", {
    d: "M3.63965 14.7712L5.43314 11.9921L3.78988 9.22839H5.11174L6.00848 10.9958C6.09128 11.1637 6.14802 11.2884 6.17872 11.3707H6.19035C6.24926 11.2368 6.31128 11.1067 6.37639 10.9805L7.335 9.22933H8.54848L6.86336 11.9768L8.59128 14.7712H7.30012L6.2643 12.8312C6.21551 12.7486 6.17411 12.6619 6.14059 12.5721H6.12524C6.09489 12.6601 6.05464 12.7444 6.00523 12.8233L4.93872 14.7712H3.63965Z",
    fill: "white"
}), h.createElement("path", {
    d: "M20.1489 2.69763H13.5596V7.34879H21.0014V3.55019C21.0014 3.07933 20.6197 2.69763 20.1489 2.69763Z",
    fill: "#33C481"
}), h.createElement("path", {
    d: "M13.5596 12H21.0014V16.6512H13.5596V12Z",
    fill: "#107C41"
}), h.createElement("defs", null, h.createElement("linearGradient", {
    id: "paint0_linear_376_5372",
    x1: 2.7776,
    y1: 6.21762,
    x2: 9.45496,
    y2: 17.7825,
    gradientUnits: "userSpaceOnUse"
}, h.createElement("stop", {
    stopColor: "#18884F"
}), h.createElement("stop", {
    offset: .5,
    stopColor: "#117E43"
}), h.createElement("stop", {
    offset: 1,
    stopColor: "#0B6631"
}))))
  , vbe = e => h.createElement("svg", {
    width: 24,
    height: 24,
    viewBox: "0 0 24 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ...e
}, h.createElement("path", {
    d: "M13.0927 12.9302L11.6973 2.69763H11.5932C6.51931 2.71244 2.40983 6.82193 2.39502 11.8958V12L13.0927 12.9302Z",
    fill: "#ED6C47"
}), h.createElement("path", {
    d: "M11.8019 2.69763H11.6978V12L16.3489 13.8604L21.0001 12V11.8958C20.9853 6.82193 16.8758 2.71244 11.8019 2.69763Z",
    fill: "#FF8F6B"
}), h.createElement("path", {
    d: "M20.9997 12V12.1023C20.9851 17.1773 16.8746 21.2878 11.7997 21.3023H11.595C6.52004 21.2878 2.40958 17.1773 2.39502 12.1023V12H20.9997Z",
    fill: "#D35230"
}), h.createElement("path", {
    opacity: .1,
    d: "M12.1625 7.26975V17.1953C12.1602 17.5402 11.9512 17.8501 11.6322 17.9814C11.5307 18.0243 11.4216 18.0465 11.3113 18.0465H4.59038C4.46015 17.8977 4.33457 17.7395 4.21829 17.5814C3.03331 16.0006 2.39349 14.0779 2.39503 12.1023V11.8977C2.39231 10.1157 2.9131 8.37221 3.8927 6.8837C3.99503 6.72556 4.102 6.56742 4.21829 6.41858H11.3113C11.7799 6.42213 12.1589 6.80114 12.1625 7.26975Z",
    fill: "#282828"
}), h.createElement("path", {
    opacity: .2,
    d: "M11.6974 7.73496V17.6605C11.6973 17.7708 11.6752 17.8799 11.6322 17.9815C11.5009 18.3004 11.1911 18.5094 10.8462 18.5117H5.01364C4.86648 18.3623 4.72528 18.2071 4.59038 18.0466C4.46015 17.8977 4.33457 17.7396 4.21829 17.5815C3.03331 16.0007 2.39349 14.078 2.39503 12.1024V11.8977C2.39231 10.1158 2.9131 8.37231 3.8927 6.88379H10.8462C11.3148 6.88733 11.6938 7.26634 11.6974 7.73496Z",
    fill: "#282828"
}), h.createElement("path", {
    opacity: .2,
    d: "M11.6974 7.73495V16.7303C11.6938 17.1989 11.3148 17.5779 10.8462 17.5815H4.21829C3.03331 16.0007 2.39349 14.078 2.39503 12.1024V11.8977C2.39231 10.1158 2.9131 8.37231 3.8927 6.88379H10.8462C11.3148 6.88732 11.6938 7.26633 11.6974 7.73495Z",
    fill: "#282828"
}), h.createElement("path", {
    opacity: .2,
    d: "M11.2322 7.73495V16.7303C11.2287 17.1989 10.8497 17.5779 10.3811 17.5815H4.21829C3.03331 16.0007 2.39349 14.078 2.39503 12.1024V11.8977C2.39231 10.1158 2.9131 8.37231 3.8927 6.88379H10.3811C10.8497 6.88732 11.2287 7.26633 11.2322 7.73495Z",
    fill: "#282828"
}), h.createElement("path", {
    d: "M1.85255 6.88379H10.38C10.8509 6.88379 11.2325 7.2655 11.2325 7.73634V16.2638C11.2325 16.7346 10.8508 17.1163 10.38 17.1163H1.85255C1.38171 17.1163 1 16.7346 1 16.2638V7.73634C1 7.2655 1.38171 6.88379 1.85255 6.88379Z",
    fill: "url(#paint0_linear_376_5382)"
}), h.createElement("path", {
    d: "M6.20915 9.15766C6.76426 9.12021 7.31459 9.28145 7.76171 9.61255C8.13464 9.94549 8.3339 10.4313 8.30217 10.9302C8.30827 11.277 8.21585 11.6185 8.03567 11.9149C7.85325 12.2062 7.59043 12.4385 7.27892 12.5837C6.9228 12.7493 6.53344 12.8311 6.14077 12.8228H5.06217V14.8274H3.95752V9.15766H6.20915ZM5.06125 11.9567H6.01195C6.31334 11.9789 6.61239 11.8897 6.85242 11.706C7.05094 11.5156 7.155 11.247 7.1366 10.9726C7.1366 10.3477 6.7735 10.0353 6.0473 10.0353H5.06126V11.9567H5.06125Z",
    fill: "white"
}), h.createElement("defs", null, h.createElement("linearGradient", {
    id: "paint0_linear_376_5382",
    x1: 2.7776,
    y1: 6.21762,
    x2: 9.45496,
    y2: 17.7825,
    gradientUnits: "userSpaceOnUse"
}, h.createElement("stop", {
    stopColor: "#CA4C28"
}), h.createElement("stop", {
    offset: .5,
    stopColor: "#C5401E"
}), h.createElement("stop", {
    offset: 1,
    stopColor: "#B62F14"
}))))
  , _be = e => h.createElement("svg", {
    width: 24,
    height: 24,
    viewBox: "0 0 24 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ...e
}, h.createElement("path", {
    d: "M20.1467 2.69775H6.50295C6.03209 2.69775 5.65039 3.07946 5.65039 3.55031V7.34892L13.5574 9.6745L20.9992 7.34892V3.55031C20.9992 3.07946 20.6175 2.69775 20.1467 2.69775Z",
    fill: "#41A5EE"
}), h.createElement("path", {
    d: "M20.9992 7.34888H5.65039V12L13.5574 13.3954L20.9992 12V7.34888Z",
    fill: "#2B7CD3"
}), h.createElement("path", {
    d: "M5.65039 12.0001V16.6513L13.0923 17.5815L20.9992 16.6513V12.0001H5.65039Z",
    fill: "#185ABD"
}), h.createElement("path", {
    d: "M6.50295 21.3024H20.1467C20.6175 21.3024 20.9992 20.9207 20.9992 20.4498V16.6512H5.65039V20.4498C5.65039 20.9207 6.03209 21.3024 6.50295 21.3024Z",
    fill: "#103F91"
}), h.createElement("path", {
    opacity: .1,
    d: "M11.3095 6.4187H5.65039V18.0466H11.3095C11.7797 18.0451 12.1605 17.6643 12.162 17.194V7.27126C12.1605 6.80104 11.7797 6.42023 11.3095 6.4187Z",
    fill: "#282828"
}), h.createElement("path", {
    opacity: .2,
    d: "M10.8443 6.88379H5.65039V18.5117H10.8443C11.3146 18.5102 11.6954 18.1294 11.6969 17.6591V7.73635C11.6954 7.26613 11.3146 6.88532 10.8443 6.88379Z",
    fill: "#282828"
}), h.createElement("path", {
    opacity: .2,
    d: "M10.8443 6.88379H5.65039V17.5815H10.8443C11.3146 17.5799 11.6954 17.1991 11.6969 16.7289V7.73635C11.6954 7.26613 11.3146 6.88532 10.8443 6.88379Z",
    fill: "#282828"
}), h.createElement("path", {
    opacity: .2,
    d: "M10.3792 6.88379H5.65039V17.5815H10.3792C10.8494 17.5799 11.2303 17.1991 11.2318 16.7289V7.73635C11.2303 7.26613 10.8494 6.88532 10.3792 6.88379Z",
    fill: "#282828"
}), h.createElement("path", {
    d: "M1.85256 6.88379H10.38C10.8509 6.88379 11.2326 7.26549 11.2326 7.73635V16.2638C11.2326 16.7347 10.8509 17.1164 10.38 17.1164H1.85256C1.3817 17.1164 1 16.7347 1 16.2638V7.73635C1 7.26549 1.3817 6.88379 1.85256 6.88379Z",
    fill: "url(#paint0_linear_376_5387)"
}), h.createElement("path", {
    d: "M4.49888 13.4224C4.51562 13.554 4.52679 13.6684 4.5319 13.7666H4.55143C4.55887 13.6736 4.57437 13.5615 4.59794 13.4303C4.62151 13.2991 4.64275 13.1883 4.66166 13.0978L5.55841 9.22891H6.71795L7.64818 13.0396C7.70223 13.2766 7.74092 13.5168 7.764 13.7587H7.77935C7.79669 13.5243 7.82901 13.2913 7.87609 13.061L8.61795 9.22705H9.6733L8.37004 14.7712H7.13702L6.2533 11.0996C6.22772 10.994 6.19842 10.8559 6.16632 10.6861C6.13423 10.5163 6.11423 10.3922 6.10632 10.314H6.09097C6.08074 10.4042 6.06073 10.5382 6.03097 10.7159C6.0012 10.8936 5.97732 11.025 5.95933 11.1103L5.12863 14.7703H3.87468L2.56445 9.2289H3.63887L4.44678 13.1056C4.46492 13.1852 4.48214 13.2912 4.49888 13.4224Z",
    fill: "white"
}), h.createElement("defs", null, h.createElement("linearGradient", {
    id: "paint0_linear_376_5387",
    x1: 2.7776,
    y1: 6.21762,
    x2: 9.45496,
    y2: 17.7825,
    gradientUnits: "userSpaceOnUse"
}, h.createElement("stop", {
    stopColor: "#2368C4"
}), h.createElement("stop", {
    offset: .5,
    stopColor: "#1A5DBE"
}), h.createElement("stop", {
    offset: 1,
    stopColor: "#1146AC"
}))))
  , GOe = ({className: e, contextConnector: t, extension: n}) => {
    const r = gt()
      , s = ybe(t, n);
    return g.jsx("div", {
        className: `${e} dark:bg-token-main-surface-secondary flex items-center justify-center rounded-md border border-gray-100 bg-gray-50 dark:border-white/10`,
        children: g.jsx(s, {
            className: "w-[20px]",
            "aria-label": r.formatMessage({
                id: "ccc.fileIcon",
                defaultMessage: "File icon for {contextConnector}"
            }, {
                contextConnector: t
            })
        })
    })
}
;
function ybe(e, t) {
    switch (e) {
    case Ae.CONFLUENCE:
        return WG;
    case Ae.GDRIVE:
        switch (t) {
        case "doc":
        case "docx":
            return hbe;
        case "xls":
        case "xlsx":
            return pbe;
        case "ppt":
        case "pptx":
            return mbe;
        default:
            return td
        }
    case Ae.JIRA:
        return KG;
    case Ae.NOTION_OPEN_CONNECTOR:
        return a4;
    case Ae.O365_BUSINESS:
    case Ae.O365_PERSONAL:
    case Ae.O365:
        switch (t) {
        case "doc":
        case "docx":
            return _be;
        case "xls":
        case "xlsx":
            return gbe;
        case "ppt":
        case "pptx":
            return vbe;
        default:
            return fbe
        }
    case Ae.SLACK_OPEN_CONNECTOR:
        return F1
    }
}
function VOe(e) {
    switch (e) {
    case Ae.CONFLUENCE:
        return WG;
    case Ae.GDRIVE:
        return td;
    case Ae.JIRA:
        return KG;
    case Ae.NOTION_OPEN_CONNECTOR:
        return a4;
    case Ae.O365_PERSONAL:
    case Ae.O365:
        return IB;
    case Ae.O365_BUSINESS:
        return jG;
    case Ae.SLACK_OPEN_CONNECTOR:
        return F1
    }
}
var Ad = {}, hA;
function bbe() {
    if (hA)
        return Ad;
    hA = 1,
    Object.defineProperty(Ad, "__esModule", {
        value: !0
    });
    function e(t, n) {
        if (n)
            return t;
        throw new Error("Unhandled discriminated union member: " + JSON.stringify(t))
    }
    return Ad.assertNever = e,
    Ad.default = e,
    Ad
}
var Cbe = bbe();
const Sbe = mn(Cbe)
  , wbe = Un({
    defaultMessage: "Microsoft OneDrive (personal)",
    id: "ContextConnector.OneDrivePersonal.name"
})
  , Ebe = Un({
    defaultMessage: "Microsoft OneDrive (work/school)",
    id: "ContextConnector.OneDriveBusiness.name"
})
  , HOe = xt({
    includesSharePoint: {
        id: "ContextConnectorPicker.o365BusinessIncludesSharePoint",
        defaultMessage: "Includes SharePoint"
    }
});
function zOe(e, t, n) {
    switch (e) {
    case Ae.CONFLUENCE:
        return "Confluence";
    case Ae.GDRIVE:
        return "Google Drive";
    case Ae.JIRA:
        return "Jira";
    case Ae.NOTION_OPEN_CONNECTOR:
        return "Notion";
    case Ae.O365:
        return n ? "OneDrive" : "Microsoft OneDrive";
    case Ae.O365_PERSONAL:
        return n ? "OneDrive" : t?.formatMessage(wbe) ?? "Microsoft OneDrive (personal)";
    case Ae.O365_BUSINESS:
        return n ? "Sharepoint" : t?.formatMessage(Ebe) ?? "Microsoft OneDrive (work/school)";
    case Ae.SLACK_OPEN_CONNECTOR:
        return "Slack"
    }
}
function xbe(e, t) {
    switch (e) {
    case Ae.CONFLUENCE:
        return "Confluence Page";
    case Ae.GDRIVE:
        switch (t) {
        case "doc":
        case "docx":
            return "Google Docs";
        case "xls":
        case "xlsx":
            return "Google Sheets";
        case "ppt":
        case "pptx":
            return "Google Slides";
        default:
            return "Google Drive"
        }
    case Ae.JIRA:
        return "Jira Issue";
    case Ae.NOTION_OPEN_CONNECTOR:
        return "Notion Page";
    case Ae.O365:
    case Ae.O365_PERSONAL:
    case Ae.O365_BUSINESS:
        switch (t) {
        case "doc":
        case "docx":
            return "Microsoft Word";
        case "xls":
        case "xlsx":
            return "Microsoft Excel";
        case "ppt":
        case "pptx":
            return "Microsoft PowerPoint";
        default:
            return "Microsoft OneDrive"
        }
    case Ae.SLACK_OPEN_CONNECTOR:
        return "Slack"
    }
    Sbe(e)
}
function $Oe({contextConnector: e, extension: t}) {
    return g.jsx(g.Fragment, {
        children: xbe(e, t)
    })
}
const Tbe = en(e => {
    const n = Jf(e)?.user
      , r = Vn(e, "1967546325")
      , s = r.get("gdrivePicker", !1)
      , o = r.get("o365Picker", !1)
      , i = r.get("gdriveLink", !1)
      , a = r.get("o365PersonalLink", !1)
      , l = r.get("o365BusinessLink", !1)
      , c = r.get("testCtor1Link", !1)
      , u = r.get("testCtor2Link", !1)
      , d = r.get("testCtor3Link", !1)
      , f = r.get("oversmokeLink", !1)
      , p = Vn(e, "3747383021")
      , m = Xe(e, "3544641259") && p.get("github", !1)
      , v = r.get("gdrivePercentage", 0)
      , _ = r.get("o365Percentage", 0)
      , y = r.get("testCtor1Percentage", 0)
      , b = r.get("testCtor2Percentage", 0)
      , S = r.get("testCtor3Percentage", 0)
      , C = r.get("oversmokePercentage", 0)
      , w = r.get("loadTestPercentage", 0)
      , x = r.get("showWorkspaceSettings", !1)
      , E = n ? kbe(n.id) : null;
    return {
        confluenceLinkStatus: Ns(c, E, y),
        gdriveLinkStatus: Ns(i, E, v),
        gdriveStatus: Ns(s, E, v),
        jiraLinkStatus: Ns(u, E, b),
        notionLinkStatus: Ns(d, E, S),
        o365BusinessLinkStatus: Ns(l, E, _),
        o365PersonalLinkStatus: Ns(a, E, _),
        o365Status: Ns(o, E, _),
        slackLinkStatus: Ns(f, E, C),
        githubLinkStatus: Ns(m, E, 100),
        loadTest: Ns(!0, E, w) === "true",
        showWorkspaceSettings: x
    }
}
);
function P4() {
    const e = ue();
    return Tbe(e)
}
function Ns(e, t, n) {
    return !e || t == null ? "false" : t < n ? "true" : "ifConnected"
}
function kbe(e) {
    const n = Obe(e) % 100;
    return Math.abs(n)
}
function Obe(e) {
    let t = 0;
    for (let n = 0; n < e.length; n++) {
        const r = e.charCodeAt(n);
        t = (t << 5) - t + r,
        t |= 0
    }
    return t
}
const Abe = new Map;
function WOe() {
    const {confluenceLinkStatus: e, gdriveLinkStatus: t, jiraLinkStatus: n, notionLinkStatus: r, o365BusinessLinkStatus: s, o365PersonalLinkStatus: o, slackLinkStatus: i} = P4();
    return D4(t, s, o, e, n, r, i)
}
function KOe() {
    const {gdriveStatus: e, o365Status: t} = P4();
    return D4(e, t, t)
}
function Mbe() {
    const {gdriveStatus: e, o365Status: t, confluenceLinkStatus: n, jiraLinkStatus: r, notionLinkStatus: s, slackLinkStatus: o, githubLinkStatus: i} = P4();
    return D4(e, t, t, i, n, r, s, o)
}
function D4(e, t, n, r=null, s=null, o=null, i=null, a=null) {
    const l = ue()
      , u = bn(l)?.getWorkspaceId()
      , d = [Ae.GDRIVE, Ae.O365_PERSONAL, Ae.O365_BUSINESS, ...s === "true" || s === "ifConnected" ? [Ae.CONFLUENCE] : [], ...o === "true" || o === "ifConnected" ? [Ae.JIRA] : [], ...i === "true" || i === "ifConnected" ? [Ae.NOTION_OPEN_CONNECTOR] : [], ...a === "true" || a === "ifConnected" ? [Ae.SLACK_OPEN_CONNECTOR] : []]
      , {connectors: f, isLoading: p, error: m, refetch: v} = Ibe(d)
      , {data: _, isLoading: y, error: b, refetch: S} = n1(u)
      , C = !u || _?.beta_settings?.[Wi.CONTEXT_CONNECTOR_CONFLUENCE]
      , w = !u || _?.beta_settings?.[Wi.CONTEXT_CONNECTOR_GDRIVE]
      , x = !u || _?.beta_settings?.[Wi.CONTEXT_CONNECTOR_JIRA]
      , E = !u || _?.beta_settings?.[Wi.CONTEXT_CONNECTOR_NOTION]
      , T = !u || _?.beta_settings?.[Wi.CONTEXT_CONNECTOR_O365_PERSONAL]
      , k = !u || _?.beta_settings?.[Wi.CONTEXT_CONNECTOR_O365_BUSINESS]
      , A = !u || _?.beta_settings?.[Wi.CONTEXT_CONNECTOR_SLACK]
      , O = f.get(Ae.CONFLUENCE)
      , M = f.get(Ae.GDRIVE)
      , I = f.get(Ae.JIRA)
      , R = f.get(Ae.NOTION_OPEN_CONNECTOR)
      , D = f.get(Ae.O365_PERSONAL)
      , P = f.get(Ae.O365_BUSINESS)
      , L = f.get(Ae.SLACK_OPEN_CONNECTOR)
      , N = (Ie, be) => Ie === "true" || Ie === "ifConnected" && be
      , B = h.useMemo( () => {
        const Ie = !!s && N(s, !!O?.access_token)
          , be = !!M?.access_token
          , me = N(e, be)
          , ge = !!o && N(o, !!I?.access_token)
          , ce = !!i && N(i, !!R?.access_token)
          , Z = !!(D?.access_token ?? P?.access_token)
          , ne = N(t, Z)
          , _e = N(n, Z)
          , ee = !!a && N(a, !!L?.access_token)
          , oe = [Ie && O && C ? [Ae.CONFLUENCE, O] : null, me && M && w ? [Ae.GDRIVE, M] : null, ge && I && x ? [Ae.JIRA, I] : null, ce && R && E ? [Ae.NOTION_OPEN_CONNECTOR, R] : null, _e && D && T ? [Ae.O365_PERSONAL, D] : null, ne && P && k ? [Ae.O365_BUSINESS, P] : null, ee && L && A ? [Ae.SLACK_OPEN_CONNECTOR, L] : null];
        return new Map(Lj(oe))
    }
    , [O, s, M, e, I, o, R, i, P, L, t, D, n, C, a, w, E, x, T, k, A]);
    let H = null
      , ye = v;
    return m ? (H = m,
    ye = v) : b && (H = b,
    ye = S),
    {
        connectorConfig: B,
        isLoading: p || y,
        error: H,
        refetch: ye
    }
}
function Ibe(e) {
    const {isUnauthenticated: t} = ah()
      , {data: n, isLoading: r, error: s, refetch: o} = At({
        queryKey: ["fetchConnectorData", e],
        queryFn: Rbe,
        refetchInterval: 30 * 60 * 1e3,
        enabled: !t
    });
    return {
        connectors: h.useMemo( () => !n || !n.length || s ? Abe : new Map(n.map(a => [a.type, a])), [n, s]),
        isLoading: r,
        error: s,
        refetch: o
    }
}
async function Rbe({queryKey: e}) {
    const [t,n] = e;
    let r = null;
    try {
        r = await ie.safeGet("/connectors/check", {
            parameters: {
                query: {
                    connector_names: n
                }
            }
        })
    } catch (o) {
        throw q.addAction("Server Error while retrieving context connector entry", {
            cause: o
        }),
        o
    }
    return !r || !r.connectors ? [] : r.connectors.map(o => {
        const {type: i, ...a} = o
          , l = i;
        if (a.access_token) {
            if (l === Ae.O365_PERSONAL)
                return {
                    type: l,
                    ...a,
                    onedrive_endpoint_hint: {
                        type: "personal",
                        baseUrl: "https://onedrive.live.com",
                        parsedUrl: "https://onedrive.live.com/picker"
                    }
                };
            if (l === Ae.O365_BUSINESS) {
                const c = a.onedrive_business_metadata?.base_url;
                if (c) {
                    const u = new URL(c);
                    return {
                        type: l,
                        ...a,
                        onedrive_endpoint_hint: {
                            type: "business",
                            baseUrl: c,
                            parsedUrl: `https://${u.hostname}/_layouts/15/FilePicker.aspx`
                        }
                    }
                }
            }
        }
        return {
            type: l,
            ...a
        }
    }
    )
}
const pA = 10
  , YOe = 4
  , dS = {
    duration: 20,
    hasCloseButton: !0
}
  , Nbe = 512
  , ZOe = Nbe * 1024 * 1024
  , Pbe = "application/vnd.google-apps.spreadsheet"
  , Dbe = "application/vnd.google-apps.presentation"
  , Lbe = "application/vnd.google-apps.document"
  , Fbe = ["xlsx", "pptx", "docx", "page", "issue"]
  , jbe = {
    [Pbe]: "xlsx",
    [Dbe]: "pptx",
    [Lbe]: "docx"
};
function JOe(e) {
    return e ? jbe[e.split(";")[0]] ?? null : null
}
function Ube(e) {
    return Fbe.includes(e)
}
function Bbe(e) {
    return e && Ube(e) ? e : null
}
var Bn = (e => (e[e.None = 0] = "None",
e[e.Multimodal = 1] = "Multimodal",
e[e.Interpreter = 2] = "Interpreter",
e[e.Retrieval = 3] = "Retrieval",
e[e.ContextConnector = 4] = "ContextConnector",
e[e.ProfilePicture = 5] = "ProfilePicture",
e[e.Codex = 6] = "Codex",
e))(Bn || {});
function XOe(e) {
    if (e)
        return {
            contextConnector: e.context_connector,
            sourceUrl: e.source_url,
            syntheticExtension: Bbe(e.synthetic_extension),
            type: e.type
        }
}
var ii = (e => (e.Uploading = "uploading",
e.Ready = "ready",
e))(ii || {}), Vb, mA;
function qbe() {
    if (mA)
        return Vb;
    mA = 1;
    var e = n4()
      , t = v1()
      , n = K6()
      , r = Bo()
      , s = oh();
    function o(i, a, l, c) {
        if (!r(i))
            return i;
        a = t(a, i);
        for (var u = -1, d = a.length, f = d - 1, p = i; p != null && ++u < d; ) {
            var m = s(a[u])
              , v = l;
            if (m === "__proto__" || m === "constructor" || m === "prototype")
                return i;
            if (u != f) {
                var _ = p[m];
                v = c ? c(_, m, p) : void 0,
                v === void 0 && (v = r(_) ? _ : n(a[u + 1]) ? [] : {})
            }
            e(p, m, v),
            p = p[m]
        }
        return i
    }
    return Vb = o,
    Vb
}
var Hb, gA;
function YG() {
    if (gA)
        return Hb;
    gA = 1;
    var e = iw()
      , t = qbe()
      , n = v1();
    function r(s, o, i) {
        for (var a = -1, l = o.length, c = {}; ++a < l; ) {
            var u = o[a]
              , d = e(s, u);
            i(d, u) && t(c, n(u, s), d)
        }
        return c
    }
    return Hb = r,
    Hb
}
var zb, vA;
function Gbe() {
    if (vA)
        return zb;
    vA = 1;
    var e = YG()
      , t = YL();
    function n(r, s) {
        return e(r, s, function(o, i) {
            return t(r, i)
        })
    }
    return zb = n,
    zb
}
var $b, _A;
function Vbe() {
    if (_A)
        return $b;
    _A = 1;
    var e = Wu()
      , t = $6()
      , n = ks()
      , r = e ? e.isConcatSpreadable : void 0;
    function s(o) {
        return n(o) || t(o) || !!(r && o && o[r])
    }
    return $b = s,
    $b
}
var Wb, yA;
function Hbe() {
    if (yA)
        return Wb;
    yA = 1;
    var e = H6()
      , t = Vbe();
    function n(r, s, o, i, a) {
        var l = -1
          , c = r.length;
        for (o || (o = t),
        a || (a = []); ++l < c; ) {
            var u = r[l];
            s > 0 && o(u) ? s > 1 ? n(u, s - 1, o, i, a) : e(a, u) : i || (a[a.length] = u)
        }
        return a
    }
    return Wb = n,
    Wb
}
var Kb, bA;
function zbe() {
    if (bA)
        return Kb;
    bA = 1;
    var e = Hbe();
    function t(n) {
        var r = n == null ? 0 : n.length;
        return r ? e(n, 1) : []
    }
    return Kb = t,
    Kb
}
var Yb, CA;
function $be() {
    if (CA)
        return Yb;
    CA = 1;
    function e(t, n, r) {
        switch (r.length) {
        case 0:
            return t.call(n);
        case 1:
            return t.call(n, r[0]);
        case 2:
            return t.call(n, r[0], r[1]);
        case 3:
            return t.call(n, r[0], r[1], r[2])
        }
        return t.apply(n, r)
    }
    return Yb = e,
    Yb
}
var Zb, SA;
function Wbe() {
    if (SA)
        return Zb;
    SA = 1;
    var e = $be()
      , t = Math.max;
    function n(r, s, o) {
        return s = t(s === void 0 ? r.length - 1 : s, 0),
        function() {
            for (var i = arguments, a = -1, l = t(i.length - s, 0), c = Array(l); ++a < l; )
                c[a] = i[s + a];
            a = -1;
            for (var u = Array(s + 1); ++a < s; )
                u[a] = i[a];
            return u[s] = o(c),
            e(r, this, u)
        }
    }
    return Zb = n,
    Zb
}
var Jb, wA;
function Kbe() {
    if (wA)
        return Jb;
    wA = 1;
    function e(t) {
        return function() {
            return t
        }
    }
    return Jb = e,
    Jb
}
var Xb, EA;
function Ybe() {
    if (EA)
        return Xb;
    EA = 1;
    var e = Kbe()
      , t = _B()
      , n = aw()
      , r = t ? function(s, o) {
        return t(s, "toString", {
            configurable: !0,
            enumerable: !1,
            value: e(o),
            writable: !0
        })
    }
    : n;
    return Xb = r,
    Xb
}
var Qb, xA;
function Zbe() {
    if (xA)
        return Qb;
    xA = 1;
    var e = 800
      , t = 16
      , n = Date.now;
    function r(s) {
        var o = 0
          , i = 0;
        return function() {
            var a = n()
              , l = t - (a - i);
            if (i = a,
            l > 0) {
                if (++o >= e)
                    return arguments[0]
            } else
                o = 0;
            return s.apply(void 0, arguments)
        }
    }
    return Qb = r,
    Qb
}
var e2, TA;
function Jbe() {
    if (TA)
        return e2;
    TA = 1;
    var e = Ybe()
      , t = Zbe()
      , n = t(e);
    return e2 = n,
    e2
}
var t2, kA;
function Xbe() {
    if (kA)
        return t2;
    kA = 1;
    var e = zbe()
      , t = Wbe()
      , n = Jbe();
    function r(s) {
        return n(t(s, void 0, e), s + "")
    }
    return t2 = r,
    t2
}
var n2, OA;
function Qbe() {
    if (OA)
        return n2;
    OA = 1;
    var e = Gbe()
      , t = Xbe()
      , n = t(function(r, s) {
        return r == null ? {} : e(r, s)
    });
    return n2 = n,
    n2
}
var e2e = Qbe();
const t2e = mn(e2e)
  , QOe = ["none", "delay", "indexed"]
  , eAe = ["none", "Adaptive", "ChunkedCatchup", "Punctuation"]
  , n2e = {
    label: "Auto",
    value: ""
}
  , r2e = "The user has opted in to provide additional feedback on the previous response. Encourage the user to share feedback that you can store in a memory to better meet their needs in future. Use no more than 3 turns. If at any point the user indicates no longer wanting to provide feedback, return to the original topic."
  , s2e = () => ({
    fConversationEndpoint: "default",
    tokenBufferType: null,
    wordFadeType: null,
    showCompletionPerfData: !0,
    forceParagen: !1,
    forceParagenModel: n2e,
    forceIndepthFeedback: !1,
    forceIndepthFeedbackPrompt: r2e,
    forceRateLimit: !1,
    recordRendering: !1,
    recordTransformedConvoJson: !1,
    resetRateLimits: !1,
    showDebugConversationTurns: !1,
    rebaseSystemMessageContent: null,
    forceUseSearch: null,
    paragenStreamType: "none",
    paragenCotSummaryDisplay: "allow",
    showParagenMetadata: !0,
    forceShowConvoRating: !1,
    jsonViewerFilters: {},
    forceParallelSwitch: "auto",
    autoSwitcherTreatmentOverride: void 0,
    juiceScore: null,
    multimodalJuiceScore: null,
    ...{}
})
  , ZG = dn(Fj(s2e, {
    name: Ft.DebugSettings,
    partialize: e => t2e(e, ["fConversationEndpoint", "showCompletionPerfData", "jsonViewerFilters", "recordRendering", "recordTransformedConvoJson"])
}))
  , Th = () => ZG.getState()
  , tAe = e => ZG.setState(e);
function nAe(e) {
    return e.startsWith("file-service://") ? e.replace("file-service://", "") : e.startsWith("sediment://") ? e.replace("sediment://", "") : e
}
function rAe(e) {
    return e.startsWith("file_") ? "sediment://" + e : "file-service://" + e
}
function sAe(e) {
    return e.startsWith("file-service://")
}
function fS(e, t, n) {
    switch (t) {
    case "file_zero_bytes":
        return e.formatMessage(Yn.fileZeroBytes, n);
    case "file_too_large":
        return e.formatMessage(Yn.fileTooLarge, n);
    case "over_user_quota":
        return e.formatMessage(Yn.overUserQuota, n);
    case "file_not_found":
    case "file_expired":
        return e.formatMessage(Yn.fileNotFound, n);
    case "file_timed_out":
        return e.formatMessage(Yn.fileTimedOut, n);
    case "ace_pod_expired":
        return e.formatMessage(Yn.codeInterpreterSessionTimeout, n);
    case "permission_error":
        return e.formatMessage(Yn.permissionError, n);
    case "default_upload_error":
    case "file_rejected":
        return e.formatMessage(Yn.defaultCreateEntryError, n);
    case "default_download_link_error":
        return e.formatMessage(Yn.defaultDownloadLinkError, n);
    case "file_empty":
        return e.formatMessage(Yn.fileEmpty, n);
    case "too_many_tokens":
        return e.formatMessage(Yn.fileTooManyTokens, n);
    case "file_encrypted":
        return e.formatMessage(Yn.fileEncrypted, n);
    case "file_corrupted":
        return e.formatMessage(Yn.fileCorrupted, n);
    case "failed_upload_to_blobstore":
        return e.formatMessage(Yn.failedUploadToBlobStore, n);
    case "internal_error":
    default:
        return e.formatMessage(Yn.unknownError)
    }
}
function oAe() {
    const e = gt();
    return h.useCallback( (t, n) => fS(e, t, n), [e])
}
const iAe = 1e3 * 60 * 58;
async function o2e(e, t, n=!1, r, s, o, i) {
    const [,a,l] = /^(.*?)(\?.*)?$/.exec(e) ?? []
      , c = new URLSearchParams(l)
      , u = a.replaceAll("#", "*")
      , d = await ie.safeGet("/files/download/{file_id}", {
        parameters: {
            path: {
                file_id: u
            },
            query: {
                gizmo_id: t,
                post_id: i,
                ...Object.fromEntries(c.entries()),
                conversation_id: r,
                inline: s
            }
        },
        authOption: n ? Qt.Anonymous : void 0
    });
    if (d.status === gf.Success || d.status === gf.Retry)
        return d;
    throw new on("Could not get file download link","error_code"in d ? d.error_code : "unknown_error")
}
function aAe() {
    const {session: e} = Qf()
      , {isUnauthenticated: t} = ah()
      , n = Tn();
    return async (r, s) => {
        if (!t && e == null)
            return n.danger(Yn.fileDownloadFailed, {
                toastId: "file_download_failed"
            }),
            !1;
        try {
            const o = await o2e(r, void 0, t);
            if (o.status !== gf.Success)
                throw new Error("File is not ready to download: " + JSON.stringify(o));
            const i = o.download_url
              , a = document.createElement("a");
            a.href = i,
            a.download = s,
            a.click(),
            window.open(i, "_blank")
        } catch {
            return n.danger(Yn.fileDownloadFailed, {
                toastId: "file_download_failed"
            }),
            !1
        }
        return !0
    }
}
function L4(e, t) {
    return (t?.kind === cn.GizmoInteraction || t?.kind === cn.GizmoTest) && !(t?.gizmo && WB(t?.gizmo)) ? t.gizmo?.product_features : e?.product_features
}
function lAe(e, t, n) {
    const r = L4(e, t);
    return n === xe.Research ? Bn.Retrieval : r?.attachments?.type === hl.CodeInterpreter ? Bn.Interpreter : r?.attachments?.type === hl.Multimodal ? Bn.Multimodal : r?.attachments?.type === hl.Retrieval ? Bn.Retrieval : r?.attachments?.type === hl.ContextConnector ? Bn.ContextConnector : Bn.None
}
function JG(e) {
    const t = e.split(".").pop()?.toLowerCase();
    return {
        md: "text/markdown",
        java: "text/x-java",
        py: "text/x-script.python",
        c: "text/x-c",
        cpp: "text/x-c++",
        h: "text/x-c++",
        php: "text/x-php",
        rb: "text/x-ruby",
        tex: "application/x-latext",
        ts: "text/x-typescript",
        cs: "text/x-csharp",
        go: "text/x-go",
        rs: "text/x-rust",
        scala: "application/x-scala",
        kt: "text/x-kotlin",
        swift: "text/x-swift",
        lua: "text/x-lua",
        r: "text/x-r",
        jl: "text/x-julia",
        pl: "text/x-perl",
        sh: "text/x-shellscript",
        m: "text/x-objectivec",
        mm: "text/x-objectivec++",
        erl: "text/x-erlang",
        ex: "text/x-elixir",
        exs: "text/x-elixir",
        hs: "text/x-haskell",
        clj: "text/x-clojure",
        groovy: "text/x-groovy",
        dart: "text/x-dart",
        bash: "text/x-shellscript",
        jsx: "text/jsx",
        tsx: "text/tsx",
        hbs: "text/x-handlebars",
        handlebars: "text/x-handlebars",
        mustache: "text/x-mustache",
        ejs: "text/x-ejs",
        j2: "text/x-jinja2",
        jinja: "text/x-jinja2",
        jinja2: "text/x-jinja2",
        liquid: "text/x-liquid",
        erb: "text/x-erb",
        twig: "text/x-twig",
        pug: "text/x-pug",
        jade: "text/x-jade",
        tmpl: "text/x-tmpl",
        json: "application/json",
        yml: "application/x-yaml",
        yaml: "application/x-yaml",
        toml: "application/toml",
        ini: "text/plain",
        properties: "text/plain",
        env: "text/plain",
        xml: "text/xml",
        conf: "text/plain",
        log: "text/plain",
        txt: "text/plain",
        astro: "text/x-astro"
    }[t ?? ""] || ""
}
function i2e(e) {
    switch (e) {
    case "application/vnd.google-apps.spreadsheet":
        return "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet";
    case "application/vnd.google-apps.document":
    case "application/vnd.google-apps.presentation":
        return "text/plain";
    default:
        return e
    }
}
function XG(e, t, n) {
    const r = JG(e);
    return r && (t = r),
    n && (t = i2e(t)),
    t
}
function a2e(e, t, n, r, s) {
    if (s == null)
        return e;
    const o = XG(t, n, r)
      , {accepted_mime_types: i, can_accept_all_mime_types: a} = s;
    return i == null || i.length === 0 || !a || i.includes(o) ? e : Bn.Interpreter
}
function cAe(e, t, n, r) {
    const s = XG(n, t, r)
      , o = e?.product_features?.attachments;
    if (o != null)
        return o.accepted_mime_types?.includes(s) ? o.type : o.image_mime_types?.includes(s) ? hl.Multimodal : hl.CodeInterpreter
}
function uAe(e, t) {
    const n = L4(e, t);
    return n?.attachments?.can_accept_all_mime_types ? void 0 : n?.attachments?.accepted_mime_types
}
function dAe(e, t) {
    const n = L4(e, t)
      , {attachments: r} = n ?? {};
    return r?.image_mime_types ? r.image_mime_types : r?.type === "multimodal" ? r.accepted_mime_types ?? l2e : []
}
const l2e = ["image/png", "image/jpeg", "image/gif", "image/webp"]
  , AA = {
    "image/jpeg": [".jpg", ".jpeg"],
    "image/svg+xml": [".svg"],
    "application/vnd.openxmlformats-officedocument.wordprocessingml.document": [".docx"],
    "application/vnd.openxmlformats-officedocument.presentationml.presentation": [".pptx"]
};
function c2e(e) {
    return e.reduce( (t, n) => (n in AA ? t[n] = AA[n] : n.includes("/") && (t[n] = [`.${n.split("/")[1]}`]),
    t), {})
}
function fAe(e) {
    return h.useMemo( () => e === void 0 ? {} : {
        accept: c2e(e)
    }, [e])
}
function F4(e) {
    return e.split(".").pop()?.toLowerCase()
}
function hAe(e) {
    const t = F4(e);
    return t != null && ["jpg", "jpeg", "png", "gif", "webp"].includes(t)
}
function pAe(e) {
    const t = (e ?? "").toLowerCase();
    return t === "pdf" ? "PDF" : t.length === 0 ? "" : t.charAt(0).toUpperCase() + t.slice(1)
}
function mAe(e) {
    const t = F4(e);
    return t != null && ["xls", "xlsx", "csv"].includes(t)
}
function gAe(e) {
    const t = F4(e);
    return t != null && ["xls", "xlsx"].includes(t)
}
function QG(e, t, n="fit") {
    return new Promise( (r, s) => {
        const o = new FileReader;
        o.onerror = i => {
            q.addError(new Error("File reading has failed:",{
                cause: i
            })),
            s(new Error("Failed to read the file."))
        }
        ,
        o.onload = i => {
            const a = new Image;
            a.onerror = l => {
                q.addError(new Error("Image loading has failed:",{
                    cause: l
                })),
                s(new Error("Failed to load the image."))
            }
            ,
            a.onload = () => {
                const l = document.createElement("canvas");
                let c, u = 0, d = 0;
                switch (n) {
                case "fill":
                    c = t / Math.min(a.width, a.height);
                    break;
                case "square":
                    c = t / Math.min(a.width, a.height);
                    break;
                case "fit":
                    c = t / Math.max(a.width, a.height);
                    break
                }
                const f = a.width * c
                  , p = a.height * c;
                n === "square" ? (l.width = t,
                l.height = t,
                u = (t - f) / 2,
                d = (t - p) / 2) : (l.width = f,
                l.height = p);
                const m = l.getContext("2d");
                if (m == null) {
                    q.addError("Canvas context creation failed. Your environment might not fully support HTML5 canvas."),
                    s(new Error("Failed to create canvas context."));
                    return
                }
                m.drawImage(a, u, d, f, p);
                const v = e.type || "image/png";
                l.toBlob(_ => {
                    _ ? r(new File([_],e.name,{
                        type: v
                    })) : (q.addError("Blob creation failed. Blob is null."),
                    s(new Error("Failed to create blob from image data.")))
                }
                , v)
            }
            ,
            i.target == null ? (q.addError("Event target is null. Failed to load image."),
            s("Failed to load image.")) : a.src = i.target.result
        }
        ,
        o.readAsDataURL(e)
    }
    )
}
function vAe(e, t) {
    return QG(e, t, "square")
}
function _Ae(e) {
    const t = e.name.split("/") ?? [];
    return (t[t.length - 1] ?? "").replace(/[-_]/g, " ").split(".")[0]
}
function u2e(e, t) {
    return t ? e.slice(0, -t.length - 1) : e
}
function yAe() {
    const e = ue()
      , t = $t(e, "3278106051")
      , n = $t(e, "2356508715");
    return h.useMemo( () => () => !t.get("allow_receiver_see_user_uploaded_files") && !n.get("allow_receiver_see_user_uploaded_files"), [t, n])
}
const Yn = xt({
    defaultCreateEntryError: {
        id: "fileUpload.defaultCreateEntryError",
        defaultMessage: "Unable to upload {fileName}"
    },
    defaultDownloadLinkError: {
        id: "fileUpload.defaultDownloadLinkError",
        defaultMessage: "Failed to get upload status for {fileName}"
    },
    unknownError: {
        id: "fileUpload.unknownError",
        defaultMessage: "Unknown error occurred"
    },
    fileZeroBytes: {
        id: "fileUpload.fileZeroBytes",
        defaultMessage: "File is empty"
    },
    fileTooLarge: {
        id: "fileUpload.fileTooLarge",
        defaultMessage: "File is too large"
    },
    overUserQuota: {
        id: "fileUpload.overUserQuota",
        defaultMessage: "User quota exceeded"
    },
    fileNotFound: {
        id: "fileUpload.fileNotFound",
        defaultMessage: "File not found"
    },
    fileTimedOut: {
        id: "fileUpload.fileTimedOut",
        defaultMessage: "File upload timed out. Please try again."
    },
    fileEmpty: {
        id: "fileUpload.fileEmpty",
        defaultMessage: "No text could be extracted from this file."
    },
    fileTooManyTokens: {
        id: "fileUpload.fileTooManyTokens",
        defaultMessage: "This file contains too much text content. Please try again with a smaller file."
    },
    fileEncrypted: {
        id: "fileUpload.fileEncrypted",
        defaultMessage: "This file is encrypted/requires a password to access. Please try again with an unencrypted file."
    },
    fileCorrupted: {
        id: "fileUpload.fileCorrupted",
        defaultMessage: "This file is corrupted. Please ensure the file is not corrupted and try again."
    },
    codeInterpreterSessionTimeout: {
        id: "fileUpload.codeInterpreterSessionTimeout",
        defaultMessage: "Code interpreter session expired"
    },
    permissionError: {
        id: "fileUpload.permissionError",
        defaultMessage: "Missing permission to access file"
    },
    fileDownloadFailed: {
        id: "filesModal.fileDownloadFailed",
        defaultMessage: "File download failed. Please try again."
    },
    failedUploadToBlobStore: {
        id: "fileUpload.failedUploadToBlobStore",
        defaultMessage: "Failed upload to files.oaiusercontent.com. Please ensure your network settings allow access to this site or contact your network administrator."
    }
});
let r2 = null;
async function d2e() {
    return r2 || (r2 = (await he(async () => {
        const {default: e} = await import("./e8thlmiuh1tetfnu.js");
        return {
            default: e
        }
    }
    , [])).default),
    r2
}
const Mp = {
    duration: 20,
    hasCloseButton: !0
};
function f2e(e) {
    return JSON.stringify({
        file: e.name,
        modified: e.lastModified,
        currentTime: new Date().toString()
    })
}
function hS(e) {
    return new Promise( (t, n) => {
        const r = new FileReader
          , s = new Image;
        r.onload = () => {
            s.onload = () => t(s),
            s.onerror = o => n(o),
            s.src = r.result
        }
        ,
        r.readAsDataURL(e)
    }
    )
}
async function h2e(e, t, n, r, s) {
    try {
        const o = await ie.safePost("/files", {
            authOption: s ? Qt.Anonymous : void 0,
            requestBody: {
                file_name: e,
                file_size: t,
                use_case: n.kind,
                gizmo_id: n.kind === Nn.Gizmo ? n.gizmoId : void 0,
                timezone_offset_min: new Date().getTimezoneOffset(),
                reset_rate_limits: !!r
            }
        });
        if (o.status === gf.Error)
            throw V.logEvent("Create File Entry Error", {
                error_code: o.error_code,
                error_type_name: "FileServiceErrorResponse",
                error_msg: o.error_code,
                error_stack: ""
            }),
            new on("Could not create file",o.error_code);
        return o
    } catch (o) {
        throw o instanceof on || (o instanceof Qg ? V.logEvent("Create File Entry Error", {
            error_type_name: "ClientRequestMismatchedAuthError",
            error_msg: o.message,
            error_stack: o.stack
        }) : o instanceof _t ? V.logEvent("Create File Entry Error", {
            error_type_name: o.detail?.type === "throttled" ? "RequestThrottled" : "RequestError",
            error_msg: o.message,
            error_stack: o.stack
        }) : o instanceof Error ? V.logEvent("Create File Entry Error", {
            error_type_name: o.name,
            error_msg: o.message,
            error_stack: o.stack
        }) : V.logEvent("Create File Entry Error", {
            error_type_name: "UnknownError",
            error_msg: String(o),
            error_stack: ""
        })),
        o
    }
}
function eV(e) {
    const t = e.split(".")
      , n = t[t.length - 1];
    return n === "error" || n === "cancelled" || n === "failed" || n === "unknown"
}
function tV(e) {
    if (!e)
        return;
    let t;
    if (e.thumbnail && typeof e.thumbnail == "object") {
        const r = e.thumbnail
          , s = r.file_id
          , o = r.width
          , i = r.height
          , a = r.size_bytes;
        typeof s == "string" && typeof o == "number" && typeof i == "number" && typeof a == "number" && (t = {
            fileId: s,
            width: o,
            height: i,
            sizeBytes: a
        })
    }
    const n = typeof e.transcript == "string" ? e.transcript : void 0;
    if (t || n)
        return {
            thumbnail: t,
            transcript: n
        }
}
async function nV(e, t, n) {
    try {
        const r = at.streamedJsonPost(`${lt}/files/process_upload_stream`, e, {
            authOption: n ? Qt.Anonymous : void 0
        });
        let s, o, i;
        for await(const a of r) {
            if (eV(a.event)) {
                const u = `Error stream processing upload: indexing failed: ${a.event}`;
                throw new on(u,a.event,a.extra)
            }
            a.progress != null && t?.(a.progress),
            a?.extra?.total_tokens != null && (s = a.extra.total_tokens);
            const l = a?.extra?.metadata_object_id;
            typeof l == "string" && l.length > 0 && (i = l);
            const c = tV(a.extra);
            c && (o = c)
        }
        return s || o || i ? {
            fileTokenSize: s,
            libraryFileId: i,
            thumbnail: o?.thumbnail,
            transcript: o?.transcript
        } : void 0
    } catch (r) {
        throw r instanceof on || r instanceof _t && r.isClientError() ? r : new on(`Error stream processing upload: ${r}`,"stream_process_error")
    }
}
async function rV(e, t, n, r, s, o, i) {
    const a = {
        ENTRY_CREATED: 10,
        FILE_UPLOADED: 60,
        FILE_PROCESSED: 100
    };
    let l = Jr.Initial;
    V.logEvent("Upload File Initiated", {
        client: "web",
        useCase: s.kind,
        uploadEntry: "local"
    }),
    ft.logEvent("chatgpt_file_upload_started", null, {
        client: "web",
        useCase: s.kind,
        uploadEntry: "local"
    });
    const c = i.usesRetrievalIndex ?? !1
      , u = c ? performance.now() : void 0
      , d = Th().resetRateLimits;
    try {
        const {file_id: f, upload_url: p} = await h2e(t.name, t.size, s, !!d, i.isUnauthenticated);
        o.onFileCreated(e, f, p),
        l = Jr.FileCreated,
        o.onFileUploadProgress(e, a.ENTRY_CREATED);
        const m = s.kind === Nn.Gizmo ? s.gizmoId : void 0
          , v = {
            client: "web",
            useCase: s.kind,
            uploadEntry: "local",
            fileId: f,
            fileSize: t.size
        };
        V.logEvent("Blob Store Upload Started", v);
        const _ = S => S.toLowerCase().includes("/api/estuary/upload_content_and_finalize")
          , y = S => S.toLowerCase().includes("/api/estuary/upload_content_bytes");
        let b;
        if (_(p)) {
            const {finalStatus: S, metadata: C} = await y2e({
                file: t,
                cdnUrl: p,
                fileId: f,
                fileName: t.name,
                useCaseType: s,
                shouldIndexForRetrieval: c,
                gizmoId: m,
                handlers: o,
                tempId: e,
                imageDimensions: i.imageDimensions,
                milestones: {
                    entry: a.ENTRY_CREATED,
                    uploaded: a.FILE_UPLOADED,
                    processed: a.FILE_PROCESSED
                }
            });
            b = C,
            l = S
        } else if (y(p)) {
            const {finalStatus: S, metadata: C} = await _2e({
                file: t,
                destinationUrl: p,
                fileId: f,
                fileName: t.name,
                useCaseType: s,
                shouldIndexForRetrieval: c,
                gizmoId: m,
                onOverallProgress: w => {
                    o.onFileUploadProgress(e, w)
                }
                ,
                onUploadComplete: () => {
                    o.onFileUploadProgress(e, a.FILE_UPLOADED)
                }
                ,
                milestones: {
                    entry: a.ENTRY_CREATED,
                    uploaded: a.FILE_UPLOADED,
                    processed: a.FILE_PROCESSED
                }
            });
            b = C,
            l = S,
            o.onFileUploaded(e, f, i.imageDimensions, b)
        } else {
            const S = await b2e(t, p, w => {
                o.onFileUploadProgress(e, a.ENTRY_CREATED + (a.FILE_UPLOADED - a.ENTRY_CREATED) * w)
            }
            );
            if (o.onFileUploadProgress(e, a.FILE_UPLOADED),
            S.status !== 201)
                throw V.logEvent("Blob Store Upload Error", {
                    ...v,
                    error_type_name: `HTTPStatus${S.status}`,
                    error_msg: `HTTP status ${S.status}: ${S.statusText}`,
                    error_stack: ""
                }),
                new on("File upload to blobstore failed","failed_upload_to_blobstore");
            V.logEvent("Blob Store Upload Completed", v),
            l = Jr.FileUploaded;
            const C = {
                file_id: f,
                use_case: s.kind,
                gizmo_id: m,
                index_for_retrieval: c,
                file_name: t.name
            };
            b = await nV(C, w => {
                o.onFileUploadProgress(e, a.FILE_UPLOADED + (a.FILE_PROCESSED - a.FILE_UPLOADED) * w / 100)
            }
            , i.isUnauthenticated),
            l = Jr.FileProcessed,
            o.onFileUploaded(e, f, i.imageDimensions, b),
            c && (l = Jr.RetrievalIndexCreated)
        }
        u != null && yn(Ot()) && ie.safePost("/lat/retrieval", {
            requestBody: {
                e2e_latency_ms: performance.now() - u,
                type: "file"
            }
        })
    } catch (f) {
        sV(n, r, t.name, f);
        let p = "NotInstanceOfError";
        f instanceof _t ? p = `${f.name}_${f.status}` : (f instanceof Error || f instanceof on) && (p = f.name),
        o.onError(e, "error", p, s, l)
    }
}
async function bAe(e, t, n, r, s, o) {
    const {width: i, height: a} = await hS(t);
    return rV(e, t, n, r, {
        kind: s
    }, o, {
        imageDimensions: {
            width: i,
            height: a
        }
    })
}
async function p2e(e, t) {
    const n = await ie.safeGet("/files/{file_id}", {
        parameters: {
            path: {
                file_id: e
            },
            query: t != null ? {
                gizmo_id: t
            } : void 0
        }
    });
    return {
        name: n.name,
        status: n.metadata?.retrieval?.status ?? au.Processing,
        error_code: n.metadata?.retrieval?.error_code,
        file_size_tokens: n.file_size_tokens
    }
}
async function m2e(e, t) {
    const n = Date.now() + 6e4
      , r = o => new Promise(i => setTimeout(i, o));
    let s = 0;
    for (; Date.now() < n; ) {
        const o = await p2e(e, t);
        if (o.status === au.Success || o.status === au.Skipped)
            return o;
        if (o.status === au.Failed)
            throw new on("Context extraction failed",o.error_code);
        s++,
        await r(Math.min(1e3, 100 * s))
    }
    throw new on("Retrieval indexing timed out")
}
function g2e(e) {
    if (e.code === "file.indexing.error") {
        const t = e.extra?.file_parse_error_code;
        return typeof t == "string" ? t : "file.indexing.error"
    }
    return e.code ?? "internal_error"
}
function sV(e, t, n, r) {
    if (r instanceof on && r.code != null) {
        const s = fS(e, g2e(r));
        t.danger(s, {
            ...Mp,
            toastId: "file_upload_error",
            loggingTitle: s,
            loggingDescription: s
        })
    } else if (r instanceof _t && r.detail?.type === "throttled") {
        const s = r.message
          , o = "file-upload-rate-limit";
        (t.getToasts?.() ?? []).some(a => String(a.id).startsWith(o) && a.isShown !== !1) || t.info(s, {
            ...Mp,
            id: o,
            action: Dw.file_upload_rate_limit_upsell_plus
        })
    } else if (r instanceof Qg) {
        const s = e.formatMessage(pS.noAuthFileUpload);
        t.info(s, Mp)
    } else {
        const s = fS(e, "default_upload_error", {
            fileName: n
        });
        t.danger(s, {
            ...Mp,
            toastId: "file_upload_error",
            loggingTitle: s,
            loggingDescription: s
        })
    }
}
const pS = xt({
    retrievalSkippedFile: {
        id: "useFilePickerState.retrievalSkippedFile",
        defaultMessage: 'Unable to extract text from "{fileName}"'
    },
    noAuthFileUpload: {
        id: "useFilePickerState.noAuthFileUpload",
        defaultMessage: "Log in to analyze files and images for free."
    }
});
async function v2e(e) {
    const {file: t, destinationUrl: n, fileId: r, fileName: s, useCaseType: o, shouldIndexForRetrieval: i, gizmoId: a, onOverallProgress: l, onUploadComplete: c, milestones: u} = e
      , d = new FormData;
    d.append("file", t);
    const p = new URL(n,window.location.origin).searchParams.get("upload_url") ?? n;
    d.append("upload_url", p),
    d.append("file_id", r),
    d.append("file_name", s),
    d.append("use_case", o.kind),
    d.append("index_for_retrieval", String(!!i)),
    a && d.append("gizmo_id", a);
    const m = Xf(Ot())
      , v = xi()
      , _ = {
        [Ug]: v,
        [jg]: Hu
    };
    m && (_.Authorization = `Bearer ${m}`);
    const y = ze.getCookie(Be.Workspace);
    typeof y == "string" && y.trim().length > 0 && y.trim() !== di && (_["ChatGPT-Account-ID"] = encodeURIComponent(y.trim()));
    let b = !1;
    const S = L => {
        l(u.entry + (u.uploaded - u.entry) * L)
    }
      , C = L => {
        l(u.uploaded + (u.processed - u.uploaded) * (L / 100))
    }
      , w = 1e4
      , x = 120
      , E = 96;
    let T, k = 0, A = !1, O = 0, M = 0;
    function I(L) {
        return 1 - Math.pow(1 - L, 3)
    }
    function R() {
        if (!A)
            return;
        const L = performance.now() - k
          , N = Math.min(1, L / w)
          , B = E * I(N)
          , H = Math.max(M, Math.min(E, B), O);
        if (H > M && (M = H,
        C(H)),
        O >= 100) {
            P();
            return
        }
        T = window.setTimeout(R, H >= E && O === 0 ? x * 4 : x)
    }
    function D() {
        A || (A = !0,
        k = performance.now(),
        R())
    }
    function P(L=!1) {
        A = !1,
        T !== void 0 && (window.clearTimeout(T),
        T = void 0),
        L && (M = 100,
        C(100))
    }
    return await new Promise( (L, N) => {
        const B = new XMLHttpRequest;
        B.open("POST", n, !0),
        B.withCredentials = !0;
        for (const [ne,_e] of Object.entries(_))
            B.setRequestHeader(ne, _e);
        let H = "", ye, Ie = !1, be;
        function me(ne) {
            if (!Ie) {
                Ie = !0;
                try {
                    B.abort()
                } catch {}
                N(ne instanceof on ? ne : new on(`Error stream processing upload: ${String(ne)}`,"stream_process_error"))
            }
        }
        let ge;
        function ce(ne) {
            for (; ; ) {
                const _e = H.indexOf(`
`);
                if (_e === -1)
                    break;
                const ee = H.slice(0, _e).trim();
                if (H = H.slice(_e + 1),
                !!ee)
                    try {
                        const oe = JSON.parse(ee);
                        if (eV(oe.event)) {
                            P(),
                            me(new on(`Error stream processing upload: indexing failed: ${oe.event}`,oe.event,oe.extra));
                            return
                        }
                        oe.progress != null && (O = oe.progress,
                        O > M && (M = O,
                        C(O)),
                        O >= 100 && P(!0)),
                        oe.event === "file.processing.metadata" && (O = 100,
                        P(!0)),
                        oe?.extra?.total_tokens != null && (ye = oe.extra.total_tokens);
                        const te = tV(oe.extra);
                        te && (be = te);
                        const ve = oe?.extra?.metadata_object_id;
                        typeof ve == "string" && ve.length > 0 && (ge = ve)
                    } catch {
                        if (!ne) {
                            H = ee + `
` + H;
                            break
                        }
                    }
            }
        }
        B.upload.onprogress = ne => {
            if (!ne.lengthComputable)
                return;
            const _e = ne.loaded / ne.total;
            S(_e),
            _e === 1 && !b && (b = !0,
            c(),
            D())
        }
        ;
        let Z = 0;
        B.onreadystatechange = () => {
            if (B.readyState === XMLHttpRequest.LOADING || B.readyState === XMLHttpRequest.DONE) {
                const ne = B.responseText.substring(Z);
                Z = B.responseText.length,
                H += ne,
                ce(B.readyState === XMLHttpRequest.DONE)
            }
            if (B.readyState === XMLHttpRequest.DONE) {
                if (B.status >= 400) {
                    P(),
                    me(new on("File upload to blobstore failed","failed_upload_to_blobstore"));
                    return
                }
                P(M < 100),
                L(ye || be || ge ? {
                    fileTokenSize: ye,
                    libraryFileId: ge,
                    thumbnail: be?.thumbnail,
                    transcript: be?.transcript
                } : {})
            }
        }
        ;
        try {
            B.send(d)
        } catch (ne) {
            me(ne)
        }
    }
    )
}
async function _2e(e) {
    const {file: t, destinationUrl: n, fileId: r, fileName: s, useCaseType: o, shouldIndexForRetrieval: i, gizmoId: a, onOverallProgress: l, onUploadComplete: c, milestones: u} = e
      , d = new FormData;
    d.append("file", t);
    const p = new URL(n,window.location.origin).searchParams.get("upload_url") ?? n;
    d.append("upload_url", p);
    const m = Xf(Ot())
      , v = xi()
      , _ = {
        [Ug]: v,
        [jg]: Hu
    };
    m && (_.Authorization = `Bearer ${m}`);
    const y = ze.getCookie(Be.Workspace);
    typeof y == "string" && y.trim().length > 0 && y.trim() !== di && (_["ChatGPT-Account-ID"] = encodeURIComponent(y.trim())),
    await new Promise( (w, x) => {
        const E = new XMLHttpRequest;
        E.open("POST", n, !0),
        E.withCredentials = !0;
        for (const [T,k] of Object.entries(_))
            E.setRequestHeader(T, k);
        E.upload.onprogress = T => {
            if (!T.lengthComputable)
                return;
            const k = T.loaded / T.total;
            l(u.entry + (u.uploaded - u.entry) * k),
            k === 1 && c()
        }
        ,
        E.onreadystatechange = () => {
            if (E.readyState === XMLHttpRequest.DONE) {
                if (E.status >= 400) {
                    x(new on(`File upload to Estuary failed: HTTP ${E.status}`,"failed_upload_to_blobstore"));
                    return
                }
                w()
            }
        }
        ;
        try {
            E.send(d)
        } catch (T) {
            x(T instanceof on ? T : new on(`Error uploading to Estuary: ${String(T)}`,"stream_process_error"))
        }
    }
    );
    const b = {
        file_id: r,
        use_case: o.kind,
        gizmo_id: a,
        index_for_retrieval: i,
        file_name: s
    }
      , S = await nV(b, w => {
        l(u.uploaded + (u.processed - u.uploaded) * w / 100)
    }
    );
    return {
        finalStatus: i ? Jr.RetrievalIndexCreated : Jr.FileProcessed,
        metadata: S
    }
}
async function y2e(e) {
    const {file: t, cdnUrl: n, fileId: r, fileName: s, useCaseType: o, shouldIndexForRetrieval: i, gizmoId: a, handlers: l, tempId: c, imageDimensions: u, milestones: d} = e
      , f = await v2e({
        file: t,
        destinationUrl: n,
        fileId: r,
        fileName: s,
        useCaseType: o,
        shouldIndexForRetrieval: i,
        gizmoId: a,
        onOverallProgress: m => {
            l.onFileUploadProgress(c, m)
        }
        ,
        onUploadComplete: () => {
            l.onFileUploadProgress(c, d.uploaded)
        }
        ,
        milestones: d
    });
    let p = Jr.FileProcessed;
    return l.onFileUploaded(c, r, u, f),
    i && (p = Jr.RetrievalIndexCreated),
    {
        finalStatus: p,
        metadata: f
    }
}
async function b2e(e, t, n, r) {
    const s = await d2e();
    return await s.request({
        method: "put",
        url: t,
        data: e,
        headers: {
            "x-ms-blob-type": "BlockBlob",
            "x-ms-version": "2020-04-08",
            "Content-Type": e.type
        },
        onUploadProgress: o => {
            o.progress !== void 0 && n && n(o.progress)
        }
    }).catch(function(o) {
        let i = {
            ...r
        };
        throw s && o instanceof s.AxiosError && o.response?.status ? i = {
            ...i,
            error_type_name: `AxiosHTTPError${o.response.status}`,
            error_msg: o.message,
            error_stack: o.stack
        } : o instanceof Error && (i = {
            ...i,
            error_type_name: o.name,
            error_msg: o.message,
            error_stack: o.stack
        }),
        V.logEvent("Blob Store Upload Error", i),
        new on("File upload to blobstore failed","failed_upload_to_blobstore")
    })
}
const oV = {
    files: [],
    connectorFileData: {}
}
  , iV = h.createContext(null);
function CAe({children: e, initialState: t=oV}) {
    const [n] = h.useState( () => Ei( () => t));
    return g.jsx(iV.Provider, {
        value: n,
        children: e
    })
}
function aV() {
    const e = h.useContext(iV);
    if (e == null)
        throw new Error("useFilePickerState must be used inside a FilePickerContext");
    return e
}
function SAe(e) {
    const t = aV();
    return Xl(t, e)
}
const wAe = {
    hasUploadInProgress: ({files: e}) => e.some(t => t.status === ii.Uploading),
    getReadyFiles: ({files: e}) => e.filter(t => t.status === ii.Ready)
}
  , s2 = 2048;
async function MA(e) {
    let t = e
      , {width: n, height: r} = await hS(t);
    if (n > s2 || r > s2)
        try {
            const s = await QG(t, s2)
              , o = await hS(s);
            n = o.width,
            r = o.height,
            t = s
        } catch (s) {
            q.addError(new Error("Error resizing image:",{
                cause: s
            }))
        }
    return {
        file: t,
        width: n,
        height: r
    }
}
async function C2e(e, t, n, r, s, o, i, a, l) {
    const c = performance.now();
    V.logEvent("Upload File Initiated", {
        client: "web",
        useCase: r.kind,
        contextConnector: o.contextConnector,
        fileSourceType: o.type
    }),
    ft.logEvent("chatgpt_file_upload_started", null, {
        client: "web",
        useCase: r.kind,
        contextConnector: o.contextConnector,
        fileSourceType: o.type
    });
    let u = Jr.Initial;
    const d = cV(e);
    try {
        const f = await ie.safePost("/connectors/upload/{connector_name}", {
            parameters: {
                path: {
                    connector_name: o.contextConnector
                }
            },
            requestBody: {
                id: t,
                upload_use_case: r.kind,
                mime_type: n.type,
                name: n.name,
                gizmo_id: i,
                drive_id: o.o365DriveId,
                manifest: o.manifest
            }
        });
        switch (r.kind === Nn.Gizmo && (r = {
            ...r,
            kind: s.includes(lV(n)) ? Nn.Multimodal : Nn.MyFiles
        }),
        f.type) {
        case "error":
            throw S2e(f.error);
        case "file":
            {
                switch (d.onFileCreated(t, f.file.id, "", o.contextConnector),
                u = Jr.FileProcessed,
                r.kind) {
                case Nn.MyFiles:
                    {
                        d.onFileUploadProgress(t, 90);
                        const p = await m2e(f.file.file_id, i);
                        p?.status === au.Skipped && l.danger(a.formatMessage(pS.retrievalSkippedFile, {
                            fileName: p.name
                        }), {
                            ...dS,
                            toastId: "retrieval_index_skipped",
                            loggingTitle: pS.retrievalSkippedFile.defaultMessage,
                            loggingDescription: "Retrieval index skipped"
                        }),
                        d.onFileUploaded(t, f.file.file_id, void 0, {
                            fileTokenSize: p.file_size_tokens,
                            mimeType: f.file.mime_type
                        }),
                        u = Jr.RetrievalIndexCreated;
                        break
                    }
                case Nn.Multimodal:
                    {
                        d.onFileUploaded(t, f.file.file_id, {
                            width: 512,
                            height: 512
                        }, {
                            mimeType: f.file.mime_type
                        });
                        break
                    }
                case Nn.AceUpload:
                    {
                        d.onFileUploaded(t, f.file.file_id, void 0, {
                            mimeType: f.file.mime_type
                        });
                        break
                    }
                case Nn.DalleAgent:
                case Nn.Gizmo:
                case Nn.ProfilePicture:
                default:
                    throw new on(`Use case not supported by cloud doc: ${r.kind}`)
                }
                break
            }
        case "folder":
            throw new on("Folder type not supported")
        }
        yn(Ot()) && ie.safePost("/lat/retrieval", {
            requestBody: {
                e2e_latency_ms: performance.now() - c,
                type: o.contextConnector
            }
        })
    } catch (f) {
        q.addError(new Error(`Failed to upload connected file by ${o.contextConnector}`,{
            cause: f
        }));
        const p = u2e(n.name, o?.syntheticExtension);
        sV(a, l, p, f);
        let m = "NotInstanceOfError";
        f instanceof _t ? m = `${f.name}_${f.status}` : (f instanceof Error || f instanceof on) && (m = f.name),
        d.onError(t, "error", "connector_upload_" + m, {
            kind: Nn.MyFiles
        }, u)
    }
}
function lV(e) {
    return e.type || JG(e.name)
}
function S2e({status_code: e, error_code: t, error_message: n}) {
    if (e && e < 500) {
        let r = "internal_error";
        return t ? r = t : e === 404 ? r = "file_not_found" : e === 403 ? r = "permission_error" : e === 413 && (r = "file_too_large"),
        new on(n,r)
    } else
        return _t.createWithErrorMessage("/connectors/upload", "server", n)
}
const ca = {
    reset: e => {
        e.setState(oV)
    }
    ,
    restoreFiles: (e, t) => {
        e.setState({
            files: t
        })
    }
    ,
    uploadFile: async (e, t, n, r, s, o, i, a={}, l, c, u=!1, d=!1) => {
        const {gizmoId: f, isUnauthenticated: p} = a
          , m = e.getState().files
          , v = a2e(r, n.name, n.type, c?.contextConnector, l)
          , _ = {
            tempId: t,
            gizmoId: a.gizmoId,
            status: ii.Uploading,
            file: n,
            progress: 1,
            fileId: null,
            cdnUrl: null,
            contextConnectorInfo: c,
            contextConnector: c?.contextConnector,
            source: u ? "library" : c ? "connector" : "local"
        };
        if (!u && m.length === pA)
            V.logEvent("Uploaded Max Files Error"),
            i.danger(o.formatMessage(Ip.maxUploadsAtATime, {
                maxUploads: pA,
                fileName: n.name
            }), {
                ...dS,
                toastId: "max_uploads_at_a_time",
                loggingTitle: Ip.maxUploadsAtATime.defaultMessage,
                loggingDescription: "Max uploads at a time"
            });
        else if (!u && m.some(y => y.tempId === t))
            V.logEvent("Uploaded Duplicate File Error"),
            i.danger(o.formatMessage(Ip.duplicateFileAttached, {
                fileName: n.name.length > 20 ? n.name.slice(0, 19) + "â€¦" : n.name
            }), {
                ...dS,
                toastId: "duplicate_file_attached",
                loggingTitle: Ip.duplicateFileAttached.defaultMessage,
                loggingDescription: "Duplicate file attached"
            });
        else {
            (v !== Bn.Retrieval ? !0 : d ? u : !0) && e.setState( ({files: C}) => ({
                files: [...C, _]
            }));
            let b;
            const S = {
                isUnauthenticated: p
            };
            if (s.includes(n.type)) {
                if (b = {
                    kind: Nn.Multimodal
                },
                !c) {
                    const C = await MA(n);
                    n = C.file,
                    S.imageDimensions = {
                        width: C.width,
                        height: C.height
                    }
                }
            } else if (["video/mp4", "video/quicktime"].includes(n.type) && s.includes("image/png") && Xe(Ot(), "3681682292"))
                b = {
                    kind: "multimodal_video"
                };
            else if (v === Bn.Codex) {
                b = {
                    kind: Nn.Codex
                };
                const C = await MA(n);
                n = C.file,
                S.imageDimensions = {
                    width: C.width,
                    height: C.height
                }
            } else
                switch (v) {
                case Bn.Multimodal:
                    throw new Error(`Multimodal file upload not supported mime type, ${n.type}
Supported mime types: ` + s.join(", "));
                case Bn.Interpreter:
                    b = {
                        kind: Nn.AceUpload
                    };
                    break;
                case Bn.Retrieval:
                    b = {
                        kind: u ? Nn.LibraryFiles : Nn.MyFiles
                    },
                    S.usesRetrievalIndex = !0;
                    break;
                case Bn.ProfilePicture:
                    throw new Error("cannot upload profile picture via uploadFile");
                case Bn.ContextConnector:
                case Bn.None:
                    return
                }
            f != null && (b = {
                kind: Nn.Gizmo,
                gizmoId: f
            }),
            a.skipUpload || (c ? await C2e(e, t, n, b, s, c, a.gizmoId, o, i) : await rV(t, n, o, i, b, cV(e), S))
        }
    }
    ,
    createFileCompleted: (e, t, n, r, s) => {
        const o = e.getState().files
          , i = o.findIndex(l => l.tempId === t)
          , a = o[i];
        if (i >= 0 && a.status === ii.Uploading) {
            const l = [...o];
            l.splice(i, 1, {
                ...a,
                progress: 10,
                fileId: n,
                cdnUrl: r,
                contextConnector: s
            }),
            e.setState({
                files: l
            })
        }
    }
    ,
    updateProgress: (e, t, n) => {
        const r = e.getState().files
          , s = r.findIndex(i => i.tempId === t)
          , o = r[s];
        if (s >= 0 && o.status === ii.Uploading) {
            const i = [...r];
            i.splice(s, 1, {
                ...o,
                progress: n
            }),
            e.setState({
                files: i
            })
        }
    }
    ,
    uploadCompleted: (e, t, n, r, s, o) => {
        const i = e.getState().files
          , a = i.findIndex(l => l.tempId === t);
        if (a >= 0 && i[a].status === ii.Uploading && i[a].fileId != null) {
            const l = i[a]
              , c = [...i]
              , u = {
                ...l,
                tempId: t,
                status: ii.Ready,
                progress: 100,
                fileSpec: {
                    name: l.file.name,
                    id: l.fileId,
                    size: l.file.size,
                    contextConnectorInfo: l.contextConnectorInfo,
                    mimeType: s?.mimeType ?? lV(l.file),
                    ...r || {},
                    ...s || {}
                },
                libraryFileId: s?.libraryFileId ?? l.libraryFileId
            };
            c.splice(a, 1, u);
            const d = {
                ...e.getState().connectorFileData
            };
            o && (d[o?.file_id] = o),
            e.setState({
                files: c,
                connectorFileData: d
            }),
            V.logEvent("Upload File Completed", {
                status: l.status,
                fileId: l.fileId,
                contextConnector: l.contextConnector ?? "local"
            }),
            ft.logEvent("chatgpt_file_upload_completed", null, {
                status: l.status,
                contextConnector: l.contextConnector ?? "local"
            })
        }
    }
    ,
    remove: (e, t, n, r, s, o) => {
        const i = e.getState().files
          , a = i.findIndex(l => l.tempId === t);
        if (a >= 0) {
            const l = i[a];
            n === "error" ? (V.logEvent("Upload File Error", {
                status: l.status,
                fileId: l.fileId,
                client: "web",
                errorClassName: r ?? "undefined",
                useCaseType: s,
                uploadStatus: o ?? "undefined",
                contextConnector: l.contextConnector
            }),
            ft.logEvent("chatgpt_file_upload_error", null, {
                client: "web",
                errorClassName: r ?? "undefined",
                useCaseType: s?.kind ?? "undefined",
                uploadStatus: o ?? "undefined",
                contextConnector: l.contextConnector ?? "undefined"
            })) : V.logEvent("Remove File", {
                status: l.status,
                fileId: l.fileId
            });
            const c = [...i];
            c.splice(a, 1),
            e.setState({
                files: c
            })
        }
    }
    ,
    attachLibraryFile: (e, t) => {
        const n = new File([],t.name,{
            type: t.mimeType
        })
          , r = f2e(n)
          , s = e.getState().files;
        if (s.some(a => a.fileId === t.id))
            return;
        const o = t.mimeType?.startsWith("image/") === !0
          , i = {
            tempId: r,
            status: ii.Ready,
            file: n,
            fileId: t.id,
            cdnUrl: null,
            progress: 100,
            source: "library",
            libraryFileId: t.libraryFileId,
            fileSpec: {
                id: t.id,
                name: t.name,
                size: t.size ?? 0,
                mimeType: t.mimeType,
                ...o ? {
                    width: 512,
                    height: 512
                } : {}
            }
        };
        e.setState({
            files: [...s, i]
        })
    }
}
  , cV = e => ({
    onFileCreated: ca.createFileCompleted.bind(null, e),
    onFileUploadProgress: ca.updateProgress.bind(null, e),
    onFileUploaded: ca.uploadCompleted.bind(null, e),
    onError: ca.remove.bind(null, e)
})
  , Ip = xt({
    maxUploadsAtATime: {
        id: "useFilePickerState.maxUploadsAtATime",
        defaultMessage: "Unable to upload {fileName}. Max {maxUploads} uploads at a time"
    },
    duplicateFileAttached: {
        id: "useFilePickerState.duplicateFileAttached",
        defaultMessage: "Unable to upload {fileName} because an identical file has already been attached to this message."
    }
})
  , w2e = Ne.createContext({
    mode: void 0,
    getGizmoId: void 0
})
  , E2e = () => h.useContext(w2e)
  , o2 = {
    filePickerStarted: e => {
        V.logEvent("Context Connectors: Picker Started", {
            contextConnector: e
        })
    }
    ,
    filePickerLoaded: e => {
        V.logEvent("Context Connectors: Picker Loaded", {
            contextConnector: e
        })
    }
    ,
    filePickerPicked: (e, t) => {
        V.logEvent("Context Connectors: Picker Picked", {
            contextConnector: e,
            numFiles: t
        })
    }
    ,
    filePickerCancelled: e => {
        V.logEvent("Context Connectors: Picker Cancelled", {
            contextConnector: e
        })
    }
    ,
    linkPasted: e => {
        V.logEvent("Context Connectors: Link Pasted", {
            ...e
        })
    }
    ,
    linkMetadataFetchStarted: e => {
        V.logEvent("Context Connectors: Link Metadata Fetch Started", {
            contextConnector: e
        })
    }
    ,
    linkMetadataFetchSucceeded: (e, t) => {
        V.logEvent("Context Connectors: Link Metadata Fetch Succeeded", {
            contextConnector: e,
            mimeType: t
        })
    }
    ,
    linkMetadataFetchFailed: (e, t) => {
        V.logEvent("Context Connectors: Link Metadata Fetch Failed", {
            contextConnector: e,
            reason: String(t)
        })
    }
    ,
    oauthUpsellButtonClick: (e, t) => {
        V.logEvent("Context Connectors: OAuth Upsell Button Click", {
            contextConnector: e,
            choice: t
        })
    }
    ,
    expiredAccessTokenUsed: (e, t) => {
        V.logEvent("Context Connectors: Expired Access Token Used", {
            contextConnector: e,
            useCase: t
        })
    }
};
function EAe(e, t, n, r) {
    const s = Tn()
      , o = gt()
      , {getGizmoId: i} = E2e()
      , [a,l] = h.useState();
    h.useEffect( () => {
        i ? i().then(f => l(f)) : l(void 0)
    }
    , [i]);
    const c = Xl(t)
      , u = aV();
    return h.useCallback(f => {
        const {docsReferencedByURL: p} = sn(e) ?? {};
        if (p != null)
            for (const m of f) {
                const {id: v, type: _, handler: y} = m
                  , b = `${_}:${v}`
                  , S = p[b]
                  , w = u.getState().files.find(x => x.tempId === v);
                if (S != null && S !== "failed" && w) {
                    s.success(o.formatMessage(Rp.fileAlreadyAttached), {
                        hasCloseButton: !0
                    });
                    continue
                }
                switch (y.type) {
                case "fetch":
                    {
                        kt(e, x => {
                            x.docsReferencedByURL[b] = "pending"
                        }
                        ),
                        ca.uploadFile(u, v, new File([],o.formatMessage(Rp.fileLoading)), Bn.None, n, o, s, {
                            skipUpload: !0,
                            gizmoId: a
                        }, r, {
                            contextConnector: _,
                            sourceUrl: m.url,
                            syntheticExtension: null,
                            type: _f.Link
                        }),
                        o2.linkMetadataFetchStarted(_),
                        y.tryFetch().then(x => {
                            if (ca.remove(u, v, "none"),
                            x == null)
                                return null;
                            const {id: E, title: T, connector: k, mimeType: A, url: O, syntheticExtension: M, o365DriveId: I, manifest: R} = x;
                            o2.linkMetadataFetchSucceeded(_, A),
                            kt(e, P => {
                                P.docsReferencedByURL[b] = "fetched"
                            }
                            );
                            let D = T;
                            k === Ae.GDRIVE && (D = M ? `${T}.${M}` : T),
                            ca.uploadFile(u, E, new File([],D,{
                                type: A.split(";")[0]
                            }), Bn.Retrieval, n, o, s, {
                                gizmoId: a
                            }, r, {
                                contextConnector: k,
                                sourceUrl: O,
                                syntheticExtension: M,
                                type: _f.Link,
                                o365DriveId: I,
                                manifest: R
                            })
                        }
                        ).catch(x => {
                            o2.linkMetadataFetchFailed(_, x),
                            x instanceof _t && x.status === 404 && _ === Ae.NOTION_OPEN_CONNECTOR ? (s.danger(Rp.fileNotAccessible, {
                                hasCloseButton: !0,
                                toastId: "ccc_use_parsed_document_handler"
                            }),
                            c.appendMessageIfNotDismissed({
                                connector: _,
                                type: "not-connected"
                            })) : s.danger(Rp.fileFetchFailed, {
                                hasCloseButton: !0,
                                toastId: "ccc_use_parsed_document_handler"
                            }),
                            kt(e, E => {
                                E.docsReferencedByURL[b] = "failed"
                            }
                            ),
                            ca.remove(u, v, "none")
                        }
                        );
                        break
                    }
                case "prompt":
                    {
                        c.appendMessageIfNotDismissed({
                            connector: _,
                            type: y.message
                        }),
                        kt(e, x => {
                            x.docsReferencedByURL[b] = "prompted"
                        }
                        );
                        break
                    }
                }
            }
    }
    , [e, u, s, o, n, a, r, c])
}
const Rp = xt({
    fileLoading: {
        id: "CCC.fileLoading",
        defaultMessage: "Loadingâ€¦"
    },
    fileFetchFailed: {
        id: "CCC.fileFetchFailed",
        defaultMessage: "Unable to fetch file information"
    },
    fileAlreadyAttached: {
        id: "CCC.fileAlreadyAttached",
        defaultMessage: "This file is already a part of your message."
    },
    fileNotAccessible: {
        id: "CCC.fileNotAccessible",
        defaultMessage: "This document is not accessible by ChatGPT, please make sure the document exists and you have granted ChatGPT the access."
    }
})
  , uV = () => {
    const e = A4()
      , {connectorConfig: t, isLoading: n, error: r, refetch: s} = Mbe()
      , o = t.has(Ae.CONFLUENCE) && !e
      , i = t.has(Ae.GDRIVE) && !e
      , a = t.has(Ae.JIRA) && !e
      , l = t.has(Ae.NOTION_OPEN_CONNECTOR) && !e
      , c = (t.has(Ae.O365_PERSONAL) || t.has(Ae.O365_BUSINESS)) && !e
      , u = t.has(Ae.SLACK_OPEN_CONNECTOR) && !e;
    return {
        isConfluenceEnabled: o,
        isGdriveEnabled: i,
        isJiraEnabled: a,
        isNotionOpenConnectorEnabled: l,
        isO365Enabled: c,
        isSlackOpenConnectorEnabled: u,
        connectorConfig: t,
        isLoading: n,
        hasContextConnectorEnabled: o || i || a || l || c || u,
        error: r,
        refetch: s
    }
}
  , xAe = mr[U.GDRIVE_ACTION_CONNECTOR]
  , TAe = mr[U.GITHUB_CONNECTOR]
  , kAe = mr[U.SHAREPOINT_CONNECTOR]
  , mS = `#settings/${dh.Connectors}`
  , OAe = [U.GDRIVE_ACTION_CONNECTOR, U.GCAL_CONNECTOR, U.GMAIL_CONNECTOR].map(e => mr[e])
  , dV = "connector"
  , j4 = "add-connector-link"
  , x2e = "connector-toggle"
  , T2e = "create-connector"
  , U4 = "product-sku"
  , fV = "redirectAfter"
  , k2e = "system-hint-type"
  , hV = "referrer"
  , AAe = "toggle-all";
var pV = (e => (e.ConversationFollowup = "conversation_followup",
e.UpgradeAccountOnboarding = "upgrade_account_onboarding",
e.JitPluginMessage = "jit_plugin_message",
e.ConnectorNuxModal = "connector_nux_modal",
e.SourcesDropdown = "sources_dropdown",
e.SuggestedPrompts = "suggested_prompts",
e.SettingsConnectorsTab = "settings_connectors_tab",
e.ConnectorToggle = "connector_toggle",
e.Codex = "codex",
e))(pV || {})
  , O2e = (e => (e.Off = "off",
e.EnabledNotSticky = "enabledNotSticky",
e.EnabledSticky = "enabledSticky",
e.EnabledGlaux = "enabledGlaux",
e))(O2e || {});
const MAe = () => {
    const e = oo();
    return ({connectorId: t, redirectAfter: n, systemHintType: r, referrer: s}) => e(mV(o => {
        o.set(j4, "true"),
        o.set(U4, sr.CONNECTOR_SETTING),
        t && o.set(dV, t),
        n && o.set(fV, n),
        r && o.set(k2e, r),
        s && o.set(hV, s)
    }
    ), {
        replace: !0
    })
}
  , IAe = () => {
    const e = oo();
    return () => e(mV(t => {
        t.delete(j4),
        t.delete(U4),
        t.delete(hV)
    }
    ), {
        replace: !0
    })
}
;
function mV(e) {
    const t = window.location.hash
      , [n,r] = t.split("?")
      , s = new URLSearchParams(r);
    e(s);
    const o = s.toString();
    return mS + (o ? `?${o}` : "")
}
const RAe = () => {
    const {hash: e} = cs()
      , t = e.indexOf("?");
    return t === -1 ? !1 : new URLSearchParams(e.substring(t + 1)).get(j4) === "true"
}
  , NAe = () => {
    const {hash: e} = cs()
      , t = e.indexOf("?");
    return t === -1 ? !1 : new URLSearchParams(e.substring(t + 1)).get(x2e) === "true"
}
  , PAe = () => {
    const {hash: e} = cs()
      , t = e.indexOf("?");
    return t === -1 ? !1 : new URLSearchParams(e.substring(t + 1)).get(T2e) === "true"
}
  , DAe = () => {
    const e = oo();
    return t => {
        const n = window.location.hash
          , [r,s] = n.split("?")
          , o = new URLSearchParams(s);
        t ? o.set("connector", t) : o.delete("connector");
        const i = o.toString() ? `${r}?${o.toString()}` : r;
        e(i, {
            replace: !0
        })
    }
}
  , B4 = e => {
    const {hash: t} = cs();
    return h.useMemo( () => {
        const n = t.indexOf("?");
        return n === -1 ? void 0 : new URLSearchParams(t.slice(n + 1)).get(e) ?? void 0
    }
    , [t, e])
}
  , LAe = () => B4(fV)
  , FAe = () => B4(U4)
  , jAe = () => B4(dV)
  , A2e = e => e.supported_auth.some(t => t.type === "OAUTH") ? "OAUTH" : "NONE"
  , M2e = e => ie.safePost("/aip/connectors/links/noauth", {
    requestBody: {
        connector_id: e.id,
        name: e.name,
        action_names: e.actions.map(t => t.name)
    },
    additionalHeaders: {
        [pr]: sr.CONNECTOR_SETTING
    }
})
  , I2e = async ({connector: e, redirectAfter: t, shouldRedirectToConnectorDetails: n=!1, onError: r, openPopup: s, toaster: o, intl: i, productSku: a}) => {
    const l = {
        connectorId: e.id,
        name: e.name,
        actionNames: e.connector_type === "MCP" || e.connector_type === "OPEN_API" ? e.actions.map(c => c.name) : null,
        oauthClientId: null,
        oauthClientScopes: null
    };
    return Rj({
        redirectUri: Ij(e.id),
        connectorPlatformParams: l,
        redirectTo: t || (n ? `${mS}?connector=${e.id}` : mS),
        onError: r,
        openPopup: s,
        toaster: o,
        intl: i,
        productSku: a
    })
}
  , R2e = async ({connector: e, shouldRedirectToConnectorDetails: t=!1, openPopup: n, toaster: r, intl: s}) => {
    switch (A2e(e)) {
    case "OAUTH":
        return await I2e({
            connector: e,
            redirectAfter: void 0,
            shouldRedirectToConnectorDetails: t,
            openPopup: n,
            toaster: r,
            intl: s,
            productSku: sr.CONNECTOR_SETTING
        }),
        null;
    case "NONE":
        return await M2e(e)
    }
}
  , UAe = (e, t) => ie.safePost("/accounts/{account_id}/connectors/{connector_id}/publish", {
    parameters: {
        path: {
            account_id: t,
            connector_id: e
        }
    }
})
  , N2e = () => {
    const e = nc()
      , t = xh()
      , n = h.useMemo( () => t.data?.connection_statuses.filter(i => ["google_drive_oauth", "google_drive_dwd"].includes(i.user_connection_details.knowledge_connector_type)), [t.data])
      , r = uV()
      , s = r.connectorConfig.get(Ae.GDRIVE)
      , o = r.isGdriveEnabled && !!s;
    return {
        isLoading: t.isLoading || r.isLoading,
        fileUploadConfig: o ? s : null,
        internalKnowledgeEnabled: e,
        internalKnowledgeConfigs: e && n?.length ? n : null
    }
}
  , BAe = () => {
    const e = nc()
      , t = xh()
      , n = t.data?.connection_statuses.some(r => r.user_connection_details.connection_type === "github_sync_connector");
    return {
        isLoading: t.isLoading,
        isEnabled: e && n
    }
}
  , qAe = () => {
    const e = nc()
      , t = xh()
      , n = t.data?.connection_statuses.some(r => r.user_connection_details.connection_type === "sharepoint_sync_connector");
    return {
        isLoading: t.isLoading,
        isEnabled: e && n
    }
}
  , P2e = () => {
    const e = uV()
      , t = e.connectorConfig.get(Ae.O365_PERSONAL)
      , n = e.connectorConfig.get(Ae.O365_BUSINESS);
    return {
        isLoading: e.isLoading,
        personalConfig: e.isO365Enabled && t?.access_token ? t : null,
        businessConfig: e.isO365Enabled && n?.access_token ? n : null
    }
}
  , GAe = () => {
    const e = nc()
      , t = bh(e, sr.CONNECTOR_SETTING)
      , n = Vl({
        fetchValidLinksOnly: !0,
        productSku: sr.CONNECTOR_SETTING
    })
      , {fileUploadConfig: r, internalKnowledgeConfigs: s} = N2e()
      , o = P2e()
      , {availableConnectors: i} = l4()
      , a = (n.connectorLinks.get(mr[U.GDRIVE_ACTION_CONNECTOR])?.length ?? 0) > 0 || (s?.filter(_ => _.user_connection_details.auth_status !== "not_connected").length ?? 0) > 0
      , l = (n.connectorLinks.get(mr[U.SHAREPOINT_CONNECTOR])?.length ?? 0) > 0
      , c = !!r?.access_token
      , u = !!o.businessConfig?.access_token
      , d = t.platformConnectors.get(mr[U.GDRIVE_ACTION_CONNECTOR])
      , f = d && d.status !== "DISABLED_BY_ADMIN" || (s?.filter(_ => _.user_connection_details.auth_status === "not_connected").length ?? 0) > 0
      , p = i.some(_ => _.type === U.SHAREPOINT_CONNECTOR && _.status !== "DISABLED_BY_ADMIN");
    return {
        canUpgradeGDrive: c && !a && f,
        canUpgradeSharepoint: u && !l && p,
        isLoading: t.isLoading || n.isLoading
    }
}
;
async function VAe(e) {
    return (await ie.safeGet("/aip/connectors/mcp/oauth_config", {
        parameters: {
            query: {
                mcp_url: e
            }
        },
        additionalHeaders: {
            [pr]: sr.CONNECTOR_SETTING
        }
    })).oauth_config
}
function HAe(e) {
    return ie.safePost("/aip/connectors/mcp/refresh_actions", {
        requestBody: {
            link_id: e
        },
        additionalHeaders: {
            [pr]: sr.CONNECTOR_SETTING
        }
    })
}
function zAe(e, t) {
    return ie.safePatch("/aip/connectors/links/{link_id}", {
        parameters: {
            path: {
                link_id: e
            }
        },
        requestBody: {
            actions: t
        },
        additionalHeaders: {
            [pr]: sr.CONNECTOR_SETTING
        }
    })
}
function D2e(e) {
    return ie.safeGet("/aip/connectors/{connector_id}/conformance", {
        parameters: {
            path: {
                connector_id: e
            }
        },
        additionalHeaders: {
            [pr]: sr.CONNECTOR_SETTING
        }
    })
}
function L2e(e) {
    return ie.safeDelete("/aip/connectors/{connector_id}", {
        parameters: {
            path: {
                connector_id: e
            }
        },
        additionalHeaders: {
            [pr]: sr.CONNECTOR_SETTING
        }
    })
}
const F2e = xt({
    gdriveBrandName: {
        id: "81dp6y",
        defaultMessage: "Google Drive"
    }
})
  , $Ae = (e, t) => e === "gdrive_action_connector" ? t.formatMessage(F2e.gdriveBrandName) : e;
async function WAe(e, t, n) {
    const r = `https://chat.openai.com/aip/${e.id}/oauth/callback`
      , s = t
      , o = await ie.safeGet("/aip/p/{id}/user-settings/oauth/redirect", {
        parameters: {
            path: {
                id: e.id
            },
            query: {
                redirect_uri: r,
                redirect_to: s
            }
        }
    });
    window.location.href = o.redirect_uri
}
async function KAe(e, t, n, r) {
    const s = await ie.safeGet("/connectors/{id}/oauth/redirect", {
        parameters: {
            path: {
                id: e.id
            },
            query: {
                redirect_uri: n,
                entry_point: t,
                redirect_to: r
            }
        }
    });
    window.location.href = s.redirect_uri
}
async function j2e(e, t) {
    e && await ie.safeDelete("/aip/connectors/links/{link_id}", {
        parameters: {
            path: {
                link_id: e
            }
        },
        additionalHeaders: t ? {
            [pr]: t
        } : void 0
    })
}
async function U2e(e, t) {
    await ie.safeDelete("/aip/connectors/links", {
        requestBody: {
            connector_id: e
        },
        additionalHeaders: t ? {
            [pr]: t
        } : void 0
    }),
    window.location.reload()
}
function YAe(e) {
    switch (e) {
    case _f.Link:
        return "link_paste_popover";
    case _f.Picker:
        return "file_upload_menu"
    }
}
async function ZAe(e) {
    await ie.safeDelete("/connectors/user_setting/{connector_name}", {
        parameters: {
            path: {
                connector_name: e
            }
        }
    }),
    window.location.reload()
}
function B2e(e, t, n) {
    const {isLoading: r, error: s, refetch: o, platformConnectors: i} = bh(!0, t, n)
      , a = i.get(e);
    return {
        enabled: !!a && a.status !== "DISABLED_BY_ADMIN",
        isLoading: r,
        error: s,
        refetch: o
    }
}
function JAe(e) {
    return B2e(mr[U.GITHUB_CONNECTOR], e)
}
function q2e(e, t, n) {
    const r = yh()
      , s = gt()
      , o = Tn()
      , {data: i, isLoading: a, error: l, refetch: c} = At({
        queryKey: ["connector-client-data", e],
        queryFn: async () => {
            const u = await ie.safeGet("/aip/connectors/oauth_clients", {
                parameters: {
                    query: {
                        service: t
                    }
                },
                additionalHeaders: n ? {
                    [pr]: n
                } : void 0
            });
            return u.oauth_clients ? u.oauth_clients : (o.danger(s.formatMessage({
                id: "OfpT7B",
                defaultMessage: "Request error fetching oauth clients"
            }), {
                id: "fetch-oauth-clients-error",
                duration: 3,
                hasCloseButton: !0
            }),
            [])
        }
        ,
        enabled: r
    });
    return {
        oAuthClients: i,
        isLoading: a,
        error: l,
        refetch: c
    }
}
function XAe(e, t, n="/", r, s, o) {
    const {platformConnectors: i, isLoading: a, error: l, refetch: c} = bh(!0, r)
      , {connectorLinks: u, isLoading: d, error: f, refetch: p} = Vl({
        productSku: r
    })
      , {oAuthClients: m, isLoading: v, error: _, refetch: y} = q2e(e, t, r)
      , b = G2e()
      , S = h.useCallback( () => {
        c(),
        p(),
        y()
    }
    , [c, p, y])
      , C = mr[e]
      , w = i.get(C)
      , x = u.has(C)
      , E = u.get(C)?.[0]?.id
      , T = h.useCallback( () => {
        E && b(E, () => {
            S()
        }
        , r)
    }
    , [b, S, E, r])
      , k = l ?? f ?? _
      , A = a || d || v
      , O = h.useCallback( () => {
        if (!A) {
            if (!w) {
                s?.();
                return
            }
            if (!m?.length) {
                o?.();
                return
            }
            window.location.hash = `#settings/${dh.Connectors}?connector=${C}&add-connector-link=true&redirectAfter=${n}&product-sku=${r}&referrer=${pV.Codex}`
        }
    }
    , [A, w, m, C, s, o, n, r]);
    return h.useMemo( () => ({
        isLoading: A,
        isConnected: x,
        openGithubModal: O,
        error: k,
        refetch: S,
        handleDisconnect: T
    }), [A, x, O, k, S, T])
}
function QAe(e) {
    "use forget";
    const t = De.c(16)
      , n = gt()
      , r = Tn()
      , s = Jhe()
      , {refetch: o} = bh(!0, e);
    let i;
    t[0] === Symbol.for("react.memo_cache_sentinel") ? (i = {
        fetchValidLinksOnly: !0
    },
    t[0] = i) : i = t[0];
    const {refetch: a} = Vl(i);
    let l;
    t[1] !== e ? (l = {
        fetchValidLinksOnly: !1,
        productSku: e
    },
    t[1] = e,
    t[2] = l) : l = t[2];
    const {refetch: c} = Vl(l)
      , u = xee(zu.DeveloperMode);
    let d;
    t[3] !== n || t[4] !== u || t[5] !== s || t[6] !== e || t[7] !== r ? (d = async m => {
        const {supported_auth: v, ..._} = m
          , {connector: y} = await ie.safePost("/aip/connectors/mcp", {
            requestBody: {
                ..._,
                auth_request: {
                    supported_auth: v,
                    oauth_client_params: null
                }
            },
            additionalHeaders: e ? {
                [pr]: e
            } : void 0
        });
        if (y.supported_auth.length === 0) {
            const S = await D2e(y.id);
            if (!u.data && !S.implements_retrievable)
                return await L2e(y.id),
                {
                    connector: null,
                    link: null,
                    implementsRetrievable: !1
                }
        }
        const b = await R2e({
            connector: y,
            shouldRedirectToConnectorDetails: !0,
            openPopup: s,
            toaster: r,
            intl: n
        });
        return {
            connector: y,
            link: b,
            implementsRetrievable: !0
        }
    }
    ,
    t[3] = n,
    t[4] = u,
    t[5] = s,
    t[6] = e,
    t[7] = r,
    t[8] = d) : d = t[8];
    let f;
    t[9] !== o || t[10] !== c || t[11] !== a ? (f = () => {
        o(),
        a(),
        c()
    }
    ,
    t[9] = o,
    t[10] = c,
    t[11] = a,
    t[12] = f) : f = t[12];
    let p;
    return t[13] !== d || t[14] !== f ? (p = {
        mutationFn: d,
        onSettled: f
    },
    t[13] = d,
    t[14] = f,
    t[15] = p) : p = t[15],
    nr(p)
}
function eMe() {
    const e = gt()
      , t = Tn()
      , n = ir()
      , r = Vl()
      , s = Lr();
    return async (i, a, l) => {
        try {
            await U2e(i, l),
            s.invalidateQueries({
                queryKey: ["fetchConnectorLinkData", n?.normalizedAccountUserId]
            }),
            await r.refetch(),
            a?.()
        } catch {
            t.danger(e.formatMessage({
                id: "Gmong7",
                defaultMessage: "Error disconnecting connector"
            }))
        }
    }
}
function G2e() {
    const e = gt()
      , t = Tn()
      , n = ir()
      , r = Vl()
      , s = Lr();
    return async (i, a, l) => {
        try {
            await j2e(i, l),
            s.invalidateQueries({
                queryKey: ["fetchConnectorLinkData", n?.normalizedAccountUserId]
            }),
            await r.refetch(),
            a?.()
        } catch {
            t.danger(e.formatMessage({
                id: "Gmong7",
                defaultMessage: "Error disconnecting connector"
            }))
        }
    }
}
function tMe() {
    const e = ir()
      , t = gt()
      , n = Tn()
      , {refetch: r} = _h({
        skip: !0
    });
    return nr({
        mutationKey: ["upgradeConnectorToSync"],
        mutationFn: ({link: s, user_extension: o}) => e?.isPersonalAccount() ? ka.user_request_connect_upgrade_to_sync({
            link_id: s.id,
            user_extension: o
        }) : ka.user_activate_workspace_connection_and_user({
            link_id: s.id,
            user_extension: o
        }),
        onMutate: ({link: s, isConnectingAndUpgrading: o=!1}) => {
            V.logEventWithStatsig("Connectors - Upgrade To Sync Initiated", "chatgpt_connectors_upgrade_to_sync_initiated", {
                connector_id: s.connector_id,
                isConnectingAndUpgrading: o ? "true" : "false"
            })
        }
        ,
        onSuccess: (s, {link: o, isConnectingAndUpgrading: i=!1}) => {
            r(),
            n.success(i ? t.formatMessage({
                id: "rfbIpd",
                defaultMessage: "{connector} is now connected and syncing."
            }, {
                connector: o.name
            }) : t.formatMessage({
                id: "yhtO5d",
                defaultMessage: "{connector} is now syncing."
            }, {
                connector: o.name
            })),
            V.logEventWithStatsig("Connectors - Upgrade To Sync Success", "chatgpt_connectors_upgrade_to_sync_success", {
                connector_id: o.connector_id,
                isConnectingAndUpgrading: i ? "true" : "false"
            })
        }
        ,
        onError: (s, {link: o, isConnectingAndUpgrading: i=!1}) => {
            if (i)
                n.warning(t.formatMessage({
                    id: "wag12O",
                    defaultMessage: "{connector} is now connected, but not syncing. Try enabling sync again."
                }, {
                    connector: o.name
                }));
            else {
                const a = s instanceof _t && s.status === 409 ? t.formatMessage({
                    id: "Tedt6I",
                    defaultMessage: "Connector name already exists"
                }) : t.formatMessage({
                    id: "tumE6A",
                    defaultMessage: "There was a problem syncing {connector}. Try again later."
                }, {
                    connector: o.name
                });
                n.danger(a, {
                    toastId: "upgrade_connector_to_sync",
                    loggingTitle: s instanceof _t && s.status === 409 ? "Connector name already exists" : "There was a problem syncing {connector}. Try again later."
                })
            }
            V.logEventWithStatsig("Connectors - Upgrade To Sync Error", "chatgpt_connectors_upgrade_to_sync_error", {
                connector_id: o.connector_id,
                isConnectingAndUpgrading: i ? "true" : "false"
            })
        }
    })
}
function nMe() {
    const e = gt()
      , t = Tn()
      , {refetch: n} = xh()
      , {refetch: r} = _h({
        skip: !0
    });
    return async o => {
        try {
            await ka.user_delete_sync(o),
            n(),
            r(),
            t.success(e.formatMessage({
                id: "Nktfkq",
                defaultMessage: "Successfully disabled sync."
            }))
        } catch {
            t.danger({
                defaultMessage: "Error disabling sync for your connector.",
                description: "Error message when disabling sync for a connector fails"
            }, {
                toastId: "disable_sync_on_connector"
            })
        }
    }
}
function V2e() {
    const t = ir()?.isEnterprisey()
      , {availableConnectors: n} = l4()
      , r = EB() ?? !1;
    return t ? n.length > 0 || r : !0
}
function rMe({platformConnectors: e, enabled: t}) {
    const {isLoading: n, data: r} = AB(t)
      , {disabledTools: s=[], ...o} = r ?? {}
      , i = Lr()
      , {isPending: a, mutate: l} = nr({
        mutationFn: async ({data: y}) => await Ahe(y),
        onSettled: (y, b) => {
            const S = ["userContext"];
            y != null && !b ? i.setQueryData(S, y) : i.invalidateQueries({
                queryKey: S
            })
        }
        ,
        onError: y => (V.logEventWithStatsig("chatgpt_web_disable_auto_connectors_for_teams_error", "chatgpt_web_disable_auto_connectors_for_teams_error", {
            errorMessage: y.message
        }),
        y)
    })
      , {allAutoConnectors: c, enabledAutoConnectors: u, isLoading: d} = RB({
        getDisabledAutoConnectors: t
    })
      , [f,p] = h.useState(!1)
      , m = h.useMemo( () => c.filter(y => e.has(mr[y]) && e.get(mr[y])?.status === "DISABLED_BY_ADMIN"), [c, e])
      , {newDisabledTools: v, maybeNewEnabledTools: _} = h.useMemo( () => {
        if (!t)
            return {
                newDisabledTools: [],
                maybeNewEnabledTools: []
            };
        const y = []
          , b = [];
        return u.length > 0 && u.forEach(S => {
            m.includes(S) && !s.includes(mp(S) ?? "") && y.push(S)
        }
        ),
        m.length < c.length && m.length < c.length && c.forEach(S => {
            !m.includes(S) && s.includes((mp(S) ?? "").concat("_admin_disabled")) && b.push(S)
        }
        ),
        {
            newDisabledTools: y,
            maybeNewEnabledTools: b
        }
    }
    , [t, u, s, c, m]);
    h.useEffect( () => {
        if (!t || n || a || f || d || v.length === 0 && _.length === 0)
            return;
        const y = new Set(s);
        _.forEach(b => {
            const S = mp(b);
            S && (y.delete(S),
            y.delete(`${S}_admin_disabled`))
        }
        ),
        v.forEach(b => {
            const S = mp(b);
            S && (y.add(S),
            y.add(`${S}_admin_disabled`))
        }
        ),
        l({
            data: {
                disabledTools: Array.from(y),
                ...o
            }
        }),
        p(!0)
    }
    , [n, a, l, v, _, o, f, s, d, t])
}
function H2e() {
    return At({
        queryKey: ["userIsInSearchHoldoutWithWebDisabled"],
        queryFn: () => ie.safeGet("/user_is_in_search_holdout_with_web_disabled", {
            authOption: Qt.SendIfAvailable
        }),
        select: e => ({
            userIsInSearchHoldoutWithWebDisabled: e.user_is_in_search_holdout_with_web_disabled ?? !1
        })
    })
}
function z2e() {
    "use forget";
    const e = De.c(3)
      , t = ue()
      , n = bn(t)
      , r = !yn(t)
      , s = H2e();
    if (r || n && !n.isFree()) {
        let a;
        return e[0] === Symbol.for("react.memo_cache_sentinel") ? (a = {
            userIsInSearchHoldoutWithWebDisabled: !1
        },
        e[0] = a) : a = e[0],
        a
    }
    const o = s.isLoading ? !1 : s.data?.userIsInSearchHoldoutWithWebDisabled;
    let i;
    return e[1] !== o ? (i = {
        userIsInSearchHoldoutWithWebDisabled: o
    },
    e[1] = o,
    e[2] = i) : i = e[2],
    i
}
const $2e = Ei( () => ({}));
function W2e() {
    const e = ue()
      , t = WP(Bg)
      , n = Xl($2e);
    if (!yn(e)) {
        const y = $t(e, "2526598250");
        return {
            isSingleLine: t ? !0 : y.get("single-line", !1),
            plusButtonLabel: y.get("plus-button-label", !1),
            loggedOutVoiceLabel: y.get("logged-out-voice-label", !0),
            fontSize: y.get("font-size", "base"),
            attachfileRateLimitMessageVariant: "title_and_description",
            attachfileRateLimitMessageShowIcon: !0,
            fullyCollapsedToolMenu: !1,
            showSlashHint: !1,
            showModelsInPlusMenu: !1,
            showSelectedModelInComposer: !1,
            showModelSlashCommands: !1,
            showThinkingEffortPicker: !1,
            hasLegacyEffortDefault: !1
        }
    }
    const r = $t(e, "790459319")
      , s = n.isSingleLine ?? (t ? !0 : r.get("single-line", !1))
      , o = n.fontSize ?? r.get("font-size", "base")
      , i = n.attachfileRateLimitMessageVariant ?? r.get("attachfile-rate-limit-message-variant", "title_and_description")
      , a = n.attachfileRateLimitMessageShowIcon ?? r.get("attachfile-rate-limit-message-show-icon", !0)
      , l = n.fullyCollapsedToolMenu ?? r.get("fully-collapsed-tool-menu", !1)
      , c = n.showSlashHint ?? r.get("show-slash-hint", !1)
      , u = n.plusButtonLabel ?? r.get("plus-button-label", !1)
      , d = n.loggedOutVoiceLabel ?? r.get("logged-out-voice-label", !0)
      , f = n.showModelsInPlusMenu ?? r.get("models-in-plus-menu", !1)
      , p = n.showSelectedModelInComposer ?? r.get("show-selected-model-in-composer", !1)
      , m = n.showModelSlashCommands ?? r.get("model-slash-commands", !1)
      , v = n.showThinkingEffortPicker ?? r.get("show-juice-control", !1)
      , _ = n.hasLegacyEffortDefault ?? r.get("legacy-juice-default", !1);
    return {
        isSingleLine: s,
        fontSize: o,
        attachfileRateLimitMessageVariant: i,
        attachfileRateLimitMessageShowIcon: a,
        fullyCollapsedToolMenu: l,
        showSlashHint: c,
        plusButtonLabel: u,
        loggedOutVoiceLabel: d,
        showModelsInPlusMenu: f,
        showSelectedModelInComposer: p,
        showModelSlashCommands: m,
        showThinkingEffortPicker: v,
        hasLegacyEffortDefault: _
    }
}
const K2e = e => h.createElement("svg", {
    width: 20,
    height: 20,
    viewBox: "0 0 20 20",
    fill: "currentColor",
    xmlns: "http://www.w3.org/2000/svg",
    ...e
}, h.createElement("path", {
    d: "M14.0857 8.74999C14.0857 5.80355 11.6972 3.41503 8.75073 3.41503C5.80429 3.41503 3.41577 5.80355 3.41577 8.74999C3.41577 11.6964 5.80429 14.085 8.75073 14.085C11.6972 14.085 14.0857 11.6964 14.0857 8.74999ZM15.4158 8.74999C15.4158 10.3539 14.848 11.8245 13.9041 12.9746L13.9705 13.0303L16.9705 16.0303L17.0564 16.1338C17.2269 16.3919 17.1977 16.7434 16.9705 16.9707C16.7432 17.1975 16.3925 17.226 16.1345 17.0557L16.03 16.9707L13.03 13.9707L12.9753 13.9033C11.8253 14.8472 10.3547 15.415 8.75073 15.415C5.06975 15.415 2.08569 12.431 2.08569 8.74999C2.08569 5.06901 5.06975 2.08495 8.75073 2.08495C12.4317 2.08495 15.4158 5.06901 15.4158 8.74999Z"
}));
function gV({className: e, inputClassName: t, value: n, onChange: r, onKeyDown: s, onFocus: o, onBlur: i, placeholder: a, id: l, autoFocus: c}) {
    return g.jsxs("div", {
        className: we("relative", e),
        children: [g.jsx(K2e, {
            className: "icon-sm text-token-text-tertiary absolute start-2 top-1/2 -translate-y-1/2 transform"
        }), g.jsx("input", {
            id: l,
            type: "text",
            value: n,
            onKeyDown: s,
            onChange: r,
            onFocus: o,
            onBlur: i,
            placeholder: a,
            autoFocus: c,
            className: we("rounded-lg border border-gray-200 ps-8 placeholder:text-gray-500 dark:border-gray-600 dark:bg-gray-700", t),
            autoComplete: "off"
        })]
    })
}
const Y2e = e => h.createElement("svg", {
    width: 20,
    height: 20,
    viewBox: "0 0 16 16",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ...e
}, h.createElement("path", {
    d: "M7.33325 1.8217C7.74579 1.58352 8.25405 1.58352 8.66659 1.8217L13.0175 4.33342C13.43 4.5716 13.6842 5.01203 13.6842 5.48836V10.5118C13.6842 10.9882 13.43 11.4286 13.0175 11.6668L8.66659 14.1785C8.25405 14.4166 7.74579 14.4166 7.33325 14.1785L2.98234 11.6668C2.56983 11.4286 2.31567 10.9882 2.31567 10.5118V5.48836C2.31567 5.01203 2.56983 4.5716 2.98234 4.33342L7.33325 1.8217Z",
    stroke: "currentColor",
    strokeWidth: 1.2
}), h.createElement("path", {
    d: "M8.41547 5.37106C8.39153 5.15986 8.21293 5.00022 8.0004 5C7.78787 4.99979 7.609 5.15906 7.5846 5.37021C7.4326 6.68853 6.68853 7.4326 5.37021 7.5846C5.15906 7.609 4.99979 7.78787 5 8.0004C5.00022 8.21293 5.15986 8.39153 5.37106 8.41547C6.67067 8.56267 7.46633 9.29953 7.58353 10.6189C7.60267 10.8348 7.78367 11.0002 8.00047 11C8.2172 10.9997 8.39787 10.8339 8.41653 10.6179C8.52913 9.31727 9.31727 8.52913 10.6179 8.41653C10.8339 8.39787 10.9997 8.2172 11 8.00047C11.0002 7.78367 10.8348 7.60267 10.6189 7.58353C9.29953 7.46633 8.56267 6.67067 8.41547 5.37106Z",
    fill: "currentColor"
}))
  , Z2e = e => h.createElement("svg", {
    width: 24,
    height: 24,
    viewBox: "0 0 24 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ...e
}, h.createElement("path", {
    d: "M9.50052 9.00046C9.71306 9.00069 9.89164 9.16037 9.91556 9.37156C10.0629 10.6708 10.7997 11.4662 12.1187 11.5835C12.3346 11.6026 12.5008 11.7837 12.5005 12.0005C12.5003 12.2172 12.3337 12.3978 12.1177 12.4165C10.8173 12.5292 10.0292 13.3173 9.91654 14.6177C9.89785 14.8336 9.71729 15.0002 9.50052 15.0005C9.28377 15.0007 9.10271 14.8345 9.08353 14.6186C8.96627 13.2996 8.17085 12.5628 6.87162 12.4155C6.66043 12.3916 6.50075 12.213 6.50052 12.0005C6.50031 11.7879 6.65949 11.6088 6.87064 11.5844C8.18858 11.4323 8.93237 10.6885 9.08451 9.37058C9.10886 9.15943 9.28798 9.00025 9.50052 9.00046Z",
    fill: "currentColor"
}), h.createElement("path", {
    d: "M9.52591 2.56101C10.8927 1.19443 13.1083 1.19443 14.4751 2.56101L21.44 9.52585C22.8061 10.8927 22.8064 13.1084 21.44 14.4751L14.4751 21.4399C13.1085 22.8063 10.8927 22.806 9.52591 21.4399L2.56107 14.4751C1.19449 13.1083 1.19449 10.8926 2.56107 9.52585L9.52591 2.56101ZM13.0611 3.97507C12.4753 3.38954 11.5257 3.38954 10.94 3.97507L3.97513 10.9399C3.3896 11.5257 3.3896 12.4753 3.97513 13.061L10.94 20.0259C11.5258 20.6109 12.4755 20.6112 13.0611 20.0259L20.0259 13.061C20.6113 12.4754 20.611 11.5257 20.0259 10.9399L13.0611 3.97507Z",
    fill: "currentColor"
}))
  , IA = e => h.createElement("svg", {
    width: 16,
    height: 16,
    viewBox: "0 0 16 16",
    fill: "currentColor",
    xmlns: "http://www.w3.org/2000/svg",
    ...e
}, h.createElement("path", {
    d: "M8 7.33301C8.36819 7.33301 8.66699 7.63181 8.66699 8V10.667C8.66682 11.035 8.36808 11.333 8 11.333C7.63192 11.333 7.33318 11.035 7.33301 10.667V8C7.33301 7.63181 7.63181 7.33301 8 7.33301Z"
}), h.createElement("path", {
    d: "M8 4.66699C8.42342 4.66699 8.7666 5.01018 8.7666 5.43359C8.76646 5.85689 8.42333 6.2002 8 6.2002C7.57667 6.20019 7.23354 5.85689 7.2334 5.43359C7.2334 5.01018 7.57658 4.66699 8 4.66699Z"
}), h.createElement("path", {
    fillRule: "evenodd",
    clipRule: "evenodd",
    d: "M8 1.33301C11.6819 1.33301 14.667 4.3181 14.667 8C14.667 11.6819 11.6819 14.667 8 14.667C4.3181 14.667 1.33301 11.6819 1.33301 8C1.33301 4.3181 4.3181 1.33301 8 1.33301ZM8 2.66699C5.05448 2.66699 2.66699 5.05448 2.66699 8C2.66699 10.9455 5.05448 13.333 8 13.333C10.9455 13.333 13.333 10.9455 13.333 8C13.333 5.05448 10.9455 2.66699 8 2.66699Z"
}))
  , RA = e => h.createElement("svg", {
    width: 24,
    height: 24,
    viewBox: "0 0 24 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ...e
}, h.createElement("path", {
    d: "M15.11 14.285a.41.41 0 0 1 .78 0c.51 2.865.96 3.315 3.825 3.826.38.12.38.658 0 .778-2.865.511-3.315.961-3.826 3.826a.408.408 0 0 1-.778 0c-.511-2.865-.961-3.315-3.826-3.826a.408.408 0 0 1 0-.778c2.865-.511 3.315-.961 3.826-3.826Zm2.457-12.968a.454.454 0 0 1 .866 0C19 4.5 19.5 5 22.683 5.567a.454.454 0 0 1 0 .866C19.5 7 19 7.5 18.433 10.683a.454.454 0 0 1-.866 0C17 7.5 16.5 7 13.317 6.433a.454.454 0 0 1 0-.866C16.5 5 17 4.5 17.567 1.317Z",
    fill: "currentColor"
}), h.createElement("path", {
    fillRule: "evenodd",
    clipRule: "evenodd",
    d: "M7.001 4a1 1 0 0 1 .993.887c.192 1.7.701 2.877 1.476 3.665.768.783 1.913 1.3 3.618 1.452a1 1 0 0 1-.002 1.992c-1.675.145-2.849.662-3.638 1.452-.79.79-1.307 1.963-1.452 3.638a1 1 0 0 1-1.992.003c-.152-1.706-.67-2.851-1.452-3.62-.788-.774-1.965-1.283-3.665-1.475a1 1 0 0 1-.002-1.987c1.73-.2 2.878-.709 3.646-1.476.767-.768 1.276-1.916 1.476-3.646A1 1 0 0 1 7 4Zm-2.472 6.998a6.11 6.11 0 0 1 2.468 2.412 6.232 6.232 0 0 1 1.037-1.376 6.232 6.232 0 0 1 1.376-1.036 6.114 6.114 0 0 1-2.412-2.469 6.163 6.163 0 0 1-1.053 1.416 6.163 6.163 0 0 1-1.416 1.053Z",
    fill: "currentColor"
}))
  , J2e = e => h.createElement("svg", {
    width: 24,
    height: 24,
    viewBox: "0 0 24 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ...e
}, h.createElement("path", {
    fillRule: "evenodd",
    clipRule: "evenodd",
    d: "M12 7.42a22.323 22.323 0 0 0-2.453 2.127A22.323 22.323 0 0 0 7.42 12a22.32 22.32 0 0 0 2.127 2.453c.807.808 1.636 1.52 2.453 2.128a22.335 22.335 0 0 0 2.453-2.128A22.322 22.322 0 0 0 16.58 12a22.326 22.326 0 0 0-2.127-2.453A22.32 22.32 0 0 0 12 7.42Zm1.751-1.154a24.715 24.715 0 0 1 2.104 1.88 24.722 24.722 0 0 1 1.88 2.103c.316-.55.576-1.085.779-1.59.35-.878.507-1.625.503-2.206-.003-.574-.16-.913-.358-1.111-.199-.199-.537-.356-1.112-.36-.58-.003-1.328.153-2.205.504-.506.203-1.04.464-1.59.78Zm3.983 7.485a24.706 24.706 0 0 1-1.88 2.104 24.727 24.727 0 0 1-2.103 1.88 12.7 12.7 0 0 0 1.59.779c.878.35 1.625.507 2.206.503.574-.003.913-.16 1.111-.358.199-.199.356-.538.36-1.112.003-.58-.154-1.328-.504-2.205a12.688 12.688 0 0 0-.78-1.59ZM12 18.99c.89.57 1.768 1.03 2.605 1.364 1.026.41 2.036.652 2.955.646.925-.006 1.828-.267 2.5-.94.673-.672.934-1.575.94-2.5.006-.919-.236-1.929-.646-2.954A15.688 15.688 0 0 0 18.99 12a15.6 15.6 0 0 0 1.364-2.606c.41-1.025.652-2.035.646-2.954-.006-.925-.267-1.828-.94-2.5-.672-.673-1.575-.934-2.5-.94-.919-.006-1.929.235-2.954.646-.838.335-1.716.795-2.606 1.364a15.69 15.69 0 0 0-2.606-1.364C8.37 3.236 7.36 2.994 6.44 3c-.925.006-1.828.267-2.5.94-.673.672-.934 1.575-.94 2.5-.006.919.235 1.929.646 2.955A15.69 15.69 0 0 0 5.01 12c-.57.89-1.03 1.768-1.364 2.605-.41 1.026-.652 2.036-.646 2.955.006.925.267 1.828.94 2.5.672.673 1.575.934 2.5.94.92.006 1.93-.235 2.955-.646A15.697 15.697 0 0 0 12 18.99Zm-1.751-1.255a24.714 24.714 0 0 1-2.104-1.88 24.713 24.713 0 0 1-1.88-2.104c-.315.55-.576 1.085-.779 1.59-.35.878-.507 1.625-.503 2.206.003.574.16.913.359 1.111.198.199.537.356 1.111.36.58.003 1.328-.153 2.205-.504.506-.203 1.04-.463 1.59-.78Zm-3.983-7.486a24.727 24.727 0 0 1 1.88-2.104 24.724 24.724 0 0 1 2.103-1.88 12.696 12.696 0 0 0-1.59-.779c-.878-.35-1.625-.507-2.206-.503-.574.003-.913.16-1.111.359-.199.198-.356.537-.36 1.111-.003.58.153 1.328.504 2.205.203.506.464 1.04.78 1.59Z",
    fill: "currentColor"
}))
  , vV = e => h.createElement("svg", {
    width: 20,
    height: 20,
    viewBox: "0 0 20 20",
    fill: "currentColor",
    xmlns: "http://www.w3.org/2000/svg",
    ...e
}, h.createElement("path", {
    d: "M16.0012 14.4404C16.0011 13.9504 15.8513 13.4739 15.5735 13.0742L15.4465 12.9082L15.012 12.3877C13.8614 12.8911 12.9152 13.1121 12.0618 13.1562C11.1474 13.2035 10.3804 13.0475 9.66528 12.8857C8.94197 12.7221 8.2815 12.5562 7.4729 12.5146C6.70029 12.475 5.77576 12.5504 4.5686 12.8887L4.55298 12.9082C4.19457 13.3383 3.9984 13.8806 3.99829 14.4404C3.99829 15.7627 5.07059 16.835 6.39282 16.835H13.6077C14.9298 16.8349 16.0012 15.7626 16.0012 14.4404ZM11.8352 3.16504H8.16528V7.72949C8.16528 8.20671 8.01876 8.6713 7.74829 9.06055L7.62427 9.22266L5.93384 11.25C6.52115 11.1756 7.05045 11.1614 7.54028 11.1865C8.48665 11.2351 9.26917 11.432 9.95825 11.5879C10.6556 11.7456 11.2718 11.8653 11.9924 11.8281C12.5791 11.7978 13.2616 11.6591 14.1213 11.3184L12.3752 9.22266C12.0261 8.80363 11.8352 8.27494 11.8352 7.72949V3.16504ZM13.1653 7.72949C13.1653 7.96372 13.2468 8.19111 13.3967 8.37109L16.468 12.0566L16.6653 12.3154C17.0974 12.9371 17.3312 13.6782 17.3313 14.4404C17.3313 16.4971 15.6643 18.1649 13.6077 18.165H6.39282C4.33605 18.165 2.66821 16.4972 2.66821 14.4404C2.66832 13.5694 2.97386 12.7258 3.53149 12.0566L6.60278 8.37109L6.65552 8.30176C6.77186 8.13447 6.83521 7.93464 6.83521 7.72949V3.16504H6.66626C6.29914 3.16486 6.00122 2.86716 6.00122 2.5C6.00122 2.13284 6.29914 1.83514 6.66626 1.83496H13.3333L13.467 1.84863C13.7702 1.91057 13.9983 2.17857 13.9983 2.5C13.9983 2.82143 13.7702 3.08943 13.467 3.15137L13.3333 3.16504H13.1653V7.72949Z"
}))
  , sMe = Object.freeze(Object.defineProperty({
    __proto__: null,
    default: vV
}, Symbol.toStringTag, {
    value: "Module"
}));
function _V(e, t, n={
    skipUpdateIfModelStickyOnServer: !0
}) {
    Xe(e, "1333611684") && n.skipUpdateIfModelStickyOnServer || ze.setCookie(Be.LastUsedModel, t, {
        path: "/",
        maxAge: 60 * 60 * 24 * 30
    })
}
function oMe() {
    ze.deleteCookie(Be.LastUsedModel)
}
function X2e() {
    return ze.getCookie(Be.LastUsedModel)
}
function Q2e(e) {
    RP( () => {
        const n = cL(e)().data?.settings[zu.LastUsedModelConfig];
        return n?.slugs[Z3.WEB] ?? n?.slugs[Z3.DEFAULT] ?? X2e()
    }
    , t => {
        t && _V(e, t, {
            skipUpdateIfModelStickyOnServer: !1
        })
    }
    )
}
function eCe({modelSwitcherDeny: e}) {
    const t = ue()
      , r = bn(t)?.isPro();
    switch (e.reason) {
    case gs.UNSUPPORTED_TOOL_USE:
    case gs.UNSUPPORTED_AUDIO:
    case gs.UNSUPPORTED_IMAGE:
    case gs.UNSUPPORTED_GIZMO:
    case gs.UNSUPPORTED_ATTACHMENT:
    case gs.UNSUPPORTED_CUSTOM_INSTRUCTIONS:
    case gs.UNSUPPORTED_CANVAS:
    case gs.UNSUPPORTED_TEMPORARY_CHAT:
        return g.jsx(g.Fragment, {
            children: e.description
        });
    case k6.RATE_LIMIT:
        {
            const {resetsAfter: o} = e
              , i = new Date(o)
              , a = new Date(o).toLocaleTimeString([], {
                hour: "numeric",
                minute: "2-digit"
            });
            if (r)
                return g.jsx("div", {
                    children: g.jsx(de, {
                        id: "CwSQn9",
                        defaultMessage: "Temporarily limited. Contact <supportEmail>support@openai.com</supportEmail> for help.",
                        values: {
                            supportEmail: l => g.jsx(Bf, {
                                to: "mailto:support@openai.com",
                                className: "underline",
                                children: l
                            })
                        }
                    })
                });
            if (jme(i))
                return g.jsx(de, {
                    id: "HUybjA",
                    defaultMessage: "Your limit will reset at {time}",
                    values: {
                        time: a
                    }
                });
            if (Ume(i))
                return g.jsx(de, {
                    id: "TvYw9K",
                    defaultMessage: "Your limit will reset at {time} tomorrow",
                    values: {
                        time: a
                    }
                });
            {
                const l = i.toLocaleDateString([], {
                    month: "short",
                    day: "numeric"
                });
                return g.jsx(de, {
                    id: "60ZcZL",
                    defaultMessage: "Your limit will reset on {date}",
                    values: {
                        date: l
                    }
                })
            }
        }
    }
    const s = e.description;
    if (s)
        return g.jsx(g.Fragment, {
            children: s
        })
}
var of = (e => (e.GPT4o = "AG8PqS2q",
e.AUTO = "auto",
e))(of || {});
const iMe = e => {
    const {categoryId: t} = e;
    return t === "auto"
}
;
function aMe(e) {
    return e?.categories.some( ({categoryId: t}) => t === of.GPT4o) ?? !1
}
function yV(e, t) {
    return t != null ? e?.get(t) ?? null : null
}
function tCe(e=!1) {
    const t = ue()
      , n = Xe(t, "1213809372")
      , r = Xe(t, "1854238036")
      , s = cs()
      , o = oo()
      , [,i] = Eg();
    return h.useCallback( ({location: a, modelId: l, options: c, extraQueryParams: u=new URLSearchParams}) => {
        const d = s.pathname.includes("/g/")
          , f = s.pathname.startsWith("/g/g-p-");
        if (e || d && !n && !r && !f) {
            V.logNewChatButtonClicked({
                location: a
            }),
            u.toString();
            const p = new URLSearchParams(u);
            p.set("model", l),
            o({
                pathname: "/",
                search: "?" + p.toString()
            }, c)
        } else
            i(p => {
                const m = new URLSearchParams([...u, ...p]);
                return m.set("model", l),
                m
            }
            ),
            V.logNewChatButtonClicked({
                location: a
            })
    }
    , [e, s, o, i, n, r])
}
function bV(e) {
    const {clientThreadId: t, isGizmo: n=!1} = typeof e == "string" ? {
        clientThreadId: e,
        isGizmo: !1
    } : e
      , {modelsData: r} = hw({
        isGizmo: n
    })
      , s = Ai(t, o => o?.modelId);
    return yV(r?.models, s) ?? null
}
function nCe(e) {
    const {clientThreadId: t, isGizmo: n=!1} = typeof e == "string" ? {
        clientThreadId: e,
        isGizmo: !1
    } : e;
    return bV({
        clientThreadId: t,
        isGizmo: n
    })
}
function rCe(e, t) {
    return e?.enabledTools?.includes(t) ?? !1
}
function CV(e) {
    return yV(e?.models, e?.defaultModelSlug)
}
const lMe = "g-2fkFE8rbu"
  , cMe = {
    UNSET: "unset",
    GLOBAL: "global",
    PROJECT: "project",
    PROJECT_V2: "project_v2"
};
var sCe = (e => (e[e.USER = 1] = "USER",
e[e.GROUP = 2] = "GROUP",
e[e.WORKSPACE = 3] = "WORKSPACE",
e[e.ALL = 4] = "ALL",
e[e.PROJECT = 5] = "PROJECT",
e[e.ORGANIZATION = 6] = "ORGANIZATION",
e[e.SYSTEM = 7] = "SYSTEM",
e[e.AGENT = 8] = "AGENT",
e[e.EMAIL = 10] = "EMAIL",
e))(sCe || {});
const oCe = {
    can_read: !0,
    can_view_config: !1,
    can_write: !1,
    can_delete: !1,
    can_export: !1,
    can_share: !1
}
  , uMe = {
    can_read: !0,
    can_view_config: !0,
    can_write: !1,
    can_delete: !1,
    can_export: !1,
    can_share: !1
}
  , dMe = {
    can_read: !0,
    can_view_config: !0,
    can_write: !0,
    can_delete: !1,
    can_export: !1,
    can_share: !1
}
  , zr = {
    Private: "private",
    User: "user",
    Group: "group",
    WorkspaceLink: "workspace_link",
    Workspace: "workspace",
    Link: "link",
    Marketplace: "marketplace"
};
var iCe = (e => (e.FirstParty = "first_party",
e.UsesFunctionCalls = "uses_function_calls",
e.Reportable = "reportable",
e.Private = "private",
e.Workspace = "workspace",
e.Public = "public",
e.Beta = "beta",
e.Pinned = "pinned",
e.WorkspaceDisabled = "workspace_disabled",
e.Unreviewable = "unreviewable",
e))(iCe || {});
const fMe = e => e.gizmo.tags?.includes("first_party")
  , hMe = e => e.gizmo.gizmo_type !== "snorlax" && !e.gizmo.tags?.includes("unreviewable");
var zl = (e => (e.PROJECT = "snorlax",
e.GPT = "gpt",
e))(zl || {})
  , SV = (e => (e.FILE_SERVICE = "fs",
e))(SV || {});
function pMe(e) {
    return e.type === 10 || e.type === 1 || e.type === 2
}
const NA = [1, 2, 3, 4];
function mMe(e) {
    return e.length === 0 ? null : e.reduce( (t, n) => NA.indexOf(n.type) < NA.indexOf(t.type) ? t : n, e[0])
}
function gMe(e, t, n) {
    return t = t.filter(r => r.type === zr.User || r.type === zr.Group),
    e === zr.Private || e === zr.User || e === zr.Group ? [{
        type: zr.Private,
        capabilities: oCe
    }, ...t] : [...t, {
        type: e,
        capabilities: n
    }]
}
class aCe {
    constructor(t) {
        this.response = t
    }
}
var ou = (e => (e.FirstParty = "first_party",
e.SidebarKeep = "sidebar_keep",
e.Mine = "mine",
e.Recent = "recent",
e.Workspace = "workspace",
e))(ou || {});
const lCe = "q"
  , vMe = "author"
  , cCe = "project_id"
  , uCe = "owner_user_id";
function Np(e, t, n, r, s) {
    return n && t && r && s && r !== s ? `${Ff(Lf(t))}/shared/c/${e}?${cCe}=${t.gizmo.id}&${uCe}=${r}` : t ? `${Ff(Lf(t))}/c/${e}` : `/c/${e}`
}
function Lf(e) {
    return e.gizmo.short_url ?? e.gizmo.id ?? "-"
}
function Ff(e) {
    return `/g/${e}`
}
function _Me() {
    return "/gpts"
}
function yMe() {
    return "/schedules"
}
function bMe() {
    return "/gpts/mine"
}
function wV(e) {
    return e ? `/gpts/editor/${e}` : "/gpts/editor"
}
function CMe(e) {
    const t = dCe();
    return e == null ? t : wV(e)
}
function dCe(e) {
    return wV(e)
}
function fCe(e) {
    if (!e)
        return null;
    try {
        return new URL(e).hostname
    } catch {
        return null
    }
}
function SMe(e) {
    const t = fCe(e);
    return t ? t.replace(/^www\./, "") : e
}
const Z1 = "client-correlated-secret";
function PA() {
    const e = localStorage.getItem(Z1);
    return e == null ? e : crypto.subtle.importKey("jwk", JSON.parse(e), {
        name: "HMAC",
        hash: {
            name: "SHA-512"
        }
    }, !0, ["sign", "verify"])
}
async function EV() {
    PA() == null && localStorage.setItem(Z1, JSON.stringify(await crypto.subtle.exportKey("jwk", await crypto.subtle.generateKey({
        name: "HMAC",
        hash: {
            name: "SHA-512"
        }
    }, !0, ["sign", "verify"]))));
    const t = PA();
    if (t == null)
        throw new Error("Failed to get key from storage");
    return t
}
function hCe(e) {
    const t = new Uint8Array(e.length / 2);
    for (let n = 0; n < t.length; n++)
        t[n] = parseInt(e.substr(n * 2, 2), 16);
    return t.buffer
}
function pCe(e) {
    return [...new Uint8Array(e)].map(t => t.toString(16).padStart(2, "0")).join("")
}
function mCe(e) {
    const t = new URL(e)
      , n = At({
        queryKey: [Z1, "generate-challenge", e.search],
        queryFn: async () => pCe(await crypto.subtle.sign("HMAC", await EV(), new TextEncoder().encode(e.search))),
        staleTime: 0
    });
    if (n.data !== void 0)
        return t.hash = n.data,
        t
}
function wMe() {
    const e = location?.search
      , t = location?.hash;
    return At({
        queryKey: [Z1, "verify-challenge", e, t],
        queryFn: async () => typeof e != "string" || typeof t != "string" ? !1 : crypto.subtle.verify("HMAC", await EV(), hCe(t.slice(1)), new TextEncoder().encode(e))
    }).data ? new URLSearchParams(e) : void 0
}
class Cn {
    static getMyGizmos() {
        return ct("gizmo_api.get_my_gizmos", () => at.get(`${lt}/gizmos?mine=true`))
    }
    static getGizmosByUser(t) {
        return ct("gizmo_api.get_gizmos_by_user", () => at.get(`${lt}/gizmos/u/${t}`))
    }
    static getGizmo(t, n) {
        const r = n ? "?draft=true" : "";
        return ct("gizmo_api.get_gizmo", () => at.get(`${lt}/gizmos/${t}${r}`))
    }
    static shareGizmo(t, n) {
        return ct("gizmo_api.share", () => at.post(`${lt}/gizmos/${t}/share`, n))
    }
    static getGizmoDiscovery(t, n) {
        const r = new URLSearchParams;
        return t != null && r.set("locale", t),
        ct("gizmo_api.discovery", () => at.get(n ? `${Vp}/gizmos/discovery_anon?${r}` : `${Vp}/gizmos/discovery?${r}`, {
            authOption: Qt.SendIfAvailable
        }))
    }
    static async getGizmoDiscoveryCut(t, n) {
        const r = o => {
            const i = {};
            o != null && (i.cursor = o),
            n?.limit != null && (i.limit = `${n.limit}`),
            n?.locale != null && (i.locale = n.locale);
            const a = `${Vp}/gizmos/discovery/${t}`;
            return ct("gizmo_api.discovery", () => at.get(a, {
                params: i,
                authOption: Qt.SendIfAvailable
            }))
        }
          , s = await r(n?.cursor);
        return s.list.items.length === 0 && s.list.cursor != null ? (await new Promise(o => setTimeout(o, Math.random() * 30)),
        await r(s.list.cursor)) : s
    }
    static getGizmoBootstrap(t) {
        return ct("gizmo_api.bootstrap", () => at.get(`${lt}/gizmos/bootstrap?limit=${t}`))
    }
    static getGizmoPinned() {
        return ct("gizmo_api.pinned", () => at.get(`${lt}/gizmos/pinned`))
    }
    static getGizmoSearch(t, n=null) {
        return n ? ct("gizmo_api.search_with_cursor", () => at.get(`${lt}/gizmos/search?q=${t}&cursor=${n} `)) : ct("gizmo_api.search", () => at.get(`${lt}/gizmos/search?q=${t}`))
    }
    static getGizmoSearchForWorkspace(t, n=null) {
        return n ? ct("gizmo_api.search_workspace_cursor", () => at.get(`${lt}/gizmos/search?q=${t}&workspace_only=true&cursor=${n}`)) : ct("gizmo_api.search_workspace", () => at.get(`${lt}/gizmos/search?q=${t}&workspace_only=true`))
    }
    static async postGizmoAppeal(t, n, r, s, o) {
        await ct("gizmo_api.appeal", () => at.post(`${lt}/gizmos/${n}/appeal`, {
            reason: r,
            share_recipient: s,
            categories: o
        })),
        await t.invalidateQueries({
            queryKey: ["gizmo", {
                gizmoId: n
            }]
        })
    }
    static async postGizmoCancelAppeal(t, n) {
        await ct("gizmo_api.cancel_appeal", () => at.post(`${lt}/gizmos/${n}/cancel_appeal`, {})),
        await t.invalidateQueries({
            queryKey: ["gizmo", {
                gizmoId: n
            }]
        })
    }
    static upsertDraft(t, n) {
        return n !== void 0 ? ct("gizmo_api.upsert_gizmo", () => at.post(`${lt}/gizmos?gizmo_id=${n}`, t)) : ct("gizmo_api.upsert_gizmo", () => at.post(`${lt}/gizmos`, t))
    }
    static promoteDraft(t, n) {
        return ct("gizmo_api.promote", () => at.post(`${lt}/gizmos/${n}/promote`, t))
    }
    static deleteGizmo(t) {
        return ct("gizmo_api.delete_gizmos", () => ie.safeDelete("/gizmos/{gizmo_id}", {
            parameters: {
                path: {
                    gizmo_id: t
                }
            }
        }))
    }
    static getBuilderProfile() {
        return ct("gizmo_api.gizmo_creator_profile", () => at.get(`${lt}/gizmo_creator_profile`))
    }
    static updateBuilderProfile(t) {
        return ct("gizmo_api.gizmo_creator_profile", () => at.post(`${lt}/gizmo_creator_profile`, t))
    }
    static unverifySocialAuth(t) {
        return ct("gizmo_api.delete_socials", () => ie.safeDelete("/gizmo_creator_profile/socials/{verifier_type}", {
            parameters: {
                path: {
                    verifier_type: t
                }
            }
        }))
    }
    static async updateGizmoSidebar(t, n, r, s, o) {
        const i = await ct("gizmo_api.update_sidebar", () => at.post(`${lt}/gizmos/${r}/sidebar`, {
            action: s
        }));
        switch (s) {
        case "keep":
            V.logEvent("Sidebar Gizmo Keep", {
                location: o
            }),
            n.handleGizmoSidebarKeep(t, r);
            break;
        case "hide":
            V.logEvent("Sidebar Gizmo Hide", {
                location: o
            }),
            n.handleGizmoSidebarHide(t, r);
            break
        }
        return i
    }
    static async removeFromRecent(t, n) {
        const r = await ct("gizmo_api.remove_recent", () => at.post(`${lt}/gizmos/${n}/remove_recent`, {}));
        return t.invalidateQueries({
            queryKey: ["gizmos", "bootstrap"]
        }),
        t.invalidateQueries({
            queryKey: ["gizmos", "discovery"]
        }),
        r
    }
    static fetchOpenAPISpec(t) {
        return ct("gizmo_api.fetch_openapi", () => at.post(`${lt}/gizmos/fetch_openapi`, {
            url: t
        }))
    }
    static validateOpenAPISpec(t) {
        return ct("gizmo_api.validate_openapi", () => at.post(`${lt}/gizmos/validate_openapi`, {
            raw_spec: t
        }))
    }
    static transformToOpenAPISpec(t, n) {
        return ct("gizmo_api.transform_openapi", () => at.post(`${lt}/gizmos/transform_openapi`, {
            ...t,
            auth: n
        }))
    }
    static async doOAuthRedirect(t, n, r, s, o) {
        const i = await ct("gizmo_api.oauth_redirect", () => at.post(`${lt}/gizmos/oauth_redirect`, {
            gizmo_id: t,
            gizmo_action_id: n,
            domain: r,
            redirect_to: s,
            draft: o
        }));
        window.location.href = i.redirect_uri
    }
    static async upsertUserActionSettings(t, n, r) {
        return ct("gizmo_api.action_settings", () => at.post(`${lt}/gizmos/action_settings`, {
            gizmo_action_id: t,
            domain: n,
            action_settings: r
        }))
    }
    static async getUserActionSettings(t) {
        return ct("gizmo_api.user_action_settings", () => at.get(`${lt}/gizmos/user_action_settings?gizmo_id=${t}`))
    }
    static async generateCategory(t, n) {
        return ct("gizmo_api.gen_category", () => at.post(`${lt}/gizmos/gen_category`, {
            name: t,
            instructions: n
        }))
    }
    static async getConversations(t, n=null) {
        return ct("gizmo_api.conversations", () => at.get(`${lt}/gizmos/${t}/conversations`, {
            params: {
                ...n ? {
                    cursor: n
                } : {}
            }
        }))
    }
    static async getProjectConversations(t, n=null) {
        return ct("gizmo_api.conversations", () => at.get(`${lt}/gizmos/${t}/conversations`, {
            params: {
                ...n ? {
                    cursor: n
                } : {}
            }
        }))
    }
    static async getCategories() {
        return ct("gizmo_api.categories", () => at.get(`${lt}/gizmos/categories`))
    }
    static async getUserReview(t) {
        return ct("gizmo_api.get_gizmo_reviews", () => at.get(`${lt}/gizmo_reviews/${t}`))
    }
    static async upsertUserReview(t, n, r, s) {
        return ct("gizmo_api.upsert_gizmo_reviews", () => at.post(`${lt}/gizmo_reviews/${t}`, {
            rating: n,
            message: r,
            include_from: s
        }))
    }
    static async sendFeedbackEmail(t, n, r) {
        return ct("gizmo_api.feedback", () => at.post(`${lt}/gizmos/${t}/feedback`, {
            message: n,
            include_from: r
        }))
    }
    static async getAbout(t) {
        return ct("gizmo_api.about", () => at.get(`${lt}/gizmos/${t}/about`))
    }
    static async getCreatorSlice({creatorId: t}) {
        return ct("gizmo_api.gizmo_creators", () => at.get(`${lt}/gizmo_creators/${t}/gizmos`))
    }
    static async getVersion({gizmoId: t, version: n}) {
        return n == null ? ct("gizmo_api.latest_version", () => at.get(`${lt}/gizmos/${t}/version/latest`)) : ct("gizmo_api.version", () => at.get(`${lt}/gizmos/${t}/version/${n}`))
    }
    static async listVersions({gizmoId: t, limit: n, cursor: r}) {
        const s = {};
        return n && (s.limit = n),
        r && (s.cursor = r),
        ct("gizmo_api.versions", () => at.get(`${lt}/gizmos/${t}/versions`, {
            params: s
        }))
    }
    static async copyGizmo({gizmoId: t}) {
        return ct("gizmo_api.copy", () => at.post(`${lt}/gizmos/${t}/copy`))
    }
}
async function ct(e, t) {
    return q.addAction(`${e}.start`),
    t().catch(n => {
        throw q.addAction(`${e}.failure`, {
            error: n
        }),
        n
    }
    )
}
async function gCe() {
    const e = await ie.safeGet("/me", {
        authOption: Qt.SendIfAvailable
    });
    return {
        id: e.id,
        email: e.email,
        name: e.name,
        picture: e.picture,
        created: e.created,
        phone_number: e.phone_number,
        first_name: e.first_name,
        email_domain_type: ["government", "professional", "education", "social", "unknown", "missing"].includes(e.email_domain_type) ? e.email_domain_type : "unknown"
    }
}
const vCe = so({
    queryKey: ["user"],
    queryFn: gCe,
    staleTime: 1 / 0
});
function _Ce() {
    return At(vCe).data
}
const yCe = {
    currentWorkspace: null,
    subscriptionStatus: null,
    workspaces: []
};
function xV(e) {
    const t = At({
        ...Ci(),
        select: n => {
            const r = u1(n);
            return {
                currentWorkspace: r?.data ?? null,
                subscriptionStatus: r?.data.subscriptionStatus ?? null,
                workspaces: n.accountItems.map(s => s.data)
            }
        }
    }).data ?? yCe;
    return e ? e(t) : t
}
const bCe = {
    isBusinessWorkspace: ({currentWorkspace: e}) => e != null ? e.structure === Dr.WORKSPACE : void 0,
    isEduPlan: ({subscriptionStatus: e}) => sh(e?.planType),
    isEnterpriseyPlan: ({subscriptionStatus: e}) => e != null && r1(e.planType),
    isTeamPlan: ({subscriptionStatus: e}) => e?.planType === We.SELF_SERVE_BUSINESS,
    workspaceId: ({currentWorkspace: e}) => e != null ? e.id : null,
    workspaces: ({workspaces: e}) => e,
    accountUserId: ({currentWorkspace: e}) => e?.accountUserId
};
function EMe() {
    return ir()?.data.subscriptionStatus.lastActiveSubscription
}
function CCe(e) {
    return e.email_domain_type === "professional" || e.email_domain_type === "government" || e.email_domain_type === "unknown"
}
function xMe(e) {
    return e.email_domain_type === "professional" || e.email_domain_type === "unknown"
}
const q4 = e => {
    const t = ir()
      , n = t?.getWorkspaceId()
      , r = Cge()
      , {data: s, isLoading: o} = n1(n);
    if (!t?.isWorkspaceAccount())
        return {
            hasWorkspacePermission: !0,
            isLoading: !1
        };
    const i = s?.permissions?.includes(e) ?? !1;
    return {
        hasWorkspacePermission: r ? i : !0,
        isLoading: o
    }
}
  , TMe = () => {
    const e = ir()
      , {hasWorkspacePermission: t, isLoading: n} = q4(rc.CrudGPT);
    return {
        canCreate: e?.hasPaidFeatures() && t,
        isLoading: n
    }
}
;
function kMe(e) {
    const {hasWorkspacePermission: t, isLoading: n} = q4(rc.CrudGPT);
    return {
        canDelete: (t && e?.gizmo.current_user_permission?.can_delete) ?? !1,
        isLoading: n
    }
}
function OMe(e) {
    const {hasWorkspacePermission: t, isLoading: n} = q4(rc.CrudGPT);
    return {
        canEdit: (t && e?.gizmo.current_user_permission?.can_write) ?? !1,
        isLoading: n
    }
}
function AMe(e) {
    return {
        canViewConfig: e.gizmo.current_user_permission?.can_view_config ?? !1
    }
}
function SCe(e, t, n) {
    const r = t?.name;
    switch (e) {
    case zr.Link:
        return n.formatMessage(Pp.privacyAnyoneWithLink);
    case zr.Private:
        return n.formatMessage(Pp.privacyOnlyMe);
    case zr.Group:
    case zr.User:
        return n.formatMessage({
            id: "B9pJ5o",
            defaultMessage: "Invite only"
        });
    case zr.Marketplace:
        return n.formatMessage(Pp.privacyMarketplace);
    case zr.Workspace:
        return n.formatMessage(Pp.privacyWorkspace, {
            workspaceName: r
        });
    case zr.WorkspaceLink:
        return n.formatMessage({
            id: "T5Eek0",
            defaultMessage: "Anyone at {workspaceName} with the link"
        }, {
            workspaceName: r
        })
    }
}
function MMe(e) {
    const t = gt()
      , n = xV(r => r.currentWorkspace);
    return SCe(e, n, t)
}
function wCe(e) {
    return "gizmo"in e
}
function ECe(e) {
    return "id"in e
}
function IMe(e) {
    return `${e.replaceAll(".", "_").replaceAll("-", "_")}__jit_plugin`
}
const Pp = xt({
    privacyOnlyMe: {
        id: "gizmo.privacyOnlyMe",
        defaultMessage: "Only me"
    },
    privacyAnyoneWithLink: {
        id: "gizmo.privacyAnyoneWithLink",
        defaultMessage: "Anyone with a link"
    },
    privacyWorkspace: {
        id: "gizmo.privacyWorkspace",
        defaultMessage: "Anyone at {workspaceName}"
    },
    privacyMarketplace: {
        id: "gizmo.privacyMarketplace",
        defaultMessage: "Everyone"
    }
})
  , RMe = "GPT Builder"
  , TV = "gizmo-bootstrap"
  , kV = 1;
function NMe(e) {
    if (e)
        return `ChatGPT - ${e}`
}
function PMe(e) {
    return `https://chatgpt.com${Ff(e)}`
}
function xCe(e, t) {
    return Xe(e, "491279851") && Mi(t.gizmo.id) ? `${Ff(Lf(t))}/project` : Ff(Lf(t))
}
function DMe(e, t, n) {
    const r = new URLSearchParams;
    return n != null && r.set(lCe, n),
    mCe(new URL(`${xCe(e, t)}?${r}`,"https://chatgpt.com"))
}
function LMe(e) {
    return `/g/${Lf(e)}`
}
function FMe(e) {
    return wCe(e) && e.gizmo.live_version === 0 || ECe(e) && e.liveVersion === 0
}
function jMe(e, t) {
    return At({
        queryKey: ["gizmos", "discovery", {
            locale: e,
            isAnon: t
        }],
        queryFn: async () => Cn.getGizmoDiscovery(e, t)
    })
}
function UMe({cutId: e, locale: t, limit: n, cursor: r, enabled: s=!0}) {
    return PS({
        queryKey: ["gizmos", "discovery", {
            cutId: e,
            locale: t,
            limit: n
        }],
        queryFn: async ({pageParam: o}) => Cn.getGizmoDiscoveryCut(e, {
            locale: t,
            cursor: o,
            limit: n
        }),
        initialPageParam: r,
        getNextPageParam: o => o.list.cursor ?? void 0,
        enabled: s
    })
}
const BMe = en(e => Zf(e, () => so({
    queryKey: ["gizmos", "discovery", {
        cutId: "recent",
        limit: 20
    }],
    queryFn: () => Cn.getGizmoDiscoveryCut("recent", {
        limit: 20
    }),
    enabled: yn(e)
})))
  , qMe = en(e => Zf(e, () => so({
    queryKey: ["gizmos", "pinned"],
    enabled: yn(e),
    queryFn: Cn.getGizmoPinned
})));
function Ol(e=2) {
    return so({
        queryKey: ["gizmos", "bootstrap"],
        experimental_prefetchInRender: !0,
        queryFn: async () => Cn.getGizmoBootstrap(e).then(t => (q.addFirstTiming("load.gizmoBootstrap"),
        {
            gizmos: Object.values(t).flat().filter(r => r).filter(r => r.resource.gizmo?.gizmo_type !== zl.PROJECT).map(r => ({
                resource: r.resource,
                flair: r.flair
            }))
        }))
    })
}
const GMe = en(e => Zf(e, Ol));
function VMe() {
    const e = ue()
      , n = Xe(e, "1524046265") ? 20 : 2
      , r = Ol(n)
      , s = y1(TV, kV, r.queryKey);
    return At({
        ...r,
        initialData: s
    })
}
function HMe() {
    const e = ue()
      , n = Xe(e, "1524046265") ? 20 : 2
      , r = Ol(n)
      , s = y1(TV, kV, r.queryKey);
    return f$({
        ...r,
        initialData: s
    })
}
function DA(e, t) {
    const n = e.filter(s => s.resource.gizmo.id !== t.resource.gizmo.id);
    let r = n.findIndex(s => s.flair.kind === ou.Recent);
    return r === -1 && (r = n.length),
    n.splice(r, 0, t),
    n
}
const zMe = {
    handleGizmoInteracted(e, t) {
        const n = e.getQueryData($l(e, t).queryKey);
        n == null || Mi(t) || e.setQueryData(Ol().queryKey, r => {
            if (r == null)
                return r;
            const s = r.gizmos.find(o => o.resource.gizmo.id === t);
            return s?.flair.kind === ou.FirstParty || s?.flair.kind === ou.SidebarKeep ? r : {
                gizmos: DA(r.gizmos, {
                    resource: n,
                    flair: {
                        kind: ou.Recent
                    }
                })
            }
        }
        )
    },
    handleGizmoSidebarKeep(e, t) {
        const n = e.getQueryData($l(e, t).queryKey);
        n != null && e.setQueryData(Ol().queryKey, r => r == null ? r : {
            gizmos: DA(r.gizmos, {
                resource: n,
                flair: {
                    kind: ou.SidebarKeep
                }
            })
        })
    },
    handleGizmoSidebarHide(e, t) {
        e.setQueryData(Ol().queryKey, n => n?.gizmos.some(r => r.resource.gizmo.id === t) ? {
            gizmos: n.gizmos.filter(r => r.resource.gizmo.id !== t)
        } : n)
    }
};
function OV(e, t=!1) {
    const n = Lr();
    return At($l(n, e, t))
}
const $Me = ({gizmoId: e, limit: t, cursor: n}) => At({
    queryFn: async () => Cn.listVersions({
        gizmoId: e
    }),
    queryKey: ["gizmo", "versions", {
        gizmoId: e,
        limit: t,
        cursor: n
    }]
});
function WMe({gizmoId: e, draft: t, version: n}) {
    const r = Lr()
      , s = n ? {
        queryKey: ["gizmo", "version", {
            gizmoId: e,
            version: n
        }],
        queryFn: async () => Cn.getVersion({
            gizmoId: e,
            version: n
        }),
        enabled: e != null
    } : $l(r, e, t);
    return At(s)
}
function KMe(e, t) {
    return At({
        queryKey: ["gizmo", "userActionSettings", {
            gizmoId: e
        }],
        queryFn: async () => Cn.getUserActionSettings(e),
        enabled: e != null && t
    })
}
function $l(e, t, n=!1) {
    return so({
        queryKey: ["gizmo", {
            gizmoId: t
        }, {
            draft: n
        }],
        queryFn: async () => Cn.getGizmo(t, n),
        enabled: t != null,
        initialData: () => {
            if (n === !0)
                return;
            const r = e.getQueryData(Ol().queryKey);
            if (r != null)
                return r.gizmos.find(o => o.resource.gizmo.id === t)?.resource;
            const s = e.getQueryData(["gizmos", "discovery"]);
            if (s != null)
                for (const o of s.cuts) {
                    const i = o.list.items.find(a => a.resource.gizmo.id === t)?.resource;
                    if (i != null)
                        return i
                }
        }
    })
}
function TCe(e, t) {
    return e.fetchQuery($l(e, t))
}
function YMe(e) {
    return At({
        queryKey: ["gizmo", {
            search: e
        }],
        queryFn: async () => Cn.getGizmoSearch(e),
        enabled: e.length > 0
    })
}
function ZMe(e, t) {
    return At({
        queryKey: ["gizmo-search-workspace", {
            search: e
        }],
        queryFn: async () => Cn.getGizmoSearchForWorkspace(e),
        enabled: e.length > 0 && t
    })
}
function JMe(e, t=!1, n=!1, r=null) {
    return PS({
        queryKey: [n ? "gizmo-search-workspace" : "gizmo", {
            query: e,
            cursor: r
        }],
        queryFn: async ({pageParam: s}) => n ? Cn.getGizmoSearchForWorkspace(e, r = s) : Cn.getGizmoSearch(e, r = s),
        initialPageParam: r,
        getNextPageParam: s => s.cursor ?? void 0,
        enabled: t
    })
}
function XMe() {
    const e = Lr();
    return nr({
        mutationFn: async ({gizmoId: t, editorData: n}) => {
            const {instructions: r, name: s, description: o, emoji: i, theme: a, profilePictureId: l, profilePictureUrl: c, promptStarters: u, tools: d, files: f, defaultModel: p, trainingDisabled: m} = n
              , v = {
                instructions: r,
                display: {
                    name: s,
                    description: o,
                    emoji: i,
                    theme: a,
                    profile_pic_id: l,
                    profile_picture_url: c,
                    prompt_starters: u
                },
                tools: d,
                files: f.map(_ => ({
                    ..._,
                    location: SV.FILE_SERVICE
                })),
                training_disabled: m,
                default_model: p ?? void 0
            };
            return Cn.upsertDraft(v, t)
        }
        ,
        onSettled: t => {
            t && (e.setQueryData($l(e, t.gizmo.id, !0).queryKey, t),
            e.invalidateQueries({
                queryKey: ["gizmos", "mine"],
                refetchType: "none"
            }))
        }
    })
}
function QMe() {
    const e = Lr();
    return nr({
        mutationFn: async ({gizmoId: t, data: n}) => {
            const {sharingRecipient: r, categories: s} = n
              , o = await Cn.promoteDraft({
                sharing: n.sharingSubjects && n.sharingSubjects.length > 0 ? n.sharingSubjects : {
                    recipient: r
                },
                categories: s
            }, t);
            if (o.error)
                throw new aCe(o);
            return o.resource
        }
        ,
        onSettled: t => {
            e.invalidateQueries({
                queryKey: ["gizmos"],
                refetchType: "all"
            }),
            e.invalidateQueries({
                queryKey: ["gizmos", "pinned"],
                refetchType: "none"
            }),
            t && e.setQueryData($l(e, t.gizmo.id, !1).queryKey, t)
        }
    })
}
function eIe() {
    const e = Lr();
    return nr({
        mutationFn: async ({gizmoId: t}) => Cn.deleteGizmo(t),
        onSettled: () => {
            e.invalidateQueries({
                queryKey: ["gizmos"],
                refetchType: "all"
            })
        }
    })
}
function tIe() {
    const e = Lr()
      , t = Tn();
    return nr({
        mutationFn: async ({name: n, hideName: r, websiteUrl: s, willReceiveSupportEmails: o}) => Cn.updateBuilderProfile({
            name: n,
            hide_name: r,
            website_url: s,
            will_receive_support_emails: o
        }),
        onSuccess: n => {
            e.setQueryData(["builderProfile"], n)
        }
        ,
        onError: n => {
            t.warning(n.message)
        }
    })
}
function nIe() {
    return At({
        queryKey: ["builderProfile"],
        queryFn: async () => Cn.getBuilderProfile()
    })
}
function rIe() {
    return nr({
        mutationFn: async ({gizmoId: e}) => Cn.copyGizmo({
            gizmoId: e
        })
    })
}
function sIe() {
    return At({
        queryKey: ["gizmoCategories"],
        queryFn: async () => Cn.getCategories()
    })
}
function oIe(e, t) {
    const n = ue()
      , r = Xe(n, "2632917233");
    return !!(t != null && [cn.PrimaryAssistant, cn.GizmoInteraction].includes(t) && (r || e?.includes(x6.GPT_4)))
}
function iIe(e, t) {
    const n = Lr()
      , r = Tn();
    return nr({
        mutationFn: async ({rating: s, message: o, includeFrom: i}) => {
            await Cn.upsertUserReview(e, s, o, i)
        }
        ,
        onSuccess: async () => {
            n.invalidateQueries({
                queryKey: ["gizmo", "review", {
                    gizmoId: e
                }]
            })
        }
        ,
        onError: s => {
            r.danger(s.message, {
                toastId: "gizmo_review_error",
                loggingTitle: "useUpsertUserReviewMutation",
                loggingDescription: s.message
            })
        }
    })
}
function kCe({clientThreadId: e}) {
    const t = lw()
      , [n,r] = Ai(e, f => [Ce.getCurrentNode(f)?.message.metadata?.model_switcher_deny, Ce.getGizmoId(f)])
      , s = r ?? t
      , {data: o} = OV(s)
      , {data: i} = sse({
        isGizmo: !!s
    })
      , a = gt()
      , l = {}
      , c = ue()
      , u = Xe(c, "891514942")
      , d = VQ();
    for (const {resets_after: f, model_slug: p} of d)
        [Pd.CONVERSATION, Pd.REGENERATE].forEach(m => {
            const v = l[p] ?? {}
              , _ = v[m] ?? []
              , y = {
                reason: k6.RATE_LIMIT,
                resetsAfter: f,
                isAvailable: !1
            };
            _.push(y),
            v[m] = _,
            l[p] = v
        }
        );
    if (n?.forEach(f => {
        const {slug: p, context: m, reason: v, description: _, is_available: y} = f
          , b = u && y
          , S = l[p] ?? {}
          , C = S[m] ?? [];
        C.push({
            reason: v,
            description: _,
            isAvailable: b
        }),
        S[m] = C,
        l[p] = S
    }
    ),
    s && Mi(s)) {
        const f = [bo.GIZMO_PROJECT];
        o?.files?.length && f.push(bo.ATTACHMENT),
        o?.gizmo.instructions.length && f.push(bo.CUSTOM_INSTRUCTIONS),
        i?.categories.forEach(p => {
            const {defaultModel: m, supportedFeatures: v} = p
              , _ = v || []
              , y = [];
            if (f.includes(bo.GIZMO_PROJECT) && !_.includes(bo.GIZMO_PROJECT) && y.push({
                reason: gs.UNSUPPORTED_GIZMO,
                description: a.formatMessage({
                    id: "6w0z4F",
                    defaultMessage: "This model doesn't support projects."
                }),
                isAvailable: !1
            }),
            f.includes(bo.ATTACHMENT) && !_.includes(bo.ATTACHMENT) && y.push({
                reason: gs.UNSUPPORTED_ATTACHMENT,
                description: a.formatMessage({
                    id: "ZKjdak",
                    defaultMessage: "This model doesn't support file attachments."
                }),
                isAvailable: !1
            }),
            f.includes(bo.CUSTOM_INSTRUCTIONS) && !_.includes(bo.CUSTOM_INSTRUCTIONS) && y.push({
                reason: gs.UNSUPPORTED_CUSTOM_INSTRUCTIONS,
                description: a.formatMessage({
                    id: "zaubcf",
                    defaultMessage: "This model doesn't support custom instructions."
                }),
                isAvailable: !1
            }),
            y.length) {
                const b = l[m] ?? {};
                [Pd.CONVERSATION, Pd.REGENERATE].forEach(S => {
                    const C = b[S] ?? [];
                    C.push(...y),
                    b[S] = C,
                    l[m] = b
                }
                )
            }
        }
        )
    }
    return l
}
function OCe({modelSlug: e, modelSwitcherDenialsBySlug: t}) {
    const n = e ? t[e]?.conversation : null;
    return n ? n.every(r => r.isAvailable === !0) : !0
}
function ACe({currentModel: e, categoryOptions: t, className: n, modelSwitcherDenialsBySlug: r, displayInFull_INTERNAL_USE_ONLY: s=!1, onModelItemClick: o, preferredModelId: i}) {
    const a = gt()
      , l = e?.id ?? null
      , [c,u] = h.useState("")
      , d = h.useMemo( () => c ? t.filter(f => f.name.toLowerCase().includes(c.toLowerCase())) : t, [t, c]);
    return g.jsx(Dt.Portal, {
        children: g.jsxs(Dt.SubContent, {
            className: we("flex flex-col pt-0", n),
            children: [g.jsxs("div", {
                style: {
                    borderRadius: "inherit"
                },
                className: "sticky top-0 z-1 bg-white",
                children: [g.jsx("div", {
                    className: "p-2",
                    children: g.jsx(gV, {
                        inputClassName: "w-full",
                        value: c,
                        onKeyDown: f => {
                            f.stopPropagation()
                        }
                        ,
                        onChange: f => {
                            u(f.target.value)
                        }
                    })
                }), g.jsx("hr", {})]
            }), g.jsxs("div", {
                className: "scrollbar-gutter-stable w-[min(320px,95vw)] flex-grow overflow-auto",
                children: [d.length === 0 && g.jsx(Dt.Item, {
                    children: a.formatMessage({
                        id: "model-switcher.no-results",
                        defaultMessage: "No results found"
                    })
                }), d.map(f => {
                    const {value: p} = f;
                    return "options"in f ? g.jsx(Kc, {
                        currentModel: e,
                        isSelected: l?.startsWith(p),
                        option: f,
                        modelSwitcherDenialsBySlug: r,
                        displayInFull_INTERNAL_USE_ONLY: s,
                        onModelItemClick: o,
                        preferredModelId: i
                    }, p) : g.jsx(Xi, {
                        currentModelId: l,
                        isSelected: l === p,
                        value: p,
                        modelSwitcherDenialsBySlug: r,
                        displayInFull_INTERNAL_USE_ONLY: s,
                        onClick: o,
                        preferredModelId: i,
                        children: f.name
                    }, p)
                }
                )]
            })]
        })
    })
}
function Kc({currentModel: e, option: t, isSelected: n=!1, modelSwitcherDenialsBySlug: r, displayInFull_INTERNAL_USE_ONLY: s=!1, onModelItemClick: o, preferredModelId: i}) {
    const {name: a, options: l, categoryId: c} = t
      , u = `${a} Models`
      , d = () => g.jsx("div", {
        className: "flex shrink-0 grow justify-between gap-2",
        children: g.jsxs("div", {
            className: "flex items-center gap-3",
            children: [g.jsx(vV, {
                className: "icon"
            }), u]
        })
    });
    let f;
    return s && n && (f = t.options.find(p => p.value === e?.id)?.name),
    g.jsxs(Dt.Sub, {
        children: [g.jsx(Dt.SubMenuTrigger, {
            children: g.jsxs("div", {
                className: we("flex grow justify-between gap-2 overflow-hidden", s ? "items-center break-all" : ""),
                children: [c ? d() : a, n && g.jsx("div", {
                    className: "text-token-text-tertiary truncate",
                    children: f ?? e?.title
                })]
            })
        }), g.jsx(ACe, {
            currentModel: e,
            categoryOptions: l,
            modelSwitcherDenialsBySlug: r,
            displayInFull_INTERNAL_USE_ONLY: s,
            onModelItemClick: o,
            preferredModelId: i
        })]
    })
}
function Xi({value: e, children: t, icon: n, secondary: r, currentModelId: s, isSelected: o, onClick: i, modelSwitcherDenialsBySlug: a, isUpgradeUpsell: l=!1, testId: c, displayInFull_INTERNAL_USE_ONLY: u=!1, deprecated: d, preferredModelId: f, disabledByAdmin: p}) {
    const m = ue()
      , v = tCe()
      , _ = e ? a[e]?.conversation?.[0] : null
      , y = OCe({
        modelSlug: e,
        modelSwitcherDenialsBySlug: a
    })
      , b = p || !y
      , S = $t(m, "1846737571")
      , C = () => {
        if (i)
            i(e);
        else if (e) {
            V.logEvent("Model Switcher Model Changed", {
                from: s,
                to: e
            }),
            ft.logEvent("chatgpt_model_switcher_model_changed", e, {
                from: s ?? "",
                to: e
            });
            const x = e;
            _V(m, x),
            v({
                modelId: x,
                location: "Model switcher menu item"
            })
        }
    }
      , w = g.jsx(Dt.Item, {
        onClick: C,
        disabled: b,
        className: we(u && "break-all"),
        icon: n,
        secondary: r,
        trailingColor: "primary",
        trailing: l ? g.jsx(an, {
            color: "secondary",
            size: "small",
            className: S.get("is_upgrade_button_blue", !1) ? "border-none bg-blue-600 text-white hover:bg-blue-800" : "",
            children: g.jsx(de, {
                id: "oKo8wt",
                defaultMessage: "Upgrade"
            })
        }) : o ? g.jsx(g4, {
            className: "icon-sm"
        }) : g.jsx("span", {
            className: "icon"
        }),
        "data-testid": c,
        children: g.jsxs("span", {
            className: "flex items-center gap-1",
            children: [t, e && e === f && !o && !l && !d && g.jsx("span", {
                className: "inline-flex items-center rounded-full bg-blue-100 px-2 py-0.5 text-xs font-medium text-blue-700",
                children: g.jsx(de, {
                    id: "model-switcher.preferred",
                    defaultMessage: "GPT creator recommended"
                })
            })]
        })
    }, e);
    return _ ? g.jsx(ls, {
        withArrow: !0,
        side: "right",
        sideOffset: -10,
        label: g.jsx(eCe, {
            modelSwitcherDeny: _
        }),
        children: w
    }) : w
}
function MCe(e, t) {
    switch (t) {
    case "gpt-4o":
        return us(e).checkGate("1627380539");
    default:
        return !1
    }
}
function ICe(e) {
    return X5(new URL(e,"https://chatgpt.com").searchParams).includes(xe.Search)
}
var RCe = (e => (e.DownloadMessages = "download-messages",
e.InviteUsersToWorkspace = "invite-users-to-workspace",
e.WorkspaceAppearance = "workspace-appearance",
e.KeyboardActions = "keyboard-actions",
e.WorkspaceSwitcher = "workspace-switcher",
e.ReadOnlyConversationTemplate = "read-only-conversation-template",
e.CookieManagement = "cookie-management",
e.AgeVerificationInterstitial = "age-verification-interstitial",
e.GPTDetails = "gpt-details",
e.GPTPrivacySettings = "gpt-privacy-settings",
e.GPTFeedbackEmail = "gpt-support-email",
e.GPTReview = "gpt-review",
e.GPTRemoveThirdParty = "gpt-remove-third-party",
e.SharedConversationModeration = "shared-conversation-moderation",
e.ReportConversation = "report-conversation",
e.BlockingInitialComponent = "blocking-initial-component",
e.NoAuthNewChat = "no-auth-new-chat",
e.GlobalMemoryOnboarding = "global-memory-onboarding",
e.AccountPayment = "account-payment",
e.CreateExclusion = "create-exclusion",
e.AddServiceAccountKey = "add-service-account-key",
e.DeleteServiceAccountKey = "delete-service-account-key",
e.LogoutConfirm = "logout-confirm",
e.NotificationFeed = "notification-feed",
e.DeepResearchShare = "deep-research-share",
e))(RCe || {});
function NCe({isOpen: e}) {
    ze.setCookie(Be.NavigationState, e ? "1" : "0", {
        maxAge: 2 * 365 * 24 * 60 * 60
    })
}
const bt = dn()( () => ({
    isThreadHeaderVisible: !0,
    isSlideoverSidebarOpen: void 0,
    isPopoverSidebarOpen: !1,
    isVoiceActive: !1,
    isConversationScrolledFromTop: !1,
    sharingModalThreadId: void 0,
    deepResearchShareTaskId: void 0,
    feedbackModalThreadId: void 0,
    leaveWorkspaceData: null,
    activeSidebar: !1,
    activeStageSidebar: !1,
    activeModals: new Set,
    isLatencyDevToolsVisible: !1,
    purchaseWorkspaceData: null,
    browseMode: "conversation",
    voiceFeedbackThread: null,
    lastVoiceSessionStartTime: null,
    lastVoiceSessionEndTime: null,
    displayAnnouncementTooltip: null,
    noAuthMadlibsModalOpen: !1,
    onboardingConvoState: null,
    autoHighlightNicknameInput: !1,
    shouldShowThreadModelPickerDot: !1
}))
  , aIe = {
    isLatencyDevtoolsVisible: e => e.isLatencyDevToolsVisible
}
  , af = {
    setBrowseMode: e => {
        bt.setState(t => ({
            ...t,
            browseMode: e
        }))
    }
    ,
    setIsConversationScrolledFromTop: e => {
        bt.setState(t => ({
            ...t,
            isConversationScrolledFromTop: e
        }))
    }
    ,
    enterGizmoEditor: () => {
        bt.setState({
            browseMode: "gizmo-editor"
        })
    }
    ,
    exitGizmoEditor: () => {
        bt.setState({
            browseMode: "conversation"
        })
    }
    ,
    setAutoHighlightNicknameInput: e => {
        bt.setState({
            autoHighlightNicknameInput: e
        })
    }
    ,
    setSidebarOpen(e) {
        PCe() ? af.setPopoverSidebarOpen(e) : af.setSlideoverSidebarOpen(e)
    },
    setPopoverSidebarOpen: e => {
        bt.setState( ({isPopoverSidebarOpen: t}) => ({
            isPopoverSidebarOpen: e ?? !t
        }))
    }
    ,
    setSlideoverSidebarOpen: e => {
        bt.setState( ({isSlideoverSidebarOpen: t}) => {
            const n = e ?? !(t ?? AV());
            return NCe({
                isOpen: n
            }),
            V.logToggleDesktopNavCollapsed({
                isDesktopNavCollapsed: !n,
                action: "button_click"
            }),
            {
                isSlideoverSidebarOpen: n
            }
        }
        ),
        MV = !1
    }
    ,
    hideThreadHeader: () => {
        bt.setState({
            isThreadHeaderVisible: !1
        })
    }
    ,
    showThreadHeader: () => {
        bt.setState({
            isThreadHeaderVisible: !0
        })
    }
    ,
    openSharingModal(e, t) {
        bt.setState({
            sharingModalThreadId: e
        }),
        V.logEvent("Share Conversation: Open Modal", {
            location: t
        })
    },
    closeSharingModal() {
        bt.setState({
            sharingModalThreadId: void 0
        })
    },
    openFeedbackModal(e) {
        bt.setState({
            feedbackModalThreadId: e
        })
    },
    closeFeedbackModal() {
        bt.setState({
            feedbackModalThreadId: void 0
        })
    },
    setLeaveWorkspaceData(e) {
        bt.setState({
            leaveWorkspaceData: e
        })
    },
    setPurchaseWorkspaceData(e) {
        bt.setState({
            purchaseWorkspaceData: e
        })
    },
    setActiveSidebar(e) {
        bt.setState({
            activeSidebar: e
        })
    },
    setThreadModelPickerAlertDot: e => {
        bt.setState( ({shouldShowThreadModelPickerDot: t}) => (t !== e && V.logEvent("Notifications: Thread Model Picker Alert Dot", {
            shown: e
        }),
        {
            shouldShowThreadModelPickerDot: e
        }))
    }
    ,
    toggleActiveSidebar(e) {
        bt.setState(t => ({
            activeSidebar: t.activeSidebar === e ? !1 : e
        }))
    },
    closeActiveSidebar() {
        bt.setState( () => ({
            activeSidebar: !1
        }))
    },
    setActiveStageSidebar(e) {
        bt.setState({
            activeStageSidebar: e
        })
    },
    toggleModal(e) {
        bt.setState(t => {
            const n = new Set(t.activeModals);
            return n.has(e) ? n.delete(e) : n.add(e),
            {
                activeModals: n
            }
        }
        )
    },
    openModal(e) {
        bt.setState(t => {
            if (t.activeModals.has(e))
                return t;
            const n = new Set(t.activeModals);
            return n.add(e),
            {
                activeModals: n
            }
        }
        )
    },
    closeModal(e) {
        bt.setState(t => {
            if (!t.activeModals.has(e))
                return t;
            const n = new Set(t.activeModals);
            return n.delete(e),
            {
                activeModals: n
            }
        }
        )
    },
    openDeepResearchShare(e) {
        bt.setState(t => ({
            ...t,
            deepResearchShareTaskId: e
        })),
        af.openModal("deep-research-share")
    },
    closeAllActiveModals() {
        bt.getState().activeModals.size > 0 && bt.setState({
            activeModals: new Set
        })
    },
    hideLatencyDevTools: () => {
        bt.setState({
            isLatencyDevToolsVisible: !1
        })
    }
    ,
    showLatencyDevTools: () => {
        bt.setState({
            isLatencyDevToolsVisible: !0
        })
    }
    ,
    showAnnouncementTooltipExclusively(e, t=!1) {
        bt.setState(n => n.displayAnnouncementTooltip && !t ? n : {
            displayAnnouncementTooltip: e
        })
    },
    setNoAuthMadlibsModalOpen: e => {
        bt.setState({
            noAuthMadlibsModalOpen: e
        }),
        Wt.setItem(Ft.NoAuthMadlibsModalState, "seen")
    }
    ,
    setOnboardingConvoState: e => {
        bt.setState({
            onboardingConvoState: e
        })
    }
};
function lIe(e) {
    return bt(t => t.activeModals.has(e))
}
function AV() {
    if (MV)
        return !1;
    const e = ze.getCookie(Be.NavigationState);
    return e != null ? e === "1" : !0
}
let MV = ICe(window.location.href);
function PCe() {
    const e = bt.getState().activeStageSidebar
      , t = ane();
    return e || !t
}
function DCe() {
    const e = bt(n => n.activeStageSidebar)
      , t = LL();
    return e || !t
}
function cIe() {
    const e = ue()
      , t = DCe()
      , n = bt(r => r.isSlideoverSidebarOpen);
    return yn(e) && !t && (n ?? AV())
}
function uIe() {
    return bt(e => e.activeModals.has("blocking-initial-component"))
}
function dIe() {
    const [e,t] = h.useState(!1);
    return h.useEffect( () => bt.subscribe(n => {
        n.activeModals.has("blocking-initial-component") && t(r => r || n.activeModals.has("blocking-initial-component"))
    }
    ), []),
    e
}
const fIe = (e, t, n, r) => {
    const s = Xe(e, "2861925050")
      , o = n?.some( ({model_slug: i}) => r?.models.get(i));
    return !(!s || !o || !t || !t.isTeam())
}
  , IV = () => {
    const e = Wt.getItem(Ft.FinchAdminNotified);
    return new Date(e ?? 0)
}
  , LCe = () => {
    const e = new Date;
    e.setDate(e.getDate() + 1),
    Wt.setItem(Ft.FinchAdminNotified, e.toISOString())
}
  , FCe = () => {
    const e = IV();
    return Wt.getItem(Ft.FinchAdminNotified) != null && new Date <= e
}
  , hIe = () => {
    const e = IV();
    return new Date > e
}
  , pIe = e => {
    switch (e) {
    case "wham":
        return "wham";
    case "deep_research":
        return "deep_research";
    case "image_gen":
        return "image_gen";
    case "gpt-4-5":
        return "gpt-4-5";
    default:
        return null
    }
}
  , jCe = dn(e => ({
    hasRequestedCredits: FCe(),
    setHasRequestedCredits: t => e( () => ({
        hasRequestedCredits: t
    }))
}))
  , UCe = $g( () => he( () => import("./mk041k5xr296rhm9.js"), __vite__mapDeps([13, 1, 14, 15, 9, 10, 16, 17])).then(e => e.CreditPurchaseModal))
  , BCe = () => {
    const e = Tn()
      , t = gt()
      , {hasRequestedCredits: n, setHasRequestedCredits: r} = jCe()
      , {mutate: s, isPending: o} = nr({
        mutationFn: i => ie.safePost("/credits/pleas", {
            requestBody: {
                product: i
            }
        }),
        onError: i => {
            q.addError(new Error("Error occurred while submitting credit plea request",{
                cause: i
            })),
            e.danger(_u.errorRequestCredits, {
                toastId: "teams_credit_plea_button"
            })
        }
        ,
        onSuccess: () => {
            r(!0),
            e.success(t.formatMessage(_u.successRequestCredits)),
            LCe(),
            af.setThreadModelPickerAlertDot(!1)
        }
    });
    return {
        submitCreditPleaRequest: s,
        hasRequestedCredits: n,
        isPending: o
    }
}
  , qCe = ({trigger: e, ...t}) => {
    const n = ue();
    h.useEffect( () => {
        V.logEventWithStatsig("ChatGPT Credits: Add Credits Button Shown", "chatgpt_credits_add_credits_button_shown", {
            trigger: e
        })
    }
    , [e]);
    const r = () => {
        V.logEventWithStatsig("ChatGPT Credits: Add Credits Clicked", "chatgpt_credits_add_credits_clicked"),
        Gg(n, UCe)
    }
    ;
    return g.jsx(an, {
        color: "primary",
        onClick: r,
        ...t,
        children: g.jsx(de, {
            ..._u.addCredits
        })
    })
}
  , GCe = ({creditConsumingProduct: e, trigger: t, ...n}) => {
    const r = gt()
      , {submitCreditPleaRequest: s, isPending: o, hasRequestedCredits: i} = BCe();
    h.useEffect( () => {
        V.logEventWithStatsig("ChatGPT Credits: Notify Admin Button Shown", "chatgpt_credits_notify_admin_button_shown", {
            trigger: t,
            creditConsumingProduct: e
        })
    }
    , [e, t]);
    const a = () => {
        i || (s(e),
        V.logEventWithStatsig("ChatGPT Credits: Notify Admin Clicked", "chatgpt_credits_notify_admin_clicked"))
    }
      , l = g.jsx(an, {
        loading: o,
        color: i ? "secondary" : "primary",
        disabled: i,
        onClick: a,
        ...n,
        children: i ? r.formatMessage(_u.requested) : r.formatMessage(_u.notifyAdmin)
    });
    return i ? g.jsx(ls, {
        className: "w-auto whitespace-nowrap",
        withArrow: !0,
        labelTextAlign: "left",
        contentClassName: "w-[180px]",
        side: "right",
        label: r.formatMessage(_u.alreadyRequested),
        children: l
    }) : l
}
  , _u = xt({
    notifyAdmin: {
        id: "prompt-textarea.teamsCreditRequestBanner.notifyAdmin",
        defaultMessage: "Notify admin"
    },
    addCredits: {
        id: "prompt-textarea.teamsCreditRequestBanner.addCredits",
        defaultMessage: "Add credits"
    },
    requested: {
        id: "prompt-textarea.teamsCreditRequestBanner.requested",
        defaultMessage: "Requested"
    },
    errorRequestCredits: {
        id: "prompt-textarea.teamsCreditRequestBanner.error",
        defaultMessage: "Error occurred while submitting credit request"
    },
    successRequestCredits: {
        id: "prompt-textarea.teamsCreditRequestBanner.success",
        defaultMessage: "Request sent to your admin"
    },
    alreadyRequested: {
        id: "prompt-textarea.teamsCreditRequestBanner.alreadyRequested",
        defaultMessage: "Youâ€™ve already notified your admin"
    }
})
  , LA = "needsCreditsSection"
  , VCe = () => {
    const t = ir()?.isOwnerOfAccount();
    return g.jsxs(Dt.Item, {
        className: "pointer-events-none pe-2.5! hover:bg-transparent hover:text-inherit",
        onSelect: n => n.preventDefault(),
        disabled: !0,
        children: [g.jsx("div", {
            className: "text-token-text-tertiary text-xs",
            children: g.jsx(de, {
                ...t ? FA.ownerDescription : FA.description
            })
        }), t ? g.jsx(qCe, {
            size: "small",
            trigger: "thread-header-dropdown-credits-section"
        }) : g.jsx(GCe, {
            size: "small",
            creditConsumingProduct: "gpt-4-5",
            trigger: "thread-header-dropdown-credits-section"
        })]
    })
}
  , FA = xt({
    description: {
        id: "prompt-textarea.teamsCreditRequestBanner.label",
        defaultMessage: "Limits reached. Send a request to your admin to get access"
    },
    ownerDescription: {
        id: "prompt-textarea.teamsCreditRequestBanner.ownerLabel",
        defaultMessage: "Limits reached. Add credits to your account"
    }
})
  , HCe = "https://cdn.oaistatic.com/assets/no-auth-upsell-m8ypcpwf.webp"
  , zCe = {
    src: HCe
};
function $Ce() {
    const e = ue();
    return $t(e, "3637408529").get("is_login_primary_button", !1)
}
const WCe = () => {
    const e = ue();
    return $t(e, "1346366956").get("signup_cta_copy", "SIGN_UP")
}
  , KCe = () => {
    const e = ue();
    return $t(e, "1803944755").get("login_or_signup_cta_copy", "LOGIN_OR_SIGNUP")
}
  , mIe = () => {
    switch (KCe()) {
    case "LOGIN_OR_SIGNUP":
        return jA.loginOrSignup;
    case "SIGNIN":
        return jA.signin
    }
}
  , YCe = e => {
    switch (WCe()) {
    case "SIGN_UP":
        return e;
    case "SIGN_UP_FOR_FREE":
        return Dp.signUpForFreeCta;
    case "CREATE_ACCOUNT":
        return Dp.createAccountCta;
    case "CREATE_NEW_ACCOUNT":
        return Dp.createNewAccountCta;
    case "CREATE_FREE_ACCOUNT":
        return Dp.createFreeAccountCta
    }
}
  , jA = xt({
    loginOrSignup: {
        id: "loginOrSignupCta.loginOrSignup",
        defaultMessage: "Log in or sign up"
    },
    signin: {
        id: "loginOrSignupCta.signin",
        defaultMessage: "Sign in"
    }
})
  , Dp = xt({
    createAccountCta: {
        id: "createAccountCta",
        defaultMessage: "Create account"
    },
    createNewAccountCta: {
        id: "createNewAccountCta",
        defaultMessage: "Create new account"
    },
    createFreeAccountCta: {
        id: "createFreeAccountCta",
        defaultMessage: "Create free account"
    },
    signUpForFreeCta: {
        id: "signUpForFreeCta",
        defaultMessage: "Sign up for free"
    }
});
function ZCe({statsig_login_event: e, statsig_signup_event: t, location: n}) {
    const r = ue()
      , s = $Ce()
      , o = YCe(UA.signUpCta)
      , i = `no-auth-${n}`
      , a = oo()
      , l = qf(r, "2210309751").get("variant", "control")
      , c = () => {
        a({
            hash: Nw,
            search: window.location.search
        }, {
            state: {
                [Oj]: "NoAuth Model Picker Upsell"
            }
        })
    }
      , u = () => {
        Au(r, {
            fallbackScreenHint: "login",
            callback: m => {
                V.logLogInButtonClicked({
                    location: i,
                    provider: m
                }),
                ft.logEvent(e)
            }
        })
    }
      , d = () => {
        Au(r, {
            fallbackScreenHint: "signup",
            callback: m => {
                V.logSignUpButtonClicked({
                    location: i,
                    provider: m
                }),
                ft.logEvent(t)
            }
        })
    }
      , f = g.jsx(an, {
        as: "button",
        size: "medium",
        color: s ? "primary" : "secondary",
        onClick: u,
        children: g.jsx(de, {
            id: "NavigationContent.unauthLoginCta",
            defaultMessage: "Log in"
        })
    }, "login-button")
      , p = g.jsx(an, {
        as: "button",
        size: "medium",
        color: s ? "secondary" : "primary",
        onClick: d,
        children: g.jsx(de, {
            ...o
        })
    }, "signup-button");
    return g.jsxs("div", {
        className: "-mt-4 flex max-w-[calc(100vw-2rem)] flex-col",
        children: [g.jsx("img", {
            className: "max-xs:hidden h-[132px] object-fill",
            src: zCe.src,
            alt: ""
        }), g.jsxs("div", {
            className: "flex flex-col px-4 pt-5 pb-2",
            children: [g.jsx("p", {
                className: "text-token-text-primary mb-1 text-lg font-medium text-pretty",
                children: g.jsx(de, {
                    id: "rwmTbn",
                    defaultMessage: "Try advanced features for free"
                })
            }), g.jsx("p", {
                className: "text-token-text-secondary text-sm text-pretty",
                children: g.jsx(de, {
                    id: "unOBJo",
                    defaultMessage: "Get smarter responses, upload files, create images, and more by logging in."
                })
            }), g.jsx("div", {
                className: "mt-5 flex flex-row justify-start space-x-2",
                children: s ? [f, p] : [p, f]
            }), l === "model-picker" && g.jsx("p", {
                className: "text-token-text-secondary mt-5 text-xs",
                children: g.jsx(de, {
                    ...UA.createWorkspaceTeamOrBusiness,
                    values: {
                        createWorkspaceLink: m => g.jsx("span", {
                            onClick: c,
                            className: "text-token-text-secondary decoration-token-text-primary cursor-pointer underline",
                            children: m
                        })
                    }
                })
            })]
        })]
    })
}
const UA = xt({
    signUpCta: {
        id: "NavigationContent.unauthSignupCta",
        defaultMessage: "Sign up"
    },
    createWorkspaceTeamOrBusiness: {
        id: "components.noAuthUpsell.createWorkspaceTeamOrBusiness",
        defaultMessage: "<createWorkspaceLink>Create a workspace</createWorkspaceLink> for a team or business"
    }
});
function gIe(e, t) {
    return Xe(e, "491279851") && t && Mi(t)
}
function JCe() {
    "use forget";
    const e = De.c(2)
      , t = ue();
    let n;
    return e[0] !== t ? (n = Xe(t, "491279851"),
    e[0] = t,
    e[1] = n) : n = e[1],
    n
}
function XCe(e) {
    "use forget";
    const t = De.c(3)
      , n = JCe();
    if (!e)
        return !1;
    let r;
    return t[0] !== e || t[1] !== n ? (r = n && Mi(e),
    t[0] = e,
    t[1] = n,
    t[2] = r) : r = t[2],
    r
}
function QCe(e, t) {
    return t != null && Mi(t) && Xe(e, "491279851")
}
const e3e = ({isUnauthenticated: e, enabled: t=!0}) => so({
    queryKey: ["modelMessageCap", e],
    queryFn: () => Eee.safeGet("/conversation_limit", {
        authOption: Qt.SendIfAvailable
    }),
    enabled: t
});
function vIe(e) {
    return e.map(t => typeof t == "string" ? t : "").join("")
}
function t3e(e, t) {
    const n = [];
    let r = 0;
    for (let s = 0; s < e.length; s++) {
        const o = e[s];
        if (typeof o == "string")
            if (t != null && t < r + o.length) {
                n.push({
                    type: "text",
                    text: o.slice(0, t - r)
                });
                break
            } else
                n.push({
                    type: "text",
                    text: o
                }),
                r += o.length;
        else if (o.content_type === Jn.ImageAssetPointer) {
            const i = s > 0 ? n[s - 1] : null;
            i?.type === "images" ? i.imageAssets.push(o) : n.push({
                type: "images",
                imageAssets: [o]
            })
        } else
            o.content_type === Jn.AudioTranscription && n.push({
                type: "transcription",
                text: o.text
            })
    }
    return n
}
function _Ie({isUserTurn: e, parts: t}) {
    if (!e)
        return t3e(t);
    const n = {
        text: [],
        images: []
    };
    for (let s = 0; s < t.length; s++) {
        const o = t[s];
        typeof o == "string" ? o.trim().length > 0 && n.text.push({
            type: "text",
            text: o
        }) : o.content_type === Jn.AudioTranscription ? n.text.push({
            type: "transcription",
            text: o.text
        }) : o.content_type === Jn.ImageAssetPointer && n.images.push(o)
    }
    const r = [];
    return n.images.length > 0 && r.unshift({
        type: "images",
        imageAssets: n.images
    }),
    r.push(...n.text.map(s => ({
        type: s.type,
        text: s.text
    }))),
    r
}
function n3e(e) {
    const t = e && new Date(e)
      , n = t && new Date(t);
    return n ? `after ${n.getHours() % 12 || 12}:${n.getMinutes() < 10 ? "0" : ""}${n.getMinutes()} ${n.getHours() >= 12 ? "PM" : "AM"}` : "later"
}
const r3e = "gpt-4"
  , s3e = "oai/apps/capExpiresAt";
dn( () => ({
    serverThreadIds: new Set
}));
function o3e() {
    const e = J1(s => s.isoDate)
      , t = Date.now()
      , n = e && new Date(e).getTime()
      , r = e && n && n <= t;
    return h.useEffect( () => {
        r && RV()
    }
    , [r]),
    r ? null : e ? r3e : null
}
const J1 = dn()(Fj( () => ({
    isoDate: ""
}), {
    name: s3e
}));
function i3e(e) {
    J1.setState({
        isoDate: e
    })
}
function RV() {
    J1.setState({
        isoDate: ""
    })
}
function a3e(e) {
    if (e < 60)
        return {
            type: "minute",
            value: e,
            text: e < 2 ? "minute" : `${e} minutes`
        };
    const t = Math.floor(e / 60);
    if (t < 24)
        return {
            type: "hour",
            value: t,
            text: t < 2 ? "hour" : `${t} hours`
        };
    const n = Math.floor(t / 24);
    return n < 7 ? {
        type: "day",
        value: n,
        text: n < 2 ? "day" : `${n} days`
    } : {
        type: "minute",
        value: e,
        text: e < 2 ? "minute" : `${e} minutes`
    }
}
const i2 = {
    textarea: "",
    "model-switcher": ""
};
function l3e() {
    const e = J1(a => a.isoDate)
      , t = n3e(e)
      , n = gt()
      , r = xV(bCe.isEnterpriseyPlan)
      , {isUnauthenticated: s, isLoading: o} = ah()
      , {data: i} = At(e3e({
        isUnauthenticated: s,
        enabled: !o
    }));
    return h.useMemo( () => {
        const a = i?.message_cap ?? 0
          , l = i?.message_cap_window ?? 1
          , {text: c, type: u, value: d} = a3e(l)
          , f = i?.message_disclaimer ?? i2;
        if (!c || r)
            return {
                textareaDisclaimer: f.textarea,
                modelSwitcherDisclaimer: f["model-switcher"],
                modelSwitcherLimitShort: ""
            };
        if (!i || !l || !a)
            return {
                textareaDisclaimer: i2.textarea,
                modelSwitcherDisclaimer: i2["model-switcher"],
                modelSwitcherLimitShort: ""
            };
        let p = n.formatMessage(a2.shortLimitMinutes, {
            numerator: a,
            denominator: d
        });
        switch (u) {
        case "hour":
            p = n.formatMessage(a2.shortLimitHours, {
                numerator: a,
                denominator: d
            });
            break;
        case "day":
            p = n.formatMessage(a2.shortLimitDays, {
                numerator: a,
                denominator: d
            });
            break
        }
        return {
            textareaDisclaimer: f.textarea.replaceAll("%FORMATTED_TIME%", t).replaceAll("%NUMERATOR%", `${a}`).replaceAll("%DENOMINATOR%", c),
            modelSwitcherDisclaimer: f["model-switcher"].replaceAll("%FORMATTED_TIME%", t).replaceAll("%NUMERATOR%", `${a}`).replaceAll("%DENOMINATOR%", c),
            modelSwitcherLimitShort: p
        }
    }
    , [i, t, n, r])
}
const a2 = xt({
    shortLimitMinutes: {
        id: "modelCapMessaging.shortLimitMinutes",
        defaultMessage: "Limit {numerator, plural, =0 {# message} one {# message} other {# messages}} / {denominator, plural, =0 {# minute} one {# minute} other {# minutes}}"
    },
    shortLimitHours: {
        id: "modelCapMessaging.shortLimitHours",
        defaultMessage: "Limit {numerator, plural, =0 {# message} one {# message} other {# messages}} / {denominator, plural, =0 {# hour} one {# hour} other {# hours}}"
    },
    shortLimitDays: {
        id: "modelCapMessaging.shortLimitDays",
        defaultMessage: "Limit {numerator, plural, =0 {# message} one {# message} other {# messages}} / {denominator, plural, =0 {# day} one {# day} other {# days}}"
    }
});
var ei = (e => (e.ALPHA = "alpha",
e.DATA_CAMPAIGNS = "data_campaigns",
e.EXPERIMENTS = "experiments",
e.MAINLINE = "mainline",
e))(ei || {});
const BA = {
    code_interpreter_model: {
        name: "Advanced Data Analysis"
    },
    dalle_model: {
        name: "DALLÂ·E 3"
    }
}
  , c3e = e => kB(e, ({id: t}) => t.split(":").slice(0, 1).join(":"));
function yIe() {
    const e = lw()
      , {modelsData: t} = hw({
        isGizmo: !!e
    })
      , n = o3e()
      , {modelSwitcherDisclaimer: r} = l3e();
    return h.useMemo( () => {
        const s = [];
        if (!t)
            return s;
        const {categories: o, groups: i, models: a} = t;
        for (const l of o) {
            const {defaultModel: c, categoryId: u, label: d} = l
              , f = a.get(c);
            if (f) {
                const p = n === c
                  , m = p ? [] : u3e(l, a);
                s.push({
                    categoryId: u,
                    value: c,
                    name: d,
                    description: p ? r : f.description,
                    options: [lf(f, {
                        name: "Default"
                    }), ...m]
                })
            }
        }
        for (const l of i) {
            const {group: c, label: u, modelIds: d} = l
              , f = d[0]
              , p = [];
            for (const m of d) {
                const v = a.get(m);
                v && !v.tags.includes(x6.HIDDEN) && p.push(v)
            }
            if (c === "experiments") {
                const m = c3e(p)
                  , v = Object.entries(m).map( ([_,y]) => {
                    const b = _.split(":").slice(-1)[0];
                    return {
                        key: _,
                        value: b,
                        name: b,
                        options: y.map(S => {
                            const {title: C} = S;
                            return lf({
                                ...S,
                                title: C.replace(b, "")
                            })
                        }
                        )
                    }
                }
                );
                s.push({
                    categoryId: c,
                    value: f,
                    name: u,
                    options: v
                })
            } else
                s.push({
                    categoryId: c,
                    value: f,
                    name: u,
                    options: p.map(m => lf(m))
                })
        }
        return s
    }
    , [t, n, r])
}
function lf(e, t={}) {
    return {
        value: e.id,
        name: e.title,
        ...t
    }
}
function u3e(e, t) {
    const n = []
      , r = e.code_interpreter_model != null && t.get(e.code_interpreter_model);
    if (r) {
        const o = BA.code_interpreter_model;
        n.push(lf(r, {
            name: o.name
        }))
    }
    const s = e.dalle_model != null && t.get(e.dalle_model);
    if (s) {
        const o = BA.dalle_model;
        n.push(lf(s, {
            name: o.name
        }))
    }
    return n
}
function qA(e, t) {
    let n = e;
    if (e === t5.AUTO) {
        const o = t?.categories.filter( ({defaultModel: i}) => i !== t5.AUTO);
        o?.length === 1 && (n = o[0].defaultModel)
    }
    const r = t?.categories.find( ({defaultModel: o, supportedModels: i}) => o === n || n && i?.includes(n));
    if (r) {
        const {categoryId: o} = r;
        return {
            selectedCategory: o,
            modelLabel: r.shortLabel,
            fullModelLabel: r.label
        }
    }
    const s = t?.groups.find( ({modelIds: o}) => n && o.includes(n));
    if (s) {
        const {group: o, shortLabel: i, label: a} = s;
        return {
            selectedCategory: o,
            modelLabel: i,
            fullModelLabel: a
        }
    }
    return {
        selectedCategory: null,
        modelLabel: null,
        fullModelLabel: null
    }
}
function d3e(e, t, n, r) {
    const s = t ? e.formatMessage(gS.beta) : n ? e.formatMessage(gS.alpha) : r;
    if (s)
        return g.jsx(mw, {
            children: s
        })
}
function f3e({category: e, modelSwitcherDenialsBySlug: t, currentGizmoId: n, currentModelId: r, testId: s, preferredModelId: o, disabledByAdmin: i=!1}) {
    const a = gt()
      , {defaultModel: l, label: c, description: u, isBeta: d, isAlpha: f, modelBadge: p} = e
      , m = Mi(n ?? "")
      , v = ue()
      , _ = MCe(v, l)
      , y = g.jsxs(Xi, {
        value: l,
        currentModelId: r,
        modelSwitcherDenialsBySlug: t,
        secondary: u,
        deprecated: _,
        disabledByAdmin: i,
        isSelected: (!n || m) && r === l,
        testId: s,
        preferredModelId: o,
        children: [c, d3e(a, d, f, p)]
    }, l);
    return i ? g.jsx(ls, {
        label: a.formatMessage(gS.disabledByAdmin),
        children: y
    }) : y
}
function bIe({sections: e}) {
    return g.jsx(g.Fragment, {
        children: e.map( (t, n) => g.jsxs(Ne.Fragment, {
            children: [n !== 0 && e[n - 1]?.id !== "model-picker-title" ? g.jsx(Dt.Separator, {}) : null, t.content]
        }, t.id))
    })
}
function NV() {
    const {session: e} = Qf()
      , {data: t} = ML();
    return kL(e?.account?.planType ?? We.FREE) || t && RL(t) && !!1
}
function CIe(e, t, n, r, s) {
    const o = gt()
      , i = ue()
      , a = !yn(i)
      , {data: l} = ML()
      , c = _Ce()
      , u = !a && !!c && CCe(c) && l && !RL(l) && qf(i, "3709818006").get("enabled", !1)
      , {session: d} = Qf()
      , f = d?.user
      , p = f && wZ(f)
      , m = nCe(e)
      , v = m?.id ?? null
      , _ = Ble(e)
      , y = XCe(_);
    let {modelsData: b} = hw({
        isGizmo: !!_ && !y
    });
    const S = NV()
      , C = Dle(e)
      , w = kCe({
        clientThreadId: e
    })
      , x = b?.modelPickerVersion === 2
      , {gizmoModelsData: E} = rse({
        enabled: !!_
    })
      , T = !C
      , k = t.find( ({categoryId: te}) => te === ei.ALPHA)
      , A = t.find( ({categoryId: te}) => te === ei.DATA_CAMPAIGNS)
      , O = t.find( ({categoryId: te}) => te === ei.EXPERIMENTS)
      , M = t.find( ({categoryId: te}) => te === ei.MAINLINE)
      , [I,R] = h.useState("")
      , D = is( () => !0)
      , P = [k, A, O, M].reduce( (te, ve) => ve ? [...te, ...ve.options.map(Ue => ({
        ...Ue,
        badge: ve.categoryId
    }))] : te, [])
      , L = h.useMemo( () => I ? P.filter(te => te.name.toLowerCase().includes(I.toLowerCase())) : P, [P, I]);
    if (r && _ && b && E) {
        const te = JSON.parse(JSON.stringify(b));
        te.categories = te.categories.filter( ({defaultModel: ve}) => E.editor.models_list_with_custom_actions.includes(ve)),
        b = te
    }
    const N = !!k?.options.length
      , B = !!A?.options.length
      , H = !!O?.options.length
      , ye = !!M?.options.length
      , Ie = oo()
      , be = h.useCallback(te => {
        V.logEvent("Account Pay: Open Payment from Model Picker", {
            content: "gizmo-button"
        }),
        Pw(Ie, "Thread header dropdown", te)
    }
    , [Ie])
      , me = () => {
        ft.logEvent("chatgpt_model_switcher_plus_upgrade_button_clicked"),
        V.logEvent("Model Switcher Plus Upgrade Button Clicked"),
        a ? Au(i, {
            shouldOpenPaymentModalOnAuth: !0,
            callback: te => {
                V.logSignUpButtonClicked({
                    location: "Model switcher GPT-4 upsell",
                    provider: te
                })
            }
        }) : be()
    }
      , ge = () => {
        V.logEventWithStatsig("Model Switcher Go Upgrade Button Clicked", "chatgpt_model_switcher_go_upgrade_button_clicked"),
        a ? Au(i, {
            shouldOpenPaymentModalOnAuth: !0,
            callback: te => {
                V.logSignUpButtonClicked({
                    location: "Model switcher Go upsell",
                    provider: te
                })
            }
        }) : be()
    }
      , ce = () => {
        V.logEventWithStatsig("Model Switcher Team Upgrade Button Clicked", "chatgpt_model_switcher_team_upgrade_button_clicked"),
        be(Nw)
    }
      , Z = []
      , ne = Xe(i, "3315017149");
    b?.title && ne && Z.push({
        id: "model-picker-title",
        content: [g.jsx(Dt.Label, {
            className: "mb-0",
            children: b.title
        }, "model-picker-title")]
    });
    const _e = g.jsxs(Dt.Label, {
        className: "flex items-center",
        children: [g.jsx(de, {
            id: "coNCb7",
            defaultMessage: "Models"
        }), g.jsx(ls, {
            side: "right",
            className: "ms-1.5",
            delayDuration: 120,
            label: g.jsx(de, {
                id: "/vFWz/",
                defaultMessage: "Learn more"
            }),
            children: g.jsx("a", {
                href: "https://help.openai.com/en/articles/7864572-what-is-the-chatgpt-model-selector",
                target: "_blank",
                rel: "noreferrer",
                children: g.jsx(IA, {
                    className: "h-3.5 w-3.5 shrink-0"
                })
            })
        })]
    }, "models-section-header");
    if (a) {
        const te = {
            id: "modelSection",
            content: []
        };
        te.content.push(g.jsx(ZCe, {
            location: "model-switcher",
            statsig_login_event: "chatgpt_modelswitcher_login_button_clicked",
            statsig_signup_event: "chatgpt_modelswitcher_signup_button_clicked"
        }, "noAuthUpsell")),
        Z.push(te)
    } else if (!S && !_) {
        const te = {
            id: "modelSection",
            content: []
        };
        bae(i) ? te.content.push(g.jsx(Xi, {
            value: "",
            currentModelId: v,
            onClick: ge,
            modelSwitcherDenialsBySlug: w,
            isUpgradeUpsell: !0,
            icon: Z2e,
            secondary: g.jsx(de, {
                id: "vm2Wqf",
                defaultMessage: "Our smartest model & more"
            }),
            isSelected: !1,
            children: g.jsx(de, {
                id: "/d/+gD",
                defaultMessage: "ChatGPT Go"
            })
        }, "goUpgrade")) : u ? te.content.push(g.jsx(Xi, {
            value: "",
            currentModelId: v,
            onClick: ce,
            modelSwitcherDenialsBySlug: w,
            isUpgradeUpsell: !0,
            icon: Y2e,
            secondary: g.jsx(de, {
                id: "w0dB7n",
                defaultMessage: "Power your business with AI"
            }),
            isSelected: !1,
            children: g.jsx(de, {
                id: "K94mcH",
                defaultMessage: "ChatGPT Business"
            })
        }, "teamUpgrade")) : te.content.push(g.jsx(Xi, {
            value: "",
            currentModelId: v,
            onClick: me,
            modelSwitcherDenialsBySlug: w,
            isUpgradeUpsell: !0,
            icon: RA,
            secondary: g.jsx(de, {
                id: "bqTHri",
                defaultMessage: "Our smartest model & more"
            }),
            isSelected: !1,
            children: g.jsx(de, {
                id: "mzDzkX",
                defaultMessage: "ChatGPT Plus"
            })
        }, "plusUpgrade")),
        te.content.push(g.jsx(Xi, {
            value: of.AUTO,
            currentModelId: v,
            modelSwitcherDenialsBySlug: w,
            icon: J2e,
            secondary: g.jsx(de, {
                id: "n96qML",
                defaultMessage: "Great for everyday tasks"
            }),
            isSelected: !_ && v === of.AUTO,
            children: g.jsx(de, {
                id: "U9E7Rx",
                defaultMessage: "ChatGPT"
            })
        }, of.AUTO)),
        Z.push(te)
    } else {
        const te = {
            id: "modelSection",
            content: []
        };
        b?.categories.length && !x && te.content.push(_e),
        bn(i)?.isGo() && te.content.push(g.jsx(Xi, {
            value: "",
            currentModelId: v,
            onClick: me,
            modelSwitcherDenialsBySlug: w,
            isUpgradeUpsell: !0,
            icon: RA,
            secondary: g.jsx(de, {
                id: "bqTHri",
                defaultMessage: "Our smartest model & more"
            }),
            isSelected: !1,
            children: g.jsx(de, {
                id: "mzDzkX",
                defaultMessage: "ChatGPT Plus"
            })
        }, "plusUpgrade"));
        const ve = new Map;
        b?.categories.forEach(X => {
            const Te = g.jsx(f3e, {
                category: X,
                currentGizmoId: _,
                currentModelId: v,
                modelSwitcherDenialsBySlug: w,
                preferredModelId: s,
                testId: `model-switcher-${X.defaultModel}`,
                disabledByAdmin: X.disabledByAdmin
            }, X.categoryId);
            X.subcategory ? (ve.has(X.subcategory) || ve.set(X.subcategory, []),
            ve.get(X.subcategory)?.push(Te)) : te.content.push(Te)
        }
        );
        const Ue = b?.categories?.some(X => X.defaultModel === "gpt-5") ?? !1
          , re = b?.categories?.some(X => X.defaultModel === "gpt-5-pro") ?? !1;
        if (Ue && !re && !bn(i)?.isPro() && Xe(i, "3309244414")) {
            const X = g.jsx(h3e, {})
              , Te = b?.categories?.find(se => se.defaultModel === "gpt-5-thinking")?.subcategory;
            Te ? ve.get(Te)?.push(X) : te.content.push(X)
        }
        x ? ve.forEach( (X, Te) => {
            Te && te.content.push(g.jsx(Dt.Separator, {}, `${Te}-divider`));
            const se = b?.categories.find(F => F.subcategory === Te && F.defaultModel === m?.id)
              , {fullModelLabel: G} = qA(se?.defaultModel ?? "", b);
            te.content.push(g.jsxs(Dt.Sub, {
                children: [g.jsx(Dt.SubMenuTrigger, {
                    "data-testid": Te + "-submenu",
                    trailing: g.jsx("div", {
                        className: "truncate",
                        children: G
                    }),
                    children: Te
                }), g.jsx(Dt.Portal, {
                    children: g.jsx(Dt.SubContent, {
                        children: X
                    })
                })]
            }, Te))
        }
        ) : ve.forEach( (X, Te) => {
            const se = b?.categories.find(G => G.subcategory === Te && G.defaultModel === m?.id);
            te.content.push(g.jsxs(Dt.Sub, {
                children: [g.jsx(Dt.SubMenuTrigger, {
                    "data-testid": Te ? `${Te}-submenu` : void 0,
                    trailing: se && g.jsx("div", {
                        className: "truncate",
                        children: se.label
                    }),
                    children: Te
                }), g.jsx(Dt.Portal, {
                    children: g.jsx(Dt.SubContent, {
                        children: X
                    })
                })]
            }, Te))
        }
        );
        const W = b?.categories?.some(X => X.defaultModel === "gpt-4o" || X.defaultModel === "gpt-4.1") ?? !1;
        r && _ && te.content.push(g.jsx(Dt.Label, {
            className: "flex flex-col items-start gap-1",
            children: g.jsxs("span", {
                className: "flex items-center",
                children: [g.jsx(de, {
                    id: "Y96ci5",
                    defaultMessage: "Limited models for Custom Action GPTs"
                }), g.jsx(ls, {
                    side: "right",
                    className: "ms-1.5 cursor-pointer",
                    delayDuration: 0,
                    label: Ue && W ? g.jsx(de, {
                        id: "CicYT3",
                        defaultMessage: "GPTs with custom web actions can currently only use GPT-5, GPT-4o, and GPT-4.1."
                    }) : Ue ? g.jsx(de, {
                        id: "VfAyqX",
                        defaultMessage: "GPTs with custom web actions can currently only use GPT-5."
                    }) : g.jsx(de, {
                        id: "wDE3HX",
                        defaultMessage: "GPTs with custom web actions can currently only use GPT-4o and GPT-4.1. If your GPT has no custom actions it can use any model."
                    }),
                    children: g.jsx(IA, {
                        className: "h-4 w-4 shrink-0"
                    })
                })]
            })
        })),
        Z.push(te)
    }
    const ee = {
        id: "otherOptionsSection",
        content: []
    }
      , {selectedCategory: oe} = qA(v, b);
    return T && (N || B || H || ye ? ee.content.push(g.jsx("div", {
        className: "px-4 py-2",
        children: g.jsx(gV, {
            inputClassName: "w-full",
            onKeyDown: te => {
                te.stopPropagation()
            }
            ,
            onChange: te => {
                R(te.target.value)
            }
            ,
            value: I
        })
    })) : p && ee.content.push(g.jsxs(g.Fragment, {
        children: [g.jsx(Dt.Shimmer, {
            size: "long"
        }), g.jsx(Dt.Shimmer, {
            size: "long"
        }), g.jsx(Dt.Shimmer, {
            size: "long"
        }), g.jsx(Dt.Shimmer, {
            size: "long"
        })]
    })),
    I ? ee.content.push(g.jsxs("div", {
        className: "scrollbar-gutter-stable max-h-64 w-[min(320px,95vw)] overflow-y-scroll",
        children: [L.length === 0 && g.jsx(Dt.Item, {
            className: "w-full",
            children: o.formatMessage({
                id: "model-switcher.no-results",
                defaultMessage: "No results found"
            })
        }), L.map(te => {
            const {value: ve} = te;
            return "options"in te ? g.jsx(Kc, {
                currentModel: m,
                isSelected: v?.startsWith(ve),
                option: te,
                modelSwitcherDenialsBySlug: w,
                displayInFull_INTERNAL_USE_ONLY: !0,
                preferredModelId: s
            }, ve) : g.jsxs(Xi, {
                currentModelId: v,
                isSelected: v === ve,
                value: ve,
                modelSwitcherDenialsBySlug: w,
                displayInFull_INTERNAL_USE_ONLY: !0,
                preferredModelId: s,
                children: [te.name, te.badge && g.jsx(mw, {
                    children: te.badge
                })]
            }, ve)
        }
        )]
    })) : (N && ee.content.push(g.jsx(Kc, {
        isSelected: oe === ei.ALPHA,
        currentModel: m,
        option: k,
        modelSwitcherDenialsBySlug: w,
        displayInFull_INTERNAL_USE_ONLY: !0,
        preferredModelId: s
    }, k.value)),
    B && ee.content.push(g.jsx(Kc, {
        isSelected: oe === ei.DATA_CAMPAIGNS,
        currentModel: m,
        option: A,
        modelSwitcherDenialsBySlug: w,
        displayInFull_INTERNAL_USE_ONLY: !0,
        preferredModelId: s
    }, A.value)),
    H && ee.content.push(g.jsx(Kc, {
        currentModel: m,
        isSelected: oe === ei.EXPERIMENTS,
        option: O,
        modelSwitcherDenialsBySlug: w,
        displayInFull_INTERNAL_USE_ONLY: !0,
        preferredModelId: s
    }, O.value)),
    ye && ee.content.push(g.jsx(Kc, {
        isSelected: oe === ei.MAINLINE,
        currentModel: m,
        option: M,
        modelSwitcherDenialsBySlug: w,
        displayInFull_INTERNAL_USE_ONLY: !0,
        preferredModelId: s
    }, M.value)))),
    ee.content.length && D && Z.push(ee),
    n && Z.push({
        id: LA,
        content: [g.jsx(VCe, {}, LA)]
    }),
    Z
}
const h3e = () => {
    const e = oo()
      , t = ue()
      , n = Xe(t, "3315017149");
    let r = g.jsx(de, {
        id: "4myKt+",
        defaultMessage: "GPT-5 Pro"
    });
    return n && (r = g.jsx(de, {
        id: "fCVj6z",
        defaultMessage: "Pro"
    })),
    g.jsx(Dt.Item, {
        disabled: !0,
        label: r,
        secondary: g.jsx(de, {
            id: "BsApen",
            defaultMessage: "Research-grade intelligence"
        }),
        trailing: g.jsx(an, {
            color: "secondary",
            size: "small",
            onClick: () => {
                V.logEventWithStatsig("Model Switcher Pro Upgrade Button Clicked", "chatgpt_model_switcher_pro_upgrade_button_clicked"),
                V.logEvent("Account Pay: Open Payment from Model Picker", {
                    content: "gizmo-button"
                }),
                Pw(e, "Thread header dropdown")
            }
            ,
            children: g.jsx(de, {
                id: "aJndhk",
                defaultMessage: "Upgrade"
            })
        })
    })
}
  , gS = xt({
    alpha: {
        id: "o5FsPB",
        defaultMessage: "Alpha"
    },
    beta: {
        id: "XZwFET",
        defaultMessage: "Beta"
    },
    gpt35ShortExplainer: {
        defaultMessage: "Great for everyday tasks",
        id: "ModelSwitcher.gpt35ShortExplainer"
    },
    modelTunerSmartSelectionTitle: {
        id: "czjW8I",
        defaultMessage: "Dynamic"
    },
    modelTunerSmartSelectionExplainer: {
        id: "gp/YH1",
        defaultMessage: "Optimized for speed and intelligence"
    },
    gpt4ShortExplainer: {
        defaultMessage: "With DALLÂ·E, browsing and analysis",
        id: "ModelSwitcher.gpt4ShortExplainer"
    },
    gpt4ShortExplainerWithoutBrowse: {
        defaultMessage: "With DALLÂ·E and analysis",
        id: "ModelSwitcher.gpt4ShortExplainerWithoutBrowse"
    },
    gpt4UpsellExplainer: {
        id: "ModelSwitcher.gpt4Upsell",
        defaultMessage: "Our smartest and most capable model. Includes DALLÂ·E, browsing and more."
    },
    userUpgrade: {
        id: "ModelSwithcer.upgradeButton",
        defaultMessage: "Upgrade to Plus"
    },
    userUpgradeSignup: {
        id: "ModelSwitcher.signupUpgradeButton",
        defaultMessage: "Sign up for ChatGPT Plus"
    },
    temporaryChat: {
        id: "ModelSwitcher.temporaryChat",
        defaultMessage: "Temporary chat"
    },
    shareChat: {
        id: "ModelSwitcher.shareChat",
        defaultMessage: "Share chat"
    },
    disabledByAdmin: {
        id: "XoQ6cH",
        defaultMessage: "Disabled by Admin"
    }
});
function p3e() {
    const e = ue()
      , t = V2e()
      , {data: n, isSuccess: r, isLoading: s} = lL()
      , {userIsInSearchHoldoutWithWebDisabled: o} = z2e()
      , i = NV()
      , a = Xe(e, "1627380539")
      , {showModelsInPlusMenu: l} = W2e();
    return {
        systemHints: h.useMemo( () => {
            if (s)
                return;
            if (!n || !r)
                return [];
            const u = bn(e)?.planType;
            return n.sort(m3e(u)).filter(d => !(d.systemHint === xe.Think && i && (!a || l) || d.systemHint === xe.Search && o || d.systemHint === xe.Slurm && !t))
        }
        , [n, s, r, e, o, t, i, a, l]),
        isLoading: s
    }
}
function m3e(e) {
    const t = g3e(e);
    return (n, r) => {
        const s = t.indexOf(n.systemHint)
          , o = t.indexOf(r.systemHint)
          , i = s === -1 ? Number.MAX_SAFE_INTEGER : s
          , a = o === -1 ? Number.MAX_SAFE_INTEGER : o;
        return i === a ? 0 : i > a ? 1 : -1
    }
}
function g3e(e) {
    switch (e) {
    case void 0:
    case We.FREE:
    case We.EDUCATION_CBP:
    case We.DEPRECATED_EDU:
        return [xe.Tatertot, xe.PictureV2, xe.Picture, xe.Think, xe.Agent, xe.Research, xe.ContextualAnswers, xe.Slurm, xe.Search, xe.Canvas, xe.Video];
    case We.GO:
    case We.PLUS:
    case We.PRO:
        return [xe.Agent, xe.Research, xe.PictureV2, xe.Picture, xe.Think, xe.ContextualAnswers, xe.Slurm, xe.Tatertot, xe.Search, xe.Canvas, xe.Video];
    case We.ENTERPRISE_CBP:
    case We.SELF_SERVE_BUSINESS:
    case We.QUORUM:
    case We.DEPRECATED_ENTERPRISE:
        return [xe.Agent, xe.ContextualAnswers, xe.Slurm, xe.Research, xe.Think, xe.PictureV2, xe.Picture, xe.Search, xe.Canvas, xe.Video]
    }
}
const {useDebugValue: v3e} = Ne
  , {useSyncExternalStoreWithSelector: _3e} = jP
  , y3e = e => e;
function PV(e, t=y3e, n) {
    const r = _3e(e.subscribe, e.getState, e.getServerState || e.getInitialState, t, n);
    return v3e(r),
    r
}
const GA = (e, t) => {
    const n = Ei(e)
      , r = (s, o=t) => PV(n, s, o);
    return Object.assign(r, n),
    r
}
  , SIe = (e, t) => e ? GA(e, t) : GA;
let b3e = 0;
const DV = h.createContext(null);
function C3e({children: e}) {
    const [t] = h.useState( () => ({}));
    return h.createElement(DV.Provider, {
        value: t
    }, e)
}
function kh(e) {
    if (e === void 0)
        return kh;
    const t = typeof e == "function" ? e : () => e;
    let n;
    const r = h.createContext(null);
    return class {
        static useState(o=S3e, i) {
            return PV(this.useStore(), o, i)
        }
        static useStore() {
            return this.useStoreWithInit()
        }
        static useStoreWithInit(...o) {
            const i = h.useContext(r)
              , a = h.useContext(DV);
            if (i)
                return i;
            const l = this.name ?? "Store";
            if (!a)
                throw new Error(`No StoreScope found. Must use ${l} within a <StoreScopeProvider> or <${l}.Provider>.`);
            if (n || (n = `${l}:${b3e++}`),
            n in a)
                return a[n];
            if (typeof t == "function" && t.length > 0 && o.length === 0)
                throw new Error(`Not initialized. First call ${l}.useStoreWithInit(value) or <${l}.Provider store={() => new ${l}(value)}>`);
            return a[n] = new this(...o)
        }
        static Provider({store: o, children: i}) {
            const [a] = h.useState(o);
            return h.createElement(r.Provider, {
                value: a
            }, i)
        }
        constructor(o) {
            const i = t(o);
            Object.assign(this, Ei(typeof i == "function" ? i : () => i))
        }
    }
}
function S3e(e) {
    return e
}
const Ao = e => {
    const t = {
        turn_index: e.turnIndex?.toString(),
        thread_id: e.threadId,
        conversation_id: e.clientThreadId ? to(e.clientThreadId) : void 0,
        message_id: e?.messageId
    };
    return Object.fromEntries(Object.entries(t).filter( ([n,r]) => r !== void 0))
}
;
function w3e(e, t=1e3, n=100) {
    document.activeElement !== e && e.focus();
    const r = Date.now()
      , s = setInterval( () => {
        document.activeElement !== e && e.focus(),
        Date.now() - r >= t && clearInterval(s)
    }
    , n)
}
class Wl extends kh()( ({initialHint: t=null, locked: n=!1}) => ({
    locked: n,
    activeSystemHintType: t,
    activeSystemHintTrigger: void 0
})) {
    getActiveSystemHintType = () => this.getState().activeSystemHintType;
    setActiveSystemHint(t, n) {
        const {locked: r, activeSystemHintType: s} = this.getState();
        r && n?.locked === void 0 || n?.ifPrevSystemHint !== void 0 && n.ifPrevSystemHint !== s || (T3e(s, t, n?.analyticsMetadata, n?.triggerSource),
        this.setState({
            locked: n?.locked ?? r,
            activeSystemHintType: t,
            activeSystemHintTrigger: t ? n?.triggerSource : void 0
        }))
    }
    getPersistedSystemHintTrigger = t => {
        if (!this.getState().locked && this.getState().activeSystemHintType === t)
            return this.getState().activeSystemHintTrigger
    }
}
const EIe = () => Wl.useState(e => e.activeSystemHintType);
function E3e(e, t, n, r) {
    e.setActiveSystemHint(n, r),
    FL() && n && w3e(Nf(t).dom)
}
const x3e = () => {
    const e = Wl.useStore()
      , t = lhe();
    return h.useCallback( (n, r) => E3e(e, t, n, r), [t, e])
}
;
function VA({persistSearchMode: e, persistTatertotMode: t, persistAgentMode: n, forcedSystemHintType: r, completionMetadataHints: s, systemHintsFromSearchParams: o}) {
    return r || (o.length > 0 ? o[0] : e ? xe.Search : t ? xe.Tatertot : n ? xe.Agent : s ? s[0] : null)
}
function T3e(e, t, n, r) {
    t ? (MO(t, Q5.Enable, Ao(n ?? {})),
    t === xe.Agent && q.addAction("agent.hint.enabled", {
        client_thread_id: String(n?.clientThreadId ?? "")
    })) : e && (MO(e, Q5.Disable, Ao(n ?? {})),
    e === xe.Agent && q.addAction("agent.hint.disabled", {
        client_thread_id: String(n?.clientThreadId ?? "")
    })),
    t === xe.Search ? V.logEventWithStatsig("Search Mode Engaged", "search_mode_engaged", {
        ...Ao(n ?? {}),
        triggerSource: r
    }) : t == null && e === xe.Search && V.logEventWithStatsig("Search Mode Disabled", "search_mode_disabled", Ao(n ?? {}))
}
function xIe({children: e, clientThreadId: t, forcedSystemHintType: n}) {
    const r = ue()
      , [s] = Eg()
      , {systemHints: o} = p3e()
      , i = bV(t)
      , a = rCe(i, LD.Search)
      , l = Ai(t, Ce.getLastMessageSystemHints)
      , c = qf(r, "269676899", {
        disableExposureLog: !0
    })
      , u = c.get("clear_all", !1)
      , d = c.get("skip_search", !1)
      , f = u && !d
      , p = l.includes(xe.Search) && a && !f
      , v = sge() && l.includes(xe.Tatertot)
      , y = $he() && l.includes(xe.Agent)
      , b = h.useMemo( () => l.find(E => o?.find(T => T.systemHint === E)?.persistBetweenMessages), [l, o])
      , S = is( () => KB(r)()[t])
      , [C] = h.useState( () => {
        const E = X5(s)
          , T = VA({
            persistSearchMode: p,
            persistTatertotMode: v,
            persistAgentMode: y,
            forcedSystemHintType: n,
            completionMetadataHints: S,
            systemHintsFromSearchParams: E
        });
        return new Wl({
            initialHint: T,
            locked: n != null
        })
    }
    )
      , w = h.useRef(t);
    h.useEffect( () => {
        if (w.current !== t) {
            C.setActiveSystemHint(null);
            const T = X5(s)
              , k = VA({
                persistSearchMode: p,
                persistTatertotMode: v,
                persistAgentMode: y,
                forcedSystemHintType: n,
                completionMetadataHints: S,
                systemHintsFromSearchParams: T
            });
            C.setActiveSystemHint(k, {
                locked: n != null
            }),
            w.current = t;
            return
        }
        const E = C.getActiveSystemHintType();
        p && E !== xe.Search ? C.setActiveSystemHint(xe.Search, {
            analyticsMetadata: {
                clientThreadId: t
            }
        }) : v && E !== xe.Tatertot ? C.setActiveSystemHint(xe.Tatertot, {
            analyticsMetadata: {
                clientThreadId: t
            }
        }) : b && C.setActiveSystemHint(b, {
            analyticsMetadata: {
                clientThreadId: t
            }
        })
    }
    , [t, S, n, p, v, y, C, b, s]);
    const x = h.useRef(n);
    return h.useEffect( () => {
        if (o == null || o.length === 0) {
            x.current = n;
            return
        }
        const E = n != null ? o.find(T => T.systemHint === n) : void 0;
        n != null && E != null ? C.setActiveSystemHint(n, {
            locked: !0
        }) : C.getState().locked && C.setActiveSystemHint(null, {
            locked: !1
        }),
        x.current = n
    }
    , [o, C, n]),
    g.jsx(Wl.Provider, {
        store: C,
        children: e
    })
}
function k3e({children: e}) {
    const [t] = h.useState( () => new Wl({
        initialHint: null,
        locked: !0
    }));
    return g.jsx(Wl.Provider, {
        store: t,
        children: e
    })
}
class O3e {
    #e;
    #t = t => (this.#e || (this.#e = he( () => import("./h3v66mipg7khna1m.js").then(n => n.aB), []).then(n => n?.datadogLogs)),
    this.#e.then(n => n && t(n)));
    init(t) {
        this.#t(n => n.init(t))
    }
    setGlobalContextProperty(t, n) {
        this.#t(r => r.setGlobalContextProperty(t, n))
    }
    setUser(t) {
        this.#t(n => n.setUser(t))
    }
    get logger() {
        return {
            setHandler: t => {
                this.#t(n => n.logger.setHandler(t))
            }
        }
    }
    createLogger(t, n) {
        return new A3e(this.#t,t,n)
    }
}
class A3e {
    #e;
    constructor(t, n, r) {
        this.#e = t(s => s.createLogger(n, r))
    }
    #t = t => this.#e.then(n => n && t(n));
    ok(t, n, r) {
        this.#t(s => s.ok(t, n, r))
    }
    debug(t, n, r) {
        this.#t(s => s.debug(t, n, r))
    }
    info(t, n, r) {
        this.#t(s => s.info(t, n, r))
    }
    notice(t, n, r) {
        this.#t(s => s.notice(t, n, r))
    }
    warn(t, n, r) {
        this.#t(s => s.warn(t, n, r))
    }
    error(t, n, r) {
        this.#t(s => s.error(t, n, r))
    }
    critical(t, n, r) {
        this.#t(s => s.critical(t, n, r))
    }
    alert(t, n, r) {
        this.#t(s => s.alert(t, n, r))
    }
    emerg(t, n, r) {
        this.#t(s => s.emerg(t, n, r))
    }
}
const Lc = new O3e
  , M3e = "datadoghq.com"
  , I3e = "pub1f79f8ac903a5872ae5f53026d20a77c";
class R3e {
    initialize() {
        const t = Tg ? qn?.getTelemetryConfig?.() : void 0
          , n = t !== void 0 ? t.datadogService : xN();
        Lc.init({
            clientToken: I3e,
            site: M3e,
            service: n,
            env: "prod",
            version: "9d358314d30a26d59ec2f2390d079c86e2c0018f",
            sessionSampleRate: 100,
            forwardErrorsToLogs: !1,
            beforeSend: r => (r.view.url = Kd(r.view.url),
            r.http && r.http.url && (r.http.url = Kd(r.http.url)),
            !0)
        }),
        Lc.setGlobalContextProperty("track", "stable"),
        Lc.setGlobalContextProperty("is_electron_desktop_app", t !== void 0),
        Lc.logger.setHandler(["http"])
    }
    setUser(t, n) {
        const r = {
            user_id: t.id,
            account_plan_type: n?.planType ?? "none",
            workspace_id: n?.id
        };
        Lc.setUser(r)
    }
    createLogger(t, n="info", r="http", s) {
        return Lc.createLogger(t, {
            level: n,
            handler: r,
            context: s
        })
    }
}
const vS = new R3e;
function LV(e) {
    const t = new URL(window.location.href);
    if (!t.searchParams.has(e))
        return;
    t.searchParams.delete(e);
    const n = t.pathname + t.search + t.hash;
    history.replaceState(null, "", n)
}
let HA = !1;
if (EN()) {
    const e = function() {
        return window.location.pathname !== "/search" ? void 0 : {
            sessionSampleRate: 100,
            traceSampleRate: 100
        }
    }();
    q.initialize(e)
}
function N3e(e, t) {
    if (t) {
        const n = ze.getCookie(Be.Workspace)
          , r = n === di ? void 0 : n
          , s = t.structure === Dr.WORKSPACE ? t.id : void 0;
        r !== s && q.addAction("bootstrap_client.account_cookie_mismatch", {
            accountCookieValue: n,
            lightAccount: t
        })
    }
    e.fetchQuery(Ci()).then(n => {
        const r = u1(n)
          , s = ze.getCookie(Be.Workspace)
          , o = Hte(r, n.accountItems);
        s !== o && l5(o),
        r && t && (r.id !== t.id || r.planType !== t.planType || r.isDelinquent !== t.isDelinquent || r.gracePeriodId !== t.gracePeriodId) && L6()
    }
    ).catch(n => {
        if (!(n instanceof _t && n.isClientError()))
            return q.addAction("bootstrap_client.fetchAccounts.error", {
                error: n
            }),
            null
    }
    )
}
function P3e(e, t, n) {
    if (HA)
        return;
    HA = !0;
    const r = us(e);
    if (r.checkGate("4011688770") && he( () => import("./og2klt9618t4jfpv.js"), __vite__mapDeps([18, 1])).then(s => s?.initOpenTelemetry()),
    r.on("gate_evaluation", ({gate: s}) => {
        q.addFeatureFlagEvaluation(s.name, s.value)
    }
    ),
    LV("refresh_account"),
    window.addEventListener("vite:preloadError", s => {
        s.preventDefault(),
        q.addAction("vite:preloadError", {
            payload: s.payload
        })
    }
    ),
    xi(),
    Ure(),
    q.addTiming("chatgpt.web.bootstrapClient"),
    q.addAction("bootstrap_client.start"),
    window.__oai_SSR_HTML ? q.addFirstTiming("composer.html", window.__oai_SSR_HTML) : window.__oai_logHTML = () => {
        q.addFirstTiming("composer.html")
    }
    ,
    window.__oai_SSR_TTI ? q.addFirstTiming("composer.visible", window.__oai_SSR_TTI) : window.__oai_logTTI = () => {
        q.addFirstTiming("composer.visible")
    }
    ,
    EN() && vS.initialize(),
    t.authStatus === fr.LoggedIn) {
        const s = t.user
          , o = t.session?.account;
        q.addAction("bootstrap_client.has_session_user"),
        N3e(n, o),
        gee(s, o, t.intercomHash),
        q.setUser(s, o),
        vS.setUser(s, o),
        V.initialize({
            userInfo: {
                currentAccount: o ?? null,
                sessionUser: s
            }
        }),
        q.addAction("bootstrap_client.success.is_authenticated", {
            hasCurrentAccount: !0
        })
    } else
        q.addAction("bootstrap_client.does_not_have_session_user"),
        V.initialize(),
        q.addAction("bootstrap_client.success.is_not_authenticated");
    fetch(`${lt}/edge`).catch( () => {}
    )
}
function D3e({root: e, autoFocus: t=!1}) {
    if (!e)
        return null;
    const n = ["a[href]:not([data-skip-to-content])", "area[href]", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])", "button:not([disabled])", "iframe", "object", "embed", '[tabindex]:not([tabindex="-1"])', "[contenteditable]"].join(", ")
      , r = Array.from(e.querySelectorAll(n));
    let s = null;
    for (const o of r)
        if (o.offsetWidth > 0 && o.offsetHeight > 0) {
            s = o;
            break
        }
    return t && s?.focus(),
    s
}
const L3e = () => {
    const e = ue();
    return {
        country: un(e).userCountry
    }
}
;
function zA(e) {
    return e != null && e in aW
}
const l2 = 60 * 60 * 24 * 30 * 6
  , FV = e => {
    ze.setBooleanCookie(Be.ConsentAnalytics, e.consent_analytics, {
        maxAge: l2,
        domain: k0
    }),
    ze.setBooleanCookie(Be.ConsentMarketing, e.consent_marketing, {
        maxAge: l2,
        domain: k0
    }),
    ze.setBooleanCookie(Be.AllowNonessential, e.consent_analytics && e.consent_marketing, {
        maxAge: l2,
        domain: k0
    }),
    q.addAction("update-cookie-consent.cookie.success")
}
;
async function jV(e) {
    if (FV(e),
    un(Ot()).authStatus === fr.LoggedIn)
        try {
            await ie.safePost("/user_granular_consent", {
                authOption: Qt.Required,
                requestBody: {
                    granular_consent: {
                        analytics: e.consent_analytics,
                        marketing: e.consent_marketing
                    }
                }
            }),
            q.addAction("update-cookie-consent.backend.success")
        } catch (n) {
            q.addError(n)
        }
}
const G4 = so({
    queryKey: ["cookie-consent"],
    queryFn: async () => {
        const {isUserInPioneerHR: e, userCountry: t} = un(io(Ot()));
        if (!e) {
            const o = ze.getBooleanCookie(Be.ConsentAnalytics)
              , i = ze.getBooleanCookie(Be.ConsentMarketing);
            return o != null || i != null ? {
                consent_analytics: o ?? !1,
                consent_marketing: i ?? !1,
                is_consent_required: !0
            } : (q.addAction("get-cookie-consent.use-anonymous-default.consent-not-required", {
                country: t
            }),
            {
                consent_analytics: !0,
                consent_marketing: !0,
                is_consent_required: !1
            })
        }
        if (t != null && !zA(t))
            return q.addAction("get-cookie-consent.use-anonymous-default.consent-not-required", {
                country: t
            }),
            {
                consent_analytics: !0,
                consent_marketing: !0,
                is_consent_required: !1
            };
        if (zA(t) && !e)
            return q.addAction("get-cookie-consent.use-anonymous-default.consent-required-essential-only", {
                country: t
            }),
            {
                consent_analytics: !1,
                consent_marketing: !1,
                is_consent_required: !0
            };
        let n;
        try {
            const o = await ie.safeGet("/user_granular_consent", {
                authOption: Qt.Required
            });
            n = {
                consent_analytics: o.granular_consent?.analytics ?? null,
                consent_marketing: o.granular_consent?.marketing ?? null,
                is_consent_required: o.is_consent_required
            },
            q.addAction("get-cookie-consent.use-authenticated", {
                country: t
            })
        } catch (o) {
            o instanceof Qg || q.addError(o, {
                country: t
            }),
            n = {
                consent_analytics: null,
                consent_marketing: null,
                is_consent_required: !0
            }
        }
        const r = ze.getBooleanCookie(Be.ConsentAnalytics)
          , s = ze.getBooleanCookie(Be.ConsentMarketing);
        return n.consent_analytics != null && n.consent_marketing != null && (r !== n.consent_analytics || s !== n.consent_marketing) ? (FV({
            consent_analytics: n.consent_analytics,
            consent_marketing: n.consent_marketing
        }),
        q.addAction("get-cookie-consent.update-cookie-consent-cookie", {
            country: t
        })) : r !== void 0 && s !== void 0 && n.is_consent_required && n.consent_analytics == null && n.consent_marketing == null && (jV({
            consent_analytics: r ?? !1,
            consent_marketing: s ?? !1
        }),
        q.addAction("get-cookie-consent.update-cookie-consent-backend", {
            country: t
        }),
        n = {
            ...n,
            consent_analytics: r ?? !1,
            consent_marketing: s ?? !1
        }),
        n
    }
})
  , TIe = e => {
    const {country: t} = L3e()
      , n = Lr();
    return nr({
        ...e,
        mutationFn: r => jV(r),
        onSuccess: (r, s, o) => {
            e?.onSuccess?.(r, s, o),
            n.setQueryData(G4.queryKey, i => {
                if (!i) {
                    q.addError(new Error("Cookie consent query data is undefined during mutation"));
                    return
                }
                return {
                    ...i,
                    consent_analytics: s.consent_analytics,
                    consent_marketing: s.consent_marketing
                }
            }
            )
        }
        ,
        onError: (r, s, o) => {
            e?.onError?.(r, s, o),
            q.addError(r, {
                country: t
            })
        }
    })
}
;
class c2 extends kh()( () => ({
    cookieConsentBannerClosed: !1,
    cookieConsentBannerIgnored: ze.getBooleanCookie(Be.CookieBannerIgnored) ?? !1,
    onCloseSideEffect: () => {}
    ,
    manuallySetVisibility: !1
})) {
    closeCookieConsentBanner = t => {
        const n = {
            cookieConsentBannerClosed: !0,
            ...t ? {
                cookieConsentBannerIgnored: !0
            } : {}
        };
        this.setState(n),
        t && ze.setBooleanCookie(Be.CookieBannerIgnored, !0)
    }
    ;
    setOnCloseSideEffect = t => {
        this.setState(n => ({
            ...n,
            onCloseSideEffect: t
        }))
    }
    ;
    setManualVisibility = t => {
        this.setState(n => ({
            ...n,
            manuallySetVisibility: t
        }))
    }
    ;
    static useWasClosed = () => this.useState(t => t.cookieConsentBannerClosed);
    static useWasIgnored = () => this.useState(t => t.cookieConsentBannerIgnored);
    static useOnCloseSideEffect = () => this.useState(t => t.onCloseSideEffect);
    static useManuallySetVisibility = () => this.useState(t => t.manuallySetVisibility)
}
const kIe = () => {
    const e = c2.useStore()
      , {isUnauthenticated: t, isLoading: n} = ah()
      , {data: r, isLoading: s} = At(G4)
      , o = c2.useWasClosed()
      , i = c2.useWasIgnored()
      , a = ze.getCookie(Be.CookieBannerShownPath)
      , l = a === window.location.pathname
      , c = n || s;
    return {
        shouldShowCookieBanner: (!c && t && !(o || i) && (!a || l) && r?.is_consent_required && r?.consent_analytics == null && r?.consent_marketing == null) ?? !1,
        isCookieConsentBannerLoading: c,
        closeCookieConsentBanner: e.closeCookieConsentBanner,
        ignoreCookieConsentBanner: () => e.closeCookieConsentBanner(!0)
    }
}
;
var Yc = (e => (e.Gclid = "gclid",
e.Fbclid = "fbclid",
e.Rdtcid = "rdt_cid",
e.Tiktokclid = "ttclid",
e.Liclid = "li_fat_id",
e))(Yc || {});
function OIe(e) {
    switch (e) {
    case "gclid":
        return ze.getMarketingCookie(Be.Gclid);
    case "fbclid":
        return ze.getMarketingCookie(Be.Fbclid);
    case "rdt_cid":
        return ze.getMarketingCookie(Be.Rdtcid);
    case "ttclid":
        return ze.getMarketingCookie(Be.Tiktokclid);
    case "li_fat_id":
        return ze.getMarketingCookie(Be.Liclid)
    }
}
function F3e(e) {
    switch (e) {
    case "gclid":
        return Be.Gclid;
    case "fbclid":
        return Be.Fbclid;
    case "rdt_cid":
        return Be.Rdtcid;
    case "ttclid":
        return Be.Tiktokclid;
    case "li_fat_id":
        return Be.Liclid
    }
}
function j3e({searchParams: e, clidLifetimeSeconds: t=24 * 60 * 60, eligibleExplorers: n}) {
    for (const r of n) {
        if (e.get(r) == null)
            continue;
        const s = F3e(r);
        ze.setMarketingCookie(s, e.get(r), {
            path: "/",
            maxAge: t
        })
    }
}
let UV = !1;
const U3e = e => {
    const t = un(e);
    if (!t.eligibleMarketing)
        return;
    const n = new URLSearchParams(window.location.search);
    j3e({
        searchParams: n,
        eligibleExplorers: [...t.eligibleMarketing.isUserEligibleForPioneer ? [Yc.Gclid] : [], ...t.eligibleMarketing.isUserEligibleForMaverick ? [Yc.Fbclid] : [], ...t.eligibleMarketing.isUserEligibleForTrailBlazer ? [Yc.Rdtcid] : [], ...t.eligibleMarketing.isUserEligibleForStratos ? [Yc.Tiktokclid] : [], ...t.eligibleMarketing.isUserEligibleForSeeker ? [Yc.Liclid] : []]
    }),
    UV = !0
}
  , B3e = (e, t) => {
    const n = un(e).userCountry;
    new RS(t,G4).subscribe(s => {
        if (s.isPending)
            return;
        const o = s.data;
        if (!o)
            return;
        (o.is_consent_required ? o.consent_marketing : !0) ? (ze.setAllowMarketingCookies_CLIENT_ONLY(!0),
        q.addAction("marketing-tracking.non-essential-cookies.allowed", {
            country: n
        }),
        UV || (U3e(e),
        q.addAction("marketing-tracking.non-essential-cookies.marketing-tracking-functions-run", {
            country: n
        }))) : (ze.setAllowMarketingCookies_CLIENT_ONLY(!1),
        q.addAction("marketing-tracking.non-essential-cookies.disallowed", {
            country: n
        }))
    }
    )
}
;
async function q3e() {
    if (!("container"in document.documentElement.style)) {
        performance.mark("polyfill.containerQuery.start");
        try {
            await he( () => import("./ju44vdme8sg2h8v1.js"), [])
        } catch (e) {
            return q.addError(new Error("Error loading polyfill: containerQuery",{
                cause: e
            })),
            Promise.reject(e)
        }
        performance.mark("polyfill.containerQuery.end"),
        performance.measure("polyfill.containerQuery", "polyfill.containerQuery.start", "polyfill.containerQuery.end")
    }
}
async function G3e() {
    if (!Array.prototype.findLast)
        try {
            await he( () => import("./d9i89504oytx9wvs.js"), __vite__mapDeps([19, 1]))
        } catch (e) {
            return q.addError(new Error("Error loading polyfill: findLast",{
                cause: e
            })),
            Promise.reject(e)
        }
}
async function V3e() {
    if (!CSS.supports("animation-timeline: --works") || window.ViewTimeline === void 0) {
        performance.mark("polyfill.scrollTimeline.start");
        try {
            await he( () => import("./mv7t0tsdviudgwx9.js"), [])
        } catch (e) {
            return q.addAction("Error loading polyfill: scrollTimeline", {
                cause: e
            }),
            Promise.reject(e)
        }
        performance.mark("polyfill.scrollTimeline.end"),
        performance.measure("polyfill.scrollTimeline", "polyfill.scrollTimeline.start", "polyfill.scrollTimeline.end")
    }
}
var $A = {}, WA = {}, Md, KA;
function Ln() {
    if (KA)
        return Md;
    KA = 1;
    var e = function(t) {
        return t && t.Math === Math && t
    };
    return Md = e(typeof globalThis == "object" && globalThis) || e(typeof window == "object" && window) || e(typeof self == "object" && self) || e(typeof Xc == "object" && Xc) || e(typeof Md == "object" && Md) || function() {
        return this
    }() || Function("return this")(),
    Md
}
var u2 = {}, d2, YA;
function Vo() {
    return YA || (YA = 1,
    d2 = function(e) {
        try {
            return !!e()
        } catch {
            return !0
        }
    }
    ),
    d2
}
var f2, ZA;
function Ii() {
    if (ZA)
        return f2;
    ZA = 1;
    var e = Vo();
    return f2 = !e(function() {
        return Object.defineProperty({}, 1, {
            get: function() {
                return 7
            }
        })[1] !== 7
    }),
    f2
}
var h2, JA;
function X1() {
    if (JA)
        return h2;
    JA = 1;
    var e = Vo();
    return h2 = !e(function() {
        var t = function() {}
        .bind();
        return typeof t != "function" || t.hasOwnProperty("prototype")
    }),
    h2
}
var p2, XA;
function Ho() {
    if (XA)
        return p2;
    XA = 1;
    var e = X1()
      , t = Function.prototype.call;
    return p2 = e ? t.bind(t) : function() {
        return t.apply(t, arguments)
    }
    ,
    p2
}
var m2 = {}, QA;
function H3e() {
    if (QA)
        return m2;
    QA = 1;
    var e = {}.propertyIsEnumerable
      , t = Object.getOwnPropertyDescriptor
      , n = t && !e.call({
        1: 2
    }, 1);
    return m2.f = n ? function(s) {
        var o = t(this, s);
        return !!o && o.enumerable
    }
    : e,
    m2
}
var g2, eM;
function BV() {
    return eM || (eM = 1,
    g2 = function(e, t) {
        return {
            enumerable: !(e & 1),
            configurable: !(e & 2),
            writable: !(e & 4),
            value: t
        }
    }
    ),
    g2
}
var v2, tM;
function fs() {
    if (tM)
        return v2;
    tM = 1;
    var e = X1()
      , t = Function.prototype
      , n = t.call
      , r = e && t.bind.bind(n, n);
    return v2 = e ? r : function(s) {
        return function() {
            return n.apply(s, arguments)
        }
    }
    ,
    v2
}
var _2, nM;
function Q1() {
    if (nM)
        return _2;
    nM = 1;
    var e = fs()
      , t = e({}.toString)
      , n = e("".slice);
    return _2 = function(r) {
        return n(t(r), 8, -1)
    }
    ,
    _2
}
var y2, rM;
function z3e() {
    if (rM)
        return y2;
    rM = 1;
    var e = fs()
      , t = Vo()
      , n = Q1()
      , r = Object
      , s = e("".split);
    return y2 = t(function() {
        return !r("z").propertyIsEnumerable(0)
    }) ? function(o) {
        return n(o) === "String" ? s(o, "") : r(o)
    }
    : r,
    y2
}
var b2, sM;
function e0() {
    return sM || (sM = 1,
    b2 = function(e) {
        return e == null
    }
    ),
    b2
}
var C2, oM;
function V4() {
    if (oM)
        return C2;
    oM = 1;
    var e = e0()
      , t = TypeError;
    return C2 = function(n) {
        if (e(n))
            throw new t("Can't call method on " + n);
        return n
    }
    ,
    C2
}
var S2, iM;
function H4() {
    if (iM)
        return S2;
    iM = 1;
    var e = z3e()
      , t = V4();
    return S2 = function(n) {
        return e(t(n))
    }
    ,
    S2
}
var w2, aM;
function ar() {
    if (aM)
        return w2;
    aM = 1;
    var e = typeof document == "object" && document.all;
    return w2 = typeof e > "u" && e !== void 0 ? function(t) {
        return typeof t == "function" || t === e
    }
    : function(t) {
        return typeof t == "function"
    }
    ,
    w2
}
var E2, lM;
function Ri() {
    if (lM)
        return E2;
    lM = 1;
    var e = ar();
    return E2 = function(t) {
        return typeof t == "object" ? t !== null : e(t)
    }
    ,
    E2
}
var x2, cM;
function ac() {
    if (cM)
        return x2;
    cM = 1;
    var e = Ln()
      , t = ar()
      , n = function(r) {
        return t(r) ? r : void 0
    };
    return x2 = function(r, s) {
        return arguments.length < 2 ? n(e[r]) : e[r] && e[r][s]
    }
    ,
    x2
}
var T2, uM;
function z4() {
    if (uM)
        return T2;
    uM = 1;
    var e = fs();
    return T2 = e({}.isPrototypeOf),
    T2
}
var k2, dM;
function Oh() {
    if (dM)
        return k2;
    dM = 1;
    var e = Ln()
      , t = e.navigator
      , n = t && t.userAgent;
    return k2 = n ? String(n) : "",
    k2
}
var O2, fM;
function qV() {
    if (fM)
        return O2;
    fM = 1;
    var e = Ln(), t = Oh(), n = e.process, r = e.Deno, s = n && n.versions || r && r.version, o = s && s.v8, i, a;
    return o && (i = o.split("."),
    a = i[0] > 0 && i[0] < 4 ? 1 : +(i[0] + i[1])),
    !a && t && (i = t.match(/Edge\/(\d+)/),
    (!i || i[1] >= 74) && (i = t.match(/Chrome\/(\d+)/),
    i && (a = +i[1]))),
    O2 = a,
    O2
}
var A2, hM;
function GV() {
    if (hM)
        return A2;
    hM = 1;
    var e = qV()
      , t = Vo()
      , n = Ln()
      , r = n.String;
    return A2 = !!Object.getOwnPropertySymbols && !t(function() {
        var s = Symbol("symbol detection");
        return !r(s) || !(Object(s)instanceof Symbol) || !Symbol.sham && e && e < 41
    }),
    A2
}
var M2, pM;
function VV() {
    if (pM)
        return M2;
    pM = 1;
    var e = GV();
    return M2 = e && !Symbol.sham && typeof Symbol.iterator == "symbol",
    M2
}
var I2, mM;
function HV() {
    if (mM)
        return I2;
    mM = 1;
    var e = ac()
      , t = ar()
      , n = z4()
      , r = VV()
      , s = Object;
    return I2 = r ? function(o) {
        return typeof o == "symbol"
    }
    : function(o) {
        var i = e("Symbol");
        return t(i) && n(i.prototype, s(o))
    }
    ,
    I2
}
var R2, gM;
function t0() {
    if (gM)
        return R2;
    gM = 1;
    var e = String;
    return R2 = function(t) {
        try {
            return e(t)
        } catch {
            return "Object"
        }
    }
    ,
    R2
}
var N2, vM;
function Ga() {
    if (vM)
        return N2;
    vM = 1;
    var e = ar()
      , t = t0()
      , n = TypeError;
    return N2 = function(r) {
        if (e(r))
            return r;
        throw new n(t(r) + " is not a function")
    }
    ,
    N2
}
var P2, _M;
function $4() {
    if (_M)
        return P2;
    _M = 1;
    var e = Ga()
      , t = e0();
    return P2 = function(n, r) {
        var s = n[r];
        return t(s) ? void 0 : e(s)
    }
    ,
    P2
}
var D2, yM;
function $3e() {
    if (yM)
        return D2;
    yM = 1;
    var e = Ho()
      , t = ar()
      , n = Ri()
      , r = TypeError;
    return D2 = function(s, o) {
        var i, a;
        if (o === "string" && t(i = s.toString) && !n(a = e(i, s)) || t(i = s.valueOf) && !n(a = e(i, s)) || o !== "string" && t(i = s.toString) && !n(a = e(i, s)))
            return a;
        throw new r("Can't convert object to primitive value")
    }
    ,
    D2
}
var L2 = {
    exports: {}
}, F2, bM;
function Ah() {
    return bM || (bM = 1,
    F2 = !1),
    F2
}
var j2, CM;
function W4() {
    if (CM)
        return j2;
    CM = 1;
    var e = Ln()
      , t = Object.defineProperty;
    return j2 = function(n, r) {
        try {
            t(e, n, {
                value: r,
                configurable: !0,
                writable: !0
            })
        } catch {
            e[n] = r
        }
        return r
    }
    ,
    j2
}
var SM;
function K4() {
    if (SM)
        return L2.exports;
    SM = 1;
    var e = Ah()
      , t = Ln()
      , n = W4()
      , r = "__core-js_shared__"
      , s = L2.exports = t[r] || n(r, {});
    return (s.versions || (s.versions = [])).push({
        version: "3.45.1",
        mode: e ? "pure" : "global",
        copyright: "Â© 2014-2025 Denis Pushkarev (zloirock.ru)",
        license: "https://github.com/zloirock/core-js/blob/v3.45.1/LICENSE",
        source: "https://github.com/zloirock/core-js"
    }),
    L2.exports
}
var U2, wM;
function zV() {
    if (wM)
        return U2;
    wM = 1;
    var e = K4();
    return U2 = function(t, n) {
        return e[t] || (e[t] = n || {})
    }
    ,
    U2
}
var B2, EM;
function W3e() {
    if (EM)
        return B2;
    EM = 1;
    var e = V4()
      , t = Object;
    return B2 = function(n) {
        return t(e(n))
    }
    ,
    B2
}
var q2, xM;
function Ni() {
    if (xM)
        return q2;
    xM = 1;
    var e = fs()
      , t = W3e()
      , n = e({}.hasOwnProperty);
    return q2 = Object.hasOwn || function(s, o) {
        return n(t(s), o)
    }
    ,
    q2
}
var G2, TM;
function $V() {
    if (TM)
        return G2;
    TM = 1;
    var e = fs()
      , t = 0
      , n = Math.random()
      , r = e(1.1 .toString);
    return G2 = function(s) {
        return "Symbol(" + (s === void 0 ? "" : s) + ")_" + r(++t + n, 36)
    }
    ,
    G2
}
var V2, kM;
function zo() {
    if (kM)
        return V2;
    kM = 1;
    var e = Ln()
      , t = zV()
      , n = Ni()
      , r = $V()
      , s = GV()
      , o = VV()
      , i = e.Symbol
      , a = t("wks")
      , l = o ? i.for || i : i && i.withoutSetter || r;
    return V2 = function(c) {
        return n(a, c) || (a[c] = s && n(i, c) ? i[c] : l("Symbol." + c)),
        a[c]
    }
    ,
    V2
}
var H2, OM;
function K3e() {
    if (OM)
        return H2;
    OM = 1;
    var e = Ho()
      , t = Ri()
      , n = HV()
      , r = $4()
      , s = $3e()
      , o = zo()
      , i = TypeError
      , a = o("toPrimitive");
    return H2 = function(l, c) {
        if (!t(l) || n(l))
            return l;
        var u = r(l, a), d;
        if (u) {
            if (c === void 0 && (c = "default"),
            d = e(u, l, c),
            !t(d) || n(d))
                return d;
            throw new i("Can't convert object to primitive value")
        }
        return c === void 0 && (c = "number"),
        s(l, c)
    }
    ,
    H2
}
var z2, AM;
function WV() {
    if (AM)
        return z2;
    AM = 1;
    var e = K3e()
      , t = HV();
    return z2 = function(n) {
        var r = e(n, "string");
        return t(r) ? r : r + ""
    }
    ,
    z2
}
var $2, MM;
function KV() {
    if (MM)
        return $2;
    MM = 1;
    var e = Ln()
      , t = Ri()
      , n = e.document
      , r = t(n) && t(n.createElement);
    return $2 = function(s) {
        return r ? n.createElement(s) : {}
    }
    ,
    $2
}
var W2, IM;
function YV() {
    if (IM)
        return W2;
    IM = 1;
    var e = Ii()
      , t = Vo()
      , n = KV();
    return W2 = !e && !t(function() {
        return Object.defineProperty(n("div"), "a", {
            get: function() {
                return 7
            }
        }).a !== 7
    }),
    W2
}
var RM;
function ZV() {
    if (RM)
        return u2;
    RM = 1;
    var e = Ii()
      , t = Ho()
      , n = H3e()
      , r = BV()
      , s = H4()
      , o = WV()
      , i = Ni()
      , a = YV()
      , l = Object.getOwnPropertyDescriptor;
    return u2.f = e ? l : function(u, d) {
        if (u = s(u),
        d = o(d),
        a)
            try {
                return l(u, d)
            } catch {}
        if (i(u, d))
            return r(!t(n.f, u, d), u[d])
    }
    ,
    u2
}
var K2 = {}, Y2, NM;
function Y3e() {
    if (NM)
        return Y2;
    NM = 1;
    var e = Ii()
      , t = Vo();
    return Y2 = e && t(function() {
        return Object.defineProperty(function() {}, "prototype", {
            value: 42,
            writable: !1
        }).prototype !== 42
    }),
    Y2
}
var Z2, PM;
function lc() {
    if (PM)
        return Z2;
    PM = 1;
    var e = Ri()
      , t = String
      , n = TypeError;
    return Z2 = function(r) {
        if (e(r))
            return r;
        throw new n(t(r) + " is not an object")
    }
    ,
    Z2
}
var DM;
function Mh() {
    if (DM)
        return K2;
    DM = 1;
    var e = Ii()
      , t = YV()
      , n = Y3e()
      , r = lc()
      , s = WV()
      , o = TypeError
      , i = Object.defineProperty
      , a = Object.getOwnPropertyDescriptor
      , l = "enumerable"
      , c = "configurable"
      , u = "writable";
    return K2.f = e ? n ? function(f, p, m) {
        if (r(f),
        p = s(p),
        r(m),
        typeof f == "function" && p === "prototype" && "value"in m && u in m && !m[u]) {
            var v = a(f, p);
            v && v[u] && (f[p] = m.value,
            m = {
                configurable: c in m ? m[c] : v[c],
                enumerable: l in m ? m[l] : v[l],
                writable: !1
            })
        }
        return i(f, p, m)
    }
    : i : function(f, p, m) {
        if (r(f),
        p = s(p),
        r(m),
        t)
            try {
                return i(f, p, m)
            } catch {}
        if ("get"in m || "set"in m)
            throw new o("Accessors not supported");
        return "value"in m && (f[p] = m.value),
        f
    }
    ,
    K2
}
var J2, LM;
function JV() {
    if (LM)
        return J2;
    LM = 1;
    var e = Ii()
      , t = Mh()
      , n = BV();
    return J2 = e ? function(r, s, o) {
        return t.f(r, s, n(1, o))
    }
    : function(r, s, o) {
        return r[s] = o,
        r
    }
    ,
    J2
}
var X2 = {
    exports: {}
}, Q2, FM;
function Z3e() {
    if (FM)
        return Q2;
    FM = 1;
    var e = Ii()
      , t = Ni()
      , n = Function.prototype
      , r = e && Object.getOwnPropertyDescriptor
      , s = t(n, "name")
      , o = s && function() {}
    .name === "something"
      , i = s && (!e || e && r(n, "name").configurable);
    return Q2 = {
        EXISTS: s,
        PROPER: o,
        CONFIGURABLE: i
    },
    Q2
}
var eC, jM;
function Y4() {
    if (jM)
        return eC;
    jM = 1;
    var e = fs()
      , t = ar()
      , n = K4()
      , r = e(Function.toString);
    return t(n.inspectSource) || (n.inspectSource = function(s) {
        return r(s)
    }
    ),
    eC = n.inspectSource,
    eC
}
var tC, UM;
function J3e() {
    if (UM)
        return tC;
    UM = 1;
    var e = Ln()
      , t = ar()
      , n = e.WeakMap;
    return tC = t(n) && /native code/.test(String(n)),
    tC
}
var nC, BM;
function X3e() {
    if (BM)
        return nC;
    BM = 1;
    var e = zV()
      , t = $V()
      , n = e("keys");
    return nC = function(r) {
        return n[r] || (n[r] = t(r))
    }
    ,
    nC
}
var rC, qM;
function XV() {
    return qM || (qM = 1,
    rC = {}),
    rC
}
var sC, GM;
function QV() {
    if (GM)
        return sC;
    GM = 1;
    var e = J3e(), t = Ln(), n = Ri(), r = JV(), s = Ni(), o = K4(), i = X3e(), a = XV(), l = "Object already initialized", c = t.TypeError, u = t.WeakMap, d, f, p, m = function(b) {
        return p(b) ? f(b) : d(b, {})
    }, v = function(b) {
        return function(S) {
            var C;
            if (!n(S) || (C = f(S)).type !== b)
                throw new c("Incompatible receiver, " + b + " required");
            return C
        }
    };
    if (e || o.state) {
        var _ = o.state || (o.state = new u);
        _.get = _.get,
        _.has = _.has,
        _.set = _.set,
        d = function(b, S) {
            if (_.has(b))
                throw new c(l);
            return S.facade = b,
            _.set(b, S),
            S
        }
        ,
        f = function(b) {
            return _.get(b) || {}
        }
        ,
        p = function(b) {
            return _.has(b)
        }
    } else {
        var y = i("state");
        a[y] = !0,
        d = function(b, S) {
            if (s(b, y))
                throw new c(l);
            return S.facade = b,
            r(b, y, S),
            S
        }
        ,
        f = function(b) {
            return s(b, y) ? b[y] : {}
        }
        ,
        p = function(b) {
            return s(b, y)
        }
    }
    return sC = {
        set: d,
        get: f,
        has: p,
        enforce: m,
        getterFor: v
    },
    sC
}
var VM;
function eH() {
    if (VM)
        return X2.exports;
    VM = 1;
    var e = fs()
      , t = Vo()
      , n = ar()
      , r = Ni()
      , s = Ii()
      , o = Z3e().CONFIGURABLE
      , i = Y4()
      , a = QV()
      , l = a.enforce
      , c = a.get
      , u = String
      , d = Object.defineProperty
      , f = e("".slice)
      , p = e("".replace)
      , m = e([].join)
      , v = s && !t(function() {
        return d(function() {}, "length", {
            value: 8
        }).length !== 8
    })
      , _ = String(String).split("String")
      , y = X2.exports = function(b, S, C) {
        f(u(S), 0, 7) === "Symbol(" && (S = "[" + p(u(S), /^Symbol\(([^)]*)\).*$/, "$1") + "]"),
        C && C.getter && (S = "get " + S),
        C && C.setter && (S = "set " + S),
        (!r(b, "name") || o && b.name !== S) && (s ? d(b, "name", {
            value: S,
            configurable: !0
        }) : b.name = S),
        v && C && r(C, "arity") && b.length !== C.arity && d(b, "length", {
            value: C.arity
        });
        try {
            C && r(C, "constructor") && C.constructor ? s && d(b, "prototype", {
                writable: !1
            }) : b.prototype && (b.prototype = void 0)
        } catch {}
        var w = l(b);
        return r(w, "source") || (w.source = m(_, typeof S == "string" ? S : "")),
        b
    }
    ;
    return Function.prototype.toString = y(function() {
        return n(this) && c(this).source || i(this)
    }, "toString"),
    X2.exports
}
var oC, HM;
function Z4() {
    if (HM)
        return oC;
    HM = 1;
    var e = ar()
      , t = Mh()
      , n = eH()
      , r = W4();
    return oC = function(s, o, i, a) {
        a || (a = {});
        var l = a.enumerable
          , c = a.name !== void 0 ? a.name : o;
        if (e(i) && n(i, c, a),
        a.global)
            l ? s[o] = i : r(o, i);
        else {
            try {
                a.unsafe ? s[o] && (l = !0) : delete s[o]
            } catch {}
            l ? s[o] = i : t.f(s, o, {
                value: i,
                enumerable: !1,
                configurable: !a.nonConfigurable,
                writable: !a.nonWritable
            })
        }
        return s
    }
    ,
    oC
}
var iC = {}, aC, zM;
function Q3e() {
    if (zM)
        return aC;
    zM = 1;
    var e = Math.ceil
      , t = Math.floor;
    return aC = Math.trunc || function(r) {
        var s = +r;
        return (s > 0 ? t : e)(s)
    }
    ,
    aC
}
var lC, $M;
function tH() {
    if ($M)
        return lC;
    $M = 1;
    var e = Q3e();
    return lC = function(t) {
        var n = +t;
        return n !== n || n === 0 ? 0 : e(n)
    }
    ,
    lC
}
var cC, WM;
function e5e() {
    if (WM)
        return cC;
    WM = 1;
    var e = tH()
      , t = Math.max
      , n = Math.min;
    return cC = function(r, s) {
        var o = e(r);
        return o < 0 ? t(o + s, 0) : n(o, s)
    }
    ,
    cC
}
var uC, KM;
function t5e() {
    if (KM)
        return uC;
    KM = 1;
    var e = tH()
      , t = Math.min;
    return uC = function(n) {
        var r = e(n);
        return r > 0 ? t(r, 9007199254740991) : 0
    }
    ,
    uC
}
var dC, YM;
function nH() {
    if (YM)
        return dC;
    YM = 1;
    var e = t5e();
    return dC = function(t) {
        return e(t.length)
    }
    ,
    dC
}
var fC, ZM;
function n5e() {
    if (ZM)
        return fC;
    ZM = 1;
    var e = H4()
      , t = e5e()
      , n = nH()
      , r = function(s) {
        return function(o, i, a) {
            var l = e(o)
              , c = n(l);
            if (c === 0)
                return !s && -1;
            var u = t(a, c), d;
            if (s && i !== i) {
                for (; c > u; )
                    if (d = l[u++],
                    d !== d)
                        return !0
            } else
                for (; c > u; u++)
                    if ((s || u in l) && l[u] === i)
                        return s || u || 0;
            return !s && -1
        }
    };
    return fC = {
        includes: r(!0),
        indexOf: r(!1)
    },
    fC
}
var hC, JM;
function r5e() {
    if (JM)
        return hC;
    JM = 1;
    var e = fs()
      , t = Ni()
      , n = H4()
      , r = n5e().indexOf
      , s = XV()
      , o = e([].push);
    return hC = function(i, a) {
        var l = n(i), c = 0, u = [], d;
        for (d in l)
            !t(s, d) && t(l, d) && o(u, d);
        for (; a.length > c; )
            t(l, d = a[c++]) && (~r(u, d) || o(u, d));
        return u
    }
    ,
    hC
}
var pC, XM;
function s5e() {
    return XM || (XM = 1,
    pC = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"]),
    pC
}
var QM;
function o5e() {
    if (QM)
        return iC;
    QM = 1;
    var e = r5e()
      , t = s5e()
      , n = t.concat("length", "prototype");
    return iC.f = Object.getOwnPropertyNames || function(s) {
        return e(s, n)
    }
    ,
    iC
}
var mC = {}, eI;
function i5e() {
    return eI || (eI = 1,
    mC.f = Object.getOwnPropertySymbols),
    mC
}
var gC, tI;
function a5e() {
    if (tI)
        return gC;
    tI = 1;
    var e = ac()
      , t = fs()
      , n = o5e()
      , r = i5e()
      , s = lc()
      , o = t([].concat);
    return gC = e("Reflect", "ownKeys") || function(a) {
        var l = n.f(s(a))
          , c = r.f;
        return c ? o(l, c(a)) : l
    }
    ,
    gC
}
var vC, nI;
function l5e() {
    if (nI)
        return vC;
    nI = 1;
    var e = Ni()
      , t = a5e()
      , n = ZV()
      , r = Mh();
    return vC = function(s, o, i) {
        for (var a = t(o), l = r.f, c = n.f, u = 0; u < a.length; u++) {
            var d = a[u];
            !e(s, d) && !(i && e(i, d)) && l(s, d, c(o, d))
        }
    }
    ,
    vC
}
var _C, rI;
function rH() {
    if (rI)
        return _C;
    rI = 1;
    var e = Vo()
      , t = ar()
      , n = /#|\.prototype\./
      , r = function(l, c) {
        var u = o[s(l)];
        return u === a ? !0 : u === i ? !1 : t(c) ? e(c) : !!c
    }
      , s = r.normalize = function(l) {
        return String(l).replace(n, ".").toLowerCase()
    }
      , o = r.data = {}
      , i = r.NATIVE = "N"
      , a = r.POLYFILL = "P";
    return _C = r,
    _C
}
var yC, sI;
function cc() {
    if (sI)
        return yC;
    sI = 1;
    var e = Ln()
      , t = ZV().f
      , n = JV()
      , r = Z4()
      , s = W4()
      , o = l5e()
      , i = rH();
    return yC = function(a, l) {
        var c = a.target, u = a.global, d = a.stat, f, p, m, v, _, y;
        if (u ? p = e : d ? p = e[c] || s(c, {}) : p = e[c] && e[c].prototype,
        p)
            for (m in l) {
                if (_ = l[m],
                a.dontCallGetSet ? (y = t(p, m),
                v = y && y.value) : v = p[m],
                f = i(u ? m : c + (d ? "." : "#") + m, a.forced),
                !f && v !== void 0) {
                    if (typeof _ == typeof v)
                        continue;
                    o(_, v)
                }
                (a.sham || v && v.sham) && n(_, "sham", !0),
                r(p, m, _, a)
            }
    }
    ,
    yC
}
var bC, oI;
function sH() {
    if (oI)
        return bC;
    oI = 1;
    var e = Ln()
      , t = Oh()
      , n = Q1()
      , r = function(s) {
        return t.slice(0, s.length) === s
    };
    return bC = function() {
        return r("Bun/") ? "BUN" : r("Cloudflare-Workers") ? "CLOUDFLARE" : r("Deno/") ? "DENO" : r("Node.js/") ? "NODE" : e.Bun && typeof Bun.version == "string" ? "BUN" : e.Deno && typeof Deno.version == "object" ? "DENO" : n(e.process) === "process" ? "NODE" : e.window && e.document ? "BROWSER" : "REST"
    }(),
    bC
}
var CC, iI;
function J4() {
    if (iI)
        return CC;
    iI = 1;
    var e = sH();
    return CC = e === "NODE",
    CC
}
var SC, aI;
function oH() {
    if (aI)
        return SC;
    aI = 1;
    var e = Ln();
    return SC = e,
    SC
}
var wC, lI;
function c5e() {
    if (lI)
        return wC;
    lI = 1;
    var e = fs()
      , t = Ga();
    return wC = function(n, r, s) {
        try {
            return e(t(Object.getOwnPropertyDescriptor(n, r)[s]))
        } catch {}
    }
    ,
    wC
}
var EC, cI;
function u5e() {
    if (cI)
        return EC;
    cI = 1;
    var e = Ri();
    return EC = function(t) {
        return e(t) || t === null
    }
    ,
    EC
}
var xC, uI;
function d5e() {
    if (uI)
        return xC;
    uI = 1;
    var e = u5e()
      , t = String
      , n = TypeError;
    return xC = function(r) {
        if (e(r))
            return r;
        throw new n("Can't set " + t(r) + " as a prototype")
    }
    ,
    xC
}
var TC, dI;
function f5e() {
    if (dI)
        return TC;
    dI = 1;
    var e = c5e()
      , t = Ri()
      , n = V4()
      , r = d5e();
    return TC = Object.setPrototypeOf || ("__proto__"in {} ? function() {
        var s = !1, o = {}, i;
        try {
            i = e(Object.prototype, "__proto__", "set"),
            i(o, []),
            s = o instanceof Array
        } catch {}
        return function(l, c) {
            return n(l),
            r(c),
            t(l) && (s ? i(l, c) : l.__proto__ = c),
            l
        }
    }() : void 0),
    TC
}
var kC, fI;
function h5e() {
    if (fI)
        return kC;
    fI = 1;
    var e = Mh().f
      , t = Ni()
      , n = zo()
      , r = n("toStringTag");
    return kC = function(s, o, i) {
        s && !i && (s = s.prototype),
        s && !t(s, r) && e(s, r, {
            configurable: !0,
            value: o
        })
    }
    ,
    kC
}
var OC, hI;
function p5e() {
    if (hI)
        return OC;
    hI = 1;
    var e = eH()
      , t = Mh();
    return OC = function(n, r, s) {
        return s.get && e(s.get, r, {
            getter: !0
        }),
        s.set && e(s.set, r, {
            setter: !0
        }),
        t.f(n, r, s)
    }
    ,
    OC
}
var AC, pI;
function m5e() {
    if (pI)
        return AC;
    pI = 1;
    var e = ac()
      , t = p5e()
      , n = zo()
      , r = Ii()
      , s = n("species");
    return AC = function(o) {
        var i = e(o);
        r && i && !i[s] && t(i, s, {
            configurable: !0,
            get: function() {
                return this
            }
        })
    }
    ,
    AC
}
var MC, mI;
function g5e() {
    if (mI)
        return MC;
    mI = 1;
    var e = z4()
      , t = TypeError;
    return MC = function(n, r) {
        if (e(r, n))
            return n;
        throw new t("Incorrect invocation")
    }
    ,
    MC
}
var IC, gI;
function v5e() {
    if (gI)
        return IC;
    gI = 1;
    var e = zo()
      , t = e("toStringTag")
      , n = {};
    return n[t] = "z",
    IC = String(n) === "[object z]",
    IC
}
var RC, vI;
function iH() {
    if (vI)
        return RC;
    vI = 1;
    var e = v5e()
      , t = ar()
      , n = Q1()
      , r = zo()
      , s = r("toStringTag")
      , o = Object
      , i = n(function() {
        return arguments
    }()) === "Arguments"
      , a = function(l, c) {
        try {
            return l[c]
        } catch {}
    };
    return RC = e ? n : function(l) {
        var c, u, d;
        return l === void 0 ? "Undefined" : l === null ? "Null" : typeof (u = a(c = o(l), s)) == "string" ? u : i ? n(c) : (d = n(c)) === "Object" && t(c.callee) ? "Arguments" : d
    }
    ,
    RC
}
var NC, _I;
function _5e() {
    if (_I)
        return NC;
    _I = 1;
    var e = fs()
      , t = Vo()
      , n = ar()
      , r = iH()
      , s = ac()
      , o = Y4()
      , i = function() {}
      , a = s("Reflect", "construct")
      , l = /^\s*(?:class|function)\b/
      , c = e(l.exec)
      , u = !l.test(i)
      , d = function(m) {
        if (!n(m))
            return !1;
        try {
            return a(i, [], m),
            !0
        } catch {
            return !1
        }
    }
      , f = function(m) {
        if (!n(m))
            return !1;
        switch (r(m)) {
        case "AsyncFunction":
        case "GeneratorFunction":
        case "AsyncGeneratorFunction":
            return !1
        }
        try {
            return u || !!c(l, o(m))
        } catch {
            return !0
        }
    };
    return f.sham = !0,
    NC = !a || t(function() {
        var p;
        return d(d.call) || !d(Object) || !d(function() {
            p = !0
        }) || p
    }) ? f : d,
    NC
}
var PC, yI;
function y5e() {
    if (yI)
        return PC;
    yI = 1;
    var e = _5e()
      , t = t0()
      , n = TypeError;
    return PC = function(r) {
        if (e(r))
            return r;
        throw new n(t(r) + " is not a constructor")
    }
    ,
    PC
}
var DC, bI;
function b5e() {
    if (bI)
        return DC;
    bI = 1;
    var e = lc()
      , t = y5e()
      , n = e0()
      , r = zo()
      , s = r("species");
    return DC = function(o, i) {
        var a = e(o).constructor, l;
        return a === void 0 || n(l = e(a)[s]) ? i : t(l)
    }
    ,
    DC
}
var LC, CI;
function C5e() {
    if (CI)
        return LC;
    CI = 1;
    var e = X1()
      , t = Function.prototype
      , n = t.apply
      , r = t.call;
    return LC = typeof Reflect == "object" && Reflect.apply || (e ? r.bind(n) : function() {
        return r.apply(n, arguments)
    }
    ),
    LC
}
var FC, SI;
function S5e() {
    if (SI)
        return FC;
    SI = 1;
    var e = Q1()
      , t = fs();
    return FC = function(n) {
        if (e(n) === "Function")
            return t(n)
    }
    ,
    FC
}
var jC, wI;
function X4() {
    if (wI)
        return jC;
    wI = 1;
    var e = S5e()
      , t = Ga()
      , n = X1()
      , r = e(e.bind);
    return jC = function(s, o) {
        return t(s),
        o === void 0 ? s : n ? r(s, o) : function() {
            return s.apply(o, arguments)
        }
    }
    ,
    jC
}
var UC, EI;
function w5e() {
    if (EI)
        return UC;
    EI = 1;
    var e = ac();
    return UC = e("document", "documentElement"),
    UC
}
var BC, xI;
function E5e() {
    if (xI)
        return BC;
    xI = 1;
    var e = fs();
    return BC = e([].slice),
    BC
}
var qC, TI;
function x5e() {
    if (TI)
        return qC;
    TI = 1;
    var e = TypeError;
    return qC = function(t, n) {
        if (t < n)
            throw new e("Not enough arguments");
        return t
    }
    ,
    qC
}
var GC, kI;
function aH() {
    if (kI)
        return GC;
    kI = 1;
    var e = Oh();
    return GC = /(?:ipad|iphone|ipod).*applewebkit/i.test(e),
    GC
}
var VC, OI;
function lH() {
    if (OI)
        return VC;
    OI = 1;
    var e = Ln(), t = C5e(), n = X4(), r = ar(), s = Ni(), o = Vo(), i = w5e(), a = E5e(), l = KV(), c = x5e(), u = aH(), d = J4(), f = e.setImmediate, p = e.clearImmediate, m = e.process, v = e.Dispatch, _ = e.Function, y = e.MessageChannel, b = e.String, S = 0, C = {}, w = "onreadystatechange", x, E, T, k;
    o(function() {
        x = e.location
    });
    var A = function(R) {
        if (s(C, R)) {
            var D = C[R];
            delete C[R],
            D()
        }
    }
      , O = function(R) {
        return function() {
            A(R)
        }
    }
      , M = function(R) {
        A(R.data)
    }
      , I = function(R) {
        e.postMessage(b(R), x.protocol + "//" + x.host)
    };
    return (!f || !p) && (f = function(D) {
        c(arguments.length, 1);
        var P = r(D) ? D : _(D)
          , L = a(arguments, 1);
        return C[++S] = function() {
            t(P, void 0, L)
        }
        ,
        E(S),
        S
    }
    ,
    p = function(D) {
        delete C[D]
    }
    ,
    d ? E = function(R) {
        m.nextTick(O(R))
    }
    : v && v.now ? E = function(R) {
        v.now(O(R))
    }
    : y && !u ? (T = new y,
    k = T.port2,
    T.port1.onmessage = M,
    E = n(k.postMessage, k)) : e.addEventListener && r(e.postMessage) && !e.importScripts && x && x.protocol !== "file:" && !o(I) ? (E = I,
    e.addEventListener("message", M, !1)) : w in l("script") ? E = function(R) {
        i.appendChild(l("script"))[w] = function() {
            i.removeChild(this),
            A(R)
        }
    }
    : E = function(R) {
        setTimeout(O(R), 0)
    }
    ),
    VC = {
        set: f,
        clear: p
    },
    VC
}
var HC, AI;
function T5e() {
    if (AI)
        return HC;
    AI = 1;
    var e = Ln()
      , t = Ii()
      , n = Object.getOwnPropertyDescriptor;
    return HC = function(r) {
        if (!t)
            return e[r];
        var s = n(e, r);
        return s && s.value
    }
    ,
    HC
}
var zC, MI;
function cH() {
    if (MI)
        return zC;
    MI = 1;
    var e = function() {
        this.head = null,
        this.tail = null
    };
    return e.prototype = {
        add: function(t) {
            var n = {
                item: t,
                next: null
            }
              , r = this.tail;
            r ? r.next = n : this.head = n,
            this.tail = n
        },
        get: function() {
            var t = this.head;
            if (t) {
                var n = this.head = t.next;
                return n === null && (this.tail = null),
                t.item
            }
        }
    },
    zC = e,
    zC
}
var $C, II;
function k5e() {
    if (II)
        return $C;
    II = 1;
    var e = Oh();
    return $C = /ipad|iphone|ipod/i.test(e) && typeof Pebble < "u",
    $C
}
var WC, RI;
function O5e() {
    if (RI)
        return WC;
    RI = 1;
    var e = Oh();
    return WC = /web0s(?!.*chrome)/i.test(e),
    WC
}
var KC, NI;
function A5e() {
    if (NI)
        return KC;
    NI = 1;
    var e = Ln(), t = T5e(), n = X4(), r = lH().set, s = cH(), o = aH(), i = k5e(), a = O5e(), l = J4(), c = e.MutationObserver || e.WebKitMutationObserver, u = e.document, d = e.process, f = e.Promise, p = t("queueMicrotask"), m, v, _, y, b;
    if (!p) {
        var S = new s
          , C = function() {
            var w, x;
            for (l && (w = d.domain) && w.exit(); x = S.get(); )
                try {
                    x()
                } catch (E) {
                    throw S.head && m(),
                    E
                }
            w && w.enter()
        };
        !o && !l && !a && c && u ? (v = !0,
        _ = u.createTextNode(""),
        new c(C).observe(_, {
            characterData: !0
        }),
        m = function() {
            _.data = v = !v
        }
        ) : !i && f && f.resolve ? (y = f.resolve(void 0),
        y.constructor = f,
        b = n(y.then, y),
        m = function() {
            b(C)
        }
        ) : l ? m = function() {
            d.nextTick(C)
        }
        : (r = n(r, e),
        m = function() {
            r(C)
        }
        ),
        p = function(w) {
            S.head || m(),
            S.add(w)
        }
    }
    return KC = p,
    KC
}
var YC, PI;
function M5e() {
    return PI || (PI = 1,
    YC = function(e, t) {
        try {
            arguments.length === 1 ? console.error(e) : console.error(e, t)
        } catch {}
    }
    ),
    YC
}
var ZC, DI;
function Q4() {
    return DI || (DI = 1,
    ZC = function(e) {
        try {
            return {
                error: !1,
                value: e()
            }
        } catch (t) {
            return {
                error: !0,
                value: t
            }
        }
    }
    ),
    ZC
}
var JC, LI;
function Ih() {
    if (LI)
        return JC;
    LI = 1;
    var e = Ln();
    return JC = e.Promise,
    JC
}
var XC, FI;
function Rh() {
    if (FI)
        return XC;
    FI = 1;
    var e = Ln()
      , t = Ih()
      , n = ar()
      , r = rH()
      , s = Y4()
      , o = zo()
      , i = sH()
      , a = Ah()
      , l = qV()
      , c = t && t.prototype
      , u = o("species")
      , d = !1
      , f = n(e.PromiseRejectionEvent)
      , p = r("Promise", function() {
        var m = s(t)
          , v = m !== String(t);
        if (!v && l === 66 || a && !(c.catch && c.finally))
            return !0;
        if (!l || l < 51 || !/native code/.test(m)) {
            var _ = new t(function(S) {
                S(1)
            }
            )
              , y = function(S) {
                S(function() {}, function() {})
            }
              , b = _.constructor = {};
            if (b[u] = y,
            d = _.then(function() {})instanceof y,
            !d)
                return !0
        }
        return !v && (i === "BROWSER" || i === "DENO") && !f
    });
    return XC = {
        CONSTRUCTOR: p,
        REJECTION_EVENT: f,
        SUBCLASSING: d
    },
    XC
}
var QC = {}, jI;
function id() {
    if (jI)
        return QC;
    jI = 1;
    var e = Ga()
      , t = TypeError
      , n = function(r) {
        var s, o;
        this.promise = new r(function(i, a) {
            if (s !== void 0 || o !== void 0)
                throw new t("Bad Promise constructor");
            s = i,
            o = a
        }
        ),
        this.resolve = e(s),
        this.reject = e(o)
    };
    return QC.f = function(r) {
        return new n(r)
    }
    ,
    QC
}
var UI;
function I5e() {
    if (UI)
        return WA;
    UI = 1;
    var e = cc(), t = Ah(), n = J4(), r = Ln(), s = oH(), o = Ho(), i = Z4(), a = f5e(), l = h5e(), c = m5e(), u = Ga(), d = ar(), f = Ri(), p = g5e(), m = b5e(), v = lH().set, _ = A5e(), y = M5e(), b = Q4(), S = cH(), C = QV(), w = Ih(), x = Rh(), E = id(), T = "Promise", k = x.CONSTRUCTOR, A = x.REJECTION_EVENT, O = x.SUBCLASSING, M = C.getterFor(T), I = C.set, R = w && w.prototype, D = w, P = R, L = r.TypeError, N = r.document, B = r.process, H = E.f, ye = H, Ie = !!(N && N.createEvent && r.dispatchEvent), be = "unhandledrejection", me = "rejectionhandled", ge = 0, ce = 1, Z = 2, ne = 1, _e = 2, ee, oe, te, ve, Ue = function(Y) {
        var le;
        return f(Y) && d(le = Y.then) ? le : !1
    }, re = function(Y, le) {
        var Oe = le.value, ae = le.state === ce, je = ae ? Y.ok : Y.fail, ot = Y.resolve, St = Y.reject, Tt = Y.domain, wt, ut, Mt;
        try {
            je ? (ae || (le.rejection === _e && G(le),
            le.rejection = ne),
            je === !0 ? wt = Oe : (Tt && Tt.enter(),
            wt = je(Oe),
            Tt && (Tt.exit(),
            Mt = !0)),
            wt === Y.promise ? St(new L("Promise-chain cycle")) : (ut = Ue(wt)) ? o(ut, wt, ot, St) : ot(wt)) : St(Oe)
        } catch (fn) {
            Tt && !Mt && Tt.exit(),
            St(fn)
        }
    }, W = function(Y, le) {
        Y.notified || (Y.notified = !0,
        _(function() {
            for (var Oe = Y.reactions, ae; ae = Oe.get(); )
                re(ae, Y);
            Y.notified = !1,
            le && !Y.rejection && Te(Y)
        }))
    }, X = function(Y, le, Oe) {
        var ae, je;
        Ie ? (ae = N.createEvent("Event"),
        ae.promise = le,
        ae.reason = Oe,
        ae.initEvent(Y, !1, !0),
        r.dispatchEvent(ae)) : ae = {
            promise: le,
            reason: Oe
        },
        !A && (je = r["on" + Y]) ? je(ae) : Y === be && y("Unhandled promise rejection", Oe)
    }, Te = function(Y) {
        o(v, r, function() {
            var le = Y.facade, Oe = Y.value, ae = se(Y), je;
            if (ae && (je = b(function() {
                n ? B.emit("unhandledRejection", Oe, le) : X(be, le, Oe)
            }),
            Y.rejection = n || se(Y) ? _e : ne,
            je.error))
                throw je.value
        })
    }, se = function(Y) {
        return Y.rejection !== ne && !Y.parent
    }, G = function(Y) {
        o(v, r, function() {
            var le = Y.facade;
            n ? B.emit("rejectionHandled", le) : X(me, le, Y.value)
        })
    }, F = function(Y, le, Oe) {
        return function(ae) {
            Y(le, ae, Oe)
        }
    }, ke = function(Y, le, Oe) {
        Y.done || (Y.done = !0,
        Oe && (Y = Oe),
        Y.value = le,
        Y.state = Z,
        W(Y, !0))
    }, Ee = function(Y, le, Oe) {
        if (!Y.done) {
            Y.done = !0,
            Oe && (Y = Oe);
            try {
                if (Y.facade === le)
                    throw new L("Promise can't be resolved itself");
                var ae = Ue(le);
                ae ? _(function() {
                    var je = {
                        done: !1
                    };
                    try {
                        o(ae, le, F(Ee, je, Y), F(ke, je, Y))
                    } catch (ot) {
                        ke(je, ot, Y)
                    }
                }) : (Y.value = le,
                Y.state = ce,
                W(Y, !1))
            } catch (je) {
                ke({
                    done: !1
                }, je, Y)
            }
        }
    };
    if (k && (D = function(le) {
        p(this, P),
        u(le),
        o(ee, this);
        var Oe = M(this);
        try {
            le(F(Ee, Oe), F(ke, Oe))
        } catch (ae) {
            ke(Oe, ae)
        }
    }
    ,
    P = D.prototype,
    ee = function(le) {
        I(this, {
            type: T,
            done: !1,
            notified: !1,
            parent: !1,
            reactions: new S,
            rejection: !1,
            state: ge,
            value: null
        })
    }
    ,
    ee.prototype = i(P, "then", function(le, Oe) {
        var ae = M(this)
          , je = H(m(this, D));
        return ae.parent = !0,
        je.ok = d(le) ? le : !0,
        je.fail = d(Oe) && Oe,
        je.domain = n ? B.domain : void 0,
        ae.state === ge ? ae.reactions.add(je) : _(function() {
            re(je, ae)
        }),
        je.promise
    }),
    oe = function() {
        var Y = new ee
          , le = M(Y);
        this.promise = Y,
        this.resolve = F(Ee, le),
        this.reject = F(ke, le)
    }
    ,
    E.f = H = function(Y) {
        return Y === D || Y === te ? new oe(Y) : ye(Y)
    }
    ,
    !t && d(w) && R !== Object.prototype)) {
        ve = R.then,
        O || i(R, "then", function(le, Oe) {
            var ae = this;
            return new D(function(je, ot) {
                o(ve, ae, je, ot)
            }
            ).then(le, Oe)
        }, {
            unsafe: !0
        });
        try {
            delete R.constructor
        } catch {}
        a && a(R, P)
    }
    return e({
        global: !0,
        constructor: !0,
        wrap: !0,
        forced: k
    }, {
        Promise: D
    }),
    te = s.Promise,
    l(D, T, !1, !0),
    c(T),
    WA
}
var BI = {}, e3, qI;
function uH() {
    return qI || (qI = 1,
    e3 = {}),
    e3
}
var t3, GI;
function R5e() {
    if (GI)
        return t3;
    GI = 1;
    var e = zo()
      , t = uH()
      , n = e("iterator")
      , r = Array.prototype;
    return t3 = function(s) {
        return s !== void 0 && (t.Array === s || r[n] === s)
    }
    ,
    t3
}
var n3, VI;
function dH() {
    if (VI)
        return n3;
    VI = 1;
    var e = iH()
      , t = $4()
      , n = e0()
      , r = uH()
      , s = zo()
      , o = s("iterator");
    return n3 = function(i) {
        if (!n(i))
            return t(i, o) || t(i, "@@iterator") || r[e(i)]
    }
    ,
    n3
}
var r3, HI;
function N5e() {
    if (HI)
        return r3;
    HI = 1;
    var e = Ho()
      , t = Ga()
      , n = lc()
      , r = t0()
      , s = dH()
      , o = TypeError;
    return r3 = function(i, a) {
        var l = arguments.length < 2 ? s(i) : a;
        if (t(l))
            return n(e(l, i));
        throw new o(r(i) + " is not iterable")
    }
    ,
    r3
}
var s3, zI;
function P5e() {
    if (zI)
        return s3;
    zI = 1;
    var e = Ho()
      , t = lc()
      , n = $4();
    return s3 = function(r, s, o) {
        var i, a;
        t(r);
        try {
            if (i = n(r, "return"),
            !i) {
                if (s === "throw")
                    throw o;
                return o
            }
            i = e(i, r)
        } catch (l) {
            a = !0,
            i = l
        }
        if (s === "throw")
            throw o;
        if (a)
            throw i;
        return t(i),
        o
    }
    ,
    s3
}
var o3, $I;
function fH() {
    if ($I)
        return o3;
    $I = 1;
    var e = X4()
      , t = Ho()
      , n = lc()
      , r = t0()
      , s = R5e()
      , o = nH()
      , i = z4()
      , a = N5e()
      , l = dH()
      , c = P5e()
      , u = TypeError
      , d = function(p, m) {
        this.stopped = p,
        this.result = m
    }
      , f = d.prototype;
    return o3 = function(p, m, v) {
        var _ = v && v.that, y = !!(v && v.AS_ENTRIES), b = !!(v && v.IS_RECORD), S = !!(v && v.IS_ITERATOR), C = !!(v && v.INTERRUPTED), w = e(m, _), x, E, T, k, A, O, M, I = function(D) {
            return x && c(x, "normal"),
            new d(!0,D)
        }, R = function(D) {
            return y ? (n(D),
            C ? w(D[0], D[1], I) : w(D[0], D[1])) : C ? w(D, I) : w(D)
        };
        if (b)
            x = p.iterator;
        else if (S)
            x = p;
        else {
            if (E = l(p),
            !E)
                throw new u(r(p) + " is not iterable");
            if (s(E)) {
                for (T = 0,
                k = o(p); k > T; T++)
                    if (A = R(p[T]),
                    A && i(f, A))
                        return A;
                return new d(!1)
            }
            x = a(p, E)
        }
        for (O = b ? p.next : x.next; !(M = t(O, x)).done; ) {
            try {
                A = R(M.value)
            } catch (D) {
                c(x, "throw", D)
            }
            if (typeof A == "object" && A && i(f, A))
                return A
        }
        return new d(!1)
    }
    ,
    o3
}
var i3, WI;
function D5e() {
    if (WI)
        return i3;
    WI = 1;
    var e = zo()
      , t = e("iterator")
      , n = !1;
    try {
        var r = 0
          , s = {
            next: function() {
                return {
                    done: !!r++
                }
            },
            return: function() {
                n = !0
            }
        };
        s[t] = function() {
            return this
        }
        ,
        Array.from(s, function() {
            throw 2
        })
    } catch {}
    return i3 = function(o, i) {
        try {
            if (!i && !n)
                return !1
        } catch {
            return !1
        }
        var a = !1;
        try {
            var l = {};
            l[t] = function() {
                return {
                    next: function() {
                        return {
                            done: a = !0
                        }
                    }
                }
            }
            ,
            o(l)
        } catch {}
        return a
    }
    ,
    i3
}
var a3, KI;
function hH() {
    if (KI)
        return a3;
    KI = 1;
    var e = Ih()
      , t = D5e()
      , n = Rh().CONSTRUCTOR;
    return a3 = n || !t(function(r) {
        e.all(r).then(void 0, function() {})
    }),
    a3
}
var YI;
function L5e() {
    if (YI)
        return BI;
    YI = 1;
    var e = cc()
      , t = Ho()
      , n = Ga()
      , r = id()
      , s = Q4()
      , o = fH()
      , i = hH();
    return e({
        target: "Promise",
        stat: !0,
        forced: i
    }, {
        all: function(l) {
            var c = this
              , u = r.f(c)
              , d = u.resolve
              , f = u.reject
              , p = s(function() {
                var m = n(c.resolve)
                  , v = []
                  , _ = 0
                  , y = 1;
                o(l, function(b) {
                    var S = _++
                      , C = !1;
                    y++,
                    t(m, c, b).then(function(w) {
                        C || (C = !0,
                        v[S] = w,
                        --y || d(v))
                    }, f)
                }),
                --y || d(v)
            });
            return p.error && f(p.value),
            u.promise
        }
    }),
    BI
}
var ZI = {}, JI;
function F5e() {
    if (JI)
        return ZI;
    JI = 1;
    var e = cc()
      , t = Ah()
      , n = Rh().CONSTRUCTOR
      , r = Ih()
      , s = ac()
      , o = ar()
      , i = Z4()
      , a = r && r.prototype;
    if (e({
        target: "Promise",
        proto: !0,
        forced: n,
        real: !0
    }, {
        catch: function(c) {
            return this.then(void 0, c)
        }
    }),
    !t && o(r)) {
        var l = s("Promise").prototype.catch;
        a.catch !== l && i(a, "catch", l, {
            unsafe: !0
        })
    }
    return ZI
}
var XI = {}, QI;
function j5e() {
    if (QI)
        return XI;
    QI = 1;
    var e = cc()
      , t = Ho()
      , n = Ga()
      , r = id()
      , s = Q4()
      , o = fH()
      , i = hH();
    return e({
        target: "Promise",
        stat: !0,
        forced: i
    }, {
        race: function(l) {
            var c = this
              , u = r.f(c)
              , d = u.reject
              , f = s(function() {
                var p = n(c.resolve);
                o(l, function(m) {
                    t(p, c, m).then(u.resolve, d)
                })
            });
            return f.error && d(f.value),
            u.promise
        }
    }),
    XI
}
var eR = {}, tR;
function U5e() {
    if (tR)
        return eR;
    tR = 1;
    var e = cc()
      , t = id()
      , n = Rh().CONSTRUCTOR;
    return e({
        target: "Promise",
        stat: !0,
        forced: n
    }, {
        reject: function(s) {
            var o = t.f(this)
              , i = o.reject;
            return i(s),
            o.promise
        }
    }),
    eR
}
var nR = {}, l3, rR;
function B5e() {
    if (rR)
        return l3;
    rR = 1;
    var e = lc()
      , t = Ri()
      , n = id();
    return l3 = function(r, s) {
        if (e(r),
        t(s) && s.constructor === r)
            return s;
        var o = n.f(r)
          , i = o.resolve;
        return i(s),
        o.promise
    }
    ,
    l3
}
var sR;
function q5e() {
    if (sR)
        return nR;
    sR = 1;
    var e = cc()
      , t = ac()
      , n = Ah()
      , r = Ih()
      , s = Rh().CONSTRUCTOR
      , o = B5e()
      , i = t("Promise")
      , a = n && !s;
    return e({
        target: "Promise",
        stat: !0,
        forced: n || s
    }, {
        resolve: function(c) {
            return o(a && this === i ? r : this, c)
        }
    }),
    nR
}
var oR;
function G5e() {
    return oR || (oR = 1,
    I5e(),
    L5e(),
    F5e(),
    j5e(),
    U5e(),
    q5e()),
    $A
}
var iR = {}, aR;
function pH() {
    if (aR)
        return iR;
    aR = 1;
    var e = cc()
      , t = id();
    return e({
        target: "Promise",
        stat: !0
    }, {
        withResolvers: function() {
            var r = t.f(this);
            return {
                promise: r.promise,
                resolve: r.resolve,
                reject: r.reject
            }
        }
    }),
    iR
}
var c3, lR;
function V5e() {
    if (lR)
        return c3;
    lR = 1,
    G5e(),
    pH();
    var e = Ho()
      , t = ar()
      , n = oH()
      , r = n.Promise
      , s = r.withResolvers;
    return c3 = function() {
        return e(s, t(this) ? this : r)
    }
    ,
    c3
}
var u3, cR;
function H5e() {
    if (cR)
        return u3;
    cR = 1;
    var e = V5e();
    return u3 = e,
    u3
}
var uR = {}, dR;
function z5e() {
    return dR || (dR = 1,
    pH()),
    uR
}
var d3, fR;
function $5e() {
    if (fR)
        return d3;
    fR = 1;
    var e = H5e();
    return z5e(),
    d3 = e,
    d3
}
$5e();
async function W5e() {
    performance.mark("polyfill.all.start"),
    await Promise.allSettled([G3e(), q3e(), V3e()]),
    performance.mark("polyfill.all.end"),
    performance.measure("polyfill.all", "polyfill.all.start", "polyfill.all.end")
}
const fg = ["light", "dark"]
  , eE = "(prefers-color-scheme: dark)"
  , K5e = typeof window > "u"
  , tE = h.createContext(void 0)
  , Y5e = {
    setTheme: e => {}
    ,
    themes: []
}
  , mH = () => {
    var e;
    return (e = h.useContext(tE)) !== null && e !== void 0 ? e : Y5e
}
  , Z5e = e => h.useContext(tE) ? Ne.createElement(h.Fragment, null, e.children) : Ne.createElement(X5e, e)
  , J5e = ["light", "dark"]
  , X5e = ({forcedTheme: e, disableTransitionOnChange: t=!1, enableSystem: n=!0, enableColorScheme: r=!0, storageKey: s="theme", themes: o=J5e, defaultTheme: i=n ? "system" : "light", attribute: a="data-theme", value: l, children: c, nonce: u}) => {
    const [d,f] = h.useState( () => hR(s, i))
      , [p,m] = h.useState( () => hR(s))
      , v = l ? Object.values(l) : o
      , _ = h.useCallback(C => {
        let w = C;
        if (!w)
            return;
        C === "system" && n && (w = pR());
        const x = l ? l[w] : w
          , E = t ? eSe() : null
          , T = document.documentElement;
        if (a === "class" ? (T.classList.remove(...v),
        x && T.classList.add(x)) : x ? T.setAttribute(a, x) : T.removeAttribute(a),
        r) {
            const k = fg.includes(i) ? i : null
              , A = fg.includes(w) ? w : k;
            T.style.colorScheme = A
        }
        E?.()
    }
    , [])
      , y = h.useCallback(C => {
        f(C);
        try {
            localStorage.setItem(s, C)
        } catch {}
    }
    , [e])
      , b = h.useCallback(C => {
        const w = pR(C);
        m(w),
        d === "system" && n && !e && _("system")
    }
    , [d, e]);
    h.useEffect( () => {
        const C = window.matchMedia(eE);
        return C.addListener(b),
        b(C),
        () => C.removeListener(b)
    }
    , [b]),
    h.useEffect( () => {
        const C = w => {
            w.key === s && y(w.newValue || i)
        }
        ;
        return window.addEventListener("storage", C),
        () => window.removeEventListener("storage", C)
    }
    , [y]),
    h.useEffect( () => {
        _(e ?? d)
    }
    , [e, d]);
    const S = h.useMemo( () => ({
        theme: d,
        setTheme: y,
        forcedTheme: e,
        resolvedTheme: d === "system" ? p : d,
        themes: n ? [...o, "system"] : o,
        systemTheme: n ? p : void 0
    }), [d, y, e, p, n, o]);
    return Ne.createElement(tE.Provider, {
        value: S
    }, Ne.createElement(Q5e, {
        forcedTheme: e,
        disableTransitionOnChange: t,
        enableSystem: n,
        enableColorScheme: r,
        storageKey: s,
        themes: o,
        defaultTheme: i,
        attribute: a,
        value: l,
        children: c,
        attrs: v,
        nonce: u
    }), c)
}
  , Q5e = h.memo( ({forcedTheme: e, storageKey: t, attribute: n, enableSystem: r, enableColorScheme: s, defaultTheme: o, value: i, attrs: a, nonce: l}) => {
    const c = o === "system"
      , u = n === "class" ? `var d=document.documentElement,c=d.classList;c.remove(${a.map(m => `'${m}'`).join(",")});` : `var d=document.documentElement,n='${n}',s='setAttribute';`
      , d = s ? fg.includes(o) && o ? `if(e==='light'||e==='dark'||!e)d.style.colorScheme=e||'${o}'` : "if(e==='light'||e==='dark')d.style.colorScheme=e" : ""
      , f = (m, v=!1, _=!0) => {
        const y = i ? i[m] : m
          , b = v ? m + "|| ''" : `'${y}'`;
        let S = "";
        return s && _ && !v && fg.includes(m) && (S += `d.style.colorScheme = '${m}';`),
        n === "class" ? S += v || y ? `c.add(${b})` : "null" : y && (S += `d[s](n,${b})`),
        S
    }
      , p = e ? `!function(){${u}${f(e)}}()` : r ? `!function(){try{${u}var e=localStorage.getItem('${t}');if('system'===e||(!e&&${c})){var t='${eE}',m=window.matchMedia(t);if(m.media!==t||m.matches){${f("dark")}}else{${f("light")}}}else if(e){${i ? `var x=${JSON.stringify(i)};` : ""}${f(i ? "x[e]" : "e", !0)}}${c ? "" : "else{" + f(o, !1, !1) + "}"}${d}}catch(e){}}()` : `!function(){try{${u}var e=localStorage.getItem('${t}');if(e){${i ? `var x=${JSON.stringify(i)};` : ""}${f(i ? "x[e]" : "e", !0)}}else{${f(o, !1, !1)};}${d}}catch(t){}}();`;
    return Ne.createElement("script", {
        nonce: l,
        dangerouslySetInnerHTML: {
            __html: p
        }
    })
}
, () => !0)
  , hR = (e, t) => {
    if (K5e)
        return;
    let n;
    try {
        n = localStorage.getItem(e) || void 0
    } catch {}
    return n || t
}
  , eSe = () => {
    const e = document.createElement("style");
    return e.appendChild(document.createTextNode("*{-webkit-transition:none!important;-moz-transition:none!important;-o-transition:none!important;-ms-transition:none!important;transition:none!important}")),
    document.head.appendChild(e),
    () => {
        window.getComputedStyle(document.body),
        setTimeout( () => {
            document.head.removeChild(e)
        }
        , 1)
    }
}
  , pR = e => (e || (e = window.matchMedia(eE)),
e.matches ? "dark" : "light");
function gH(e) {
    return e === "system" || vH(e)
}
function vH(e) {
    return e === "dark" || e === "light"
}
function tSe(e) {
    if (!gH(e))
        throw new Error(`Unexpected theme ${e}`)
}
function AIe() {
    const {theme: e, setTheme: t} = mH();
    function n(r) {
        tSe(r),
        r !== e && t(r)
    }
    return [gH(e) ? e : "system", n]
}
function nSe() {
    const e = mH().resolvedTheme;
    if (vH(e))
        return e
}
function rSe() {
    return nSe() === "dark"
}
function sSe() {
    return document.documentElement.classList.contains("dark")
}
const hg = new Lw;
class oSe {
    start = 0;
    connectTime = 0;
    hasLoggedGetSocketURL = !1;
    didLogPingFromWorker = !1;
    didLogPingFromServer = !1;
    pingId = Ts();
    actionMetadata = {};
    onFetchSocketURL = () => {
        if (!this.hasLoggedGetSocketURL) {
            const t = performance.now() - this.start;
            this.actionMetadata.socket_url_duration = t,
            this.actionMetadata.socket_url_time = t,
            q.addAction("ws.get-socket-url", this.actionMetadata),
            dr.hist(er.WEBSOCKET, "get-socket-url", [], t),
            this.hasLoggedGetSocketURL = !0
        }
    }
    ;
    #e = ({payload: t}) => {
        const {ping_id: n, source: r} = t;
        if (!(n != null && n !== this.pingId)) {
            if (r === "server" && !this.didLogPingFromServer) {
                this.didLogPingFromServer = !0;
                const s = performance.now() - this.start
                  , o = s - this.connectTime;
                this.actionMetadata.receive_server_ping_time = s,
                this.actionMetadata.receive_server_ping_duration = o,
                q.addAction("ws.receive-server-ping", this.actionMetadata),
                dr.hist(er.WEBSOCKET, "receive-server-ping", [], o)
            }
            if ((r === "worker" || r == null) && !this.didLogPingFromWorker) {
                this.didLogPingFromWorker = !0;
                const s = performance.now() - this.start
                  , o = s - this.connectTime;
                this.actionMetadata.receive_ping_time = s,
                this.actionMetadata.receive_ping_duration = o,
                q.addAction("ws.receive-ping", this.actionMetadata),
                dr.hist(er.WEBSOCKET, "receive-ping", [], o)
            }
            this.didLogPingFromWorker && this.didLogPingFromServer && hg.off("ping", this.#e)
        }
    }
    ;
    onInit() {
        q.addAction("ws.init"),
        dr.count(er.WEBSOCKET, "init"),
        this.start = performance.now()
    }
    onConnect() {
        if (!(this.connectTime > 0))
            try {
                this.connectTime = performance.now() - this.start;
                const t = this.connectTime - Number(this.actionMetadata.socket_url_time);
                this.actionMetadata.connect_time = this.connectTime,
                this.actionMetadata.connect_duration = t,
                q.addAction("ws.connect", this.actionMetadata),
                dr.hist(er.WEBSOCKET, "connect", [], t),
                hg.on("ping", this.#e),
                q.addAction("ws.send-ping", this.actionMetadata),
                ie.safePost("/celsius/ping", {
                    requestBody: {
                        ping_id: this.pingId
                    }
                })
            } catch (t) {
                q.addAction("ws.error", {
                    error: t
                }),
                dr.count(er.WEBSOCKET, "error")
            }
    }
}
const _H = en(e => Xe(e, "1281927149") ? new oSe : void 0);
(!globalThis.EventTarget || !globalThis.Event) && console.error(`
  PartySocket requires a global 'EventTarget' class to be available!
  You can polyfill this global by adding this to your code before any partysocket imports: 
  
  \`\`\`
  import 'partysocket/event-target-polyfill';
  \`\`\`
  Please file an issue at https://github.com/partykit/partykit if you're still having trouble.
`);
var yH = class extends Event {
    message;
    error;
    constructor(e, t) {
        super("error", t),
        this.message = e.message,
        this.error = e
    }
}
  , bH = class extends Event {
    code;
    reason;
    wasClean = !0;
    constructor(e=1e3, t="", n) {
        super("close", n),
        this.code = e,
        this.reason = t
    }
}
  , f3 = {
    Event,
    ErrorEvent: yH,
    CloseEvent: bH
};
function iSe(e, t) {
    if (!e)
        throw new Error(t)
}
function aSe(e) {
    return new e.constructor(e.type,e)
}
function lSe(e) {
    return "data"in e ? new MessageEvent(e.type,e) : "code"in e || "reason"in e ? new bH(e.code || 1999,e.reason || "unknown reason",e) : "error"in e ? new yH(e.error,e) : new Event(e.type,e)
}
var mR, cSe = typeof process < "u" && typeof ((mR = process.versions) == null ? void 0 : mR.node) < "u" && typeof document > "u", Lp = cSe ? lSe : aSe, rl = {
    maxReconnectionDelay: 1e4,
    minReconnectionDelay: 1e3 + Math.random() * 4e3,
    minUptime: 5e3,
    reconnectionDelayGrowFactor: 1.3,
    connectionTimeout: 4e3,
    maxRetries: Number.POSITIVE_INFINITY,
    maxEnqueuedMessages: Number.POSITIVE_INFINITY
}, gR = !1, _S = class cl extends EventTarget {
    _ws;
    _retryCount = -1;
    _uptimeTimeout;
    _connectTimeout;
    _shouldReconnect = !0;
    _connectLock = !1;
    _binaryType = "blob";
    _closeCalled = !1;
    _messageQueue = [];
    _debugLogger = console.log.bind(console);
    _url;
    _protocols;
    _options;
    constructor(t, n, r={}) {
        super(),
        this._url = t,
        this._protocols = n,
        this._options = r,
        this._options.startClosed && (this._shouldReconnect = !1),
        this._options.debugLogger && (this._debugLogger = this._options.debugLogger),
        this._connect()
    }
    static get CONNECTING() {
        return 0
    }
    static get OPEN() {
        return 1
    }
    static get CLOSING() {
        return 2
    }
    static get CLOSED() {
        return 3
    }
    get CONNECTING() {
        return cl.CONNECTING
    }
    get OPEN() {
        return cl.OPEN
    }
    get CLOSING() {
        return cl.CLOSING
    }
    get CLOSED() {
        return cl.CLOSED
    }
    get binaryType() {
        return this._ws ? this._ws.binaryType : this._binaryType
    }
    set binaryType(t) {
        this._binaryType = t,
        this._ws && (this._ws.binaryType = t)
    }
    get retryCount() {
        return Math.max(this._retryCount, 0)
    }
    get bufferedAmount() {
        return this._messageQueue.reduce( (n, r) => (typeof r == "string" ? n += r.length : r instanceof Blob ? n += r.size : n += r.byteLength,
        n), 0) + (this._ws ? this._ws.bufferedAmount : 0)
    }
    get extensions() {
        return this._ws ? this._ws.extensions : ""
    }
    get protocol() {
        return this._ws ? this._ws.protocol : ""
    }
    get readyState() {
        return this._ws ? this._ws.readyState : this._options.startClosed ? cl.CLOSED : cl.CONNECTING
    }
    get url() {
        return this._ws ? this._ws.url : ""
    }
    get shouldReconnect() {
        return this._shouldReconnect
    }
    onclose = null;
    onerror = null;
    onmessage = null;
    onopen = null;
    close(t=1e3, n) {
        if (this._closeCalled = !0,
        this._shouldReconnect = !1,
        this._clearTimeouts(),
        !this._ws) {
            this._debug("close enqueued: no ws instance");
            return
        }
        if (this._ws.readyState === this.CLOSED) {
            this._debug("close: already closed");
            return
        }
        this._ws.close(t, n)
    }
    reconnect(t, n) {
        this._shouldReconnect = !0,
        this._closeCalled = !1,
        this._retryCount = -1,
        !this._ws || this._ws.readyState === this.CLOSED ? this._connect() : (this._disconnect(t, n),
        this._connect())
    }
    send(t) {
        if (this._ws && this._ws.readyState === this.OPEN)
            this._debug("send", t),
            this._ws.send(t);
        else {
            const {maxEnqueuedMessages: n=rl.maxEnqueuedMessages} = this._options;
            this._messageQueue.length < n && (this._debug("enqueue", t),
            this._messageQueue.push(t))
        }
    }
    _debug(...t) {
        this._options.debug && this._debugLogger("RWS>", ...t)
    }
    _getNextDelay() {
        const {reconnectionDelayGrowFactor: t=rl.reconnectionDelayGrowFactor, minReconnectionDelay: n=rl.minReconnectionDelay, maxReconnectionDelay: r=rl.maxReconnectionDelay} = this._options;
        let s = 0;
        return this._retryCount > 0 && (s = n * t ** (this._retryCount - 1),
        s > r && (s = r)),
        this._debug("next delay", s),
        s
    }
    _wait() {
        return new Promise(t => {
            setTimeout(t, this._getNextDelay())
        }
        )
    }
    _getNextProtocols(t) {
        if (!t)
            return Promise.resolve(null);
        if (typeof t == "string" || Array.isArray(t))
            return Promise.resolve(t);
        if (typeof t == "function") {
            const n = t();
            if (!n)
                return Promise.resolve(null);
            if (typeof n == "string" || Array.isArray(n))
                return Promise.resolve(n);
            if (n.then)
                return n
        }
        throw Error("Invalid protocols")
    }
    _getNextUrl(t) {
        if (typeof t == "string")
            return Promise.resolve(t);
        if (typeof t == "function") {
            const n = t();
            if (typeof n == "string")
                return Promise.resolve(n);
            if (n.then)
                return n
        }
        throw Error("Invalid URL")
    }
    _connect() {
        if (this._connectLock || !this._shouldReconnect)
            return;
        this._connectLock = !0;
        const {maxRetries: t=rl.maxRetries, connectionTimeout: n=rl.connectionTimeout} = this._options;
        if (this._retryCount >= t) {
            this._debug("max retries reached", this._retryCount, ">=", t);
            return
        }
        this._retryCount++,
        this._debug("connect", this._retryCount),
        this._removeListeners(),
        this._wait().then( () => Promise.all([this._getNextUrl(this._url), this._getNextProtocols(this._protocols || null)])).then( ([r,s]) => {
            if (this._closeCalled) {
                this._connectLock = !1;
                return
            }
            !this._options.WebSocket && typeof WebSocket > "u" && !gR && (console.error(`â€¼ï¸ No WebSocket implementation available. You should define options.WebSocket. 

For example, if you're using node.js, run \`npm install ws\`, and then in your code:

import PartySocket from 'partysocket';
import WS from 'ws';

const partysocket = new PartySocket({
  host: "127.0.0.1:1999",
  room: "test-room",
  WebSocket: WS
});

`),
            gR = !0);
            const o = this._options.WebSocket || WebSocket;
            this._debug("connect", {
                url: r,
                protocols: s
            }),
            this._ws = s ? new o(r,s) : new o(r),
            this._ws.binaryType = this._binaryType,
            this._connectLock = !1,
            this._addListeners(),
            this._connectTimeout = setTimeout( () => this._handleTimeout(), n)
        }
        ).catch(r => {
            this._connectLock = !1,
            this._handleError(new f3.ErrorEvent(Error(r.message),this))
        }
        )
    }
    _handleTimeout() {
        this._debug("timeout event"),
        this._handleError(new f3.ErrorEvent(Error("TIMEOUT"),this))
    }
    _disconnect(t=1e3, n) {
        if (this._clearTimeouts(),
        !!this._ws) {
            this._removeListeners();
            try {
                this._ws.readyState === this.OPEN && this._ws.close(t, n),
                this._handleClose(new f3.CloseEvent(t,n,this))
            } catch {}
        }
    }
    _acceptOpen() {
        this._debug("accept open"),
        this._retryCount = 0
    }
    _handleOpen = t => {
        this._debug("open event");
        const {minUptime: n=rl.minUptime} = this._options;
        clearTimeout(this._connectTimeout),
        this._uptimeTimeout = setTimeout( () => this._acceptOpen(), n),
        iSe(this._ws, "WebSocket is not defined"),
        this._ws.binaryType = this._binaryType,
        this._messageQueue.forEach(r => {
            var s;
            return (s = this._ws) == null ? void 0 : s.send(r)
        }
        ),
        this._messageQueue = [],
        this.onopen && this.onopen(t),
        this.dispatchEvent(Lp(t))
    }
    ;
    _handleMessage = t => {
        this._debug("message event"),
        this.onmessage && this.onmessage(t),
        this.dispatchEvent(Lp(t))
    }
    ;
    _handleError = t => {
        this._debug("error event", t.message),
        this._disconnect(void 0, t.message === "TIMEOUT" ? "timeout" : void 0),
        this.onerror && this.onerror(t),
        this._debug("exec error listeners"),
        this.dispatchEvent(Lp(t)),
        this._connect()
    }
    ;
    _handleClose = t => {
        this._debug("close event"),
        this._clearTimeouts(),
        this._shouldReconnect && this._connect(),
        this.onclose && this.onclose(t),
        this.dispatchEvent(Lp(t))
    }
    ;
    _removeListeners() {
        this._ws && (this._debug("removeListeners"),
        this._ws.removeEventListener("open", this._handleOpen),
        this._ws.removeEventListener("close", this._handleClose),
        this._ws.removeEventListener("message", this._handleMessage),
        this._ws.removeEventListener("error", this._handleError))
    }
    _addListeners() {
        this._ws && (this._debug("addListeners"),
        this._ws.addEventListener("open", this._handleOpen),
        this._ws.addEventListener("close", this._handleClose),
        this._ws.addEventListener("message", this._handleMessage),
        this._ws.addEventListener("error", this._handleError))
    }
    _clearTimeouts() {
        clearTimeout(this._connectTimeout),
        clearTimeout(this._uptimeTimeout)
    }
}
;
/*!
 * Reconnecting WebSocket
 * by Pedro Ladaria <pedro.ladaria@gmail.com>
 * https://github.com/pladaria/reconnecting-websocket
 * License MIT
 */
let Qo = null;
function uSe(e, t) {
    let n = null;
    const r = () => {
        const s = Date.now()
          , o = n != null ? s - n.time : null;
        return n != null && o != null && o < t ? (q.addAction("websocket-url-cache.hit", {
            timeSinceLastValue: o
        }),
        n.promise) : (q.addAction("websocket-url-cache.miss", {
            timeSinceLastValue: o
        }),
        n = {
            promise: e().catch(i => {
                throw q.addAction("websocket-url-cache.error"),
                n = null,
                i
            }
            ),
            time: s
        },
        n.promise)
    }
    ;
    return r.invalidate = () => {
        q.addAction("websocket-url-cache.invalidate"),
        n = null
    }
    ,
    r
}
const CH = async () => (await ie.safeGet("/celsius/ws/user")).websocket_url
  , dSe = uSe(CH, 15e5);
function SH(e) {
    return Xe(e, "2892913572") ? dSe() : CH()
}
function fSe(e) {
    const t = _H(e);
    t?.onInit(),
    Qo = new _S(async () => {
        const r = await SH(e);
        return t?.onFetchSocketURL(),
        r
    }
    ,void 0,{
        maxRetries: 50,
        minReconnectionDelay: 1e3 + Math.random() * 4e3,
        reconnectionDelayGrowFactor: 1.25,
        maxReconnectionDelay: 2e4
    });
    let n;
    return Qo.addEventListener("open", () => {
        t?.onConnect(),
        Xe(e, "3274829134") && (n = setInterval( () => {
            Qo && Qo.readyState === _S.OPEN && Qo.send(JSON.stringify({
                type: "keepalive-ping"
            }))
        }
        , 2e4))
    }
    ),
    Qo.addEventListener("close", () => {
        n !== void 0 && (clearInterval(n),
        n = void 0)
    }
    ),
    Qo.addEventListener("message", r => {
        const s = JSON.parse(r.data)
          , {type: o, ...i} = s
          , a = {
            kind: o,
            ...i
        };
        hg.publish(a)
    }
    ),
    Qo.addEventListener("error", r => {
        q.addAction("websocket error", {
            error: r.error,
            message: r.message
        })
    }
    ),
    Qo
}
const vR = en( () => Pa(e => {
    const t = () => e();
    return window.addEventListener("focus", t),
    window.addEventListener("blur", t),
    document.addEventListener("visibilitychange", t),
    () => {
        window.removeEventListener("focus", t),
        window.removeEventListener("blur", t),
        document.removeEventListener("visibilitychange", t)
    }
}
, () => document.hasFocus(), {
    name: "isWindowFocused",
    getServerFallback: () => !0
}))
  , wH = en(e => new hSe(e));
function MIe(e, t) {
    return wH(e).getTopic(t)
}
class hSe {
    constructor(t) {
        this.ctx = t
    }
    ws;
    pingTest;
    nextRequestId = 1;
    commandCallbacks = {};
    topics = new Map;
    isTransportOpen = !1;
    isBatchingCommands = !1;
    batchCommands = [];
    keepaliveInterval;
    init() {
        this.pingTest = _H(this.ctx),
        this.pingTest?.onInit();
        const t = new _S(async () => {
            const n = await SH(this.ctx);
            return this.pingTest?.onFetchSocketURL(),
            n
        }
        ,void 0,{
            maxRetries: 50,
            minReconnectionDelay: 1e3 + Math.random() * 4e3,
            reconnectionDelayGrowFactor: 1.25,
            maxReconnectionDelay: 2e4
        });
        this.ws = t,
        t.addEventListener("open", () => {
            this.#e()
        }
        ),
        t.addEventListener("close", () => {
            this.#r()
        }
        ),
        t.addEventListener("message", n => {
            this.#n(n)
        }
        ),
        t.addEventListener("error", n => {
            this.#s(n)
        }
        ),
        this.#t()
    }
    connect() {
        this.ws.reconnect()
    }
    disconnect() {
        this.ws.close()
    }
    #e() {
        this.pingTest?.onConnect(),
        this.isTransportOpen = !0,
        this.startBatchCommands(),
        this.sendCommand({
            type: "connect",
            presence: {
                type: "presence",
                state: da(vR(this.ctx)) ? "foreground" : "background"
            }
        });
        for (const t of this.topics.values())
            t.state === 1 && t.subscribe();
        this.endBatchCommands(),
        Xe(this.ctx, "3274829134") && (this.keepaliveInterval = setInterval( () => {
            this.ws.send(JSON.stringify({
                type: "keepalive-ping"
            }))
        }
        , 2e4))
    }
    #t() {
        const t = vR(this.ctx);
        RP( () => t(), n => {
            this.isTransportOpen && this.sendCommand({
                type: "presence",
                state: n ? "foreground" : "background"
            })
        }
        )
    }
    #r() {
        this.isTransportOpen = !1;
        for (const t of this.topics.values())
            t.handleDisconnect();
        this.endBatchCommands(),
        this.keepaliveInterval && (clearInterval(this.keepaliveInterval),
        this.keepaliveInterval = void 0)
    }
    #n(t) {
        const n = JSON.parse(t.data);
        if (Array.isArray(n)) {
            const r = n;
            for (const s of r)
                if ("type"in s && s.type === "message") {
                    const {topic_id: o} = s
                      , i = this.topics.get(o);
                    i && i.handleMessage(s.payload)
                } else
                    "id"in s && "reply"in s && this.commandCallbacks[s.id].resolve(s.reply)
        } else {
            const r = n
              , {type: s, ...o} = r
              , i = {
                kind: s,
                ...o
            };
            hg.publish(i)
        }
    }
    #s(t) {
        q.addAction("websocket error", {
            error: t.error,
            message: t.message
        })
    }
    getTopic(t) {
        const n = this.topics.get(t);
        if (n)
            return n;
        const r = new pSe(t,this);
        return this.topics.set(t, r),
        r
    }
    startBatchCommands() {
        this.isBatchingCommands = !0,
        this.batchCommands = []
    }
    endBatchCommands() {
        this.isBatchingCommands = !1,
        this.ws.send(JSON.stringify(this.batchCommands)),
        this.batchCommands = []
    }
    async sendCommand(t) {
        const n = this.nextRequestId++;
        this.commandCallbacks[n] = Promise.withResolvers();
        const r = {
            id: n,
            command: t
        };
        this.isBatchingCommands ? this.batchCommands.push(r) : this.ws.send(JSON.stringify([r]));
        const s = await this.commandCallbacks[n].promise;
        return delete this.commandCallbacks[n],
        s
    }
}
class pSe {
    constructor(t, n) {
        this.topicId = t,
        this.client = n
    }
    state = 2;
    #e = new Lw;
    #t = !1;
    onMessage(t) {
        return this.#e.on("message", n => t(n.payload))
    }
    handleMessage(t) {
        this.#e.publish({
            kind: "message",
            payload: t
        })
    }
    handleDisconnect() {
        this.state = 1,
        this.#t = !1
    }
    async subscribe() {
        if (this.state !== 0 && (this.state = 1,
        this.client.isTransportOpen && !this.#t)) {
            this.#t = !0;
            const t = await this.client.sendCommand({
                type: "subscribe",
                topic_id: this.topicId
            });
            if (this.#t = !1,
            t.type === "subscribe" && t.topic_id === this.topicId)
                this.state = 0;
            else
                throw new Error("Unexpected reply to subscribe command")
        }
    }
    unsubscribe() {
        this.state !== 2 && ((this.state === 0 || this.#t) && this.client.sendCommand({
            type: "unsubscribe",
            topic_id: this.topicId
        }),
        this.state = 2)
    }
}
function mSe(e) {
    if (Xe(e, "1819663106")) {
        const t = wH(e);
        t.init(),
        t.getTopic("conversations").subscribe();
        return
    }
    Xe(e, "4141006638") && fSe(e)
}
function gSe(e) {
    yn(e) && (nne(e),
    Q2e(e),
    mSe(e))
}
let _R = !1;
function vSe(e) {
    _R || (_R = !0,
    gSe(e))
}
const _Se = h.createContext({
    cspScriptNonce: void 0
});
function IIe(e) {
    return un(e).windowStyle === "chatbar_view"
}
const yS = "_tm"
  , cf = "_m";
var ySe = (e => (e.SHARE_NOT_FOUND = "share_not_found",
e.SHARED_POST_NOT_FOUND = "shared_post_not_found",
e.GIZMO_NOT_FOUND = "gizmo_not_found",
e.PROJECT_NOT_FOUND = "project_not_found",
e.NO_ACCESS = "no_access",
e.OAUTH_SUCCESS = "oauth_success",
e.OAUTH_FAILED_GENERIC = "oauth_failed_generic",
e.OAUTH_FAILED_SCOPE_MISMATCH = "oauth_failed_scope_mismatch",
e.OAUTH_FAILED_EMAIL_DOMAIN_ENFORCEMENT = "oauth_failed_email_domain_enforcement",
e.CUSTOM_ERROR = "c_err",
e.CUSTOM_MSG = "c_msg",
e.ACCOUNT_TRANSFER_ERROR = "account_transfer_error",
e.MFA_ENABLED = "mfa_enabled",
e.ENABLE_MFA_ERROR = "enable_mfa_error",
e.DISABLE_MFA_SUCCESS = "disable_mfa_success",
e.DISABLE_MFA_TIMEOUT = "disable_mfa_timeout",
e.CANVAS_NOT_FOUND = "canvas_not_found",
e))(ySe || {});
function RIe(e, t="/", n) {
    const r = typeof window < "u"
      , s = new URL(t,r ? window.location.origin : "https://chatgpt.com");
    return s.searchParams.set(yS, e),
    (e === "c_err" || e === "c_msg") && (n ? s.searchParams.set(cf, n) : s.searchParams.set(cf, "An error has occurred")),
    s.pathname + s.search + s.hash
}
function bSe() {
    const [e] = Eg()
      , {pathname: t, hash: n} = cs()
      , r = oo()
      , s = gt()
      , o = Tn();
    h.useEffect( () => {
        const i = e.get(yS);
        if (i !== void 0) {
            const a = (l, c, u, d, f) => {
                const p = typeof l == "string" ? l : s.formatMessage(l);
                o[d](p, {
                    id: c,
                    duration: u,
                    hasCloseButton: f
                });
                const m = new URLSearchParams(e);
                m.delete(yS),
                m.delete(cf),
                r({
                    search: `?${m.toString()}`,
                    hash: n
                }, {
                    replace: !0
                })
            }
            ;
            switch (i) {
            case "share_not_found":
                q.addAction("global_toast.conversation_inaccessible", {
                    path: t
                }),
                a(ms.conversationInaccessible, "share_not_found", 10, "warning", !0);
                break;
            case "shared_post_not_found":
                a(ms.sharedPostNotFound, "shared_post_not_found", 10, "warning", !0);
                break;
            case "gizmo_not_found":
                a(ms.gizmoNotFound, "gizmo_not_found", 10, "warning", !0);
                break;
            case "project_not_found":
                a(ms.projectNotFound, "project_not_found", 10, "warning", !0);
                break;
            case "no_access":
                a(ms.noAccess, "no_access", 5, "warning", !0);
                break;
            case "oauth_success":
                a(ms.oauthSuccess, "oauth_success", 5, "success", !0);
                break;
            case "oauth_failed_generic":
                a(ms.oauthFailedGeneric, "oauth_failed_generic", 5, "warning", !0);
                break;
            case "oauth_failed_scope_mismatch":
                a(ms.oauthFailedScopeMismatch, "oauth_failed_scope_mismatch", 5, "warning", !0);
                break;
            case "oauth_failed_email_domain_enforcement":
                a(ms.oauthFailedEmailDomainEnforcement, "oauth_failed_email_domain_enforcement", 5, "warning", !0);
                break;
            case "c_msg":
                a(e.get(cf), "c_msg", 10, "success", !0);
                break;
            case "c_err":
                a(e.get(cf), "c_err", 5, "warning", !0);
                break;
            case "account_transfer_error":
                a({
                    id: "globalToasts.accountTransferError",
                    defaultMessage: "Error transferring account. To retry, go to Settings â†’ Merge.",
                    description: "Error when unable to transfer their personal account to the workspace"
                }, "account_transfer_error", 5, "warning", !0);
                break;
            case "mfa_enabled":
                a({
                    id: "enableMfa.success",
                    defaultMessage: "Multi-factor authentication enabled",
                    description: "Confirmation toast after an MFA enable action is successfully executed"
                }, "mfa_enabled", 5, "success", !0);
                break;
            case "enable_mfa_error":
                a({
                    id: "enrollMfa.failure",
                    defaultMessage: "Error occurred. Please try again.",
                    description: "Error toast after MFA token request failed"
                }, "enable_mfa_error", 5, "warning", !0);
                break;
            case "disable_mfa_success":
                a(ms.disableMfaSuccess, "disable_mfa_success", 5, "success", !0);
                break;
            case "disable_mfa_timeout":
                a(ms.disableMfaTimeout, "disable_mfa_timeout", 5, "warning", !0);
                break;
            case "canvas_not_found":
                a(ms.canvasNotFound, "canvas_not_found", 5, "warning", !1);
                break
            }
        }
    }
    , [s, o, t, e, r, n])
}
const ms = xt({
    conversationInaccessible: {
        id: "globalToasts.conversationInaccessible",
        defaultMessage: "Conversation inaccessible or not found. You may need to switch accounts or request access if this conversation exists."
    },
    sharedPostNotFound: {
        id: "globalToasts.sharedPostNotFound",
        defaultMessage: "This share is inaccessible or not found."
    },
    gizmoNotFound: {
        id: "globalToasts.gizmoNotFound",
        defaultMessage: "This GPT is inaccessible or not found. Ensure you are logged in, verify youâ€™re in the correct ChatGPT workspace, or request access if you believe you should have it, if it exists."
    },
    projectNotFound: {
        id: "globalToasts.projectNotFound",
        defaultMessage: "This project is inaccessible or not found. Ensure you are logged in, verify youâ€™re in the correct ChatGPT workspace, or request access if you believe you should have it, if it exists."
    },
    noAccess: {
        id: "globalToasts.noAccess",
        defaultMessage: "You do not currently have access to this feature"
    },
    oauthSuccess: {
        id: "globalToasts.oauthSuccess",
        defaultMessage: "Your account is now connected"
    },
    oauthFailedGeneric: {
        id: "globalToasts.oauthFailedGeneric",
        defaultMessage: "Something went wrong with setting up the connection"
    },
    oauthFailedScopeMismatch: {
        id: "globalToasts.oauthFailedScopeMismatch",
        defaultMessage: "Not all requested permissions were granted"
    },
    oauthFailedEmailDomainEnforcement: {
        id: "globalToasts.oauthFailedEmailDomainEnforcement",
        defaultMessage: "Your company has an enterprise workspace that manages connector access. Contact your enterprise admin to get access."
    },
    disableMfaSuccess: {
        id: "disableMfa.success",
        defaultMessage: "Multi-factor authentication disabled"
    },
    disableMfaTimeout: {
        id: "disableMfa.timeout",
        defaultMessage: "Your last log in was too long ago, please try again"
    },
    canvasNotFound: {
        id: "canvasNotFound",
        defaultMessage: "This canvas is inaccessible or not found. Ensure you are logged in, verify youâ€™re in the correct ChatGPT.com workspace, or request access if you believe you should have it, if it exists."
    }
});
let uc;
function CSe() {
    let e;
    return {
        promise: new Promise(n => {
            e = n
        }
        ),
        resolve: e
    }
}
const {promise: SSe, resolve: wSe} = CSe();
function NIe(e) {
    uc = e,
    wSe(e)
}
async function ESe() {
    try {
        const e = uc?.getHost();
        return e ? await e.getToolNames() : null
    } catch {
        return null
    }
}
const xSe = 6e4
  , TSe = "unqfp8es"
  , kSe = "kaur1br5"
  , PIe = "side_chat"
  , DIe = "ntp"
  , LIe = "website";
function Nh() {
    return uc?.getHost()
}
function OSe() {
    const [e,t] = h.useState( () => Nh());
    return h.useEffect( () => {
        if (e)
            return;
        let n = !0;
        return SSe.then(r => {
            n && t(r.getHost())
        }
        ),
        () => {
            n = !1
        }
    }
    , [e]),
    e
}
function FIe() {
    return uc?.getLinkHandler()
}
function jIe() {
    return uc?.getProductEventHandler()
}
function UIe(e, t, n) {
    return uc ? Promise.race([ASe(e, t, n), new Promise(r => setTimeout( () => r(null), xSe))]) : Promise.resolve(null)
}
async function ASe(e, t, n) {
    const r = await uc?.getSidebarWhisperContent();
    return !r || !r.content ? null : await xH(r, EH(e?.url), e, t, n)
}
function MSe(e, t) {
    return e.map(n => ({
        id: n.fileid,
        name: n.name,
        size: n.size,
        mime_type: n.mimetype,
        ...t && {
            kaur1br5: {
                source: {
                    url: t.url,
                    host: t.url ? new URL(t.url).hostname : void 0,
                    title: t.title
                }
            }
        }
    }))
}
function EH(e) {
    return e ? `${TSe} - ${e}` : void 0
}
async function xH(e, t, n, r, s) {
    if (s?.includes(xe.Agent))
        return;
    const {imageAssetPointers: o, content: i, files: a} = e;
    if (!i)
        throw new Error("Whisper content is missing content");
    let l;
    if (o) {
        const c = o.map(d => ({
            content_type: Jn.ImageAssetPointer,
            asset_pointer: d.assetPointer,
            size_bytes: d.sizeBytes,
            width: d.width,
            height: d.height
        }))
          , u = i;
        l = {
            content_type: rt.MultimodalText,
            parts: [...c, u]
        }
    } else
        l = {
            content_type: rt.Text,
            parts: [i]
        };
    return h1(l, {
        is_visually_hidden_from_conversation: !0,
        attachments: MSe(a ?? [], n),
        exclusive_key: t,
        ...await ISe(n, r, "context", s)
    })
}
async function BIe(e, t, n) {
    if (!(!e || !ao() || !$r.whisperContent))
        return await xH($r.whisperContent, EH(e.url), e, t, n)
}
async function ISe(e, t, n, r) {
    const s = u => {
        const d = u.trim();
        if ("Intl"in window && "Segmenter"in Intl) {
            const f = navigator.language || "en-US"
              , m = new Intl.Segmenter(f,{
                granularity: "word"
            }).segment(d);
            let v = 0;
            for (const _ of m)
                _.isWordLike && v++;
            return v
        }
        return d.split(/\s+/).filter(f => f.length > 0).length
    }
      , o = r?.includes(xe.Agent) === !0;
    let i, a;
    if (!o && e?.selection) {
        const u = e.selection;
        a = s(u),
        i = u.length > 1e3 ? u.substring(0, 1e3) : u
    }
    let l;
    try {
        const u = Nh();
        u && (l = await u.getClientID())
    } catch {}
    const c = {
        origin: t,
        type: n,
        client_id: l,
        sources: e ? [{
            id: e.id,
            url: e.url,
            host: e.url ? new URL(e.url).hostname : void 0,
            title: e.title,
            ...i && {
                selection: i,
                selection_word_count: a
            },
            base64favicon: e.base64favicon ?? void 0
        }] : []
    };
    return {
        [kSe]: c
    }
}
const TH = DS("Conversation")
  , n0 = en( () => ({
    conversations: {},
    newClientIdToServerId: {},
    allKnownConversationIds$: Ct([])
}));
function RSe(e) {
    return {
        id: e,
        serverId$: Ct(to(e))
    }
}
function Va(e, t) {
    const {conversations: n, newClientIdToServerId: r} = n0(e);
    if (n[t] != null)
        return n[t];
    if (hh(t)) {
        const o = r[t];
        if (o != null && n[o] != null)
            return n[o]
    }
    const s = RSe(t);
    return n[t] = s,
    PSe(e),
    s
}
function NSe(e, t, n) {
    const r = Va(e, t);
    r.serverId$.set(n);
    const {conversations: s, newClientIdToServerId: o} = n0(e);
    delete s[t],
    s[n] = r,
    hh(t) && (o[t] = n,
    Du.setServerIdForNewThread(t, n))
}
function qIe(e) {
    const {conversations: t, allKnownConversationIds$: n} = n0(e);
    return n(),
    Object.values(t)
}
let h3;
function PSe(e) {
    h3 == null && (h3 = window.setTimeout( () => {
        const {conversations: t, allKnownConversationIds$: n} = n0(e);
        n.set(Object.keys(t)),
        h3 = void 0
    }
    , 100))
}
const GIe = h.createContext(void 0)
  , yu = Ei( () => ({
    activeRequests: {}
}))
  , VIe = e => {
    const {activeRequests: t} = yu.getState();
    return t[e] ?? null
}
  , kH = e => Xl(yu, e);
function HIe(e) {
    return kH(t => OH(e, t))
}
function OH(e, t=yu.getState()) {
    return e != null && t.activeRequests[e] != null
}
function zIe() {
    return kH(e => Object.keys(e.activeRequests).length > 0)
}
const uf = {
    addRequest(e, t, n) {
        yu.setState(r => ({
            activeRequests: {
                ...r.activeRequests,
                [e]: {
                    id: e,
                    abortController: t,
                    turnTracker: n
                }
            }
        }))
    },
    removeRequest(e) {
        yu.setState(t => {
            const n = {
                ...t.activeRequests
            };
            return delete n[e],
            {
                activeRequests: n
            }
        }
        )
    },
    abortRequest(e) {
        const {activeRequests: t} = yu.getState();
        return t[e] != null ? (t[e].abortController.abort(),
        uf.removeRequest(e),
        !0) : !1
    }
};
function DSe(e, t, n, r=void 0, s={}) {
    if (r === void 0) {
        const i = sn(e);
        r = Ce.getLastMessageSystemHints(i).includes(xe.Agent)
    }
    if (!r)
        return;
    const o = {
        client_thread_id: String(e),
        client_initiated: t,
        is_agent_conversation: !0,
        reason: n,
        ...s
    };
    q.addAction("conversation.stop_attempted", {
        ...o
    }),
    V.logEvent("Agent Conversation Stop", {
        ...o,
        system_hint: "agent"
    })
}
const AH = TH( () => Ct(null));
function MH(e) {
    return AH(e)()
}
function IH(e, t) {
    const n = AH(e);
    LSe(da( () => n()), t) && n.set(t)
}
function LSe(e, t) {
    return !(e?.value === Ar.REALTIME && t?.value === Ar.STREAMING)
}
const $Ie = e => {
    const t = ue();
    return is( () => {
        if (e === void 0)
            return null;
        const n = Va(t, e);
        return MH(n)
    }
    )
}
  , nE = (e, t) => {
    const n = Va(e, t);
    return MH(n)
}
  , dl = (e, t) => {
    const n = Va(Ot(), e);
    IH(n, t)
}
;
async function RH(e, t=Ce.getRequestId(sn(e)), {clientInitiated: n=!1, reason: r="other", isAgentConversation: s=void 0}={}) {
    const o = OH(t)
      , i = Ot()
      , a = sn(e)
      , l = to(e)
      , c = nE(i, e)
      , u = c?.value === Ar.REALTIME
      , d = c?.value === Ar.STREAMING
      , f = Ce.getCurrentNode(a)
      , p = a?.stopConduitToken ?? null
      , v = ( () => {
        const S = f?.message;
        return S ? Yne(S) : !1
    }
    )()
      , _ = d && f?.message?.metadata?.model_slug?.endsWith("-pro");
    if (!o && !u && !_ && !(d && n))
        return;
    kt(e, S => {
        S.interruptionInProgress = !0
    }
    );
    let b;
    if (l && Xe(i, "3922476776")) {
        const S = {
            requestBody: {
                conversation_id: l,
                check_async_status: u || _ && !o
            },
            authOption: Qt.SendIfAvailable,
            ...p ? {
                additionalHeaders: {
                    "x-conduit-token": p
                }
            } : {}
        };
        b = await ie.safePost("/stop_conversation", S),
        p && kt(e, w => {
            w.stopConduitToken = null
        }
        );
        const C = () => (a ? Ce.getLastMessageSystemHints(a) : []).includes(xe.Agent);
        try {
            DSe(e, n, r, s === void 0 ? C() : s)
        } catch (w) {
            Qr.error("Error logging abort completion attempt for analytics", {
                error: w
            })
        }
    }
    return o && !v && uf.abortRequest(t),
    kt(e, S => {
        S.interruptionInProgress = !1
    }
    ),
    b
}
const pg = new Set
  , WIe = e => {
    h.useEffect( () => (pg.add(e),
    () => {
        pg.delete(e)
    }
    ), [e])
}
  , FSe = () => pg.size > 0
  , jSe = () => Promise.allSettled(Array.from(pg).map(e => e()));
class USe {
    completionStartTime = Date.now();
    completionEndTime;
    blurDuringCompletionTime;
    refocusTime;
    constructor() {
        window.addEventListener("blur", this.onWindowBlur)
    }
    logFocusAfterBlurDuringCompletionEvent = () => {
        ft.logEvent("chatgpt_focus_after_blur_during_completion", null, {
            completion_duration_ms: `${this.completionEndTime - this.completionStartTime}`,
            blur_time_ms: `${this.blurDuringCompletionTime - this.completionStartTime}`,
            refocus_time_ms: `${this.refocusTime - this.completionStartTime}`
        }),
        V.logEvent("Focus After Blur During Completion", {
            completion_duration_ms: `${this.completionEndTime - this.completionStartTime}`,
            blur_time_ms: `${this.blurDuringCompletionTime - this.completionStartTime}`,
            refocus_time_ms: `${this.refocusTime - this.completionStartTime}`
        })
    }
    ;
    onWindowBlur = () => {
        this.blurDuringCompletionTime === void 0 && (this.blurDuringCompletionTime = Date.now(),
        window.addEventListener("focus", this.onWindowFocusAfterBlur))
    }
    ;
    onWindowFocusAfterBlur = () => {
        this.refocusTime = Date.now(),
        this.completionEndTime !== void 0 && this.logFocusAfterBlurDuringCompletionEvent(),
        this.cleanupFocusAfterBlurListener()
    }
    ;
    cleanupFocusAfterBlurListener = () => {
        window.removeEventListener("focus", this.onWindowFocusAfterBlur)
    }
    ;
    onMessageError = () => {
        window.removeEventListener("blur", this.onWindowBlur)
    }
    ;
    onMessageDone = () => {
        window.removeEventListener("blur", this.onWindowBlur),
        this.blurDuringCompletionTime !== void 0 && (this.completionEndTime = Date.now(),
        ft.logEvent("chatgpt_blur_during_completion", null, {
            completion_duration_ms: `${this.completionEndTime - this.completionStartTime}`,
            blur_time_ms: `${this.blurDuringCompletionTime - this.completionStartTime}`
        }),
        V.logEvent("Blur During Completion", {
            completion_duration_ms: `${this.completionEndTime - this.completionStartTime}`,
            blur_time_ms: `${this.blurDuringCompletionTime - this.completionStartTime}`
        }),
        this.refocusTime !== void 0 && this.logFocusAfterBlurDuringCompletionEvent())
    }
}
const bS = new Set
  , KIe = e => {
    h.useEffect( () => (bS.add(e),
    () => {
        bS.delete(e)
    }
    ), [e])
}
  , yR = e => {
    for (const t of bS)
        try {
            t({
                error: e
            })
        } catch (n) {
            q.addError(n)
        }
}
  , ad = dn( () => ({
    messagesDevData: {},
    activeNodeId: void 0,
    ui: {
        focusedNodeId: void 0
    }
}))
  , BSe = () => ad.getState().ui.focusedNodeId
  , ld = () => ad.getState().messagesDevData;
function YIe(e) {
    const t = Object.keys(ld())
      , n = t.indexOf(e);
    if (n === -1)
        throw new Error("Key not found in object");
    const r = (n + 1) % t.length;
    return t[r]
}
function ZIe(e) {
    const t = Object.keys(ld())
      , n = t.indexOf(e);
    if (n === -1)
        throw new Error("Key not found in object");
    const r = (n - 1 + t.length) % t.length;
    return t[r]
}
function JIe(e) {
    return Object.keys(ld()).indexOf(e)
}
const XIe = () => Object.keys(ld()).length;
var p3, bR;
function qSe() {
    if (bR)
        return p3;
    bR = 1;
    function e(t, n) {
        for (var r, s = -1, o = t.length; ++s < o; ) {
            var i = n(t[s]);
            i !== void 0 && (r = r === void 0 ? i : r + i)
        }
        return r
    }
    return p3 = e,
    p3
}
var m3, CR;
function GSe() {
    if (CR)
        return m3;
    CR = 1;
    var e = qSe()
      , t = NaN;
    function n(r, s) {
        var o = r == null ? 0 : r.length;
        return o ? e(r, s) / o : t
    }
    return m3 = n,
    m3
}
var g3, SR;
function VSe() {
    if (SR)
        return g3;
    SR = 1;
    var e = GSe()
      , t = aw();
    function n(r) {
        return e(r, t)
    }
    return g3 = n,
    g3
}
var HSe = VSe();
const zSe = mn(HSe);
function $Se(e) {
    return e.length === 0 ? null : e.reduce( (n, r) => n + r, 0) / e.length
}
function WSe(e) {
    const t = e.length;
    if (t === 0)
        return 0;
    const n = $Se(e) || 0
      , r = e.reduce( (s, o) => s + Math.pow(o - n, 2), 0) / t;
    return Math.sqrt(r)
}
function wR(e, t) {
    const n = e.slice().sort( (a, l) => a - l)
      , r = t * (n.length - 1)
      , s = Math.floor(r)
      , o = Math.ceil(r);
    if (s === o)
        return n[s];
    const i = r - s;
    return (1 - i) * n[s] + i * n[o]
}
function KSe(e) {
    if (e.length === 0)
        return null;
    const t = e.slice().sort( (r, s) => r - s)
      , n = Math.floor(t.length / 2);
    return t.length % 2 === 0 ? (t[n - 1] + t[n]) / 2 : t[n]
}
var Us = (e => (e.FirstTokenLatency = "first_token_lat",
e.TotalRequestTime = "total_request_time",
e.TokenCount = "token_count",
e.StdDevTokenLatency = "std_dev_token_lat",
e.MeanTokenLatency = "mean_token_lat",
e.MedianTokenLatency = "median_token_lat",
e.MinTokenLatency = "min_token_lat",
e.MaxTokenLatency = "max_token_lat",
e.P95TokenLatency = "p95_token_lat",
e.P99TokenLatency = "p99_token_lat",
e))(Us || {});
const NH = e => {
    const t = e.filter(f => f.requestCount > 1);
    let n = 0;
    for (let f = 0; f < e.length; f++) {
        const p = e[f];
        if (n = p.requestDuration,
        p.content !== "")
            break
    }
    const r = wR(t.map(f => f.lastTokenDuration), .95)
      , s = wR(t.map(f => f.lastTokenDuration), .99)
      , o = zSe(t.map(f => f.lastTokenDuration))
      , i = KSe(t.map(f => f.lastTokenDuration))
      , a = t.filter(f => f.lastTokenDuration !== 0).reduce( (f, p) => Math.min(f, p.lastTokenDuration), 1 / 0)
      , l = t.reduce( (f, p) => Math.max(f, p.lastTokenDuration), -1 / 0)
      , c = WSe(t.map(f => f.lastTokenDuration))
      , u = e[e.length - 1]?.requestDuration;
    return [{
        id: "first_token_lat",
        name: "First Token lat.",
        stat: n > 0 ? `${n.toFixed(2)}ms` : null,
        value: n > 0 ? n : null,
        category: "summary"
    }, {
        id: "total_request_time",
        name: "Total request time",
        stat: u ? `${(u / 1e3).toFixed(2)}s` : null,
        value: u || null,
        category: "summary"
    }, {
        id: "token_count",
        name: "Token count",
        stat: `${e.length}`,
        value: e.length,
        category: "summary"
    }, {
        id: "std_dev_token_lat",
        name: "Std dev Token lat.",
        stat: `${c.toFixed(2)}`,
        value: c,
        category: "token"
    }, {
        id: "mean_token_lat",
        name: "Mean Token lat.",
        stat: o ? `${o.toFixed(2)}ms` : null,
        value: o ?? null,
        category: "aggregate"
    }, {
        id: "median_token_lat",
        name: "Median Token lat.",
        stat: i ? `${i.toFixed(2)}ms` : null,
        value: i ?? null,
        category: "token"
    }, {
        id: "min_token_lat",
        name: "Min Token lat.",
        stat: `${a.toFixed(2)}ms`,
        value: a ?? null,
        category: "token"
    }, {
        id: "max_token_lat",
        name: "Max Token lat.",
        stat: `${l.toFixed(2)}ms`,
        value: l ?? null,
        category: "token"
    }, {
        id: "p95_token_lat",
        name: "p95 Token lat.",
        stat: r ? `${r.toFixed(2)}ms` : null,
        value: r ?? null,
        category: "aggregate"
    }, {
        id: "p99_token_lat",
        name: "p99 Token lat.",
        stat: s ? `${s.toFixed(2)}ms` : null,
        value: s ?? null,
        category: "aggregate"
    }]
}
  , QIe = () => {
    const e = ld()
      , t = BSe();
    if (!e || !t)
        return {
            stats: [],
            targetLatencyData: []
        };
    const r = e[t]?.data ?? [];
    return {
        stats: NH(r),
        targetLatencyData: r
    }
}
  , YSe = (e, t, n, r) => {
    ad.setState(s => {
        const o = {
            focusedNodeId: e
        }
          , i = {
            status: "active",
            data: [],
            model: t,
            serverRequestId: n,
            preflightTime: r
        };
        return {
            ...s,
            activeNodeId: e,
            ui: o,
            messagesDevData: {
                ...s.messagesDevData,
                [e]: i
            }
        }
    }
    )
}
  , ZSe = (e, t, n) => {
    const r = n?.search_source;
    ad.setState(s => {
        const o = s.messagesDevData[e];
        return {
            ...s,
            activeNodeId: e,
            messagesDevData: {
                ...s.messagesDevData,
                [e]: {
                    ...o,
                    data: [...o?.data ?? [], t],
                    searchSource: r
                }
            }
        }
    }
    )
}
  , yo = (e, t) => t.find(n => n.id === e)?.value
  , JSe = e => {
    if (!yn(Ot()))
        return;
    const n = ld()[e]
      , r = NH(n.data)
      , {preflightTime: s, model: o, serverRequestId: i, searchSource: a} = n;
    return ie.safePost("/lat/r", {
        requestBody: {
            server_request_id: i,
            model: o,
            preflight_time_ms: s,
            search_source: a,
            count_tokens: yo(Us.TokenCount, r) ?? 0,
            ts_first_token_ms: yo(Us.FirstTokenLatency, r),
            ts_max_token_time_ms: yo(Us.MaxTokenLatency, r),
            ts_mean_token_without_first_ms: yo(Us.MeanTokenLatency, r),
            ts_median_token_without_first_ms: yo(Us.MedianTokenLatency, r),
            ts_min_token_time_ms: yo(Us.MinTokenLatency, r),
            ts_p95_token_without_first_ms: yo(Us.P95TokenLatency, r),
            ts_p99_token_without_first_ms: yo(Us.P99TokenLatency, r),
            ts_std_dev_token_ms: yo(Us.StdDevTokenLatency, r),
            ts_total_request_ms: yo(Us.TotalRequestTime, r)
        }
    })
}
  , XSe = e => ad.setState(t => {
    const n = {
        ...t.messagesDevData[e],
        status: "finished"
    };
    return {
        ...t,
        messagesDevData: {
            ...t.messagesDevData,
            [e]: n
        }
    }
}
)
  , eRe = e => ad.setState(t => ({
    ...t,
    ui: {
        ...t.ui,
        focusedNodeId: e
    }
}));
class QSe {
    constructor(t, n) {
        this.requestLatencyId = t,
        this.requestStartTime = n,
        this.requestLastTokenTime = n
    }
    requestLastTokenTime;
    requestCount = 0;
    requestTimes = [];
    onResponse(t, n, r) {
        const s = performance.now()
          , o = s - this.requestLastTokenTime
          , i = s - this.requestStartTime;
        this.requestLastTokenTime = s,
        this.requestCount += 1;
        const a = {
            requestCount: this.requestCount,
            requestDuration: i,
            lastTokenDuration: Number(JSON.stringify(o)),
            messageType: n.content.content_type,
            content: jm(n) ? m1(n) : ""
        };
        this.requestTimes.push(a),
        t.type === "message" ? ZSe(this.requestLatencyId, a, n.metadata) : t.type === "done" && r != null && (XSe(this.requestLatencyId),
        JSe(this.requestLatencyId))
    }
}
const e6e = (e, t) => {
    const {isCompletion: n, messageId: r, conversationId: s, flagged: o, blocked: i, disclaimers: a, metadata: l, shouldDisableConversation: c} = e
      , u = !!a?.length;
    kt(t, d => {
        kr.updateTree(d, f => {
            const p = f.messageIdToNodeId(r);
            i && f.clearNodeMessageParts(p);
            const m = i
              , v = l?.safety_limited ?? !1;
            f.updateNodeMetadata(p, {
                ...(u && !!a?.length && BL(a, i)) ?? {},
                ...o && jL,
                ...i && qL({
                    isSafetyLimited: v,
                    shouldDisableConversation: c,
                    isModelIncompatibility: m
                }),
                ...c && UL,
                completionSampleFinishTime: Date.now()
            })
        }
        )
    }
    ),
    V.logEvent(n ? i ? "Moderation: Completion Content Blocked" : "Moderation: Completion Content Flagged" : i ? "Moderation: Prompt Content Blocked" : "Moderation: Prompt Content Flagged", {
        threadId: s,
        id: r
    })
}
;
var v3, ER;
function PH() {
    if (ER)
        return v3;
    ER = 1;
    var e = KL()
      , t = ih()
      , n = YG()
      , r = CB();
    function s(o, i) {
        if (o == null)
            return {};
        var a = e(r(o), function(l) {
            return [l]
        });
        return i = t(i),
        n(o, a, function(l, c) {
            return i(l, c[0])
        })
    }
    return v3 = s,
    v3
}
var t6e = PH();
const DH = mn(t6e)
  , xR = {
    base_config: void 0,
    eval_preset: void 0,
    sonicberry_model_ids: void 0,
    settings_overrides: void 0,
    dump_sub_conversation: void 0
};
dn(e => ({
    settings: LH(),
    setSettings: t => {
        e({
            settings: t
        }),
        ze.setCookie(Be.InternalSearchSettings, JSON.stringify(t), {
            maxAge: 2 * 365 * 24 * 60 * 60
        })
    }
}));
function LH() {
    let e;
    try {
        const t = ze.getCookie(Be.InternalSearchSettings);
        e = t ? JSON.parse(t) : xR
    } catch {
        e = xR
    }
    return DH(e, t => !!t)
}
const FH = (e=Ot(), t=!1) => yn(e) ? bn(e)?.planType === We.FREE ? $t(e, "3178812292", {
    disableExposureLog: t
}) : $t(e, "3703416703", {
    disableExposureLog: t
}) : $t(e, "2861477803", {
    disableExposureLog: t
})
  , n6e = (e=Ot()) => {
    const t = Th().fConversationEndpoint;
    return t === "convo2" ? !0 : t === "convo1" ? !1 : Xe(e, "4154476537") ? !0 : FH(e, !0).get("use_f_prepare", !1)
}
  , rE = (e=Ot(), t=!1) => {
    const n = Th().fConversationEndpoint;
    return n === "convo2" ? !0 : n === "convo1" ? !1 : Xe(e, "4154476537") ? !0 : FH(e, t).get("use_f_convo", !1)
}
  , r6e = () => LH().fast_search ?? !1;
function TR(e, t) {
    ph.setState(n => {
        const r = n.threads[e];
        if (r)
            r.prepareRequestBlocked = t,
            t || (r.lastCompletionFinishedTimestamp = performance.now());
        else {
            const s = to(e);
            if (s) {
                const o = n.threads[s];
                o && (o.prepareRequestBlocked = t,
                t || (o.lastCompletionFinishedTimestamp = performance.now()))
            }
        }
    }
    )
}
const s6e = "starredConversations"
  , tRe = 5
  , kR = "snorlaxConversations"
  , nRe = ja.div`text-sm text-red-500`
  , o6e = 5
  , i6e = 25
  , a6e = 40
  , l6e = e => {
    switch (e) {
    case We.FREE:
        return o6e;
    case We.GO:
    case We.PLUS:
    case We.EDUCATION_CBP:
    case We.QUORUM:
    case We.DEPRECATED_EDU:
        return i6e;
    case We.DEPRECATED_ENTERPRISE:
    case We.PRO:
    case We.SELF_SERVE_BUSINESS:
    case We.ENTERPRISE_CBP:
        return a6e
    }
}
;
function rRe({accountPlanType: e, numFiles: t}) {
    return !e || ![We.FREE, We.GO, We.PLUS].includes(e) ? !1 : t >= l6e(e)
}
const c6e = "disable_history"
  , sRe = "user_latency_tools"
  , oRe = "mfa"
  , iRe = "chatgpt_allow_workspace_instruction"
  , aRe = "workspace_ip_allowlist";
var u6e = (e => (e.BrowsingAvailable = "browsing_available",
e.Sunshine = "sunshine_available",
e.WorkspaceGPTCustomActions = "workspace_gpt_custom_actions",
e.WorkspaceShareLinks = "workspace_share_links",
e.GizmoSupportEmails = "gizmo_support_emails",
e.D3Editor = "d3_editor",
e.D3EditorAllGpts = "d3_editor_gpts",
e.DataAnalysisV2 = "graphite",
e.ChartSerialization = "chart_serialization",
e.SearchTool = "search_tool",
e.SearchToolHoldout = "search_tool_holdout",
e.MemoryInSearch = "memory_in_search",
e.Canvas = "canvas",
e.CanvasCodeExecution = "canvas_code_execution",
e.CanvasCodeNetworkAccess = "canvas_code_network_access",
e.GizmoCanvasToggle = "gizmo_canvas_toggle",
e.Moonshine = "moonshine",
e.VideoScreenSharing = "video_screen_sharing",
e.DeepResearch = "caterpillar",
e.AllowVoiceUse = "breeze_available",
e.ImageGenToggle = "image_gen_toggle",
e))(u6e || {});
const d6e = 28
  , sE = "conversationHistory"
  , f6e = "conversation-history"
  , h6e = 1
  , oE = en( () => Ct([]));
function p6e(e, t, n) {
    if (!Xe(e, "1753085879"))
        return;
    oE(e).set(s => {
        const o = s.findIndex(i => i.conversationId === t);
        if (o !== -1) {
            const i = s.slice();
            return i[o] = {
                ...i[o],
                title: n
            },
            i
        }
        return [{
            conversationId: t,
            title: n
        }, ...s]
    }
    )
}
function jH() {
    return h$({
        queryKey: [sE],
        queryFn: async ({pageParam: e}) => {
            const t = await ie.safeGet("/conversations", {
                parameters: {
                    query: {
                        offset: e,
                        limit: d6e,
                        order: "updated",
                        is_archived: !1,
                        is_starred: !1
                    }
                },
                intercomEventOnError: "fetch-error:conversations:get",
                authOption: Qt.SendIfAvailable
            });
            return q.addFirstTiming("load.conversationHistory"),
            VY( () => {
                const n = oE(Ot())
                  , r = da( () => n());
                for (const s of t.items) {
                    if (s.async_status != null) {
                        const o = Va(Ot(), s.id);
                        IH(o, {
                            source: wo.SERVER,
                            value: s.async_status
                        })
                    }
                    r.some(o => o.conversationId === s.id) && n.set(o => o.filter(i => i.conversationId !== s.id))
                }
            }
            ),
            t
        }
        ,
        initialPageParam: 0,
        getNextPageParam: e => {
            const t = (e.offset ?? 0) + (e.limit ?? 0);
            return t < (e.total ?? 0) ? t : void 0
        }
    })
}
function lRe(e={}) {
    "use forget";
    const {buckets: t, recentConversationLimit: n} = e
      , s = IL()?.includes(c6e) ?? !1
      , o = ue()
      , i = bn(o)
      , a = !s && !!i
      , l = gt()
      , c = A4()
      , u = is( () => oE(o)())
      , d = c
      , f = y1(f6e, h6e, [sE])
      , {data: p, fetchNextPage: m, hasNextPage: v, isLoading: _, isFetchingNextPage: y, isError: b, refetch: S} = PS({
        ...jH(),
        enabled: a,
        refetchOnReconnect: d ? "always" : !0,
        refetchOnWindowFocus: d ? "always" : !0,
        placeholderData: f
    })
      , C = h.useMemo( () => {
        const E = p?.pages.flatMap(k => k.items) ?? [];
        return [...u.map(k => ({
            id: k.conversationId,
            title: k.title
        })).filter(k => !E.some(A => A.id === k.id)), ...E]
    }
    , [p, u])
      , w = h.useMemo( () => {
        if (!p || !t)
            return [];
        const E = m6e(C, l);
        return [E.recent, E.dynamicMonths, E.dynamicYears].flatMap(k => Object.entries(k).map( ([A,{items: O, label: M}], I) => ({
            key: `${A}-${I}`,
            label: M,
            items: O
        }))).filter(k => k.items.length > 0)
    }
    , [C, p, l, t])
      , x = h.useMemo( () => {
        const E = C.slice(0, n ?? 5);
        return {
            key: "recents",
            label: l.formatMessage($d.historyBucketRecent),
            items: E
        }
    }
    , [C, n, l]);
    return {
        buckets: w,
        conversations: C,
        data: p,
        fetchNextPage: m,
        hasNextPage: v,
        refetch: S,
        recents: x,
        isLoading: _,
        isFetchingNextPage: y,
        isError: b
    }
}
function m6e(e, t) {
    return e.reduce( (n, r) => {
        const s = new Date(r.update_time ?? r.create_time ?? 0)
          , o = jB(new Date, s);
        if (o === 0)
            n.recent.today.items.push(r);
        else if (o <= 1)
            n.recent.yesterday.items.push(r);
        else if (o <= 7)
            n.recent.lastSeven.items.push(r);
        else if (o <= 30)
            n.recent.lastThirty.items.push(r);
        else if (Fme(s)) {
            const i = CO(s)
              , a = Nme(s)
              , l = `${i}-${a}`;
            n.dynamicMonths[l] ? n.dynamicMonths[l].items.push(r) : n.dynamicMonths[l] = {
                label: t.formatDate(s, {
                    month: "long"
                }),
                items: [r]
            }
        } else {
            const a = `${CO(s)}-`;
            n.dynamicYears[a] ? n.dynamicYears[a].items.push(r) : n.dynamicYears[a] = {
                label: t.formatDate(s, {
                    year: "numeric"
                }),
                items: [r]
            }
        }
        return n
    }
    , {
        recent: {
            today: {
                label: t.formatMessage($d.historyBucketToday),
                items: []
            },
            yesterday: {
                label: t.formatMessage($d.historyBucketYesterday),
                items: []
            },
            lastSeven: {
                label: t.formatMessage($d.historyBucketLastSeven),
                items: []
            },
            lastThirty: {
                label: t.formatMessage($d.historyBucketLastThirty),
                items: []
            }
        },
        dynamicMonths: {},
        dynamicYears: {}
    })
}
function UH(e, t) {
    e.invalidateQueries({
        queryKey: [sE]
    }),
    e.invalidateQueries({
        queryKey: [s6e]
    }),
    t ? e.invalidateQueries({
        queryKey: [kR, {
            gizmoId: t
        }]
    }) : e.invalidateQueries({
        queryKey: [kR]
    })
}
function g6e(e, t, n) {
    Aa(e).setQueryData(jH().queryKey, r => {
        if (r !== void 0)
            return Bs(r, s => {
                for (const o of s.pages)
                    for (const i of o.items)
                        i.id === t && (i.title = n)
            }
            )
    }
    )
}
const $d = xt({
    historyBucketRecent: {
        id: "history.bucket.recent",
        defaultMessage: "Recent"
    },
    historyBucketToday: {
        id: "history.bucket.today",
        defaultMessage: "Today"
    },
    historyBucketYesterday: {
        id: "history.bucket.yesterday",
        defaultMessage: "Yesterday"
    },
    historyBucketLastSeven: {
        id: "history.bucket.lastSeven",
        defaultMessage: "Previous 7 Days"
    },
    historyBucketLastThirty: {
        id: "history.bucket.lastThirty",
        defaultMessage: "Previous 30 Days"
    }
});
function v6e(e) {
    window.history.pushState({}, "", e)
}
function BH(e, t, n, r) {
    kt(t, s => {
        s.title = n,
        s.titleSource = r
    }
    ),
    du.publish({
        kind: "updateThreadTitle",
        conversationId: t
    }),
    g6e(e, t, n)
}
function _6e(e, t, n) {
    const s = Ce.getCurrentNode(sn(t)).message.id;
    ie.safePost("/conversation/gen_title/{conversation_id}", {
        parameters: {
            path: {
                conversation_id: t
            }
        },
        requestBody: {
            message_id: s
        },
        intercomEventOnError: "fetch-error:conversation:generate-title",
        authOption: Qt.SendIfAvailable
    }).then( ({title: o}) => {
        const i = Ce.getGizmoId(sn(t));
        BH(e, t, o, Fw.Generated),
        UH(Aa(e), i),
        V.logEvent("Rename Thread", {
            threadId: t,
            content: o,
            model: n
        })
    }
    )
}
function y6e(e, t, n, r, s) {
    const o = Ce.getGizmoId(sn(n));
    o != null ? TCe(t, o).then(i => {
        if (r) {
            e(Np(n, i));
            return
        }
        v6e(Np(n, i))
    }
    ).catch(i => {
        q.addError(i),
        e(Np(n))
    }
    ) : e(Np(n))
}
var So = (e => (e.Unavailable = "unavailable",
e.Thinking = "thinking",
e.Generating = "generating",
e.AsyncGenerating = "async_generating",
e.AsyncHanging = "async_hanging",
e.Complete = "complete",
e.Errored = "errored",
e.Empty = "empty",
e))(So || {});
const b6e = ["generating", "async_generating", "async_hanging", "thinking"]
  , C6e = "sj1i4kz"
  , bu = `${bl.T2UAY3K}.${C6e}`;
function iE(e) {
    return e.author.role === "tool" && e.author.name === bu && e.content.content_type === rt.MultimodalText
}
function S6e(e, {skipSort: t}={
    skipSort: !1
}) {
    let n = e.filter(o => iE(o) && !o.metadata?.is_visually_hidden_from_conversation);
    t || (n = [...n].sort( (o, i) => (o.metadata?.generation_index ?? 0) - (i.metadata?.generation_index ?? 0)));
    const r = n.flatMap(o => nw.getImageAssetPointers(o))
      , s = n.map(o => o.id);
    return {
        imageAssetPointers: r,
        messageIds: s
    }
}
const qH = (e, t) => {
    const n = e.find(v => v.author.role === Ke.Tool && [rt.Error, rt.SystemError].includes(v.content.content_type) || v.metadata?.is_error)
      , {imageAssetPointers: r} = S6e(e)
      , s = r.length > 0
      , i = e.some(v => iE(v)) && !s
      , a = e.some(v => {
        if (v.metadata?.image_gen_async)
            return !1;
        const _ = v.author.name === bl.IMAGE_GEN_HALLUCINATED || v.author.name === bu
          , y = v.content.content_type === rt.Text
          , b = !!v.metadata?.is_visually_hidden_from_conversation;
        return _ && y && b
    }
    )
      , l = e.length > 0 && !!e[e.length - 1]?.metadata?.image_gen_async
      , u = !e.some(v => [bu, bl.IMAGE_GEN_HALLUCINATED].includes(v.author.name ?? "") && v.content.content_type === rt.MultimodalText) && e.some(v => {
        const _ = [bu, bl.IMAGE_GEN_HALLUCINATED].includes(v.author.name ?? "")
          , y = v.recipient === "assistant";
        return _ && y
    }
    );
    let d = 0;
    for (const v of r) {
        const _ = v.height
          , y = v.metadata?.generation?.height ?? void 0;
        d += _ !== void 0 && y !== void 0 ? y / _ : 0
    }
    const f = r.length > 0 ? d / r.length : 0
      , p = n !== void 0
      , m = t ? So.AsyncGenerating : So.AsyncHanging;
    if (i || a || u)
        return So.Empty;
    if (p)
        return So.Errored;
    if (f) {
        if (f < 1)
            return l ? m : So.Generating;
        if (f === 1)
            return So.Complete
    } else
        return l ? m : So.Thinking;
    return So.Unavailable
}
  , w6e = e => qH([e], !0) === So.Complete
  , E6e = e => e.author.role === Ke.Assistant && e.recipient === bu;
function cRe(e) {
    return (e.author.name === bu || E6e(e)) && b6e.includes(qH([e], !0))
}
const x6e = ["notificationSettings"];
class T6e {
    static async getOrCreateSubscription({endpoint: t, p256dh: n, auth: r}) {
        return ie.safePost("/notifications/subscription/register", {
            requestBody: {
                platform: "web",
                web_metadata: {
                    endpoint: t,
                    p256dh: n
                },
                token: r
            }
        })
    }
    static async getSettings() {
        return ie.safeGet("/notifications/settings")
    }
    static async updateSettings(t) {
        const {category: n, ...r} = t;
        return ie.safePatch("/notifications/settings", {
            requestBody: {
                updates: {
                    [n]: r
                }
            }
        })
    }
}
const k6e = 1e4
  , GH = dn(Da( () => ({
    notifications: []
})))
  , O6e = e => {
    const t = crypto.randomUUID();
    GH.setState(r => {
        r.notifications.push({
            ...e,
            id: t
        })
    }
    );
    const n = e.timeout ?? k6e;
    setTimeout( () => {
        A6e(t)
    }
    , n)
}
  , A6e = e => {
    GH.setState(t => {
        t.notifications = t.notifications.filter(n => n.id !== e)
    }
    )
}
  , uRe = ({onSuccess: e, alwaysRefetchOnMount: t=!1}) => At({
    queryKey: x6e,
    queryFn: async () => {
        const r = (await T6e.getSettings()).settings;
        return e?.(r),
        r
    }
    ,
    refetchOnMount: t ? "always" : !0
});
function M6e(e, t) {
    return t && (e?.kind === cn.GizmoInteraction || e?.kind === cn.PrimaryAssistant) ? {
        gizmo_id: t,
        kind: cn.GizmoInteraction
    } : e
}
function I6e(e) {
    return e == null || [cn.PrimaryAssistant, cn.GizmoInteraction].includes(e.kind)
}
function dRe(e, t) {
    "use forget";
    const n = De.c(5);
    let r;
    n[0] !== t ? (r = i => M6e(i?.mode, t),
    n[0] = t,
    n[1] = r) : r = n[1];
    const s = Ai(e, r)
      , {data: o} = OV(s != null && "gizmo_id"in s ? s.gizmo_id : void 0, s?.kind === cn.GizmoTest);
    if (s != null)
        switch (s.kind) {
        case cn.GizmoInteraction:
        case cn.GizmoMagicCreate:
        case cn.GizmoTest:
            {
                let i;
                return n[2] !== s || n[3] !== o ? (i = {
                    gizmo: o,
                    ...s
                },
                n[2] = s,
                n[3] = o,
                n[4] = i) : i = n[4],
                i
            }
        case cn.FlyingCircusCustomization:
        case cn.PrimaryAssistant:
            return s
        }
}
const mg = dn(Da( () => null))
  , R6e = {
    updateDetails: e => {
        ["beacon_banner_info", "beacon_modal_info"].includes(e.ui_info.type) && mg.setState( () => ({
            ...e
        }), !0)
    }
    ,
    dismiss: () => {
        mg.setState( () => null, !0)
    }
};
function fRe() {
    return mg(e => e?.ui_info.type === "beacon_banner_info" ? e : null)
}
function hRe() {
    return mg(e => e?.ui_info.type === "beacon_modal_info" ? e : null)
}
function N6e(e, t) {
    if (e.length <= t)
        return e;
    const n = e.slice(0, Math.min(e.length, t + 20))
      , r = n.lastIndexOf(".")
      , s = n.lastIndexOf("!")
      , o = n.lastIndexOf("?")
      , i = Math.max(r, s, o);
    if (i > 0 && i <= t && i >= Math.floor(t * .4))
        return e.slice(0, i + 1).trim() + "â€¦";
    const a = e.lastIndexOf(" ", t);
    return a > Math.floor(t * .25) ? e.slice(0, a).trim() + "â€¦" : e.slice(0, t).trim() + "â€¦"
}
function P6e(e, t={}) {
    const {maxLength: n=120, includeUrls: r=!1} = t;
    if (e == null)
        return e;
    let s = String(e);
    s = s.replace(/^\s*:::[^\n]*\r?\n?/gm, ""),
    s = s.replace(/```[\s\S]*?```/g, " "),
    s = s.replace(/`([^`]+)`/g, "$1"),
    s = s.replace(/!\[[^\]]*\]\((?:.*?)\)/g, ""),
    r ? (s = s.replace(/\[([^\]]+)\]\((https?:\/\/[^\s)]+)\)/g, (o, i, a) => `${i} (${a})`),
    s = s.replace(/\[([^\]]+)\]\((?!https?:\/\/)(.*?)\)/g, "$1")) : s = s.replace(/\[([^\]]+)\]\((?:.*?)\)/g, "$1"),
    s = s.replace(/(^|\s)#{1,6}\s+/g, "$1"),
    s = s.replace(/(^|\s)>\s+/g, "$1"),
    s = s.replace(/(^|\n)([-*+]|\d+\.)\s+/g, "$1"),
    s = s.replace(/(^|\n)-{3,}(\n|$)/g, " "),
    s = s.replace(/(\*\*|__|\*|_|~~)/g, ""),
    s = s.replace(/\r\n|\n|\r/g, " "),
    s = s.replace(/\s{2,}/g, " ");
    {
        let o = "";
        for (let i = 0; i < s.length; i++) {
            const a = s.charCodeAt(i);
            a >= 32 && a !== 127 && (o += s[i])
        }
        s = o
    }
    return s = s.trim(),
    N6e(s, n)
}
const pRe = "https://help.openai.com/en/articles/8590148-memory-faq";
function VH(e, t=!0) {
    return ["memories", {
        gizmoId: e,
        includeMemoryEntries: t
    }]
}
function mRe(e, t=!0, n=!0) {
    return At({
        queryKey: VH(e, t),
        queryFn: async () => {
            const r = await ie.safeGet("/memories", {
                parameters: {
                    query: {
                        gizmo_id: e,
                        include_memory_entries: t
                    }
                }
            })
              , s = Math.min(Math.floor(100 * r.memory_num_tokens / r.memory_max_tokens), 100);
            return {
                ...r,
                memoryFullPct: s
            }
        }
        ,
        refetchOnMount: "always",
        enabled: n
    })
}
const D6e = (e, t) => {
    window.__reactRouterDataRouter.navigate(e, t)
}
  , HH = {
    [fr.LoggedIn]: Ft.LoggedInUserMessageCount,
    [fr.LoggedOut]: Ft.NoAuthUserMessageCount
}
  , L6e = dn(Da( () => ({
    messageCountByAuthStatus: {
        [fr.LoggedIn]: OR(fr.LoggedIn),
        [fr.LoggedOut]: OR(fr.LoggedOut)
    }
})));
function gRe(e) {
    return e.messageCountByAuthStatus[fr.LoggedOut]
}
function vRe(e) {
    return e.messageCountByAuthStatus[fr.LoggedIn]
}
const F6e = {
    incrementUserMessageCount: e => {
        L6e.setState(t => {
            const n = t.messageCountByAuthStatus[e] + 1;
            t.messageCountByAuthStatus[e] = n,
            j6e({
                authStatus: e,
                messageCount: n
            })
        }
        )
    }
};
function OR(e) {
    const t = localStorage.getItem(HH[e]);
    return t ? Number(t) : 0
}
function j6e({authStatus: e, messageCount: t}) {
    localStorage.setItem(HH[e], String(t))
}
const U6e = "gpt-5-thinking"
  , B6e = e => {
    const t = $t(e, "790459319");
    return {
        showJuiceControl: t.get("show-juice-control", !1),
        legacyDefault: t.get("legacy-juice-default", !1)
    }
}
  , q6e = en( () => Jre(Ft.ModelCustomConfig, () => ({})));
function G6e(e, t, n) {
    return e[t]?.effort ?? (n ? "extended" : "standard")
}
function AR(e) {
    return !(e.type === "perf_stats" || e.type === "server_ste_metadata" || e.type === "message_marker")
}
var Gt = (e => (e.Starter = "starter",
e.Reply = "reply",
e.Capabilities = "capabilities",
e.Autocomplete = "autocomplete",
e.Trending = "trending",
e))(Gt || {})
  , V6e = (e => (e.Search = "Search",
e.Canvas = "Canvas",
e.Image = "Image",
e.ContextualAnswers = "ContextualAnswers",
e.ContextualAnswersNUX = "ContextualAnswersNUX",
e.ChatGPTTrending = "ChatGPTTrending",
e.ImageGenTrending = "ImageGenTrending",
e.Slurm = "Slurm",
e.Tatertot = "Tatertot",
e))(V6e || {});
let df = null;
async function zH() {
    return df == null && (df = await ESe()),
    df ?? []
}
function _Re(e) {
    return df == null ? !1 : df.includes(e)
}
var ni = (e => (e.Success = "success",
e.Error = "error",
e.Canceled = "canceled",
e))(ni || {});
async function *$H(e, t) {
    let n = null;
    for await(const r of e)
        if ("response"in r)
            yield r;
        else if (r.event === "delta_encoding") {
            const s = String(r.data);
            if (t?.(s),
            s === "v1")
                n = new H6e;
            else
                throw new Error(`[delta] unknown delta encoding: ${s}`)
        } else if (r.event === "delta") {
            if (!n)
                throw new Error("[delta] delta event before delta_encoding");
            yield{
                data: n.applyDelta(r.data)
            }
        } else
            yield r
}
var WH = (e => (e.V1 = "v1",
e))(WH || {});
class H6e {
    prevObjByChannel = [];
    prevDelta = {
        channel: 0,
        op: "add",
        path: "",
        value: void 0
    };
    applyDelta(t) {
        try {
            const n = this.decodeDelta(t)
              , r = n.channel
              , s = this.prevObjByChannel[r]
              , o = W6e(s, n);
            return this.prevObjByChannel[r] = o,
            o
        } catch (n) {
            q.addError(`Error applying delta: ${n}`)
        }
    }
    decodeDelta(t) {
        $6e(t);
        const n = z6e(t, this.prevDelta)
          , r = KH(n);
        return this.prevDelta = r,
        r
    }
}
function z6e(e, t) {
    for (const [n,r] of YH)
        n !== "value" && !(r in e) && (e[r] = t[n]);
    return e
}
function KH(e) {
    const t = e;
    for (const [n,r] of YH)
        r in e && (t[n] = e[r],
        delete e[r]);
    return t.op === "patch" && (t.value = t.value.map(KH)),
    t
}
function $6e(e) {
    if (!e || typeof e != "object")
        throw new Error("Unexpected delta non-object")
}
const YH = [["channel", "c"], ["path", "p"], ["op", "o"], ["value", "v"]];
function W6e(e, t) {
    return Bs({
        __root: e
    }, r => ZH(r, t)).__root
}
function ZH(e, t) {
    const n = Z6e(t.path ?? "");
    for (let s = 0; s < n.length - 1; s++)
        e[n[s]] === void 0 && (typeof n[s + 1] == "number" ? e[n[s]] = [] : e[n[s]] = {}),
        e = e[n[s]];
    const r = n[n.length - 1];
    switch (t.op) {
    case "patch":
        for (const s of t.value) {
            const o = {
                __root: e[r]
            };
            ZH(o, s),
            e[r] = o.__root
        }
        break;
    case "add":
        Array.isArray(e) ? e.splice(r, 0, t.value) : e[r] = t.value;
        break;
    case "remove":
        Array.isArray(e) ? e.splice(r, 1) : delete e[r];
        break;
    case "replace":
        e[r] = t.value;
        break;
    case "append":
        if (typeof e[r] == "string")
            e[r] += t.value;
        else if (Array.isArray(e[r]))
            e[r].push(...J6e(t.value));
        else if (MR(e[r]) && MR(t.value))
            for (const s in t.value)
                e[r][s] = t.value[s];
        else
            e[r] = t.value;
        break;
    case "truncate":
        e[r] && (typeof e[r] == "string" ? e[r] = e[r].substring(0, t.value) : Array.isArray(e[r]) && (e[r].length = t.value));
        break;
    default:
        throw new Error("Unknown json delta operation")
    }
}
function K6e(e) {
    return e.replace(/~1/g, "/").replace(/~0/g, "~")
}
const Y6e = /^(?:0|[1-9]\d*)$/d;
function Z6e(e) {
    const t = ["__root"];
    if (e === "")
        return t;
    e[0] === "/" && (e = e.substring(1));
    for (const n of e.split("/"))
        Y6e.test(n) ? t.push(parseInt(n, 10)) : t.push(K6e(n));
    return t
}
function J6e(e) {
    return Array.isArray(e) ? e : [e]
}
function MR(e) {
    return typeof e == "object" && e != null && !Array.isArray(e)
}
function X6e(e) {
    let t = !1;
    const n = []
      , r = [];
    function s(l) {
        n.length > 0 ? n.shift()(l) : r.push(l)
    }
    function o(l) {
        t || s({
            value: l,
            done: !1
        })
    }
    function i() {
        t || (t = !0,
        n.forEach(l => l({
            value: void 0,
            done: !0
        })),
        n.length = 0)
    }
    function a(l) {
        t || (s(Promise.reject(l)),
        i())
    }
    try {
        e(o, i, a)
    } catch (l) {
        a(l)
    }
    return {
        next() {
            return new Promise(l => {
                r.length > 0 ? l(r.shift()) : t ? l({
                    value: void 0,
                    done: !0
                }) : n.push(l)
            }
            )
        },
        [Symbol.asyncIterator]() {
            return this
        }
    }
}
async function Q6e(e, t) {
    const n = e.getReader();
    let r;
    for (; !(r = await n.read()).done; )
        t(r.value)
}
function ewe(e) {
    let t, n, r, s = !1;
    return function(i) {
        t === void 0 ? (t = i,
        n = 0,
        r = -1) : t = nwe(t, i);
        const a = t.length;
        let l = 0;
        for (; n < a; ) {
            s && (t[n] === 10 && (l = ++n),
            s = !1);
            let c = -1;
            for (; n < a && c === -1; ++n)
                switch (t[n]) {
                case 58:
                    r === -1 && (r = n - l);
                    break;
                case 13:
                    s = !0;
                case 10:
                    c = n;
                    break
                }
            if (c === -1)
                break;
            e(t.subarray(l, c), r),
            l = n,
            r = -1
        }
        l === a ? t = void 0 : l !== 0 && (t = t.subarray(l),
        n -= l)
    }
}
function twe(e, t, n) {
    let r = IR();
    const s = new TextDecoder;
    return function(i, a) {
        if (i.length === 0)
            n?.(r),
            r = IR();
        else if (a > 0) {
            const l = s.decode(i.subarray(0, a))
              , c = a + (i[a + 1] === 32 ? 2 : 1)
              , u = s.decode(i.subarray(c));
            switch (l) {
            case "data":
                r.data = r.data ? r.data + `
` + u : u;
                break;
            case "event":
                r.event = u;
                break;
            case "id":
                e(r.id = u);
                break;
            case "retry":
                const d = parseInt(u, 10);
                isNaN(d) || t(r.retry = d);
                break
            }
        }
    }
}
function nwe(e, t) {
    const n = new Uint8Array(e.length + t.length);
    return n.set(e),
    n.set(t, e.length),
    n
}
function IR() {
    return {
        data: "",
        event: "",
        id: "",
        retry: void 0
    }
}
var rwe = function(e, t) {
    var n = {};
    for (var r in e)
        Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
    if (e != null && typeof Object.getOwnPropertySymbols == "function")
        for (var s = 0, r = Object.getOwnPropertySymbols(e); s < r.length; s++)
            t.indexOf(r[s]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[s]) && (n[r[s]] = e[r[s]]);
    return n
};
const CS = "text/event-stream"
  , swe = 1e3
  , RR = "last-event-id";
function owe(e, t) {
    var {signal: n, headers: r, onopen: s, onmessage: o, onclose: i, onerror: a, openWhenHidden: l, fetch: c} = t
      , u = rwe(t, ["signal", "headers", "onopen", "onmessage", "onclose", "onerror", "openWhenHidden", "fetch"]);
    return new Promise( (d, f) => {
        const p = Object.assign({}, r);
        p.accept || (p.accept = CS);
        let m;
        function v() {
            m.abort(),
            document.hidden || w()
        }
        l || document.addEventListener("visibilitychange", v);
        let _ = swe
          , y = 0;
        function b() {
            document.removeEventListener("visibilitychange", v),
            window.clearTimeout(y),
            m.abort()
        }
        n?.addEventListener("abort", () => {
            b(),
            d()
        }
        );
        const S = c ?? window.fetch
          , C = s ?? iwe;
        async function w() {
            var x;
            m = new AbortController;
            try {
                const E = await S(e, Object.assign(Object.assign({}, u), {
                    headers: p,
                    signal: m.signal
                }));
                await C(E),
                await Q6e(E.body, ewe(twe(T => {
                    T ? p[RR] = T : delete p[RR]
                }
                , T => {
                    _ = T
                }
                , o))),
                i?.(),
                b(),
                d()
            } catch (E) {
                if (!m.signal.aborted)
                    try {
                        const T = (x = a?.(E)) !== null && x !== void 0 ? x : _;
                        window.clearTimeout(y),
                        y = window.setTimeout(w, T)
                    } catch (T) {
                        b(),
                        f(T)
                    }
            }
        }
        w()
    }
    )
}
function iwe(e) {
    const t = e.headers.get("content-type");
    if (!t?.startsWith(CS))
        throw new Error(`Expected content-type to be ${CS}, Actual: ${t}`)
}
function awe(e) {
    if (typeof navigator < "u" && !navigator.onLine || e instanceof TypeError)
        return !0;
    if (e instanceof Error) {
        const t = e.message.toLowerCase();
        if (t.includes("failed to fetch") || t.includes("networkerror when attempting to fetch resource") || t.includes("network error") || t.includes("load failed") || t.includes("failed to resolve") || t.includes("dns") || /\b(enotfound|eai_again|eaddrinfo|econnrefused|econnreset|etimedout)\b/.test(t))
            return !0
    }
    return !1
}
function NR(e) {
    return e.headers.get("x-request-id") ?? e.headers.get("cf-ray") ?? void 0
}
function JH(e, {ctx: t, method: n, headers: r, body: s, intercomEventOnError: o, signal: i, observer: a}={}) {
    return X6e( (l, c, u) => {
        let d = !1;
        function f(v) {
            if (d)
                return v;
            d = !0;
            try {
                return u(v),
                a?.onClose?.("error", v),
                v
            } finally {
                v instanceof _t ? (eL(v, "stream"),
                tL(v),
                o && F6(o, {
                    url: v.url,
                    message: v.message
                })) : (q.addError(v),
                V.logEvent("request_stream_error", {
                    error: v instanceof Error ? v.message : String(v)
                }))
            }
        }
        function p() {
            if (!d)
                if (d = !0,
                i?.aborted) {
                    const v = i.reason ?? new DOMException("Aborted","AbortError");
                    u(v),
                    a?.onClose?.("aborted", v)
                } else
                    c(),
                    a?.onClose?.("completed")
        }
        const m = t ? Xf(t) : void 0;
        owe(e, {
            method: n,
            credentials: "include",
            headers: {
                ...m ? t1({
                    accessToken: m
                }) : e1(),
                ...s ? {
                    "Content-Type": "application/json"
                } : null,
                ...r
            },
            body: s ? JSON.stringify(s) : void 0,
            signal: i,
            openWhenHidden: !0,
            async onopen(v) {
                const _ = v.headers.get("content-type") ?? "";
                if (v.ok && _.includes("text/event-stream"))
                    l({
                        response: v
                    }),
                    a?.onOpen?.(v);
                else if (_.includes("application/json")) {
                    const y = await v.json();
                    throw f(new _t(e,v.status,y,NR(v)))
                } else {
                    const y = await v.text();
                    throw f(new _t(e,v.status,{
                        detail: {
                            message: I$,
                            code: "unexpected_content_type",
                            contentType: _,
                            text: y.substring(0, 1e3)
                        }
                    },NR(v)))
                }
            },
            onmessage(v) {
                const _ = new TextEncoder
                  , y = v.data === "[DONE]";
                if (a?.onEvent?.({
                    byteLength: _.encode(v.data).length,
                    isDoneEvent: y
                }),
                v.event === "ping" || !v.data)
                    return;
                if (y) {
                    p();
                    return
                }
                const b = JSON.parse(v.data);
                b.error ? f(_t.createWithErrorMessage(e, "server", b.error)) : l({
                    event: v.event || void 0,
                    data: b
                })
            },
            onerror(v) {
                const _ = v instanceof Error ? v : new Error(JSON.stringify(v));
                throw awe(_) ? f(_t.createWithErrorMessage(e, "client", Al)) : _.message === "Failed to fetch" ? (V.logFailedToFetchError({
                    source: "request_stream"
                }),
                f(_t.createWithErrorMessage(e, "server", `An error occurred. Either the engine you requested does not exist or there was another issue processing your request. ${LS}`))) : f(_)
            }
        }).then(p, f)
    }
    )
}
function lwe(e) {
    let t = 2166136261;
    for (let n = 0; n < e.length; n++)
        t ^= e.charCodeAt(n),
        t = Math.imul(t, 16777619) >>> 0;
    return t ^= t >>> 16,
    t = Math.imul(t, 2246822507) >>> 0,
    t ^= t >>> 13,
    t = Math.imul(t, 3266489909) >>> 0,
    t ^= t >>> 16,
    (t >>> 0).toString(16).padStart(8, "0")
}
class cwe {
    answers = new Map;
    maxAttempts = 5e5;
    requirementsSeed = uwe();
    sid = Ts();
    errorPrefix = "wQ8Lk5FbGpA2NcR9dShT6gYjU7VxZ4D";
    async initializeAndGatherData(t) {
        this._getAnswer(t)
    }
    async startEnforcement(t) {
        this._getAnswer(t)
    }
    getEnforcementTokenSync(t) {
        const n = this._getAnswer(t);
        return typeof n == "string" ? n : null
    }
    async getEnforcementToken(t, n) {
        return this._getAnswer(t, n?.forceSync)
    }
    async getRequirementsToken() {
        return this.answers.has(this.requirementsSeed) || this.answers.set(this.requirementsSeed, this._generateAnswerAsync(this.requirementsSeed, "0")),
        "gAAAAAC" + await this.answers.get(this.requirementsSeed)
    }
    getRequirementsTokenBlocking() {
        return "gAAAAAC" + this._generateRequirementsTokenAnswerBlocking()
    }
    _getAnswer(t, n=!1) {
        const r = "gAAAAAB";
        if (!t?.proofofwork?.required)
            return null;
        const {seed: s, difficulty: o} = t.proofofwork;
        if (!(typeof s == "string" && typeof o == "string"))
            return null;
        const i = this.answers.get(s);
        if (typeof i == "string")
            return i;
        if (n) {
            const a = this._generateAnswerSync(s, o)
              , l = r + a;
            return this.answers.set(s, l),
            l
        }
        return this.answers.has(s) || this.answers.set(s, this._generateAnswerAsync(s, o)),
        Promise.resolve().then(async () => r + await this.answers.get(s)).then(a => (this.answers.set(s, a),
        a))
    }
    _runCheck = (t, n, r, s, o) => {
        s[3] = o,
        s[9] = Math.round(performance.now() - t);
        const i = Fp(s);
        return lwe(n + i).substring(0, r.length) <= r ? i + "~S" : null
    }
    ;
    buildGenerateFailMessage(t) {
        return this.errorPrefix + Fp(String(t ?? "e"))
    }
    _generateAnswerSync(t, n) {
        const r = performance.now();
        try {
            const s = this.getConfig();
            for (let o = 0; o < this.maxAttempts; o++) {
                const i = this._runCheck(r, t, n, s, o);
                if (i)
                    return i
            }
        } catch (s) {
            return this.buildGenerateFailMessage(s)
        }
        return this.buildGenerateFailMessage()
    }
    async _generateAnswerAsync(t, n) {
        const r = performance.now();
        try {
            let s = null;
            const o = this.getConfig();
            for (let i = 0; i < this.maxAttempts; i++) {
                (!s || s.timeRemaining() <= 0) && (s = await fwe());
                const a = this._runCheck(r, t, n, o, i);
                if (a)
                    return a
            }
        } catch (s) {
            return this.buildGenerateFailMessage(s)
        }
        return this.buildGenerateFailMessage()
    }
    _generateRequirementsTokenAnswerBlocking() {
        let t = "e";
        const n = performance.now();
        try {
            const r = this.getConfig();
            return r[3] = 1,
            r[9] = Math.round(performance.now() - n),
            Fp(r)
        } catch (r) {
            t = Fp(String(r))
        }
        return this.errorPrefix + t
    }
    getConfig() {
        return [screen?.width + screen?.height, "" + new Date, performance?.memory?.jsHeapSizeLimit, Math?.random(), navigator.userAgent, vm(Array.from(document.scripts).map(t => t?.src).filter(t => t)), (Array.from(document.scripts || []).map(t => t?.src?.match("c/[^/]*/_")).filter(t => t?.length)[0] ?? [])[0] ?? document.documentElement.getAttribute("data-build"), navigator.language, navigator.languages?.join(","), Math?.random(), dwe(), vm(Object.keys(document)), vm(Object.keys(window)), performance.now(), this.sid, [...new URLSearchParams(window.location.search).keys()].join(","), navigator?.hardwareConcurrency, performance.timeOrigin]
    }
}
function vm(e) {
    return e[Math.floor(Math.random() * e.length)]
}
function uwe() {
    return "" + Math.random()
}
function dwe() {
    const e = vm(Object.keys(Object.getPrototypeOf(navigator)));
    try {
        return `${e}âˆ’${navigator[e].toString()}`
    } catch {
        return `${e}`
    }
}
function Fp(e) {
    return e = JSON.stringify(e),
    window.TextEncoder ? btoa(String.fromCharCode(...new TextEncoder().encode(e))) : btoa(unescape(encodeURIComponent(e)))
}
function fwe() {
    return new Promise(e => {
        (window.requestIdleCallback || hwe)(n => {
            e(n)
        }
        , {
            timeout: 10
        })
    }
    )
}
function hwe(e) {
    return setTimeout( () => {
        e({
            timeRemaining: () => 1,
            didTimeout: !1
        })
    }
    , 0),
    0
}
const SS = new cwe
  , pwe = 0
  , mwe = 1
  , gwe = 2
  , vwe = 3
  , _we = 4
  , ywe = 5
  , bwe = 6
  , Cwe = 24
  , Swe = 7
  , wwe = 8
  , _s = 9
  , Ewe = 10
  , xwe = 11
  , Twe = 12
  , kwe = 13
  , Owe = 14
  , Awe = 15
  , XH = 16
  , Mwe = 17
  , Iwe = 18
  , Rwe = 19
  , Nwe = 23
  , Pwe = 20
  , Dwe = 21
  , Lwe = 22
  , Fwe = 25
  , jwe = 26
  , Uwe = 27
  , Bwe = 28
  , qwe = 29
  , Gwe = 30
  , Vwe = 31
  , Hwe = 32
  , zwe = 33
  , z = new Map;
let gg = 0;
function vg() {
    for (; z.get(_s).length > 0; ) {
        const [e,...t] = z.get(_s).shift();
        z.get(e)(...t),
        gg++
    }
}
function wS(e) {
    return new Promise( (t, n) => {
        let r = !1;
        setTimeout( () => {
            r = !0,
            t("" + gg)
        }
        , 100),
        z.set(vwe, s => {
            r || (r = !0,
            t(btoa("" + s)))
        }
        ),
        z.set(_we, s => {
            r || (r = !0,
            n(btoa("" + s)))
        }
        ),
        z.set(Gwe, (s, o, i, a) => {
            const l = Array.isArray(a)
              , c = l ? i : []
              , u = (l ? a : i) || [];
            z.set(s, (...d) => {
                if (r)
                    return;
                const p = [...z.get(_s)];
                let m;
                try {
                    if (l)
                        for (let v = 0; v < c.length; v++) {
                            const _ = c[v]
                              , y = d[v];
                            z.set(_, y)
                        }
                    z.set(_s, [...u]),
                    vg(),
                    m = z.get(o)
                } catch (v) {
                    m = "" + v
                } finally {
                    z.set(_s, p)
                }
                return m
            }
            )
        }
        );
        try {
            z.set(_s, JSON.parse(ES(atob(e), "" + z.get(XH)))),
            vg()
        } catch (s) {
            t(btoa(gg + ": " + s))
        }
    }
    )
}
function $we(e) {
    Wwe(),
    gg = 0,
    z.set(XH, e)
}
function ES(e, t) {
    let n = "";
    for (let r = 0; r < e.length; r++)
        n += String.fromCharCode(e.charCodeAt(r) ^ t.charCodeAt(r % t.length));
    return n
}
function Wwe() {
    z.clear(),
    z.set(pwe, wS),
    z.set(mwe, (e, t) => z.set(e, ES("" + z.get(e), "" + z.get(t)))),
    z.set(gwe, (e, t) => z.set(e, t)),
    z.set(ywe, (e, t) => {
        const n = z.get(e);
        Array.isArray(n) ? n.push(z.get(t)) : z.set(e, n + z.get(t))
    }
    ),
    z.set(Uwe, (e, t) => {
        const n = z.get(e);
        Array.isArray(n) ? n.splice(n.indexOf(z.get(t)), 1) : z.set(e, n - z.get(t))
    }
    ),
    z.set(qwe, (e, t, n) => z.set(e, z.get(t) < z.get(n))),
    z.set(zwe, (e, t, n) => {
        const r = Number(z.get(t))
          , s = Number(z.get(n));
        z.set(e, r * s)
    }
    ),
    z.set(bwe, (e, t, n) => z.set(e, z.get(t)[z.get(n)])),
    z.set(Swe, (e, ...t) => z.get(e)(...t.map(n => z.get(n)))),
    z.set(Mwe, (e, t, ...n) => z.set(e, z.get(t)(...n.map(r => z.get(r))))),
    z.set(kwe, (e, t, ...n) => {
        try {
            z.get(t)(...n)
        } catch (r) {
            z.set(e, "" + r)
        }
    }
    ),
    z.set(wwe, (e, t) => z.set(e, z.get(t))),
    z.set(Ewe, window),
    z.set(xwe, (e, t) => z.set(e, (Array.from(document.scripts || []).map(n => n?.src?.match(z.get(t))).filter(n => n?.length)[0] ?? [])[0] ?? null)),
    z.set(Twe, e => z.set(e, z)),
    z.set(Owe, (e, t) => z.set(e, JSON.parse("" + z.get(t)))),
    z.set(Awe, (e, t) => z.set(e, JSON.stringify(z.get(t)))),
    z.set(Iwe, e => z.set(e, atob("" + z.get(e)))),
    z.set(Rwe, e => z.set(e, btoa("" + z.get(e)))),
    z.set(Pwe, (e, t, n, ...r) => z.get(e) === z.get(t) ? z.get(n)(...r) : null),
    z.set(Dwe, (e, t, n, r, ...s) => Math.abs(z.get(e) - z.get(t)) > z.get(n) ? z.get(r)(...s) : null),
    z.set(Nwe, (e, t, ...n) => z.get(e) !== void 0 ? z.get(t)(...n) : null),
    z.set(Cwe, (e, t, n) => z.set(e, z.get(t)[z.get(n)].bind(z.get(t)))),
    z.set(Lwe, (e, t) => {
        const r = [...z.get(_s)];
        z.set(_s, [...t]);
        try {
            vg()
        } catch (s) {
            z.set(e, "" + s)
        } finally {
            z.set(_s, r)
        }
    }
    ),
    z.set(Vwe, e => {
        const t = z.get(e) || 0;
        z.set(e, t + 1)
    }
    ),
    z.set(Hwe, (e, t, n, r, s) => {
        const o = z.get(e) || 0
          , i = Math.max(0, o - 1);
        z.set(e, i);
        const a = z.get(t) || 0
          , l = z.get(s) || 0;
        if (!(i !== a || l !== 1))
            try {
                const c = String(z.get(n) ?? "");
                if (!c)
                    return;
                const u = atob(c)
                  , d = ES(u, "" + z.get(r))
                  , f = JSON.parse(d)
                  , m = [...z.get(_s)];
                z.set(_s, [...f]),
                vg(),
                z.set(_s, m)
            } catch {}
    }
    ),
    z.set(Bwe, () => {}
    ),
    z.set(jwe, () => {}
    ),
    z.set(Fwe, () => {}
    )
}
const Kwe = 1e3 * 60 * 9;
var ff = (e => (e.NOAUTH = "chatgpt-noauth",
e.FREEACCOUNT = "chatgpt-freeaccount",
e.PAID = "chatgpt-paid",
e))(ff || {})
  , Ywe = (e => (e.ChatRequirementsToken = "OpenAI-Sentinel-Chat-Requirements-Token",
e.TurnstileToken = "OpenAI-Sentinel-Turnstile-Token",
e.ProofToken = "OpenAI-Sentinel-Proof-Token",
e.Token = "OpenAI-Sentinel-Token",
e))(Ywe || {});
let Zwe = -1
  , qs = null;
function Jwe() {
    if (qs) {
        const {chatRequirements: e, expiration: t} = qs;
        if (Date.now() >= t)
            return qs = null,
            null;
        if (e)
            return qs = null,
            e
    }
    return null
}
async function Xwe(e=!1) {
    if (qs) {
        const {expiration: s, chatRequirementsPromise: o} = qs;
        if (Date.now() < s)
            try {
                return e || (qs = null),
                o
            } catch {}
        else
            o.then(i => q.addAction("chat_requirements_cache_expired", {
                app: i.persona.toString()
            }));
        qs = null
    }
    const t = SS.getRequirementsTokenBlocking();
    $we(t);
    const n = ie.safePost("/sentinel/chat-requirements", {
        requestBody: {
            p: t
        },
        authOption: Qt.SendIfAvailable
    })
      , r = ++Zwe;
    return e && (qs = {
        id: r,
        chatRequirements: null,
        chatRequirementsPromise: n.then(s => (qs?.id === r && (qs.chatRequirements = s),
        s)),
        expiration: Date.now() + Kwe
    }),
    n
}
function Qwe() {
    return new Promise( (e, t) => {
        const n = document.createElement("script");
        n.type = "text/javascript",
        n.src = "https://chatgpt.com/backend-api/sentinel/sdk.js",
        n.async = !0,
        n.defer = !0,
        n.onload = e,
        n.onerror = t,
        document.getElementsByTagName("head")[0].appendChild(n)
    }
    )
}
function yRe(e) {
    return e4e().then( () => window.SentinelSDK.token(e))
}
const e4e = ( () => {
    let e;
    return () => (e || (e = Qwe()),
    e)
}
)();
function t4e(e, t, n, r) {
    const s = {};
    return e?.token && (s["OpenAI-Sentinel-Chat-Requirements-Token"] = e.token),
    t && (s["OpenAI-Sentinel-Turnstile-Token"] = t),
    n && (s["OpenAI-Sentinel-Proof-Token"] = n),
    r && (s["OpenAI-Sentinel-Token"] = r),
    s
}
const Wd = e => {
    if (e.type === Gt.Starter && e.category === "onboarding")
        return "";
    switch (e.type) {
    case Gt.Reply:
        return e.text;
    case Gt.Starter:
    case Gt.Autocomplete:
    case Gt.Trending:
    case Gt.Capabilities:
        return e.prompt
    }
}
  , n4e = e => e.type === Gt.Reply
  , QH = e => e.type === Gt.Starter
  , aE = e => e.type === Gt.Autocomplete
  , ez = e => e.type === Gt.Trending
  , _g = e => aE(e) && !!e.theme
  , tz = e => e.type === Gt.Capabilities
  , r4e = e => ez(e) || tz(e) || aE(e) && !_g(e)
  , bRe = (e, t, n, r) => {
    switch (ft.logEvent("chatgpt_prompt_use_suggestion", r4e(e) ? "" : Wd(e), {
        id: QH(e) || _g(e) ? e.id ?? "" : "",
        index: `${t}`,
        type: e.type
    }),
    e.type) {
    case Gt.Reply:
        V.logEvent("Use Suggested Reply", {
            value: Wd(e),
            prompt_type: Gt.Reply,
            messageId: r
        });
        break;
    case Gt.Capabilities:
        V.logEvent("Use Capabilities Suggestion", {
            prompt_type: Gt.Capabilities,
            categoryId: e.categoryId,
            client_thread_id: n,
            messageId: r
        });
        break;
    case Gt.Starter:
        V.logEvent("Use Starter Prompt", {
            value: Wd(e),
            prompt_type: Gt.Starter,
            title: e.title,
            body: e.body,
            id: e.id,
            category: e.category,
            client_thread_id: n,
            messageId: r,
            index: t,
            theme: e.theme
        });
        break;
    case Gt.Autocomplete:
        {
            const s = _g(e);
            V.logEvent("Use Autocomplete", {
                value: s ? Wd(e) : "",
                prompt_type: Gt.Autocomplete,
                title: s ? e.title : "",
                body: s ? e.body : "",
                id: s ? e.id : "",
                category: e.category,
                index: t,
                messageId: r,
                client_thread_id: n,
                theme: e.theme ?? ""
            });
            break
        }
    case Gt.Trending:
        {
            V.logEvent("Use Trending Prompt", {
                prompt_type: Gt.Trending,
                title: e.title,
                index: t,
                messageId: r,
                client_thread_id: n
            });
            break
        }
    }
}
  , CRe = (e, t) => {
    if (e.length === 0)
        return;
    const r = Ce.getCurrentNode(sn(t)).message.id;
    if (ft.logEvent("chatgpt_prompt_show_suggestions", `count_${e.length}`, {
        type: e[0].type
    }),
    e.every(n4e))
        V.logEvent("Show Suggested Replies", {
            prompt_count: e.length,
            prompt_type: Gt.Reply,
            client_thread_id: t,
            suggestions: e.map(s => s.text),
            message_id: r
        });
    else if (e.every(QH)) {
        const {isAdditional: s} = e[0];
        V.logEvent(s ? "More Starter Prompts Shown" : "Show Starter Prompts", {
            prompt_count: e.length,
            prompt_type: Gt.Starter,
            titles: e.map(o => o.title),
            bodies: e.map(o => o.body),
            ids: e.map(o => o.id),
            client_thread_id: t,
            message_id: r,
            themes: e.map(o => o.theme ?? "")
        }),
        s && V.logEvent("Expand More Starter Prompts", {
            client_thread_id: t,
            message_id: r
        })
    } else if (e.every(aE)) {
        const s = !!e.find(o => _g(o));
        V.logEvent("Show Autocomplete Prompts", {
            prompt_count: e.length,
            prompt_type: e[0].type,
            titles: e.map(o => s ? o.title : ""),
            bodies: e.map(o => s ? o.body : ""),
            ids: e.map(o => s ? o.id : ""),
            client_thread_id: t,
            message_id: r,
            themes: e.map(o => o.theme ?? "")
        })
    } else
        e.every(ez) ? V.logEvent("Show Trending Prompts", {
            prompt_count: e.length,
            prompt_type: Gt.Trending,
            titles: e.map(s => s.title),
            client_thread_id: t,
            message_id: r
        }) : e.every(tz) ? V.logEvent("Show Capabilities Suggestions", {
            prompt_count: e.length,
            prompt_type: Gt.Capabilities,
            category_ids: e.map(s => s.categoryId),
            client_thread_id: t,
            message_id: r
        }) : q.addError("Unhandled suggestion type", {
            type: e[0].type
        })
}
  , SRe = e => {
    const n = Ce.getCurrentNode(sn(e)).message.id;
    V.logEvent("Show Expand More Starter Prompts Button", {
        client_thread_id: e,
        message_id: n
    })
}
  , wRe = e => {
    const n = Ce.getCurrentNode(sn(e)).message.id;
    V.logEvent("Expand More Starter Prompts", {
        client_thread_id: e,
        message_id: n
    })
}
  , Fc = xt({
    searchPlaceholder: {
        id: "PromptTextarea.searchPlaceholder",
        defaultMessage: "Search the web"
    },
    thinkPlaceholder: {
        id: "PromptTextarea.thinkPlaceholder",
        defaultMessage: "Ask anything"
    },
    connectorPlaceholder: {
        id: "PromptTextarea.connectorPlaceholder",
        defaultMessage: "Search connected sources"
    },
    apiToolPlaceholder: {
        id: "PromptTextarea.apiToolPlaceholder",
        defaultMessage: "Use tools"
    },
    researchPlaceholder: {
        id: "PromptTextarea.researchPlaceholder",
        defaultMessage: "Get a detailed report"
    },
    canvasPlaceholder: {
        id: "PromptTextarea.canvasPlaceholder",
        defaultMessage: "Write or code"
    },
    picturePlaceholder: {
        id: "PromptTextarea.picturePlaceholder",
        defaultMessage: "Describe an image"
    },
    pictureV2Placeholder: {
        id: "PromptTextarea.pictureV2Placeholder",
        defaultMessage: "Describe an image"
    },
    contextualAnswersPlaceholder: {
        id: "PromptTextarea.contextualAnswersPlaceholder",
        defaultMessage: "Search internal sources"
    },
    tatertotPlaceholder: {
        id: "PromptTextarea.studyAndLearnPlaceholder",
        defaultMessage: "Learn something new"
    },
    continueGenerating: {
        id: "PromptTextarea.continueGenerating",
        defaultMessage: "Continue generating"
    },
    stopGenerating: {
        id: "PromptTextarea.stopGenerating",
        defaultMessage: "Stop generating"
    },
    disallowedByWorkspacePlaceholder: {
        id: "PromptTextarea.disallowedByWorkspaceReason",
        defaultMessage: "Your workspace owner hasnâ€™t approved this GPT."
    },
    pimBlockPlaceholder: {
        id: "PromptTextarea.pimBlockPlaceholder",
        defaultMessage: "Potentially Malicious Content Detected"
    },
    noModelsAvailablePlaceholder: {
        id: "PromptTextarea.noModelsAvailablePlaceholder",
        defaultMessage: "No models available"
    },
    requiresPluginsToBeInstalled: {
        id: "PromptTextarea.requiresPluginsToBeInstalled",
        defaultMessage: "Requires plugins to be installed"
    },
    noTestGizmoId: {
        id: "PromptTextarea.noTestGizmoId",
        defaultMessage: "Start by defining your GPT."
    },
    searchWith: {
        id: "PromptTextarea.searchWith",
        defaultMessage: "Search with {name}"
    },
    loading: {
        id: "PromptTextarea.loading",
        defaultMessage: "Loading..."
    },
    placeholder: {
        id: "PromptTextarea.placeholder",
        defaultMessage: "Send a message"
    },
    placeholderWithName: {
        id: "PromptTextarea.placeholderWithName",
        defaultMessage: "Message {name}"
    },
    placeholderAskAnythingVariant: {
        id: "PromptTextarea.placeholderAskAnythingVariant",
        defaultMessage: "Ask anything"
    },
    placeholderAskNameAnythingVariant: {
        id: "PromptTextarea.placeholderAskNameAnythingVariant",
        defaultMessage: "Ask {name} anything"
    },
    continueSharedConversationPlaceholder: {
        id: "PromptTextarea.continueSharedConversationPlaceholder",
        defaultMessage: "Send a message to continue the conversation."
    },
    sendMessageTooltip: {
        id: "PromptTextarea.sendMessageTooltip",
        defaultMessage: "Send message"
    },
    unsupportedFileType: {
        id: "PromptTextarea.unsupportedFileType",
        defaultMessage: 'Uploads with file type "{file_type}" are not supported, please try another file.'
    },
    gizmoKnowledgeWarning: {
        id: "PromptTextarea.gizmoKnowledgeWarning",
        defaultMessage: "Files uploaded here may be included in conversations with your GPT. Files can be downloaded if Code Interpreter is enabled."
    },
    n7jupdSystemHintPlaceholder: {
        id: "3pa1zs",
        defaultMessage: "Describe a task"
    },
    n7jupdActivePlaceholder: {
        id: "0qUILF",
        defaultMessage: "Follow up"
    }
})
  , nz = "prompt-textarea";
function ERe() {
    document.getElementById(nz)?.focus()
}
const xRe = {
    getAndReset: (e, t) => {
        const n = Wt.getItem(Ft.RestoreMessageAfterOauthRedirect);
        return Wt.removeItem(Ft.RestoreMessageAfterOauthRedirect),
        !n || n.userId !== e || t !== n.serverThreadId || Date.now() > n.expiresAt ? null : n
    }
    ,
    set: (e, t, n) => {
        const r = {
            userId: e,
            serverThreadId: t,
            inputText: n,
            expiresAt: Date.now() + 6e4
        };
        Wt.setItem(Ft.RestoreMessageAfterOauthRedirect, r)
    }
}
  , TRe = () => {
    "use forget";
    const e = De.c(16)
      , t = x3e()
      , n = Wl.useStore();
    let r;
    e[0] !== n ? (r = m => n.getPersistedSystemHintTrigger(m),
    e[0] = n,
    e[1] = r) : r = e[1];
    const s = r;
    let o;
    e[2] !== t ? (o = m => t(null, {
        ifPrevSystemHint: m
    }),
    e[2] = t,
    e[3] = o) : o = e[3];
    const i = o;
    let a;
    e[4] !== t ? (a = () => t(null),
    e[4] = t,
    e[5] = a) : a = e[5];
    const l = a;
    let c;
    e[6] !== t ? (c = (m, v, _, y) => {
        v ? t(m, {
            analyticsMetadata: _,
            triggerSource: y
        }) : t(null, {
            ifPrevSystemHint: m,
            analyticsMetadata: _
        })
    }
    ,
    e[6] = t,
    e[7] = c) : c = e[7];
    const u = c;
    let d;
    e[8] !== t ? (d = (m, v) => {
        t(m, {
            analyticsMetadata: v
        })
    }
    ,
    e[8] = t,
    e[9] = d) : d = e[9];
    const f = d;
    let p;
    return e[10] !== l || e[11] !== i || e[12] !== s || e[13] !== u || e[14] !== f ? (p = {
        getSystemHintModeTrigger: s,
        clearSystemHintModeTrigger: i,
        setThreadSystemHintMode: u,
        clearAllSystemHintModeTriggers: l,
        updateSystemHint: f
    },
    e[10] = l,
    e[11] = i,
    e[12] = s,
    e[13] = u,
    e[14] = f,
    e[15] = p) : p = e[15],
    p
}
  , kRe = ({promptDisabledReason: e, hasPendingFiles: t, hasTextContent: n, isTextContentTooLong: r, hasAsyncTaskPending: s, noSourceSelectedDr: o, isDeepResearchTaskStreaming: i, isThreadHardBlocked: a}) => e || (a ? "rate_limit_hard_block" : t ? "file_upload_pending" : s ? i ? void 0 : "async_task_pending" : n ? r ? "text_content_too_long" : o ? "no_source_selected_dr" : void 0 : "empty_text_content");
function ORe(e, t) {
    const n = Math.ceil(t / 4);
    return typeof e?.maxTokens == "number" && n > e.maxTokens
}
function ARe(e, t) {
    return e ? t === void 0 ? !0 : t.includes(e) : !1
}
const MRe = e => {
    switch (e) {
    case "pimBlock":
        return {
            placeholder: Fc.pimBlockPlaceholder,
            isLastingDisabledStyle: !0
        };
    case "workspaceDisallowsGizmo":
        return {
            placeholder: Fc.disallowedByWorkspacePlaceholder,
            isLastingDisabledStyle: !0
        };
    case "noModelsAvailable":
        return {
            placeholder: Fc.noModelsAvailablePlaceholder,
            isLastingDisabledStyle: !0
        };
    case "requiresPluginsToBeInstalled":
        return {
            placeholder: Fc.requiresPluginsToBeInstalled,
            isLastingDisabledStyle: !0
        };
    case "loadingPlugins":
        return {
            placeholder: Fc.loading,
            isLastingDisabledStyle: !0
        };
    case "noTestGizmoId":
        return {
            placeholder: Fc.noTestGizmoId,
            isLastingDisabledStyle: !0
        }
    }
    return null
}
  , s4e = "OAI-Echo-Logs"
  , jc = {
    FOCUS_IN: 0,
    FOCUS_OUT: 1,
    COPY: 2,
    PASTE: 3,
    TOUCH_START: 4,
    TOUCH_END: 5
}
  , rz = [];
function Uc(e) {
    return () => {
        rz.push({
            type: e,
            ts: Math.round(performance.now())
        })
    }
}
const o4e = {
    focusin: Uc(jc.FOCUS_IN),
    focusout: Uc(jc.FOCUS_OUT),
    copy: Uc(jc.COPY),
    paste: Uc(jc.PASTE),
    touchstart: Uc(jc.TOUCH_START),
    touchend: Uc(jc.TOUCH_END)
};
function IRe(e) {
    const t = e ?? document.getElementById(nz);
    for (const [n,r] of Object.entries(o4e))
        t?.removeEventListener(n, r),
        t?.addEventListener(n, r)
}
function sz() {
    return {
        [s4e]: rz.slice(0, 10).map(e => `${e.type},${e.ts}`).join(",")
    }
}
var i4e = typeof globalThis == "object" ? globalThis : typeof self == "object" ? self : typeof window == "object" ? window : typeof global == "object" ? global : {}
  , yl = "1.6.0"
  , PR = /^(\d+)\.(\d+)\.(\d+)(-(.+))?$/;
function a4e(e) {
    var t = new Set([e])
      , n = new Set
      , r = e.match(PR);
    if (!r)
        return function() {
            return !1
        }
        ;
    var s = {
        major: +r[1],
        minor: +r[2],
        patch: +r[3],
        prerelease: r[4]
    };
    if (s.prerelease != null)
        return function(l) {
            return l === e
        }
        ;
    function o(a) {
        return n.add(a),
        !1
    }
    function i(a) {
        return t.add(a),
        !0
    }
    return function(l) {
        if (t.has(l))
            return !0;
        if (n.has(l))
            return !1;
        var c = l.match(PR);
        if (!c)
            return o(l);
        var u = {
            major: +c[1],
            minor: +c[2],
            patch: +c[3],
            prerelease: c[4]
        };
        return u.prerelease != null || s.major !== u.major ? o(l) : s.major === 0 ? s.minor === u.minor && s.patch <= u.patch ? i(l) : o(l) : s.minor <= u.minor ? i(l) : o(l)
    }
}
var l4e = a4e(yl)
  , c4e = yl.split(".")[0]
  , jf = Symbol.for("opentelemetry.js.api." + c4e)
  , Uf = i4e;
function Ph(e, t, n, r) {
    var s;
    r === void 0 && (r = !1);
    var o = Uf[jf] = (s = Uf[jf]) !== null && s !== void 0 ? s : {
        version: yl
    };
    if (!r && o[e]) {
        var i = new Error("@opentelemetry/api: Attempted duplicate registration of API: " + e);
        return n.error(i.stack || i.message),
        !1
    }
    if (o.version !== yl) {
        var i = new Error("@opentelemetry/api: Registration of version v" + o.version + " for " + e + " does not match previously registered API v" + yl);
        return n.error(i.stack || i.message),
        !1
    }
    return o[e] = t,
    n.debug("@opentelemetry/api: Registered a global for " + e + " v" + yl + "."),
    !0
}
function Kl(e) {
    var t, n, r = (t = Uf[jf]) === null || t === void 0 ? void 0 : t.version;
    if (!(!r || !l4e(r)))
        return (n = Uf[jf]) === null || n === void 0 ? void 0 : n[e]
}
function Dh(e, t) {
    t.debug("@opentelemetry/api: Unregistering a global for " + e + " v" + yl + ".");
    var n = Uf[jf];
    n && delete n[e]
}
var u4e = function(e, t) {
    var n = typeof Symbol == "function" && e[Symbol.iterator];
    if (!n)
        return e;
    var r = n.call(e), s, o = [], i;
    try {
        for (; (t === void 0 || t-- > 0) && !(s = r.next()).done; )
            o.push(s.value)
    } catch (a) {
        i = {
            error: a
        }
    } finally {
        try {
            s && !s.done && (n = r.return) && n.call(r)
        } finally {
            if (i)
                throw i.error
        }
    }
    return o
}
  , d4e = function(e, t, n) {
    if (n || arguments.length === 2)
        for (var r = 0, s = t.length, o; r < s; r++)
            (o || !(r in t)) && (o || (o = Array.prototype.slice.call(t, 0, r)),
            o[r] = t[r]);
    return e.concat(o || Array.prototype.slice.call(t))
}
  , f4e = function() {
    function e(t) {
        this._namespace = t.namespace || "DiagComponentLogger"
    }
    return e.prototype.debug = function() {
        for (var t = [], n = 0; n < arguments.length; n++)
            t[n] = arguments[n];
        return Id("debug", this._namespace, t)
    }
    ,
    e.prototype.error = function() {
        for (var t = [], n = 0; n < arguments.length; n++)
            t[n] = arguments[n];
        return Id("error", this._namespace, t)
    }
    ,
    e.prototype.info = function() {
        for (var t = [], n = 0; n < arguments.length; n++)
            t[n] = arguments[n];
        return Id("info", this._namespace, t)
    }
    ,
    e.prototype.warn = function() {
        for (var t = [], n = 0; n < arguments.length; n++)
            t[n] = arguments[n];
        return Id("warn", this._namespace, t)
    }
    ,
    e.prototype.verbose = function() {
        for (var t = [], n = 0; n < arguments.length; n++)
            t[n] = arguments[n];
        return Id("verbose", this._namespace, t)
    }
    ,
    e
}();
function Id(e, t, n) {
    var r = Kl("diag");
    if (r)
        return n.unshift(t),
        r[e].apply(r, d4e([], u4e(n), !1))
}
var Hr;
(function(e) {
    e[e.NONE = 0] = "NONE",
    e[e.ERROR = 30] = "ERROR",
    e[e.WARN = 50] = "WARN",
    e[e.INFO = 60] = "INFO",
    e[e.DEBUG = 70] = "DEBUG",
    e[e.VERBOSE = 80] = "VERBOSE",
    e[e.ALL = 9999] = "ALL"
}
)(Hr || (Hr = {}));
function h4e(e, t) {
    e < Hr.NONE ? e = Hr.NONE : e > Hr.ALL && (e = Hr.ALL),
    t = t || {};
    function n(r, s) {
        var o = t[r];
        return typeof o == "function" && e >= s ? o.bind(t) : function() {}
    }
    return {
        error: n("error", Hr.ERROR),
        warn: n("warn", Hr.WARN),
        info: n("info", Hr.INFO),
        debug: n("debug", Hr.DEBUG),
        verbose: n("verbose", Hr.VERBOSE)
    }
}
var p4e = function(e, t) {
    var n = typeof Symbol == "function" && e[Symbol.iterator];
    if (!n)
        return e;
    var r = n.call(e), s, o = [], i;
    try {
        for (; (t === void 0 || t-- > 0) && !(s = r.next()).done; )
            o.push(s.value)
    } catch (a) {
        i = {
            error: a
        }
    } finally {
        try {
            s && !s.done && (n = r.return) && n.call(r)
        } finally {
            if (i)
                throw i.error
        }
    }
    return o
}
  , m4e = function(e, t, n) {
    if (n || arguments.length === 2)
        for (var r = 0, s = t.length, o; r < s; r++)
            (o || !(r in t)) && (o || (o = Array.prototype.slice.call(t, 0, r)),
            o[r] = t[r]);
    return e.concat(o || Array.prototype.slice.call(t))
}
  , g4e = "diag"
  , Uo = function() {
    function e() {
        function t(s) {
            return function() {
                for (var o = [], i = 0; i < arguments.length; i++)
                    o[i] = arguments[i];
                var a = Kl("diag");
                if (a)
                    return a[s].apply(a, m4e([], p4e(o), !1))
            }
        }
        var n = this
          , r = function(s, o) {
            var i, a, l;
            if (o === void 0 && (o = {
                logLevel: Hr.INFO
            }),
            s === n) {
                var c = new Error("Cannot use diag as the logger for itself. Please use a DiagLogger implementation like ConsoleDiagLogger or a custom implementation");
                return n.error((i = c.stack) !== null && i !== void 0 ? i : c.message),
                !1
            }
            typeof o == "number" && (o = {
                logLevel: o
            });
            var u = Kl("diag")
              , d = h4e((a = o.logLevel) !== null && a !== void 0 ? a : Hr.INFO, s);
            if (u && !o.suppressOverrideMessage) {
                var f = (l = new Error().stack) !== null && l !== void 0 ? l : "<failed to generate stacktrace>";
                u.warn("Current logger will be overwritten from " + f),
                d.warn("Current logger will overwrite one already registered from " + f)
            }
            return Ph("diag", d, n, !0)
        };
        n.setLogger = r,
        n.disable = function() {
            Dh(g4e, n)
        }
        ,
        n.createComponentLogger = function(s) {
            return new f4e(s)
        }
        ,
        n.verbose = t("verbose"),
        n.debug = t("debug"),
        n.info = t("info"),
        n.warn = t("warn"),
        n.error = t("error")
    }
    return e.instance = function() {
        return this._instance || (this._instance = new e),
        this._instance
    }
    ,
    e
}()
  , v4e = function(e, t) {
    var n = typeof Symbol == "function" && e[Symbol.iterator];
    if (!n)
        return e;
    var r = n.call(e), s, o = [], i;
    try {
        for (; (t === void 0 || t-- > 0) && !(s = r.next()).done; )
            o.push(s.value)
    } catch (a) {
        i = {
            error: a
        }
    } finally {
        try {
            s && !s.done && (n = r.return) && n.call(r)
        } finally {
            if (i)
                throw i.error
        }
    }
    return o
}
  , _4e = function(e) {
    var t = typeof Symbol == "function" && Symbol.iterator
      , n = t && e[t]
      , r = 0;
    if (n)
        return n.call(e);
    if (e && typeof e.length == "number")
        return {
            next: function() {
                return e && r >= e.length && (e = void 0),
                {
                    value: e && e[r++],
                    done: !e
                }
            }
        };
    throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.")
}
  , y4e = function() {
    function e(t) {
        this._entries = t ? new Map(t) : new Map
    }
    return e.prototype.getEntry = function(t) {
        var n = this._entries.get(t);
        if (n)
            return Object.assign({}, n)
    }
    ,
    e.prototype.getAllEntries = function() {
        return Array.from(this._entries.entries()).map(function(t) {
            var n = v4e(t, 2)
              , r = n[0]
              , s = n[1];
            return [r, s]
        })
    }
    ,
    e.prototype.setEntry = function(t, n) {
        var r = new e(this._entries);
        return r._entries.set(t, n),
        r
    }
    ,
    e.prototype.removeEntry = function(t) {
        var n = new e(this._entries);
        return n._entries.delete(t),
        n
    }
    ,
    e.prototype.removeEntries = function() {
        for (var t, n, r = [], s = 0; s < arguments.length; s++)
            r[s] = arguments[s];
        var o = new e(this._entries);
        try {
            for (var i = _4e(r), a = i.next(); !a.done; a = i.next()) {
                var l = a.value;
                o._entries.delete(l)
            }
        } catch (c) {
            t = {
                error: c
            }
        } finally {
            try {
                a && !a.done && (n = i.return) && n.call(i)
            } finally {
                if (t)
                    throw t.error
            }
        }
        return o
    }
    ,
    e.prototype.clear = function() {
        return new e
    }
    ,
    e
}()
  , b4e = Symbol("BaggageEntryMetadata")
  , C4e = Uo.instance();
function S4e(e) {
    return e === void 0 && (e = {}),
    new y4e(new Map(Object.entries(e)))
}
function RRe(e) {
    return typeof e != "string" && (C4e.error("Cannot create baggage metadata from unknown type: " + typeof e),
    e = ""),
    {
        __TYPE__: b4e,
        toString: function() {
            return e
        }
    }
}
function oz(e) {
    return Symbol.for(e)
}
var w4e = function() {
    function e(t) {
        var n = this;
        n._currentContext = t ? new Map(t) : new Map,
        n.getValue = function(r) {
            return n._currentContext.get(r)
        }
        ,
        n.setValue = function(r, s) {
            var o = new e(n._currentContext);
            return o._currentContext.set(r, s),
            o
        }
        ,
        n.deleteValue = function(r) {
            var s = new e(n._currentContext);
            return s._currentContext.delete(r),
            s
        }
    }
    return e
}(), E4e = new w4e, cd = function() {
    var e = function(t, n) {
        return e = Object.setPrototypeOf || {
            __proto__: []
        }instanceof Array && function(r, s) {
            r.__proto__ = s
        }
        || function(r, s) {
            for (var o in s)
                Object.prototype.hasOwnProperty.call(s, o) && (r[o] = s[o])
        }
        ,
        e(t, n)
    };
    return function(t, n) {
        if (typeof n != "function" && n !== null)
            throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
        e(t, n);
        function r() {
            this.constructor = t
        }
        t.prototype = n === null ? Object.create(n) : (r.prototype = n.prototype,
        new r)
    }
}(), x4e = function() {
    function e() {}
    return e.prototype.createHistogram = function(t, n) {
        return P4e
    }
    ,
    e.prototype.createCounter = function(t, n) {
        return N4e
    }
    ,
    e.prototype.createUpDownCounter = function(t, n) {
        return D4e
    }
    ,
    e.prototype.createObservableGauge = function(t, n) {
        return F4e
    }
    ,
    e.prototype.createObservableCounter = function(t, n) {
        return L4e
    }
    ,
    e.prototype.createObservableUpDownCounter = function(t, n) {
        return j4e
    }
    ,
    e.prototype.addBatchObservableCallback = function(t, n) {}
    ,
    e.prototype.removeBatchObservableCallback = function(t) {}
    ,
    e
}(), lE = function() {
    function e() {}
    return e
}(), T4e = function(e) {
    cd(t, e);
    function t() {
        return e !== null && e.apply(this, arguments) || this
    }
    return t.prototype.add = function(n, r) {}
    ,
    t
}(lE), k4e = function(e) {
    cd(t, e);
    function t() {
        return e !== null && e.apply(this, arguments) || this
    }
    return t.prototype.add = function(n, r) {}
    ,
    t
}(lE), O4e = function(e) {
    cd(t, e);
    function t() {
        return e !== null && e.apply(this, arguments) || this
    }
    return t.prototype.record = function(n, r) {}
    ,
    t
}(lE), cE = function() {
    function e() {}
    return e.prototype.addCallback = function(t) {}
    ,
    e.prototype.removeCallback = function(t) {}
    ,
    e
}(), A4e = function(e) {
    cd(t, e);
    function t() {
        return e !== null && e.apply(this, arguments) || this
    }
    return t
}(cE), M4e = function(e) {
    cd(t, e);
    function t() {
        return e !== null && e.apply(this, arguments) || this
    }
    return t
}(cE), I4e = function(e) {
    cd(t, e);
    function t() {
        return e !== null && e.apply(this, arguments) || this
    }
    return t
}(cE), R4e = new x4e, N4e = new T4e, P4e = new O4e, D4e = new k4e, L4e = new A4e, F4e = new M4e, j4e = new I4e, U4e = {
    get: function(e, t) {
        if (e != null)
            return e[t]
    },
    keys: function(e) {
        return e == null ? [] : Object.keys(e)
    }
}, B4e = {
    set: function(e, t, n) {
        e != null && (e[t] = n)
    }
}, q4e = function(e, t) {
    var n = typeof Symbol == "function" && e[Symbol.iterator];
    if (!n)
        return e;
    var r = n.call(e), s, o = [], i;
    try {
        for (; (t === void 0 || t-- > 0) && !(s = r.next()).done; )
            o.push(s.value)
    } catch (a) {
        i = {
            error: a
        }
    } finally {
        try {
            s && !s.done && (n = r.return) && n.call(r)
        } finally {
            if (i)
                throw i.error
        }
    }
    return o
}, G4e = function(e, t, n) {
    if (n || arguments.length === 2)
        for (var r = 0, s = t.length, o; r < s; r++)
            (o || !(r in t)) && (o || (o = Array.prototype.slice.call(t, 0, r)),
            o[r] = t[r]);
    return e.concat(o || Array.prototype.slice.call(t))
}, V4e = function() {
    function e() {}
    return e.prototype.active = function() {
        return E4e
    }
    ,
    e.prototype.with = function(t, n, r) {
        for (var s = [], o = 3; o < arguments.length; o++)
            s[o - 3] = arguments[o];
        return n.call.apply(n, G4e([r], q4e(s), !1))
    }
    ,
    e.prototype.bind = function(t, n) {
        return n
    }
    ,
    e.prototype.enable = function() {
        return this
    }
    ,
    e.prototype.disable = function() {
        return this
    }
    ,
    e
}(), H4e = function(e, t) {
    var n = typeof Symbol == "function" && e[Symbol.iterator];
    if (!n)
        return e;
    var r = n.call(e), s, o = [], i;
    try {
        for (; (t === void 0 || t-- > 0) && !(s = r.next()).done; )
            o.push(s.value)
    } catch (a) {
        i = {
            error: a
        }
    } finally {
        try {
            s && !s.done && (n = r.return) && n.call(r)
        } finally {
            if (i)
                throw i.error
        }
    }
    return o
}, z4e = function(e, t, n) {
    if (n || arguments.length === 2)
        for (var r = 0, s = t.length, o; r < s; r++)
            (o || !(r in t)) && (o || (o = Array.prototype.slice.call(t, 0, r)),
            o[r] = t[r]);
    return e.concat(o || Array.prototype.slice.call(t))
}, _3 = "context", $4e = new V4e, r0 = function() {
    function e() {}
    return e.getInstance = function() {
        return this._instance || (this._instance = new e),
        this._instance
    }
    ,
    e.prototype.setGlobalContextManager = function(t) {
        return Ph(_3, t, Uo.instance())
    }
    ,
    e.prototype.active = function() {
        return this._getContextManager().active()
    }
    ,
    e.prototype.with = function(t, n, r) {
        for (var s, o = [], i = 3; i < arguments.length; i++)
            o[i - 3] = arguments[i];
        return (s = this._getContextManager()).with.apply(s, z4e([t, n, r], H4e(o), !1))
    }
    ,
    e.prototype.bind = function(t, n) {
        return this._getContextManager().bind(t, n)
    }
    ,
    e.prototype._getContextManager = function() {
        return Kl(_3) || $4e
    }
    ,
    e.prototype.disable = function() {
        this._getContextManager().disable(),
        Dh(_3, Uo.instance())
    }
    ,
    e
}(), xS;
(function(e) {
    e[e.NONE = 0] = "NONE",
    e[e.SAMPLED = 1] = "SAMPLED"
}
)(xS || (xS = {}));
var iz = "0000000000000000"
  , az = "00000000000000000000000000000000"
  , W4e = {
    traceId: az,
    spanId: iz,
    traceFlags: xS.NONE
}
  , hf = function() {
    function e(t) {
        t === void 0 && (t = W4e),
        this._spanContext = t
    }
    return e.prototype.spanContext = function() {
        return this._spanContext
    }
    ,
    e.prototype.setAttribute = function(t, n) {
        return this
    }
    ,
    e.prototype.setAttributes = function(t) {
        return this
    }
    ,
    e.prototype.addEvent = function(t, n) {
        return this
    }
    ,
    e.prototype.setStatus = function(t) {
        return this
    }
    ,
    e.prototype.updateName = function(t) {
        return this
    }
    ,
    e.prototype.end = function(t) {}
    ,
    e.prototype.isRecording = function() {
        return !1
    }
    ,
    e.prototype.recordException = function(t, n) {}
    ,
    e
}()
  , uE = oz("OpenTelemetry Context Key SPAN");
function dE(e) {
    return e.getValue(uE) || void 0
}
function K4e() {
    return dE(r0.getInstance().active())
}
function fE(e, t) {
    return e.setValue(uE, t)
}
function Y4e(e) {
    return e.deleteValue(uE)
}
function Z4e(e, t) {
    return fE(e, new hf(t))
}
function lz(e) {
    var t;
    return (t = dE(e)) === null || t === void 0 ? void 0 : t.spanContext()
}
var J4e = /^([0-9a-f]{32})$/i
  , X4e = /^[0-9a-f]{16}$/i;
function Q4e(e) {
    return J4e.test(e) && e !== az
}
function eEe(e) {
    return X4e.test(e) && e !== iz
}
function cz(e) {
    return Q4e(e.traceId) && eEe(e.spanId)
}
function tEe(e) {
    return new hf(e)
}
var y3 = r0.getInstance()
  , uz = function() {
    function e() {}
    return e.prototype.startSpan = function(t, n, r) {
        r === void 0 && (r = y3.active());
        var s = !!n?.root;
        if (s)
            return new hf;
        var o = r && lz(r);
        return nEe(o) && cz(o) ? new hf(o) : new hf
    }
    ,
    e.prototype.startActiveSpan = function(t, n, r, s) {
        var o, i, a;
        if (!(arguments.length < 2)) {
            arguments.length === 2 ? a = n : arguments.length === 3 ? (o = n,
            a = r) : (o = n,
            i = r,
            a = s);
            var l = i ?? y3.active()
              , c = this.startSpan(t, o, l)
              , u = fE(l, c);
            return y3.with(u, a, void 0, c)
        }
    }
    ,
    e
}();
function nEe(e) {
    return typeof e == "object" && typeof e.spanId == "string" && typeof e.traceId == "string" && typeof e.traceFlags == "number"
}
var rEe = new uz, sEe = function() {
    function e(t, n, r, s) {
        this._provider = t,
        this.name = n,
        this.version = r,
        this.options = s
    }
    return e.prototype.startSpan = function(t, n, r) {
        return this._getTracer().startSpan(t, n, r)
    }
    ,
    e.prototype.startActiveSpan = function(t, n, r, s) {
        var o = this._getTracer();
        return Reflect.apply(o.startActiveSpan, o, arguments)
    }
    ,
    e.prototype._getTracer = function() {
        if (this._delegate)
            return this._delegate;
        var t = this._provider.getDelegateTracer(this.name, this.version, this.options);
        return t ? (this._delegate = t,
        this._delegate) : rEe
    }
    ,
    e
}(), oEe = function() {
    function e() {}
    return e.prototype.getTracer = function(t, n, r) {
        return new uz
    }
    ,
    e
}(), iEe = new oEe, DR = function() {
    function e() {}
    return e.prototype.getTracer = function(t, n, r) {
        var s;
        return (s = this.getDelegateTracer(t, n, r)) !== null && s !== void 0 ? s : new sEe(this,t,n,r)
    }
    ,
    e.prototype.getDelegate = function() {
        var t;
        return (t = this._delegate) !== null && t !== void 0 ? t : iEe
    }
    ,
    e.prototype.setDelegate = function(t) {
        this._delegate = t
    }
    ,
    e.prototype.getDelegateTracer = function(t, n, r) {
        var s;
        return (s = this._delegate) === null || s === void 0 ? void 0 : s.getTracer(t, n, r)
    }
    ,
    e
}(), LR;
(function(e) {
    e[e.NOT_RECORD = 0] = "NOT_RECORD",
    e[e.RECORD = 1] = "RECORD",
    e[e.RECORD_AND_SAMPLED = 2] = "RECORD_AND_SAMPLED"
}
)(LR || (LR = {}));
var FR;
(function(e) {
    e[e.INTERNAL = 0] = "INTERNAL",
    e[e.SERVER = 1] = "SERVER",
    e[e.CLIENT = 2] = "CLIENT",
    e[e.PRODUCER = 3] = "PRODUCER",
    e[e.CONSUMER = 4] = "CONSUMER"
}
)(FR || (FR = {}));
var jR;
(function(e) {
    e[e.UNSET = 0] = "UNSET",
    e[e.OK = 1] = "OK",
    e[e.ERROR = 2] = "ERROR"
}
)(jR || (jR = {}));
var NRe = r0.getInstance()
  , PRe = Uo.instance()
  , aEe = function() {
    function e() {}
    return e.prototype.getMeter = function(t, n, r) {
        return R4e
    }
    ,
    e
}()
  , lEe = new aEe
  , b3 = "metrics"
  , cEe = function() {
    function e() {}
    return e.getInstance = function() {
        return this._instance || (this._instance = new e),
        this._instance
    }
    ,
    e.prototype.setGlobalMeterProvider = function(t) {
        return Ph(b3, t, Uo.instance())
    }
    ,
    e.prototype.getMeterProvider = function() {
        return Kl(b3) || lEe
    }
    ,
    e.prototype.getMeter = function(t, n, r) {
        return this.getMeterProvider().getMeter(t, n, r)
    }
    ,
    e.prototype.disable = function() {
        Dh(b3, Uo.instance())
    }
    ,
    e
}()
  , DRe = cEe.getInstance()
  , uEe = function() {
    function e() {}
    return e.prototype.inject = function(t, n) {}
    ,
    e.prototype.extract = function(t, n) {
        return t
    }
    ,
    e.prototype.fields = function() {
        return []
    }
    ,
    e
}()
  , hE = oz("OpenTelemetry Baggage Key");
function dz(e) {
    return e.getValue(hE) || void 0
}
function dEe() {
    return dz(r0.getInstance().active())
}
function fEe(e, t) {
    return e.setValue(hE, t)
}
function hEe(e) {
    return e.deleteValue(hE)
}
var C3 = "propagation"
  , pEe = new uEe
  , mEe = function() {
    function e() {
        this.createBaggage = S4e,
        this.getBaggage = dz,
        this.getActiveBaggage = dEe,
        this.setBaggage = fEe,
        this.deleteBaggage = hEe
    }
    return e.getInstance = function() {
        return this._instance || (this._instance = new e),
        this._instance
    }
    ,
    e.prototype.setGlobalPropagator = function(t) {
        return Ph(C3, t, Uo.instance())
    }
    ,
    e.prototype.inject = function(t, n, r) {
        return r === void 0 && (r = B4e),
        this._getGlobalPropagator().inject(t, n, r)
    }
    ,
    e.prototype.extract = function(t, n, r) {
        return r === void 0 && (r = U4e),
        this._getGlobalPropagator().extract(t, n, r)
    }
    ,
    e.prototype.fields = function() {
        return this._getGlobalPropagator().fields()
    }
    ,
    e.prototype.disable = function() {
        Dh(C3, Uo.instance())
    }
    ,
    e.prototype._getGlobalPropagator = function() {
        return Kl(C3) || pEe
    }
    ,
    e
}()
  , LRe = mEe.getInstance()
  , S3 = "trace"
  , gEe = function() {
    function e() {
        this._proxyTracerProvider = new DR,
        this.wrapSpanContext = tEe,
        this.isSpanContextValid = cz,
        this.deleteSpan = Y4e,
        this.getSpan = dE,
        this.getActiveSpan = K4e,
        this.getSpanContext = lz,
        this.setSpan = fE,
        this.setSpanContext = Z4e
    }
    return e.getInstance = function() {
        return this._instance || (this._instance = new e),
        this._instance
    }
    ,
    e.prototype.setGlobalTracerProvider = function(t) {
        var n = Ph(S3, this._proxyTracerProvider, Uo.instance());
        return n && this._proxyTracerProvider.setDelegate(t),
        n
    }
    ,
    e.prototype.getTracerProvider = function() {
        return Kl(S3) || this._proxyTracerProvider
    }
    ,
    e.prototype.getTracer = function(t, n) {
        return this.getTracerProvider().getTracer(t, n)
    }
    ,
    e.prototype.disable = function() {
        Dh(S3, Uo.instance()),
        this._proxyTracerProvider = new DR
    }
    ,
    e
}()
  , vEe = gEe.getInstance();
const pE = "RESUME_TOKEN_STORE_KEY"
  , _Ee = 1e3
  , yEe = _Ee * 60
  , bEe = yEe * 60;
function mE() {
    const e = localStorage.getItem(pE) ?? "{}"
      , t = JSON.parse(e);
    return Object.fromEntries(Object.entries(t).filter( ([r,s]) => s.expiresAt > Date.now()))
}
function fz(e) {
    const t = JSON.stringify(e);
    localStorage.setItem(pE, t)
}
function CEe(e, t) {
    const n = mE();
    n[e] = {
        token: t,
        expiresAt: Date.now() + bEe
    },
    fz(n)
}
function SEe(e) {
    return mE()[e]?.token
}
function wEe(e) {
    const t = mE();
    delete t[e],
    fz(t)
}
function EEe() {
    localStorage.removeItem(pE)
}
const w3 = {
    set: CEe,
    get: SEe,
    remove: wEe,
    clear: EEe
};
function xEe(e, t, n, r, s, o) {
    const i = OEe(e, t, n, s, o);
    return hz(n, r, i)
}
function TEe(e, t, n, r, s, o) {
    const {conversationId: i, resumeToken: a, model: l} = t;
    let c = vz({
        ctx: e,
        conversationId: i,
        resumeToken: a,
        model: l,
        turnTracker: n,
        offset: 0,
        signal: s ?? null
    });
    c = gz(c, {
        ctx: e,
        model: l,
        turnTracker: n,
        signal: s ?? null
    }),
    c = _z(c, {
        turnTracker: n,
        prepareState: null,
        signal: s ?? null,
        f_completion: !0
    });
    const d = $H(c, f => {
        n.stream_encoding = f
    }
    );
    return hz(n, r, pz(d))
}
const kEe = 1e3 * 30
  , Rd = vEe.getTracer("completion");
function E3(e, t) {
    dr.count(er.DEFAULT, e, [{
        key: "prepare_sent",
        value: t && t !== "none" ? "true" : "false"
    }, {
        key: "prepare_succeeded",
        value: t === "success" ? "true" : "false"
    }, {
        key: "prepare_failed",
        value: t === "failure" ? "true" : "false"
    }])
}
async function *hz(e, t, n) {
    let r = !1, s = !1, o = !1, i = !1, a, l, c, u, d;
    Rd.startActiveSpan("completion.response", p => {
        a = Rd.startSpan("completion.first_response"),
        l = Rd.startSpan("completion.first_token_including_tool_calls"),
        c = Rd.startSpan("completion.first_token_including_visible_content"),
        u = Rd.startSpan("completion.first_token"),
        d = p
    }
    );
    let f = setTimeout( () => {
        V.logEvent("SSE Response Took Too Long to Come Back", {}),
        e.logCompletion({
            type: ni.Error,
            error: {
                reason: "timeout",
                message: "SSE Response Took Too Long to Come Back"
            }
        })
    }
    , kEe);
    try {
        t?.logTimingOnce("prompt_submitted");
        for await(const p of n)
            yield p,
            p.type !== "connected" && f && (clearTimeout(f),
            f = null),
            p.type === "message" && (e.onMessageUpdate(p.message),
            r || (r = !0,
            a?.end(),
            t?.logTimingOnce("first_response")),
            !s && p.message.author.role === Ke.Assistant && (s = !0,
            l?.end(),
            t?.logTimingOnce("first_assistant_token")),
            !o && p.message.author.role === Ke.Assistant && jm(p.message) && (o = !0,
            c?.end(),
            t?.logTimingOnce("first_visible_content_token")),
            !i && p.message.author.role === Ke.Assistant && zL(p.message) && (i = !0,
            u?.end(),
            t?.logTimingOnce("first_message_token"))),
            p.type === "perf_stats" && e.addServerPerfStats(p),
            p.type === "server_ste_metadata" && e.addServerSteMetadata(p),
            p.type === "message_marker" && e.onMessageMarker(p),
            p.type === "done" && e.onStreamClose()
    } catch (p) {
        throw f && (clearTimeout(f),
        f = null),
        p
    } finally {
        d?.end()
    }
}
async function *OEe(e, t, n, r, s) {
    const {conduitToken: o, prepareState: i, model: a, f_completion: l, f_search: c} = t
      , u = Rr(3010482349, `${a}-AAAA`) || Rr(3240390095, `${a}-AAAA`)
      , d = yn(e) ? u ? "https://chatgpt.com/backend-alt" : "https://chatgpt.com/backend-api" : "https://chatgpt.com/backend-anon";
    let f = `${d}/conversation`;
    l && (f = `${d}/f/conversation`),
    Xe(e, "212625335") && (f += "?debug=true"),
    n.onSentUserMessage();
    const p = ao() ? await zH() : void 0;
    let m = JH(f, {
        ctx: e,
        method: "POST",
        headers: {
            ...sz(),
            ...t4e(t.chatReq, t.turnstileToken, t.proofToken, null),
            ...o ? {
                "x-conduit-token": o
            } : {}
        },
        body: mz(t, p),
        intercomEventOnError: "fetch-error:conversation:new-message",
        signal: r,
        observer: {
            onEvent: y => {
                n.onStreamEvent(y.byteLength, y.isDoneEvent)
            }
        }
    });
    m = gz(m, {
        ctx: e,
        model: a,
        turnTracker: n,
        signal: r ?? null
    }),
    m = _z(m, {
        turnTracker: n,
        prepareState: i,
        signal: r ?? null,
        f_completion: l ?? null
    }),
    l && s && kt(s, y => {
        y.stopConduitToken = o ?? null,
        y.conduitToken = null,
        y.prepareState = null,
        y.lastPrepareTimestamp = null
    }
    );
    const _ = $H(m, y => {
        n.stream_encoding = y
    }
    );
    yield*pz(_)
}
async function *pz(e) {
    let t = !1;
    for await(const n of e)
        if ("response"in n) {
            const r = n.response
              , s = r?.headers?.get("Cf-Ray") ?? null
              , o = r?.headers?.get("X-Conduit-Token") ?? null;
            yield{
                type: "connected",
                serverRequestId: s,
                interruptConversationToken: o
            }
        } else {
            const r = MEe(n.data);
            r && (r.type === "done" && (t = !0),
            yield r)
        }
    t || (yield{
        type: "done"
    })
}
function mz(e, t) {
    const n = "threadId"in e ? e.threadId : void 0;
    return {
        action: e.completionType,
        messages: e.messages.length > 0 ? e.messages.map(AEe) : void 0,
        continue_from_shared_conversation_id: "continueFromSharedConversationId"in e && n == null ? e.continueFromSharedConversationId : void 0,
        branching_from_conversation_id: "branchingFromConversationId"in e && n == null ? e.branchingFromConversationId : void 0,
        branching_from_message_id: "branchingFromMessageId"in e && n == null ? e.branchingFromMessageId : void 0,
        continue_from_shared_post_id: "continueFromSharedPostId"in e ? e.continueFromSharedPostId : void 0,
        fork_from_shared_post: "forkFromSharedPost"in e ? e.forkFromSharedPost : void 0,
        ..."sharedProjectConversationOwnerId"in e && "sharedProjectConversationId"in e && e.sharedProjectConversationId && e.sharedProjectConversationOwnerId ? {
            continue_from_shared_project_conversation_id: e.sharedProjectConversationId,
            shared_project_conversation_owner_id: e.sharedProjectConversationOwnerId
        } : {
            conversation_id: n
        },
        parent_message_id: e.parentMessageId,
        model: e.model,
        timezone_offset_min: new Date().getTimezoneOffset(),
        timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
        variant_purpose: e.completionMetadata?.variantPurpose,
        suggestions: e.completionMetadata?.suggestions ? e.completionMetadata.suggestions.map(r => Wd(r)) : void 0,
        chosen_suggestion: e.completionMetadata?.suggestion ? {
            type: e.completionMetadata.suggestion.type,
            index: e.completionMetadata.suggestionIndex,
            source: e.completionMetadata.suggestion.type === Gt.Autocomplete ? e.completionMetadata.suggestion.source : void 0,
            user_input: e.completionMetadata.suggestion.type === Gt.Autocomplete ? e.completionMetadata.suggestion.userInput : void 0
        } : void 0,
        history_and_training_disabled: Ps(e.historyDisabled),
        conversation_mode: c5(e.completionMetadata?.conversationMode),
        force_paragen: Ps(e.forceParagen),
        force_paragen_model_slug: e.forceParagenModel,
        force_indepth_feedback: Ps(e.forceIndepthFeedback),
        force_rate_limit: Ps(e.forceRateLimit),
        reset_rate_limits: Ps(e.resetRateLimits),
        record_rendering: Ps(e.recordRendering),
        record_transformed_convo_json: Ps(e.recordTransformedConvoJson),
        disable_system_content_toggling: Ps(e.disableSystemContentToggling),
        enable_message_followups: e.enableMessageFollowups,
        source: e.completionMetadata?.source,
        system_hints: e.completionMetadata?.systemHints,
        prefetch_ids: e.completionMetadata?.prefetchIds,
        supports_buffering: !0,
        supported_encodings: [WH.V1],
        conversation_origin: Ds(e.conversationOrigin),
        force_use_search: Ds(e.forceUseSearch),
        force_disable_features: Ds(e.forceDisableFeatures),
        client_reported_search_source: e.completionMetadata?.searchSource,
        client_contextual_info: e.contextualInfo,
        paragen_stream_type_override: Ds(e.paragenStreamType === "none" ? null : e.paragenStreamType),
        paragen_cot_summary_display_override: Ds(e.paragenCotSummaryDisplay === "none" ? null : e.paragenCotSummaryDisplay),
        is_onboarding_conversation: Ps(e.isOnboardingConversation),
        override_infer_treatment: Ds(e.overrideInferTreatment),
        model_slug_stats_override: Ds(e.modelSlugStatsOverride),
        is_anon_mode: Ps(e.isAnonModeEnabled),
        is_reasoning_skipped: Ps(e.isReasoningSkipped),
        force_parallel_switch: Ds(e.forceParallelSwitch),
        thinking_effort: Ds(e.thinkingEffort),
        juice_score: Ds(e.juiceScore),
        multimodal_juice_score: Ds(e.multimodalJuiceScore),
        local_function_names: ao() && t ? [...t] : void 0
    }
}
function AEe(e) {
    let t = e;
    return e.clientMetadata && (t = {
        ...e
    },
    delete t.clientMetadata),
    t
}
function Ps(e) {
    if (e === !0)
        return e
}
function Ds(e) {
    if (e != null)
        return e
}
function MEe(e) {
    if ("type"in e)
        switch (e.type) {
        case "gizmo_inline_review":
            return {
                type: "gizmo_inline_review",
                gizmoId: e.gizmo_id
            };
        case "title_generation":
            return {
                type: "title_generation",
                title: e.title,
                conversation_id: e.conversation_id
            };
        case "moderation":
            return {
                type: "moderation",
                conversationId: e.conversation_id,
                messageId: e.message_id,
                isCompletion: e.is_completion,
                flagged: e.moderation_response.flagged,
                blocked: e.moderation_response.blocked,
                shouldDisableConversation: !!e.moderation_response.should_disable_conversation,
                disclaimers: e.moderation_response.disclaimers,
                metadata: e.moderation_response.metadata
            };
        case "url_moderation":
            return {
                type: "url_moderation",
                conversationId: e.conversation_id,
                messageId: e.message_id,
                url: e.url_moderation_result.full_url,
                isSafe: e.url_moderation_result.is_safe
            };
        case "num_variants_in_stream":
            return {
                type: "num_variants_in_stream",
                num_variants_in_stream: e.num_variants_in_stream,
                display_treatment: e.display_treatment
            };
        case "perf_stats":
        case "conversation_detail_metadata":
        case "beacon_ui_response":
        case "resume_conversation_token":
        case "conversation_async_status":
        case "server_ste_metadata":
        case "message_marker":
            return e;
        case "message_stream_complete":
            return {
                type: "done"
            };
        default:
            return
        }
    if (e.message)
        return {
            type: "message",
            message: e.message,
            conversationId: e.conversation_id
        }
}
async function FRe(e, t, n=[], r, s=!1, o=!1) {
    const i = Ot();
    if (!rE(i, !0) || !n6e(i))
        return;
    const a = to(e)
      , l = sn(e);
    if (l?.prepareRequestBlocked)
        return;
    const c = 3e3;
    if (l?.lastCompletionFinishedTimestamp) {
        const E = performance.now() - l.lastCompletionFinishedTimestamp
          , T = c - E;
        T > 0 && await new Promise(k => setTimeout(k, T))
    }
    const u = l?.conversationOrigin ?? null;
    let d;
    s ? d = Ce.getParentPromptNode(l)?.id ?? "" : d = Ce.getCurrentNode(l).message.id;
    const f = Th()
      , p = dw(i)
      , m = l?.conduitToken ?? null
      , v = l?.prepareState ?? "none"
      , _ = {
        threadId: a,
        prepareState: v,
        conduitToken: m,
        continueFromSharedPostId: l?.continuingFromSharedPostId,
        forkFromSharedPost: !!l?.continuingFromSharedPostId,
        continueFromSharedConversationId: l?.continuingFromSharedConversationId,
        branchingFromMessageId: l?.branchingFromMessageId,
        branchingFromConversationId: l?.branchingFromConversationId,
        sharedProjectConversationId: l?.continuingFromSharedProjectConversationId,
        sharedProjectConversationOwnerId: l?.sharedProjectConversationOwner?.id,
        isOnboardingConversation: o,
        conversationOrigin: u,
        model: t,
        completionType: cu.Next,
        completionMetadata: {
            systemHints: n,
            conversationMode: l?.mode ?? {
                kind: cn.PrimaryAssistant
            }
        },
        messages: [],
        parentMessageId: d,
        recordRendering: f.recordRendering,
        recordTransformedConvoJson: f.recordTransformedConvoJson,
        historyDisabled: p
    }
      , y = ao() ? await zH() : void 0
      , b = mz(_, y)
      , S = {
        "x-conduit-token": m ?? "no-token"
    }
      , C = Rr(3010482349, `${t}-AAAA`) || Rr(3240390095, `${t}-AAAA`);
    if (C) {
        kt(e, E => {
            E.conduitToken = null,
            E.prepareState = null
        }
        );
        return
    }
    const x = `${yn(i) ? C ? "https://chatgpt.com/backend-alt" : "https://chatgpt.com/backend-api" : "https://chatgpt.com/backend-anon"}/f/conversation/prepare`;
    try {
        kt(e, k => {
            k.prepareState = "sent",
            k.lastPrepareTimestamp = performance.now()
        }
        );
        const E = await at.post(x, b, {
            additionalHeaders: S,
            authOption: Qt.SendIfAvailable
        })
          , {conduit_token: T} = E;
        r(T)
    } catch (E) {
        dr.count(er.DEFAULT, "conduit_f_conversation_prepare_api_error"),
        q.addError(E),
        kt(e, T => {
            T.conduitToken = null,
            T.prepareState = "failure"
        }
        )
    }
}
const IEe = e => new Promise(t => setTimeout(t, e));
async function *gz(e, t) {
    const n = Vn(t.ctx, "3165814200")
      , r = n.get("MIN_RETRY_INTERVAL", 300)
      , s = n.get("MAX_RETRY_INTERVAL", 5e3)
      , o = n.get("RETRY_FACTOR", 1.5)
      , i = n.get("MAX_RETRY_COUNT", 12)
      , {signal: a} = t;
    let l, c, u = e, d = 0, f = 0, p = 0, m = 0;
    for (; u != null; )
        try {
            for await(const v of u) {
                const _ = "response"in v;
                !_ && v.data != null && typeof v.data == "object" && "type"in v.data && v.data.type === "resume_conversation_token" && "token"in v.data && "conversation_id"in v.data ? (c = String(v.data.token),
                l = String(v.data.conversation_id),
                w3.set(l, c)) : yield v,
                f > 0 && (m++,
                V.logEventWithStatsig("ChatGPT Convo Stream: Resume Succeeded", "chatgpt_convo_stream_resume_succeeded", {
                    conversationId: l,
                    offset: d,
                    afterRetryCount: f,
                    successfulResumeCount: m
                }),
                f = 0),
                _ || d++
            }
            V.logEventWithStatsig("ChatGPT Convo Stream: Stream Completed", "chatgpt_convo_stream_completed", {
                conversationId: l,
                resumeAttempts: p,
                successfulResumeCount: m
            }),
            l != null && w3.remove(l),
            u = null
        } catch (v) {
            const _ = UR(v);
            if (f === 0 && V.logEventWithStatsig("ChatGPT Convo Stream: Error", "chatgpt_convo_stream_error", {
                conversationId: l,
                offset: d,
                isNetworkError: _,
                successfulResumeCount: m,
                errorMessage: v instanceof Error ? v.message : String(v)
            }),
            f < i && !a?.aborted && c != null && l != null && UR(v) && $t(t.ctx, "2489999880").get("is_resume_enabled", !1)) {
                f === 0 && V.logEventWithStatsig("ChatGPT Convo Stream: Resume Attempted", "chatgpt_convo_stream_resume_attempted", {
                    conversationId: l,
                    offset: d,
                    retryCount: f,
                    successfulResumeCount: m
                }),
                f++,
                p++;
                const b = Math.min(r * o ** f, s) * (.5 + Math.random() * .5);
                await IEe(b),
                u = vz({
                    ...t,
                    resumeToken: c,
                    conversationId: l,
                    offset: d
                })
            } else {
                const y = v instanceof _t && v.status === 404;
                throw (f >= i || y && f > 0) && V.logEventWithStatsig("ChatGPT Convo Stream: Resume Failed", "chatgpt_convo_stream_resume_failed", {
                    conversationId: l,
                    offset: d,
                    afterRetryCount: f,
                    successfulResumeCount: m,
                    isNetworkError: _,
                    is404: y
                }),
                u = null,
                v instanceof _t && v.status === 404 && f > 0 ? (l != null && w3.remove(l),
                _t.createWithErrorMessage(v.url, "client", Al)) : v
            }
        }
}
function UR(e) {
    return e instanceof Error && e.message === Al || typeof e == "string" && e === Al
}
function vz({ctx: e, conversationId: t, resumeToken: n, model: r, turnTracker: s, offset: o, signal: i}) {
    const a = Rr(3010482349, `${r}-AAAA`) || Rr(3240390095, `${r}-AAAA`)
      , l = yn(e) ? a ? "https://chatgpt.com/backend-alt" : "https://chatgpt.com/backend-api" : "https://chatgpt.com/backend-anon"
      , c = {
        "x-conduit-token": n ?? "no-token"
    }
      , u = `${l}/f/conversation/resume`
      , d = e ? Xf(e) : void 0
      , f = {
        conversation_id: t,
        offset: o
    };
    return JH(u, {
        method: "POST",
        headers: {
            ...sz(),
            ...d ? t1({
                accessToken: d
            }) : e1(),
            ...c,
            "Content-Type": "application/json"
        },
        body: f,
        intercomEventOnError: "fetch-error:conversation:new-message",
        signal: i ?? void 0,
        observer: {
            onEvent: m => {
                s.onStreamEvent(m.byteLength, m.isDoneEvent)
            }
        }
    })
}
async function *_z(e, {turnTracker: t, prepareState: n, f_completion: r, signal: s}) {
    try {
        for await(const o of e)
            yield o;
        t.onStreamClose(),
        r && E3("conduit_f_conversation_api.success", n)
    } catch (o) {
        throw dr.count(er.DEFAULT, "conversation_api.client_request_error"),
        s?.aborted ? (t.handleAbort(o),
        r && E3("conduit_f_conversation_api.aborted", n)) : (t.handleRawError(o instanceof Error || typeof o == "string" ? o : JSON.stringify(o)),
        r && E3("conduit_f_conversation_api.error", n)),
        o
    }
}
class yz {
    constructor(t, n, r, s, o, i, a, l, c, u, d, f, p, m, v, _, y, b, S, C, w=!1, x, E=!1, T=!1, k=void 0, A) {
        this.ctx = t,
        this.requestId = n,
        this.queryClient = r,
        this.initialThread = s,
        this.clientThreadId = o,
        this.parentMessageId = i,
        this.prependMessages = a,
        this.promptMessage = l,
        this.appendMessages = c,
        this.completionType = u,
        this.model = d,
        this.eventSource = f,
        this.isHistoryAndTrainingDisabled = p,
        this.startPreflightTime = m,
        this.isSnorlaxEnabledForGizmo = v,
        this.isNewThread = _,
        this.isContinuingFromSharedConversation = y,
        this.isContinuingFromBranchingConversation = b,
        this.isContinuingFromSharedProjectConversation = S,
        this.turnTracker = C,
        this.isAnonModeEnabled = x,
        this.isContinuableSharedPost = E,
        this.isReasoningSkipped = T,
        this.modelSlugStatsOverride = k,
        this.completionLatencyTracker = new QSe(this.requestId,m),
        this.isFirstCompletionInThread = _ || this.isContinuingFromSharedConversation || this.isContinuingFromSharedProjectConversation || this.isContinuableSharedPost || this.isContinuingFromBranchingConversation,
        A?.disablePlaceholder || (this.placeholderNodeId = `${ale}${n}`),
        w && (this.sentNotification = !0)
    }
    isFirstCompletionInThread;
    activeBranchLastMessage;
    messagesToUpdate = {};
    allIncompleteMessageIds = new Set;
    responseThreadId;
    isCompletionBlocked = !1;
    isEitherFlagged = !1;
    sentNotification = !1;
    variantsInStreamInfo;
    blurDuringCompletionTracker = new USe;
    completionLatencyTracker;
    preflightTime;
    treatCompletionAsAsync = !1;
    realtimeAsyncCompletion = !1;
    resumeToken;
    placeholderNodeId;
    updateBeforeRequest() {
        F6e.incrementUserMessageCount(yn(this.ctx) ? fr.LoggedIn : fr.LoggedOut),
        Du.retainThread(this.clientThreadId),
        kt(this.clientThreadId, t => {
            t.stopConduitToken = t.conduitToken ?? null,
            t.conduitToken = null,
            t.prepareState = null,
            t.lastPrepareTimestamp = null,
            this.completionType === cu.Next && Ce.hasUserMessage(t) && this.promptMessage?.author.role === Ke.User && (t.scrollToMessageId = this.promptMessage?.id),
            kr.updateTree(t, (n, r) => {
                if (this.parentMessageId && (r = Ce.getNode(t, this.parentMessageId).id),
                this.prependMessages)
                    for (const o of this.prependMessages)
                        r = n.addMessageNode(r, o);
                if (this.promptMessage && (r = n.addMessageNode(r, this.promptMessage)),
                this.appendMessages)
                    for (const o of this.appendMessages)
                        r = n.addMessageNode(r, o);
                const s = this.promptMessage?.metadata?.gizmo_id;
                if (this.placeholderNodeId) {
                    const o = z8("", s ? {
                        gizmo_id: s
                    } : void 0, {
                        requestId: this.requestId,
                        isPlaceholder: !0
                    }, this.placeholderNodeId);
                    r = n.addMessageNode(r, o)
                }
                return r
            }
            )
        }
        )
    }
    async sendRequest$({conduitToken: t, turnstileToken: n, proofToken: r, completionMetadata: s, resolvedParentMessageId: o, messages: i, extraStreamParams: a, chatReq: l, profiler: c}) {
        TR(this.clientThreadId, !0);
        const u = new AbortController;
        uf.addRequest(this.requestId, u, this.turnTracker);
        const d = Th()
          , f = to(this.clientThreadId);
        if (this.completionType === cu.Variant && f == null) {
            q.addError("Generating variant without conversation_id"),
            this.#n(new Error("Regeneration must have conversation_id"));
            return
        }
        const p = xEe(this.ctx, {
            conversationOrigin: this.initialThread?.conversationOrigin ?? null,
            model: this.model,
            completionType: this.completionType,
            prepareState: this.initialThread?.prepareState ?? "none",
            conduitToken: t,
            threadId: f,
            isReasoningSkipped: this.isReasoningSkipped,
            overrideInferTreatment: d.autoSwitcherTreatmentOverride,
            modelSlugStatsOverride: this.modelSlugStatsOverride,
            continueFromSharedConversationId: this.initialThread?.continuingFromSharedConversationId,
            branchingFromConversationId: this.initialThread?.branchingFromConversationId,
            branchingFromMessageId: this.initialThread?.branchingFromMessageId,
            sharedProjectConversationOwnerId: this.initialThread?.sharedProjectConversationOwner?.id,
            sharedProjectConversationId: this.initialThread?.continuingFromSharedProjectConversationId,
            continueFromSharedPostId: this.initialThread?.continuingFromSharedPostId,
            forkFromSharedPost: this.initialThread?.forkFromSharedPost,
            historyDisabled: this.isHistoryAndTrainingDisabled,
            isAnonModeEnabled: this.isAnonModeEnabled,
            parentMessageId: o,
            messages: i,
            chatReq: l,
            turnstileToken: n,
            proofToken: r,
            completionMetadata: s,
            contextualInfo: {
                is_dark_mode: sSe(),
                time_since_loaded: Math.floor(performance.now() / 1e3),
                page_height: window.innerHeight,
                page_width: window.innerWidth,
                pixel_ratio: window.devicePixelRatio,
                screen_height: window.screen.height,
                screen_width: window.screen.width
            },
            isOnboardingConversation: s?.isOnboardingConversation,
            thinkingEffort: this.#e(),
            forceParagen: d.forceParagen,
            forceParagenModel: d.forceParagen ? d.forceParagenModel.value : void 0,
            forceRateLimit: d.forceRateLimit,
            resetRateLimits: d.resetRateLimits,
            recordRendering: d.recordRendering,
            recordTransformedConvoJson: d.recordTransformedConvoJson,
            disableSystemContentToggling: d.rebaseSystemMessageContent != null,
            forceUseSearch: d.forceUseSearch ?? void 0,
            paragenStreamType: d.paragenStreamType,
            paragenCotSummaryDisplay: d.paragenCotSummaryDisplay,
            forceParallelSwitch: d.forceParallelSwitch,
            juiceScore: d.juiceScore,
            multimodalJuiceScore: d.multimodalJuiceScore,
            ...rE(this.ctx) ? {
                f_completion: !0
            } : {},
            ...r6e() ? {
                f_search: !0
            } : {},
            ...a
        }, this.turnTracker, c, u.signal, this.clientThreadId);
        try {
            for await(const m of p)
                m.type === "connected" ? this.#t(m) : AR(m) && this.#r(m)
        } catch (m) {
            zE(m) || u.signal.aborted ? this.#o(m) : this.#n(m)
        } finally {
            TR(this.clientThreadId, !1)
        }
    }
    async sendResumeRequest$({conversationId: t, resumeToken: n, profiler: r}) {
        const s = new AbortController;
        uf.addRequest(this.requestId, s, this.turnTracker),
        kt(this.clientThreadId, i => {
            kr.setRequestIdOnCurrentLeaf(i, this.requestId)
        }
        );
        const o = TEe(this.ctx, {
            conversationId: t,
            resumeToken: n,
            model: this.model
        }, this.turnTracker, r, s.signal, this.clientThreadId);
        try {
            for await(const i of o)
                i.type === "connected" ? this.#t(i) : AR(i) && this.#r(i)
        } catch (i) {
            zE(i) || s.signal.aborted ? this.#o(i) : this.#n(i)
        }
    }
    #e() {
        if (this.model !== U6e)
            return;
        const t = B6e(this.ctx);
        if (!t || !t.showJuiceControl)
            return;
        const n = q6e(this.ctx);
        return G6e(da(n), this.model, t.legacyDefault)
    }
    #t(t) {
        const {serverRequestId: n, interruptConversationToken: r} = t;
        this.turnTracker.onStreamOpen(),
        n && this.turnTracker.onReceivedServerRequestId(n),
        r && kt(this.clientThreadId, s => {
            s.conduitToken = r
        }
        ),
        YSe(this.requestId, this.model, n, io(this.preflightTime))
    }
    #r = t => {
        if (this.activeBranchLastMessage && this.completionLatencyTracker.onResponse(t, this.activeBranchLastMessage, this.responseThreadId),
        this.responseThreadId === void 0 && "conversationId"in t) {
            const n = t.conversationId;
            if (this.responseThreadId = n,
            hh(this.clientThreadId) && to(this.clientThreadId) !== n && (NSe(this.ctx, this.clientThreadId, n),
            V.logEvent("Attribution: Client Thread to Server Thread", {
                client_thread_id: this.clientThreadId,
                server_thread_id: n
            })),
            this.isContinuingFromSharedConversation && (kt(this.clientThreadId, s => {
                delete s.continuingFromSharedConversationId
            }
            ),
            ft.logEvent("chatgpt_continue_conversation_first_message_sent"),
            V.logEvent("Continue Conversation: First Message Sent")),
            this.isContinuingFromBranchingConversation && kt(this.clientThreadId, s => {
                delete s.branchingFromConversationId,
                delete s.branchingFromMessageId
            }
            ),
            this.isContinuingFromSharedProjectConversation && kt(this.clientThreadId, s => {
                delete s.continuingFromSharedProjectConversationId,
                delete s.sharedProjectConversationOwner
            }
            ),
            this.isContinuableSharedPost && kt(this.clientThreadId, s => {
                delete s.continuingFromSharedPostId,
                delete s.forkFromSharedPost
            }
            ),
            this.isFirstCompletionInThread) {
                const s = sn(this.clientThreadId);
                V.logEvent("Create New Thread"),
                !this.isHistoryAndTrainingDisabled && I6e(s?.mode) && yn(this.ctx) && (UH(this.queryClient, Ce.getGizmoId(s)),
                s?.disableConversationNavigation || y6e(D6e, this.queryClient, n, this.isSnorlaxEnabledForGizmo)),
                this.queryClient.invalidateQueries(Vs())
            }
            const r = {
                id: this.requestId,
                threadId: this.responseThreadId,
                completionType: this.completionType,
                eventSource: this.eventSource,
                model: this.model
            };
            if (this.completionType === cu.Next) {
                const s = Ce.getConversationTurns(this.initialThread)
                  , o = s.length
                  , i = s.filter(l => l.role === Ke.User)
                  , a = i && i[i.length - 1]?.messages[0];
                if (a?.content.content_type === rt.Text) {
                    const l = a.content.parts.join("").length
                      , c = i?.length ?? 0;
                    r.countConversationTurns = o,
                    r.countUserSubmittedMessages = c,
                    r.countLastUserPromptTextMessageLength = l
                }
            }
            V.logEvent("Generate Completion", r)
        }
        switch (t.type) {
        case "num_variants_in_stream":
            this.#h(t);
            break;
        case "moderation":
            this.#p(t);
            break;
        case "url_moderation":
            this.#m(t);
            break;
        case "message":
            this.#g(t);
            break;
        case "done":
            this.#i();
            break;
        case "gizmo_inline_review":
            this.#s(t);
            break;
        case "title_generation":
            this.#l(t);
            break;
        case "conversation_detail_metadata":
            this.#c(t);
            break;
        case "beacon_ui_response":
            this.#u(t);
            break;
        case "conversation_async_status":
            this.#d(t);
            break;
        case "resume_conversation_token":
            this.#f(t);
            break
        }
    }
    ;
    #n(t) {
        const n = N$(t)
          , r = n.message
          , s = t instanceof _t ? t.code : void 0
          , o = t instanceof _t ? t.detail?.can_retry : void 0
          , i = r === Al
          , a = i && !this.treatCompletionAsAsync && yn(this.ctx) && $t(this.ctx, "2489999880").get("is_polling_enabled", !1);
        a && (this.treatCompletionAsAsync = !0),
        this.debouncedUpdateExistingMessages.flush(),
        this.treatCompletionAsAsync && r === Al && !a || kt(this.clientThreadId, c => {
            kr.updateTree(c, (u, d) => {
                const f = this.variantsInStreamInfo ? Ce.getParentPromptNode(c)?.id ?? d : d
                  , p = {
                    err: a ? R$ : r,
                    errType: a ? "info" : "danger",
                    errCode: a ? _N.NetworkErrorWithReconnection : s,
                    completionSampleFinishTime: Date.now(),
                    canRetry: a ? !1 : o
                };
                if (u.getNodeIfExists(f)?.message?.content?.content_type !== rt.Text) {
                    const m = z8("");
                    return m.clientMetadata = {
                        ...m.clientMetadata,
                        ...p
                    },
                    u.addMessageNode(f, m)
                } else
                    u.updateNodeMetadata(f, p)
            }
            )
        }
        );
        try {
            const c = sn(this.clientThreadId);
            if (Ce.getLastMessageSystemHints(c)?.includes(Zs)) {
                const f = t instanceof _t ? t : void 0
                  , p = f?.status
                  , m = f?.isClientError() ?? !1
                  , v = f?.isServerError() ?? !1
                  , _ = i ? "network" : v ? "server" : m ? "client" : "unknown";
                q.addAction("agent.conversation.start_failed", {
                    request_id: this.requestId,
                    model: this.model,
                    error_code: s ?? "unknown",
                    is_network_error: i,
                    is_recoverable_error: a,
                    error_status: p,
                    is_client_error: m,
                    is_server_error: v,
                    error_type: _
                })
            }
        } catch {}
        switch (i && V.logNetworkError({
            source: "request_stream",
            type: a ? "info_polling" : "error"
        }),
        s) {
        case Mu.ContentPolicy:
        case Mu.ContentOrTos:
        case Gp.ModelCapExceeded:
        case Gp.HistoryDisabledConversationNotFound:
            break;
        default:
            r !== void 0 && ft.logEvent("chatgpt_conversation_error_web", r)
        }
        if (this.blurDuringCompletionTracker.onMessageError(),
        yR(n),
        this.#a(),
        du.publish({
            kind: "completionFinished",
            serverThreadId: this.responseThreadId
        }),
        t instanceof _t && t.code === Gp.ModelCapExceeded) {
            const c = t.detail?.clears_in;
            c && (i3e(new Date(Date.now() + c * 1e3).toISOString()),
            setTimeout( () => {
                RV()
            }
            , c * 1e3))
        }
    }
    #s({gizmoId: t}) {
        kt(this.clientThreadId, n => {
            n.promptGptRating = {
                gizmoId: t
            }
        }
        )
    }
    #l(t) {
        BH(this.ctx, t.conversation_id, t.title, Fw.Generated),
        this.isSnorlaxEnabledForGizmo || p6e(this.ctx, t.conversation_id, t.title),
        this.maybeSendNotification()
    }
    #c(t) {
        const {default_model_slug: n} = t;
        n && kt(this.clientThreadId, s => {
            s.modelId = n
        }
        ),
        Xe(this.ctx, "3315017149") && qQ(t) && this.queryClient.invalidateQueries({
            queryKey: lh()
        }),
        zD.updateDetails(t)
    }
    #u(t) {
        R6e.updateDetails(t)
    }
    #d(t) {
        const {async_status: n} = t;
        n === Ar.REALTIME && (this.realtimeAsyncCompletion = !0),
        this.responseThreadId && dl(this.responseThreadId, {
            source: wo.SERVER,
            value: n
        }),
        dl(this.clientThreadId, {
            source: wo.SERVER,
            value: n
        })
    }
    #f(t) {
        const {token: n} = t;
        this.resumeToken = n ?? void 0;
        const r = sn(this.clientThreadId)
          , o = Ce.getLastMessageSystemHints(r)?.includes(Zs);
        this.realtimeAsyncCompletion && o && q.addAction("agent.conversation.start_succeeded", {
            conversation_id: t.conversation_id ?? this.responseThreadId ?? "",
            request_id: this.requestId,
            model: this.model
        })
    }
    #h(t) {
        this.variantsInStreamInfo = t,
        kt(this.clientThreadId, n => {
            kr.updateTree(n, (r, s) => {
                const o = Ce.getParentPromptNode(n) ?? r.getNodeByIdOrMessageId(s);
                r.updateNodeMetadata(o.id, {
                    variantsInStreamInfo: this.variantsInStreamInfo
                })
            }
            )
        }
        )
    }
    #p(t) {
        const {isCompletion: n, flagged: r, blocked: s, disclaimers: o} = t
          , i = !!o?.length;
        (r || s || i) && (this.debouncedUpdateExistingMessages.flush(),
        this.isEitherFlagged = !0,
        s && n && (this.isCompletionBlocked = !0),
        e6e(t, this.clientThreadId))
    }
    #m(t) {
        const {conversationId: n, url: r, isSafe: s} = t;
        s && kt(n, o => {
            o.safeUrls.push(r)
        }
        )
    }
    #g({message: t, conversationId: n}) {
        if (this.activeBranchLastMessage = t,
        t?.author.role === Ke.Tool && t?.author.name === "bio") {
            const r = t.metadata?.gizmo_id;
            setTimeout( () => {
                this.queryClient.invalidateQueries({
                    queryKey: VH(r)
                })
            }
            , 5e3)
        }
        if (t.metadata?.trigger_async_ux && (this.treatCompletionAsAsync = !0,
        dl(this.clientThreadId, {
            source: wo.SERVER,
            value: Ar.STREAMING
        })),
        Ce.getTree(sn(n)).containsNodeOrMessageId(t.id)) {
            this.messagesToUpdate[t.id] = t,
            this.debouncedUpdateExistingMessages();
            return
        }
        this.debouncedUpdateExistingMessages.flush(),
        kt(this.clientThreadId, r => {
            kr.updateTree(r, (s, o) => {
                const i = {
                    requestId: this.requestId
                };
                t.status !== "in_progress" ? i.completionSampleFinishTime = Date.now() : this.allIncompleteMessageIds.add(t.id);
                const a = {
                    ...t,
                    clientMetadata: i
                }
                  , l = t.metadata?.parent_id;
                if (l) {
                    if (this.placeholderNodeId && s.getParent(this.placeholderNodeId).id === s.getNodeByIdOrMessageId(l).id)
                        if (Ca(a)) {
                            s.prependNode(this.placeholderNodeId, a);
                            return
                        } else
                            s.deleteNode(this.placeholderNodeId),
                            this.placeholderNodeId = void 0;
                    return s.addMessageNode(l, a)
                } else {
                    const c = s.findFirst(u => !Ca(u.message));
                    if (c)
                        s.prependNode(c.id, a);
                    else
                        return s.addMessageNode(o, a)
                }
            }
            )
        }
        )
    }
    debouncedUpdateExistingMessages = DB( () => {
        if (this.isCompletionBlocked)
            return;
        const t = Object.values(this.messagesToUpdate);
        t.length !== 0 && (kt(this.clientThreadId, n => {
            kr.updateTree(n, r => {
                for (const s of t)
                    r.updateNodeMessage(s.id, s),
                    s.status !== "in_progress" && (r.updateNodeMetadata(s.id, {
                        completionSampleFinishTime: Date.now()
                    }),
                    this.allIncompleteMessageIds.delete(s.id))
            }
            )
        }
        ),
        this.messagesToUpdate = {})
    }
    , 50, {
        leading: !0,
        maxWait: 50
    });
    #o(t) {
        this.debouncedUpdateExistingMessages.flush(),
        kt(this.clientThreadId, n => {
            kr.updateTree(n, r => {
                for (const s of this.allIncompleteMessageIds)
                    r.updateNodeMessageMetadata(s, {
                        finish_details: {
                            type: "interrupted"
                        }
                    })
            }
            )
        }
        ),
        this.#i()
    }
    #i() {
        this.debouncedUpdateExistingMessages.flush(),
        this.isEitherFlagged || (this.isFirstCompletionInThread && this.responseThreadId && !this.isHistoryAndTrainingDisabled && !ft.checkGate("2562876640") && _6e(this.ctx, this.responseThreadId, this.model),
        du.publish({
            kind: "completionFinished",
            serverThreadId: this.responseThreadId
        })),
        du.publish({
            kind: "createConversation",
            clientThreadId: this.clientThreadId
        }),
        this.blurDuringCompletionTracker.onMessageDone(),
        yR(),
        this.#a()
    }
    maybeSendNotification() {
        if (this.sentNotification)
            return;
        const t = sn(this.clientThreadId)
          , n = t?.title ?? void 0;
        if (!n)
            return;
        const r = Ce.getCurrentNode(t).message;
        if (iE(r) && !w6e(r))
            return;
        const s = r.content
          , o = s?.content_type === rt.Text ? P6e(s.parts[0] ?? "") : void 0;
        O6e({
            title: n,
            subtitle: o,
            clientThreadId: this.clientThreadId
        }),
        this.sentNotification = !0
    }
    #a() {
        kt(this.clientThreadId, t => {
            kr.updateTree(t, n => {
                for (const r of this.allIncompleteMessageIds)
                    n.updateNodeMetadata(r, {
                        completionSampleFinishTime: Date.now()
                    })
            }
            )
        }
        ),
        this.allIncompleteMessageIds.clear(),
        kt(this.clientThreadId, t => {
            t.conduitToken = null
        }
        ),
        setTimeout( () => {
            if (this.treatCompletionAsAsync || this.realtimeAsyncCompletion) {
                const t = this.treatCompletionAsAsync ? Ar.STREAMING : Ar.REALTIME
                  , n = r => {
                    if (!r)
                        return;
                    const s = nE(this.ctx, r);
                    (s == null || s.source === wo.CLIENT) && dl(r, {
                        source: wo.SERVER,
                        value: t
                    })
                }
                ;
                n(this.responseThreadId),
                n(this.clientThreadId)
            } else
                dl(this.clientThreadId, {
                    source: wo.CLIENT,
                    value: Ar.UNREAD
                });
            this.maybeSendNotification(),
            uf.removeRequest(this.requestId),
            Du.releaseThread(this.clientThreadId)
        }
        , 0)
    }
}
const REe = 10
  , NEe = dn(Da( () => ({
    requests: {},
    requestIds: []
})))
  , jp = (e, t, n) => {
    if (!us(Ot()).checkGate("1154002920"))
        return null;
    NEe.setState(r => {
        if (r.requestIds.length === REe) {
            const s = r.requestIds.shift();
            s != null && delete r.requests[s]
        }
        r.requests[e] ??= {
            serverRequestId: null,
            timeToFirstToken: null,
            apiStartDelay: null,
            serverStats: null
        },
        r.requests[e][t] = n
    }
    )
}
  , Up = {
    publishServerRequestId: (e, t) => {
        jp(e, "serverRequestId", t)
    }
    ,
    publishServerStats: (e, t) => {
        jp(e, "serverStats", t)
    }
    ,
    publishApiStartDelay: (e, t) => {
        jp(e, "apiStartDelay", t)
    }
    ,
    publishTimeToFirstToken: (e, t) => {
        jp(e, "timeToFirstToken", t)
    }
};
var x3, BR;
function PEe() {
    if (BR)
        return x3;
    BR = 1;
    function e(t) {
        return t === void 0
    }
    return x3 = e,
    x3
}
var DEe = PEe();
const LEe = mn(DEe);
var T3, qR;
function FEe() {
    if (qR)
        return T3;
    qR = 1;
    var e = "Expected a function";
    function t(n) {
        if (typeof n != "function")
            throw new TypeError(e);
        return function() {
            var r = arguments;
            switch (r.length) {
            case 0:
                return !n.call(this);
            case 1:
                return !n.call(this, r[0]);
            case 2:
                return !n.call(this, r[0], r[1]);
            case 3:
                return !n.call(this, r[0], r[1], r[2])
            }
            return !n.apply(this, r)
        }
    }
    return T3 = t,
    T3
}
var k3, GR;
function jEe() {
    if (GR)
        return k3;
    GR = 1;
    var e = ih()
      , t = FEe()
      , n = PH();
    function r(s, o) {
        return n(s, t(e(o)))
    }
    return k3 = r,
    k3
}
var UEe = jEe();
const BEe = mn(UEe);
function qEe(e) {
    return typeof e == "number" ? Math.trunc(e) : e
}
const GEe = ["time_since_prompt_sent_ms", "time_since_last_event_ms", "first_token_lat", "api_start_delay", "completion_request_time_to_first_visible_message"];
class bz {
    ctx;
    start_time_ms;
    turn_id;
    trigger;
    result;
    time_since_prompt_sent_ms;
    stream_update_event_count = 0;
    first_token_lat;
    first_visible_content_token_lat;
    first_nav_link_token_lat;
    last_model_message_received;
    api_start_time;
    time_since_last_event_ms;
    api_start_delay;
    completion_request_time_to_first_visible_message;
    model_slug;
    last_message_model_slug;
    tools_used;
    system_hints;
    gizmo_id;
    promptSentTimestamp;
    serverStats;
    serverSteMetadata;
    logger;
    server_request_id;
    client_request_id;
    completed = !1;
    num_images_attached = 0;
    num_files_attached = 0;
    bytes_received = 0;
    model_message_update_count = 0;
    stream_encoding;
    stream_buffering = !0;
    gizmo_type;
    isStreamOpen = !1;
    isTemporaryChat;
    messageMarkerLatencies = {};
    constructor({ctx: t, clientRequestId: n, gizmoType: r, preflightTime: s, isTemporaryChat: o}) {
        this.ctx = t,
        this.client_request_id = n,
        this.start_time_ms = performance.now(),
        this.turn_id = Ts(),
        this.promptSentTimestamp = s ?? performance.now(),
        this.tools_used = new Set,
        this.system_hints = new Set,
        this.logger = vS.createLogger("turn-analytics", "info", "http"),
        r && (this.gizmo_type = r),
        this.isTemporaryChat = o
    }
    truncateValueForKey(t) {
        const n = qEe(this[t]);
        n !== void 0 && (this[t] = n)
    }
    onUserMessages(t) {
        t.forEach(n => {
            n.author.role === "user" && (n.metadata?.attachments?.forEach(r => {
                r.height && r.width ? this.num_images_attached += 1 : this.num_files_attached += 1
            }
            ),
            n.metadata?.system_hints?.forEach(r => {
                this.system_hints.add(r)
            }
            ))
        }
        )
    }
    addServerPerfStats(t) {
        Up.publishServerStats(this.client_request_id, t),
        this.serverStats = t
    }
    addServerSteMetadata(t) {
        this.serverSteMetadata = t.metadata
    }
    onMessageMarker(t) {
        const r = `${t.event}_received`;
        this.messageMarkerLatencies[t.marker] = {
            ...this.messageMarkerLatencies[t.marker],
            [r]: performance.now() - this.promptSentTimestamp
        }
    }
    onStreamOpen() {
        this.isStreamOpen = !0,
        this.logCompletionStarted()
    }
    onStreamClose() {
        this.model_message_update_count > 0 ? this.logCompletion({
            type: ni.Success
        }) : this.logCompletion({
            type: ni.Error,
            error: {
                reason: "empty_response",
                message: "Successful completion ended with no messages"
            }
        })
    }
    onCompletionStarted(t, n) {
        switch (t) {
        case "next":
            this.trigger = "submit";
            break;
        case "variant":
            this.trigger = "reroll";
            break;
        case "continue":
            this.trigger = "continue";
            break
        }
        this.model_slug = n
    }
    onReceivedServerRequestId(t) {
        this.server_request_id = t,
        Up.publishServerRequestId(this.client_request_id, this.server_request_id)
    }
    onStreamEvent(t, n) {
        this.bytes_received += t,
        n || (this.stream_update_event_count += 1)
    }
    onSentUserMessage() {
        this.api_start_time = performance.now(),
        this.api_start_delay = this.api_start_time - this.promptSentTimestamp,
        Up.publishApiStartDelay(this.client_request_id, this.api_start_delay)
    }
    onMessageUpdate(t) {
        const {model_slug: n, gizmo_id: r} = t.metadata ?? {}
          , {role: s, name: o} = t.author;
        if (this.gizmo_id = this.gizmo_id ?? r,
        s === Ke.Tool && o && this.tools_used.add(o),
        s !== Ke.User && s !== Ke.System && s !== Ke.Developer && s !== Ke.Root && (this.model_message_update_count += 1,
        this.last_model_message_received = performance.now(),
        this.last_message_model_slug = n ?? this.last_message_model_slug),
        !this.first_token_lat && t.author.role !== Ke.User && jm(t) && m1(t).length > 0) {
            const i = performance.now();
            this.first_token_lat = i - this.promptSentTimestamp,
            this.api_start_time && (this.completion_request_time_to_first_visible_message = i - this.api_start_time),
            Up.publishTimeToFirstToken(this.client_request_id, this.first_token_lat)
        }
        !this.first_visible_content_token_lat && t.author.role === Ke.Assistant && jm(t) && (this.first_visible_content_token_lat = performance.now() - this.promptSentTimestamp),
        !this.first_nav_link_token_lat && Do(t) === Re.SuperWidget && t.content.widgets.navlinks.length > 0 && (this.first_nav_link_token_lat = performance.now() - this.promptSentTimestamp)
    }
    handleAbort(t) {
        this.logCompletion({
            type: ni.Canceled
        })
    }
    handleRawError(t) {
        let n, r = null, s = null;
        t instanceof Error ? (r = t.message ?? "Something went wrong",
        s = t instanceof _t ? t.status : void 0) : r = t,
        s === 400 || r === Al || r === "NetworkError when attempting to fetch resource." || r === "The network connection was lost." ? n = "network_error" : r === "Request timed out" ? n = "timeout" : n = "request_failed",
        this.logCompletion({
            type: ni.Error,
            error: {
                reason: n,
                message: r,
                ...s && {
                    status_code: s
                }
            }
        })
    }
    getFeatureFlags() {
        const t = {
            "resumable-streaming": $t(this.ctx, "2489999880", {
                disableExposureLog: !0
            }).get("is_resume_enabled", !1)
        }
          , n = Object.entries(t)
          , r = n.filter( ([o,i]) => i).map( ([o]) => o)
          , s = n.filter( ([o,i]) => !i).map( ([o]) => o);
        return {
            enabled_feature_flags: r,
            disabled_feature_flags: s
        }
    }
    createLogPayload() {
        const {enabled_feature_flags: t, disabled_feature_flags: n} = this.getFeatureFlags()
          , r = {
            turn_id: this.turn_id,
            trigger: this.trigger,
            result: io(this.result?.type),
            ...this.result?.type === ni.Error ? {
                error: this.result.error
            } : void 0,
            time_since_prompt_sent_ms: this.time_since_prompt_sent_ms,
            stream_update_event_count: this.stream_update_event_count,
            model_message_update_count: this.model_message_update_count,
            time_since_last_event_ms: this.time_since_last_event_ms,
            first_token_lat: this.first_token_lat,
            first_visible_content_token_lat: this.first_visible_content_token_lat,
            first_nav_link_token_lat: this.first_nav_link_token_lat,
            api_start_delay: this.api_start_delay,
            completion_request_time_to_first_visible_message: this.completion_request_time_to_first_visible_message,
            bytes_received: this.bytes_received,
            stream_encoding: this.stream_encoding,
            stream_buffering: this.stream_buffering,
            model_slug: this.model_slug,
            last_message_model_slug: this.last_message_model_slug,
            tools_used: [...this.tools_used],
            system_hints: [...this.system_hints],
            gizmo_id: this.gizmo_id,
            attachments: {
                files: this.num_files_attached,
                images: this.num_images_attached,
                total: this.num_files_attached + this.num_images_attached
            },
            temporary_chat: this.isTemporaryChat,
            gizmo_type: this.gizmo_type,
            server_ste_metadata: this.serverSteMetadata,
            message_marker_latencies: this.messageMarkerLatencies,
            enabled_feature_flags: t,
            disabled_feature_flags: n
        };
        return {
            request_id: this.server_request_id,
            turn_analytics: r
        }
    }
    createStatsigPayload() {
        return BEe({
            turn_id: String(this.turn_id),
            trigger: this.trigger,
            result: this.result?.type,
            error: JSON.stringify(this.result?.type === ni.Error ? {
                error: this.result.error
            } : void 0),
            time_since_prompt_sent_ms: String(this.time_since_prompt_sent_ms),
            stream_update_event_count: String(this.stream_update_event_count),
            model_message_update_count: String(this.model_message_update_count),
            time_since_last_event_ms: JSON.stringify(this.time_since_last_event_ms),
            first_token_lat: String(this.first_token_lat),
            api_start_delay: String(this.api_start_delay),
            completion_request_time_to_first_visible_message: String(this.completion_request_time_to_first_visible_message),
            bytes_received: String(this.bytes_received),
            stream_encoding: this.stream_encoding,
            stream_buffering: this.stream_buffering,
            model_slug: this.model_slug,
            last_message_model_slug: this.last_message_model_slug,
            tools_used: [...this.tools_used].join(", "),
            system_hints: [...this.system_hints].join(", "),
            gizmo_id: this.gizmo_id,
            attachments: JSON.stringify({
                files: this.num_files_attached,
                images: this.num_images_attached,
                total: this.num_files_attached + this.num_images_attached
            }),
            temporary_chat: String(this.isTemporaryChat),
            gizmo_type: this.gizmo_type,
            server_ste_metadata: JSON.stringify(this.serverSteMetadata),
            message_marker_latencies: JSON.stringify(this.messageMarkerLatencies)
        }, LEe)
    }
    logCompletionStarted() {
        V.logEventWithStatsig("chatgpt_conversation_turn_turn_exchange_started", "chatgpt_conversation_turn_turn_exchange_started", this.createStatsigPayload())
    }
    logCompletion(t) {
        if (this.completed)
            return;
        const n = performance.now();
        dr.count(er.DEFAULT, "completion_request"),
        dr.hist(er.DEFAULT, "completion_request_time", [], n - this.start_time_ms),
        this.completed = !0,
        this.result = t;
        for (const r of GEe)
            this.truncateValueForKey(r);
        this.time_since_prompt_sent_ms = n - this.promptSentTimestamp,
        this.last_model_message_received && (this.time_since_last_event_ms = n - this.last_model_message_received),
        t.type === ni.Error ? this.logger.error("Turn exchange complete", this.createLogPayload()) : this.logger.info("Turn exchange complete", this.createLogPayload()),
        V.logEventWithStatsig("chatgpt_conversation_turn_turn_exchange_complete", "chatgpt_conversation_turn_turn_exchange_complete", this.createStatsigPayload())
    }
}
function jRe(e) {
    return Gne(e) && !Hne(e)
}
const Bp = 50
  , VEe = 95;
function URe(e, t) {
    if (e <= t)
        return e / t * Bp;
    {
        const n = Bp
          , r = VEe - Bp
          , s = e - t
          , i = -(Bp / t) / r;
        return n + r * (1 - Math.exp(i * s))
    }
}
class HEe {
    mostRecentCompletionRequest;
    loggedRequests = new Set;
    onCompletionRequestStarted(t) {
        this.mostRecentCompletionRequest = {
            requestId: t,
            timestamp: Date.now()
        },
        this.loggedRequests.clear()
    }
    logEvent(t, n, r, s, o) {
        const i = this.mostRecentCompletionRequest;
        i != null && !this.loggedRequests.has(t) && Ce.getNode(sn(n), r).message.clientMetadata?.requestId === i.requestId && (V.logEvent(t, {
            messageId: r,
            timeMs: Date.now() - i.timestamp,
            ...s
        }),
        o?.(),
        this.loggedRequests.add(t))
    }
}
const zEe = new HEe;
function BRe(e) {
    return (e.find(s => s.metadata?.image_search_results !== void 0)?.metadata?.image_search_results ?? []).slice(0, 5)
}
function Cz(e, t) {
    if (Xe(e, "1627380539"))
        return "gpt-5";
    switch (bn(e)?.planType) {
    case We.FREE:
        return t ? "gpt-4o" : "auto";
    case void 0:
        return "auto";
    default:
        return "gpt-4o"
    }
}
function $Ee(e) {
    return e instanceof KeyboardEvent || "key"in e || "detail"in e && e.detail === 0 ? "keyboard" : "mouse"
}
function Sz(e) {
    return e != null && typeof e == "object" && "then"in e && typeof e.then == "function"
}
const wz = TH( () => Ct(!1));
function WEe(e) {
    return wz(e)()
}
function Ez(e, t) {
    wz(e).set(t)
}
function xz(e, t) {
    const n = sn(t)?.mode
      , r = n && "gizmo_id"in n ? n.gizmo_id : null;
    if (r != null)
        return QCe(e, r) ? zl.PROJECT : zl.GPT
}
const KEe = "https://challenges.cloudflare.com/turnstile/v0/api.js"
  , YEe = {
    [ff.PAID]: "0x4AAAAAAASbFNinhLLnW5f1",
    [ff.FREEACCOUNT]: "0x4AAAAAAACPe2BTwOIpYk6H",
    [ff.NOAUTH]: "0x4AAAAAAASbHVR44GU82lOI"
};
class yg {
    toString() {
        return JSON.stringify(this.toJSON())
    }
}
class O3 extends yg {
    constructor(t) {
        super(),
        this.message = t,
        this.message = t
    }
    toJSON() {
        return {
            "Turnstile-Internal-Error": this.message
        }
    }
}
class ZEe extends yg {
    constructor(t) {
        super(),
        this.errorCode = t,
        this.errorCode = t
    }
    toJSON() {
        return {
            "Turnstile-Client-Error": this.errorCode
        }
    }
}
class JEe {
    app = ff.NOAUTH;
    status = "idle";
    turnstileInstancePromise = null;
    enforcementTokenPromise = null;
    enforcementTokenCache = new WeakMap;
    requestStartTimeMs = 0;
    _onCompleted;
    _onError;
    async initializeAndGatherData(t) {
        this._getOrCreateInstance(t)
    }
    async _getOrCreateInstance(t) {
        return !t.turnstile?.required || t.turnstile?.dx ? null : (this.app !== t.persona && (this.app = t.persona,
        this.turnstileInstancePromise = this._getTurnstileInstancePromise()),
        this.turnstileInstancePromise ?? new O3("Turnstile instance not initialized."))
    }
    getEnforcementTokenSync(t) {
        return this.enforcementTokenCache.get(t) ?? null
    }
    async getEnforcementToken(t) {
        return t.turnstile?.dx ? wS(t.turnstile.dx) : this.startEnforcement(t).then(n => (this.enforcementTokenPromise = null,
        n ? n.toString() : null))
    }
    async startEnforcement(t) {
        return t.turnstile?.required ? t.turnstile?.dx ? wS(t.turnstile.dx).then(n => (n && this.enforcementTokenCache.set(t, n),
        n)) : this.enforcementTokenPromise !== null ? this.enforcementTokenPromise : this.enforcementTokenPromise = this._getEnforcementToken(t) : null
    }
    async _getEnforcementToken(t, n) {
        const r = await this._getOrCreateInstance(t);
        return r instanceof yg || r === null ? r : new Promise( (s, o) => {
            this.setOnCompleted(i => {
                const a = performance.now() - this.requestStartTimeMs;
                q.addAction("turnstile_get_token_success", {
                    app: this.app.toString(),
                    durationMs: a
                }),
                s(i)
            }
            ),
            this.setOnError(i => {
                if (!n)
                    this._getEnforcementToken(t, !0).then(s, o);
                else {
                    const a = performance.now() - this.requestStartTimeMs;
                    q.addAction("turnstile_get_token_error", {
                        app_release: "9d358314d30a26d59ec2f2390d079c86e2c0018f",
                        error: i,
                        app: this.app.toString(),
                        durationMs: a
                    }),
                    s(new ZEe(i))
                }
            }
            ),
            this.setStatus("ready"),
            this.requestStartTimeMs = performance.now(),
            r.reset(),
            r.execute()
        }
        )
    }
    setStatus(t) {
        this.status = t
    }
    onCompleted(t) {
        this._onCompleted?.(t)
    }
    setOnCompleted(t) {
        this._onCompleted = t
    }
    onError(t) {
        this._onError?.(t)
    }
    setOnError(t) {
        this._onError = t
    }
    onExpired() {
        this.enforcementTokenPromise = null
    }
    _getTurnstileInstancePromise(t) {
        if (this.turnstileInstancePromise !== null)
            if (t)
                this.turnstileInstancePromise.then(n => {
                    n instanceof yg || n.remove()
                }
                ),
                this.turnstileInstancePromise = null;
            else
                return this.turnstileInstancePromise;
        return this.turnstileInstancePromise = new Promise( (n, r) => {
            const s = "onloadTurnstileCallback";
            Object.defineProperty(window, s, {
                value: () => {
                    if (this.status === "ready")
                        return;
                    this.setStatus("script_loaded");
                    const {turnstile: c} = window;
                    if (c === null) {
                        this.setStatus("error"),
                        t ? (q.addAction("turnstile_instance_missing", {
                            app_release: "9d358314d30a26d59ec2f2390d079c86e2c0018f",
                            app: this.app.toString()
                        }),
                        n(new O3("Turnstile instance missing"))) : this._getTurnstileInstancePromise(!0).then(n, r);
                        return
                    }
                    c.render("#" + o, {
                        sitekey: YEe[this.app],
                        execution: "execute",
                        callback: this.onCompleted.bind(this),
                        "error-callback": this.onError.bind(this),
                        "expired-callback": this.onExpired.bind(this)
                    }),
                    n(c)
                }
            });
            const o = "cf-turnstile"
              , i = "cf-turnstile-script";
            document.getElementById(o)?.remove(),
            document.getElementById(i)?.remove();
            const a = document.createElement("div");
            a.id = o,
            a.hidden = !0,
            document.body.appendChild(a),
            this.setStatus("loading");
            const l = document.createElement("script");
            l.id = i,
            l.src = KEe + `?onload=${s}`,
            l.async = !0,
            l.defer = !0,
            l.onerror = () => {
                this.setStatus("error"),
                t ? (q.addAction("turnstile_script_load_error", {
                    app_release: "9d358314d30a26d59ec2f2390d079c86e2c0018f",
                    app: this.app.toString()
                }),
                n(new O3("Turnstile script failed to load"))) : this._getTurnstileInstancePromise(!0).then(n, r)
            }
            ,
            document.body.appendChild(l)
        }
        ),
        this.turnstileInstancePromise
    }
}
const VR = new JEe;
function XEe(e, t) {
    const n = Xe(e, "3530414009")
      , r = !!t?.prefetchIds?.length
      , s = performance.now()
      , o = []
      , i = Jwe();
    if (i == null)
        return o.push("chatReq"),
        Xwe().then(a);
    return a(i);
    function a(l) {
        l.force_login && Au(e, {
            fallbackScreenHint: "login"
        });
        const c = VR.getEnforcementTokenSync(l);
        if (c == null)
            return o.push("turnstile"),
            VR.getEnforcementToken(l).then(u);
        return u(c);
        function u(d) {
            const f = performance.now()
              , p = SS.getEnforcementTokenSync(l);
            if (p == null)
                return o.push("proofofwork"),
                SS.getEnforcementToken(l, {
                    forceSync: r && n
                }).then(m);
            return m(p);
            function m(v) {
                const _ = String(performance.now() - f)
                  , y = o.includes("chatReq") ? "false" : "true"
                  , b = o.includes("turnstile") ? "false" : "true"
                  , S = o.includes("proofofwork") ? "false" : "true";
                return dr.hist(er.DEFAULT, "chat_req_time", [{
                    key: "wasChatReqSync",
                    value: y
                }, {
                    key: "wasTurnstileSync",
                    value: b
                }, {
                    key: "wasProofofworkSync",
                    value: S
                }], performance.now() - s),
                bm(Ot(), {
                    eventName: "chatgpt_web_completion_integrity_checks",
                    value: o.length === 0 ? "true" : "false",
                    metadata: {
                        wasChatReqSync: y,
                        wasTurnstileSync: b,
                        wasProofofworkSync: S,
                        isPrefetchInitialLoad: r ? "true" : "false",
                        powTime: _
                    }
                }),
                {
                    chatReq: l,
                    turnstileToken: d,
                    proofToken: v
                }
            }
        }
    }
}
async function QEe({ctx: e, clientThreadId: t, requestedModelId: n, completionType: r=cu.Next, sourceEvent: s, eventSource: o, completionMetadata: i, extraStreamParams: a, parentMessageId: l, promptMessage: c, existingMessages: u, prependMessages: d, appendMessages: f, profiler: p, skipNotification: m, isReasoningSkipped: v, parentMessageIdPromise: _}) {
    Ez(Va(e, t), !0);
    const y = Aa(e)
      , b = s?.timeStamp ?? performance.now()
      , S = o ?? (s ? $Ee(s) : "mouse")
      , C = Bj()
      , w = `request-${t}-${C}`
      , x = sn(t)
      , {conduitToken: E=null, prepareState: T="none", lastPrepareTimestamp: k=null} = x ?? {}
      , A = n ?? x?.modelId ?? CV(lF(y))?.id ?? Cz(Ot(), !1)
      , O = Ce.findNode(x, Ue => Ue.message.author.role === Ke.Assistant || Ue.message.author.role === Ke.Tool) == null
      , M = x?.continuingFromSharedConversationId != null
      , I = x?.continuingFromSharedProjectConversationId != null
      , R = !!x?.continuingFromSharedPostId
      , D = x?.branchingFromConversationId != null
      , P = l ? Ce.getNode(x, l) : u?.[0] ? Ce.getParentNode(x, u[0].id) : Ce.getCurrentNode(x);
    let L = P.message.id ?? P.id;
    const N = [...u ?? [], ...d ?? [], ...c ? [c] : [], ...f ?? []]
      , B = xz(e, t)
      , H = new bz({
        ctx: e,
        clientRequestId: w,
        gizmoType: B,
        preflightTime: b,
        isTemporaryChat: fw()
    });
    if (H.onUserMessages(N),
    B === zl.PROJECT && O && !qf(e, "269676899", {
        disableExposureLog: !0
    }).get("clear_all", !1)) {
        const Ue = i?.systemHints;
        KB(e).set(W => ({
            ...W,
            [t]: Ue ?? []
        }))
    }
    const ye = dw(e)
      , Ie = Yre()
      , be = Wt.getItem(Ft.ModelSlugStatsOverride)
      , me = new yz(e,w,y,x,t,l,d,c,f,r,A,S,ye,b,B === zl.PROJECT,O,M,D,I,H,m ?? !1,Ie,R,v,be)
      , ge = i?.systemHints?.includes(Zs)
      , ce = ao();
    ce && c && ge && $r.signalAgentConversationSentMessage(t),
    ge && q.addAction("agent.conversation.start_attempted", {
        client_thread_id: String(t),
        model: A
    });
    const Z = RH(t, void 0, {
        clientInitiated: !0,
        reason: "new_completion",
        isAgentConversation: ge
    });
    if (du.publish({
        kind: "requestCompletion"
    }),
    dl(t, {
        source: wo.CLIENT,
        value: ge ? Ar.REALTIME : Ar.STREAMING
    }),
    zEe.onCompletionRequestStarted(w),
    me.updateBeforeRequest(),
    nE(e, t)?.value === Ar.REALTIME) {
        const Ue = await Z;
        Ue?.last_message_id && (L = Ue.last_message_id)
    }
    if (_) {
        const Ue = await _;
        Ue && (L = Ue)
    }
    const _e = XEe(e, i)
      , {chatReq: ee, turnstileToken: oe, proofToken: te} = Sz(_e) ? await _e : _e;
    if (ee.force_login)
        return;
    y.getQueriesData(Um()) == null && await y.ensureQueryData(Um()),
    FSe() && (await jSe()).forEach(re => {
        re.status === "fulfilled" && re.value && N.unshift(re.value)
    }
    ),
    H.onCompletionStarted(r, A),
    me.preflightTime = performance.now() - b;
    const ve = rE(e);
    if (q.addFeatureFlagEvaluation("fast_convo", ve),
    ve && k != null) {
        const Ue = performance.now() - k;
        Ue <= 6e4 && dr.hist(er.DEFAULT, "fast_conversation_last_prepare_to_convo_client", [{
            key: "model_id",
            value: A
        }, {
            key: "prepare_state",
            value: String(T)
        }, {
            key: "has_conduit_token",
            value: E != null ? "true" : "false"
        }], Ue)
    }
    ve && ce && dr.count(er.DEFAULT, "client_request_conduit_token", [{
        key: "has_conduit_token",
        value: E != null ? "true" : "false"
    }]),
    ce && p?.logTimingOnce("prompt_request_started"),
    await me.sendRequest$({
        conduitToken: E,
        turnstileToken: oe,
        proofToken: te,
        completionMetadata: i,
        resolvedParentMessageId: L,
        messages: N,
        extraStreamParams: a,
        chatReq: ee,
        profiler: p
    })
}
async function qRe({ctx: e, clientThreadId: t, completionType: n, token: r, conversationId: s, preflightTime: o}) {
    const i = Va(e, t);
    if (da( () => WEe(i)))
        return;
    Ez(i, !0);
    const a = o ?? performance.now()
      , l = Aa(e)
      , c = xz(e, t)
      , d = sn(t)?.modelId ?? CV(lF(l))?.id ?? Cz(Ot(), !1);
    dl(t, {
        source: wo.CLIENT,
        value: Ar.STREAMING
    });
    const f = Bj()
      , p = `request-${t}-${f}`
      , m = new bz({
        ctx: e,
        clientRequestId: p,
        gizmoType: c,
        preflightTime: a,
        isTemporaryChat: fw()
    });
    sn(t) || Du.initThread({
        clientThreadId: t,
        conversationMode: {
            kind: cn.PrimaryAssistant
        },
        modelId: d,
        userId: void 0,
        accountId: void 0
    }),
    Du.retainThread(t);
    const v = new yz(e,p,l,void 0,t,void 0,void 0,void 0,void 0,n,d,"url",dw(e),a,c === zl.PROJECT,!1,!1,!1,!1,m,void 0,!1,void 0,void 0,void 0,{
        disablePlaceholder: !0
    });
    v.preflightTime = 0,
    await v.sendResumeRequest$({
        conversationId: s,
        resumeToken: r,
        profiler: void 0
    })
}
const e7e = e => h.createElement("svg", {
    width: 20,
    height: 20,
    viewBox: "0 0 20 20",
    fill: "currentColor",
    xmlns: "http://www.w3.org/2000/svg",
    ...e
}, h.createElement("path", {
    d: "M4.12916 6.71647C3.30231 7.66684 2.69669 8.64386 2.31959 9.33561L2.1399 9.67643C2.03481 9.88215 2.03489 10.1172 2.1399 10.3229L2.31959 10.6637C2.79011 11.5269 3.61393 12.8363 4.78346 13.9811C6.11816 15.2875 7.85464 16.3346 10.0003 16.3346C11.1135 16.3346 12.116 16.0511 13.01 15.5973L13.9905 16.5778C12.8512 17.2276 11.5215 17.6646 10.0003 17.6647C7.38789 17.6647 5.33564 16.3827 3.8528 14.9313C2.55744 13.6633 1.65876 12.2312 1.14967 11.2965L0.955334 10.9284C0.6562 10.3426 0.656129 9.65668 0.955334 9.07096L1.14967 8.7028C1.56617 7.93819 2.24311 6.84027 3.18483 5.77213L4.12916 6.71647Z"
}), h.createElement("path", {
    d: "M2.52955 2.52897C2.75682 2.30194 3.10844 2.27358 3.36647 2.44401L3.47096 2.52897L17.471 16.529L17.5559 16.6335C17.7264 16.8915 17.698 17.2431 17.471 17.4704C17.2437 17.6976 16.8922 17.7258 16.634 17.5553L16.5296 17.4704L2.52955 3.47037L2.44459 3.36588C2.27419 3.10776 2.30233 2.75619 2.52955 2.52897Z"
}), h.createElement("path", {
    d: "M10.0003 2.33463C12.6124 2.33477 14.664 3.61673 16.1467 5.06803C17.6273 6.51728 18.5903 8.18058 19.0452 9.07096L19.1428 9.29557C19.311 9.75097 19.3109 10.2483 19.1428 10.7038L19.0452 10.9284C18.6628 11.6768 17.9199 12.9706 16.8137 14.2253L15.8714 13.2829C16.8454 12.1631 17.5118 11.0058 17.8606 10.3229L17.8948 10.2448C17.9539 10.0856 17.954 9.91374 17.8948 9.75455L17.8606 9.67643C17.4383 8.84982 16.5534 7.32638 15.2171 6.01822C13.8824 4.71194 12.1457 3.66485 10.0003 3.66471C8.88688 3.66471 7.88357 3.94723 6.98951 4.40104L6.00905 3.42057C7.14849 2.77093 8.47916 2.33463 10.0003 2.33463Z"
}), h.createElement("path", {
    d: "M7.78053 10.3678C7.93665 11.3159 8.68321 12.0619 9.63112 12.2184L10.8831 13.4704C10.6006 13.5421 10.305 13.5817 10.0003 13.5817C8.02216 13.5817 6.41822 11.9778 6.41822 9.99967C6.41825 9.69449 6.45574 9.39775 6.5276 9.1149L7.78053 10.3678Z"
}), h.createElement("path", {
    d: "M10.0003 6.41764C11.9781 6.41787 13.5811 8.02186 13.5813 9.99967C13.5813 10.304 13.5414 10.5994 13.47 10.8815L12.219 9.63053C12.0623 8.68292 11.3162 7.93616 10.3684 7.77994L9.11549 6.52701C9.39833 6.45518 9.69509 6.41764 10.0003 6.41764Z"
}))
  , t7e = e => h.createElement("svg", {
    width: 20,
    height: 20,
    viewBox: "0 0 20 20",
    fill: "currentColor",
    xmlns: "http://www.w3.org/2000/svg",
    ...e
}, h.createElement("path", {
    d: "M16.0012 6.09038C16.0012 5.74214 15.8209 5.42299 15.5315 5.24175L15.4016 5.17241L10.4016 2.98491C10.1776 2.8869 9.9263 2.87423 9.69556 2.9478L9.59888 2.98491L4.59888 5.17241C4.23428 5.33192 3.99829 5.69242 3.99829 6.09038V10.8335C3.99834 12.3761 4.58097 13.7821 5.53735 14.8453C6.5736 13.5214 8.18682 12.6685 10.0002 12.6685C11.8135 12.6686 13.426 13.5216 14.4622 14.8453C15.4186 13.7821 16.0012 12.3762 16.0012 10.8335V6.09038ZM10.0002 13.9986C8.58354 13.9986 7.32514 14.6781 6.53345 15.731C7.5127 16.4254 8.70843 16.8355 10.0002 16.8355C11.2918 16.8354 12.4869 16.4252 13.4661 15.731C12.6744 14.6783 11.4167 13.9987 10.0002 13.9986ZM11.6262 8.54155C11.6261 7.64334 10.8984 6.91477 10.0002 6.9146C9.1019 6.9146 8.37336 7.64323 8.37329 8.54155C8.37329 9.43993 9.10186 10.1685 10.0002 10.1685C10.8985 10.1683 11.6262 9.43983 11.6262 8.54155ZM12.9563 8.54155C12.9563 10.1744 11.633 11.4984 10.0002 11.4986C8.36732 11.4986 7.04321 10.1745 7.04321 8.54155C7.04328 6.90869 8.36737 5.5855 10.0002 5.5855C11.633 5.58567 12.9562 6.9088 12.9563 8.54155ZM17.3313 10.8335C17.3312 14.8825 14.0492 18.1644 10.0002 18.1646C5.95114 18.1646 2.66831 14.8826 2.66821 10.8335V6.09038C2.66821 5.16401 3.21698 4.32497 4.06567 3.95366L9.06567 1.76616L9.29224 1.6812C9.82924 1.51009 10.4135 1.53807 10.9348 1.76616L15.9348 3.95366L16.0901 4.02886C16.8496 4.43032 17.3313 5.22192 17.3313 6.09038V10.8335Z"
}))
  , n7e = "https://help.openai.com/en/articles/11752874-chatgpt-agent#h_beedf96566";
function r7e({onClose: e, onConfirm: t}) {
    return g.jsxs(Ti, {
        testId: "modal-odyssey-takeover-nux",
        isOpen: !0,
        onClose: e,
        shouldIgnoreClickOutside: !0,
        onEscapeKeyDown: () => {}
        ,
        className: "w-[420px]! p-2",
        children: [g.jsx("div", {
            className: "flex w-full flex-col items-center pt-2 text-center",
            children: g.jsx("div", {
                className: "text-xl font-semibold text-balance",
                children: g.jsx(de, {
                    id: "0hMe9z",
                    defaultMessage: "Youâ€™re about to control ChatGPTâ€™s browser"
                })
            })
        }), g.jsx("div", {
            className: "border-token-border-default mt-6 mb-8 rounded-2xl border",
            children: g.jsxs("div", {
                className: "divide-token-border-default flex flex-col divide-y px-4",
                children: [g.jsxs("div", {
                    className: "flex items-center gap-4 py-4 text-sm",
                    children: [g.jsx(e7e, {
                        className: "h-6 w-6 shrink-0"
                    }), g.jsxs("div", {
                        children: [g.jsx("div", {
                            className: "pb-0.5 font-medium",
                            children: g.jsx(de, {
                                id: "+htsoa",
                                defaultMessage: "ChatGPT wonâ€™t take screenshots"
                            })
                        }), g.jsx("div", {
                            className: "text-token-text-secondary",
                            children: g.jsx(de, {
                                id: "jNhK03",
                                defaultMessage: "Only you can see info you enter (like passwords) while youâ€™re in control."
                            })
                        })]
                    })]
                }), g.jsxs("div", {
                    className: "flex items-center gap-4 py-4 text-sm",
                    children: [g.jsx(t7e, {
                        className: "h-6 w-6 shrink-0"
                    }), g.jsxs("div", {
                        children: [g.jsx("div", {
                            className: "pb-0.5 font-medium",
                            children: g.jsx(de, {
                                id: "Ip50c4",
                                defaultMessage: "Your browser session will be saved"
                            })
                        }), g.jsx("div", {
                            className: "text-token-text-secondary",
                            children: g.jsx(de, {
                                id: "qE+5u7",
                                defaultMessage: "This will keep you signed into sites after you finish. You can manage this in Settings."
                            })
                        })]
                    })]
                }), g.jsxs("div", {
                    className: "flex items-center gap-4 py-4 text-sm",
                    children: [g.jsx(Pu, {
                        className: "h-6 w-6 shrink-0 text-[#E25507] dark:text-[#FF9E6C]"
                    }), g.jsxs("div", {
                        children: [g.jsx("div", {
                            className: "pb-0.5 font-medium text-[#E25507] dark:text-[#FF9E6C]",
                            children: g.jsx(de, {
                                id: "2OxBmy",
                                defaultMessage: "This may put your data at risk"
                            })
                        }), g.jsx("div", {
                            className: "text-[#E25507] opacity-80 dark:text-[#FF9E6C]",
                            children: g.jsx(de, {
                                id: "JGhrvI",
                                defaultMessage: "Signing ChatGPT into websites can expose your data to malicious sites. {learnMoreLink}",
                                values: {
                                    learnMoreLink: g.jsx("a", {
                                        href: n7e,
                                        target: "_blank",
                                        rel: "noopener noreferrer",
                                        className: "underline",
                                        children: g.jsx(de, {
                                            id: "L9XdfE",
                                            defaultMessage: "Learn more"
                                        })
                                    })
                                }
                            })
                        })]
                    })]
                })]
            })
        }), g.jsxs("div", {
            className: "flex w-full flex-row gap-3",
            children: [g.jsx(an, {
                size: "large",
                color: "secondary",
                className: "flex flex-1",
                onClick: e,
                children: g.jsx(de, {
                    id: "qz9XeG",
                    defaultMessage: "Cancel"
                })
            }), g.jsx(an, {
                size: "large",
                color: "primary",
                className: "flex flex-1",
                onClick: () => {
                    t(),
                    e()
                }
                ,
                children: g.jsx(de, {
                    id: "h00sr3",
                    defaultMessage: "I understand"
                })
            })]
        })]
    })
}
const s7e = (e, t=!1) => e === "web" ? Rn.Web : e === "cloud" ? Rn.Cloud : Qae[e] ?? (t ? e : void 0)
  , o7e = (e, t=!1) => Array.from(e.values()).map(n => s7e(n, t)).filter(Boolean);
var Tz = (e => (e.FirstTimeUsingUserContext = "oai/apps/hasUserContextFirstTime/2023-06-29",
e.Onboarding = "oai/apps/hasSeenOnboarding",
e.TeamOwnerOnboarding = "oai/apps/hasSeenTeamOwnerOnboarding",
e.MemoryOnboarding = "oai/apps/hasSeenMemoryOnboarding",
e.TemporaryChatOnboarding = "oai/apps/hasSeenTemporaryChatOnboarding",
e.ArchiveConversationOnboarding = "oai/apps/hasSeenArchiveConversationOnboarding",
e.NewOnboardingConvo = "oai/apps/hasSeenNewUserOnboardingConvo",
e.DalleEditingOnboarding = "oai/apps/hasSeenDalleEditingOnboarding",
e.ModelSwitcherAutoDowngrade = "oai/apps/hasSeenModelSwitcherAutoDowngrade",
e.hasDismissedCanvasOnboarding = "oai/apps/hasDismissedCanvasOnboarding",
e.HasSeenAdvancedVoiceOnMobile = "oai/apps/hasSeenAdvancedVoiceOnMobile/2024-09-26",
e.SidekickLauncherOnboarding = "oai/apps/hasSeenSidekickLauncherOnboarding",
e.UseSidekick = "oai/apps/hasDismissedUseSidekick",
e.UseSidetron = "oai/apps/hasDismissedUseSidetron",
e.hasSeenSncUsageNux = "oai/apps/hasSeenSncUsageNux",
e.hasSeenSncWelcomeNux = "oai/apps/hasSeenSncWelcomeNux",
e.hasSeenSncSourcesTooltip = "oai/apps/hasSeenSncSourcesTooltip",
e.hasSeenComposerSearchButtonTooltip = "oai/apps/hasSeenComposerSearchButtonTooltip",
e.hasSeenComposerContextualAnswerTooltip = "oai/apps/hasSeenComposerContextualAnswerTooltip",
e.hasSeenContextualAnswerAdminNuxModal = "oai/apps/hasSeenContextualAnswerAdminNuxModal",
e.hasSeenContextualAnswerUserNuxModal = "oai/apps/hasSeenContextualAnswerUserNuxModal",
e.hasSeenConnectorsNuxModal = "oai/apps/hasSeenConnectorsNuxModal",
e.hasSeenGoogleConnectorsNuxModal = "oai/apps/hasSeenGoogleConnectorsNuxModal",
e.hasSeenContextualAnswerGoogleSyncFinished = "oai/apps/hasSeenContextualAnswerGoogleSyncFinished",
e.hasSeenConnectorsSourcesPillTooltip = "oai/apps/hasSeenConnectorsSourcesPillTooltip",
e.hasSeenConnectorsUpgradeFileAccessModal = "oai/apps/hasSeenConnectorsUpgradeFileAccessModal",
e.hasSeenComposerSystemHintButtonTooltip = "oai/apps/hasSeenComposerSystemHintButtonTooltip",
e.hasSeenPioneer = "oai/apps/hasSeenPioneer",
e.hasSeenMaverick = "oai/apps/hasSeenMaverick",
e.hasSeenMaverickCapi = "oai/apps/hasSeenMaverickCapi",
e.hasSeenTrailBlazer = "oai/apps/hasSeenTrailBlazer",
e.hasSeenStratos = "oai/apps/hasSeenStratos",
e.hasSeenStarpath01 = "oai/apps/hasSeenStarpath01",
e.hasSeenStarpath02 = "oai/apps/hasSeenStarpath02",
e.hasSeenStarpath03 = "oai/apps/hasSeenStarpath03",
e.hasSeenStarpath04 = "oai/apps/hasSeenStarpath04",
e.hasSeenAdvancedVoiceNuxFullPage = "oai/apps/hasSeenAdvancedVoice/2024-09-24",
e.hasSeenWindowsAppOnboarding = "oai/apps/hasSeenWindowsAppOnboarding",
e.DesktopBrowserExtensionAnnouncement = "oai/apps/hasSeenDesktopBrowserExtensionAnnouncement",
e.DesktopBrowserExtensionReactiveAnnouncement = "oai/apps/hasSeenDesktopBrowserExtensionReactiveAnnouncement",
e.DesktopOperatorAnnouncement = "oai/apps/hasSeenDesktopOperatorAnnouncement",
e.DesktopClassmatesPromotionAnnouncement = "oai/apps/hasSeenDesktopClassmatesPromotionAnnouncement",
e.NewOnboardingFlow = "oai/apps/hasSeenOnboardingFlow",
e.NewStaticOnboardingFlow = "oai/apps/hasSeenStaticOnboarding",
e.NewPromptOnboardingFlow = "oai/apps/hasSeenPromptOnboarding",
e.hasUsedConversationalOnboardingStarterPrompt = "oai/apps/hasUsedNewUserStarterPrompt",
e.hasSeenProjectsWebNuxTooltip = "oai/apps/hasSeenProjectsWebNuxTooltip",
e.hasSeenProjectsUpdateNuxTooltip = "oai/apps/hasSeenProjectsUpdateNuxTooltip",
e.hasSeenProjectsToFree = "oai/apps/hasSeenProjectsToFree",
e.hasSeenMemoryInSearch = "oai/apps/hasSeenMemoryInSearch",
e.hasSeenMoonshineNux = "oai/apps/hasSeenMoonshineNux",
e.hasSeenMoonshineNuxV2 = "oai/apps/hasSeenMoonshineNuxV2",
e.hasSeenInlineFeedbackCustomInstrMessage = "oai/apps/hasSeenInlineFeedbackCustomInstrMessage",
e.hasSeenCaSystemHint = "oai/apps/hasSeenCaSystemHint",
e.hasDismissedPromoRedemption = "oai/apps/hasDismissedPromoRedemption",
e.hasSeenFilePickerNuxTooltip = "oai/apps/hasSeenFilePicker",
e.hasSeenMultipleGPTEditorsTooltip = "oai/apps/hasSeenMultipleGPTEditorsTooltip",
e.hasSeenSharedProjectsTooltip = "oai/apps/hasSeenSharedProjectsTooltip",
e.hasSeenPhoenixNux = "oai/apps/hasSeenPhoenixNux",
e.hasSeenPhoenixFreeNux = "oai/apps/hasSeenPhoenixFreeNux",
e.hasSeenAshwingNux = "oai/apps/hasSeenAshwingNux",
e.hasDismissedReferrerRedemption = "oai/apps/hasDismissedReferrerRedemption",
e.hasDismissedRefereeRedemption = "oai/apps/hasDismissedRefereeRedemption",
e.hasSeenReferralUpsellAnnouncement = "oai/apps/hasSeenReferralProgramUpsell",
e.hasSeenTatertotIntakeForm = "oai/apps/hasSeenTatertotIntakeForm",
e.hasSeenComposerBigBoxEnterHint = "oai/apps/hasSeenComposerBigBoxEnterHint",
e.d2dee219 = "oai/apps/d2dee219",
e.hasSeenStudentsUpsellAnnouncement = "oai/apps/hasSeenStudentsUpsellAnnouncement",
e.hasSeenMemoryUpdatedTooltip = "oai/apps/hasSeenMemoryUpdatedTooltip",
e.hasSeenTeamsContextualAnswersUpsell = "oai/apps/hasSeenTeamsContextualAnswersUpsell",
e.hasSeenO3O4MiniAutomations = "oai/apps/hasSeenO3O4MiniAutomations",
e.hasSeenn7jupdNux = "oai/apps/hasSeenn7jupdNux",
e.hasSeenTatertotNux = "oai/apps/hasSeenTatertotNux",
e.hasSeenTatertotQuizNux = "oai/apps/hasSeenTatertotQuizNux",
e.hasSeenAudioParagenPrompt = "oai/apps/hasSeenAudioParagenPrompt",
e.hasSeenOdysseyConnectorsModal = "oai/apps/hasSeenOdysseyConnectorsModal",
e.hasSeenOdysseyTakeoverModal = "oai/apps/hasSeenOdysseyTakeoverModal",
e.hasSeenAgentModeAnnouncementBanner = "oai/apps/hasSeenAgentModeAnnouncementBanner",
e.hasSeenWorkspaceDiscoveryFirstLogin = "oai/apps/hasSeenWorkspaceDiscoveryFirstLogin",
e))(Tz || {});
function i7e() {
    "use forget";
    return uL(a7e)
}
function a7e(e) {
    return e.eligible_announcements
}
function l7e(e) {
    "use forget";
    const t = De.c(16)
      , {data: n, isLoading: r} = i7e();
    let s;
    t[0] !== n ? (s = n === void 0 ? [] : n,
    t[0] = n,
    t[1] = s) : s = t[1];
    const o = s
      , {mutate: i} = c7e()
      , {mutate: a} = d7e();
    let l;
    t[2] !== e || t[3] !== i ? (l = () => i({
        key: e
    }),
    t[2] = e,
    t[3] = i,
    t[4] = l) : l = t[4];
    const c = l;
    let u;
    t[5] !== e || t[6] !== a ? (u = () => a({
        key: e
    }),
    t[5] = e,
    t[6] = a,
    t[7] = u) : u = t[7];
    const d = u;
    let f;
    t[8] !== o || t[9] !== e ? (f = o.includes(e),
    t[8] = o,
    t[9] = e,
    t[10] = f) : f = t[10];
    let p;
    return t[11] !== r || t[12] !== c || t[13] !== d || t[14] !== f ? (p = {
        eligible: f,
        markAsViewed: c,
        markAsViewedDontInvalidateCache: d,
        isLoading: r
    },
    t[11] = r,
    t[12] = c,
    t[13] = d,
    t[14] = f,
    t[15] = p) : p = t[15],
    p
}
function c7e() {
    "use forget";
    const e = De.c(2)
      , t = Lr();
    let n;
    return e[0] !== t ? (n = {
        mutationFn: u7e,
        onMutate: r => {
            const {key: s} = r;
            t.getQueryData(Vs().queryKey)?.persistent_announcements?.includes(s) || t.setQueryData(Vs().queryKey, i => i && {
                ...i,
                eligible_announcements: i.eligible_announcements.filter(a => a !== s)
            })
        }
        ,
        onSuccess: () => {
            t.invalidateQueries(Vs())
        }
    },
    e[0] = t,
    e[1] = n) : n = e[1],
    nr(n)
}
function u7e(e) {
    const {key: t} = e;
    return ie.safePost("/settings/announcement_viewed", {
        parameters: {
            query: {
                announcement_id: t
            }
        }
    })
}
function d7e() {
    "use forget";
    const e = De.c(1);
    let t;
    return e[0] === Symbol.for("react.memo_cache_sentinel") ? (t = {
        mutationFn: f7e
    },
    e[0] = t) : t = e[0],
    nr(t)
}
function f7e(e) {
    const {key: t} = e;
    return ie.safePost("/settings/announcement_viewed", {
        parameters: {
            query: {
                announcement_id: t
            }
        }
    })
}
const GRe = h.createContext( () => Promise.resolve())
  , h7e = h.createContext(null)
  , p7e = () => h.useContext(h7e) != null;
h.createContext({
    onDismount: () => {}
});
const m7e = "I took control of the virtual browser. If you're unsure what changed, ask for more context. If the task is complete, just acknowledge and wrap it up. Otherwise, please proceed."
  , tr = dn( () => ({
    token: null,
    clientThreadId: null,
    isOpen: !1,
    isResuming: !1,
    parentMessageId: null,
    vmId: null,
    abortPromise: null
}))
  , VRe = (e, t) => {
    tr.setState(n => ({
        ...n,
        clientThreadId: e,
        token: t
    }))
}
  , g7e = () => {
    const e = ue()
      , t = l7e(Tz.hasSeenOdysseyTakeoverModal)
      , {clientThreadId: n} = tr()
      , r = Ai(n ?? void 0, a => Ce.findNode(a, l => l.message.author.name === "n7jupd.metadata"));
    if (!n)
        return () => {
            Qr.info("VNC modal opened without a client thread id")
        }
        ;
    const s = async a => {
        const l = to(a);
        if (l)
            return await ie.safePost("/conversation/{conversation_id}/agent/resume", {
                parameters: {
                    path: {
                        conversation_id: l
                    }
                }
            })
    }
      , o = () => {
        if (!ao() || !r?.message.metadata?.kaur1br5_mode)
            return Promise.resolve(!1);
        const a = to(n);
        if (!a)
            return Qr.info("Agent viewer opened without a server thread id"),
            Promise.resolve(!1);
        try {
            const c = Nh()?.tryOpenAgentViewer(a) ?? !1;
            return Promise.resolve(c)
        } catch {
            return Qr.error("Failed to open local agent viewer - error thrown"),
            Promise.resolve(!1)
        }
    }
      , i = async () => {
        if (await o()) {
            Qr.info("Opened VNC modal with local agent viewer");
            return
        }
        tr.setState({
            isResuming: !0
        }),
        tr.setState({
            isOpen: !0
        }),
        af.setSidebarOpen(!1);
        let a;
        q.addAction("agent.conversation.resume_rpc_attempted", {
            client_thread_id: n
        });
        try {
            a = await s(n),
            a ? q.addAction("agent.conversation.resume_rpc_succeeded", {
                client_thread_id: n,
                vm_id: a.vm_id ?? ""
            }) : q.addAction("agent.conversation.resume_rpc_failed", {
                client_thread_id: n,
                reason: "no_response"
            })
        } catch (l) {
            q.addAction("agent.conversation.resume_rpc_failed", {
                client_thread_id: n,
                reason: "exception",
                error: l
            })
        }
        tr.setState({
            isResuming: !1,
            vmId: a?.vm_id
        }),
        Oz({})
    }
    ;
    return async () => {
        if (t.eligible) {
            Gg(e, r7e, {
                onConfirm: async () => {
                    t.markAsViewed(),
                    await i()
                }
            });
            return
        }
        await i()
    }
}
  , v7e = async (e, {startNewTurn: t}) => {
    tr.setState({
        isOpen: !1
    }),
    await Az(e, {
        startNewTurn: t
    })
}
  , _7e = e => {
    const t = h1("", {
        is_takeover_ended_message: !0,
        system_hints: [Zs]
    });
    (t.clientMetadata ||= {}).isPlaceholder = !0,
    kt(e, n => {
        kr.appendMessage(n, t)
    }
    )
}
  , kz = e => {
    kt(e, t => {
        kr.updateTree(t, n => {
            const r = n.nodes.filter(s => {
                const o = s.message?.metadata;
                return s.message?.clientMetadata?.isPlaceholder && o?.is_takeover_ended_message && o?.system_hints?.includes(Zs)
            }
            );
            for (const s of r)
                n.updateNodeMetadata(s.id, {
                    isPlaceholder: !1
                })
        }
        )
    }
    )
}
  , y7e = e => {
    kz(e)
}
  , Oz = async ({showPlaceholderMessage: e=!1}) => {
    const {clientThreadId: t} = tr.getState();
    if (!t) {
        Qr.info("VNC takeover started without a client thread id");
        return
    }
    const n = await Mz();
    e && _7e(t),
    tr.setState({
        parentMessageId: n?.last_message_id ?? null
    })
}
  , Az = async (e, {startNewTurn: t, waitForAbortCompletion: n=!1}) => {
    const {clientThreadId: r} = tr.getState();
    if (!r) {
        Qr.info("VNC modal closed without a client thread id");
        return
    }
    if (!t)
        return;
    const s = b7e()
      , {abortPromise: o} = tr.getState();
    o && n && await o,
    kz(r);
    const a = sn(r)?.selectedSources?.get(Zs);
    await QEe({
        ctx: e,
        clientThreadId: r,
        eventSource: "mouse",
        promptMessage: h1(m7e, {
            is_takeover_ended_message: !0,
            system_hints: [Zs],
            ...a && {
                selected_sources: o7e(a)
            }
        }),
        parentMessageIdPromise: s,
        completionMetadata: {
            systemHints: [Zs],
            conversationMode: {
                kind: cn.PrimaryAssistant
            }
        }
    })
}
  , Mz = () => {
    const {clientThreadId: e} = tr.getState();
    if (!e)
        return Qr.info("stopAgent called without a client thread id"),
        Promise.resolve(void 0);
    const t = RH(e, void 0, {
        clientInitiated: !0,
        reason: "takeover",
        isAgentConversation: !0
    }).then(n => n).finally( () => {
        tr.setState({
            abortPromise: null
        })
    }
    );
    return tr.setState({
        abortPromise: t
    }),
    t
}
  , b7e = (e=5e3) => new Promise(t => {
    const {parentMessageId: n} = tr.getState();
    if (n)
        return t(n);
    const r = setTimeout( () => {
        s(),
        t(void 0)
    }
    , e)
      , s = tr.subscribe(o => {
        o.parentMessageId && (t(o.parentMessageId),
        clearTimeout(r),
        s())
    }
    )
}
)
  , HRe = () => {
    tr.setState({
        token: null,
        clientThreadId: null,
        isOpen: !1
    })
}
  , zRe = () => {
    const e = g7e()
      , t = tr(s => ({
        token: s.token,
        clientThreadId: s.clientThreadId,
        isOpen: s.isOpen,
        isResuming: s.isResuming,
        vmId: s.vmId,
        open: e,
        close: v7e
    }))
      , r = !p7e();
    return h.useMemo( () => ({
        ...t,
        isVNCEnabled: r
    }), [t, r])
}
;
function C7e() {
    const e = is($r.wantsHandleAgentRequest$)
      , t = is($r.wantsAgentConversationSentMessage$)
      , n = ue();
    h.useEffect( () => {
        if (!e)
            return;
        $r.wantsHandleAgentRequest$.set(!1);
        const r = $r.agentRequest;
        if (r)
            switch (r) {
            case "startTakeoverFromAgent":
                {
                    Oz({
                        showPlaceholderMessage: !0
                    });
                    break
                }
            case "endTakeoverFromAgent":
                {
                    Az(n, {
                        startNewTurn: !0,
                        waitForAbortCompletion: !0
                    });
                    break
                }
            case "stopAgent":
                {
                    Mz();
                    break
                }
            }
    }
    , [e, n]),
    h.useEffect( () => {
        if (!t)
            return;
        $r.wantsAgentConversationSentMessage$.set(!1);
        const r = $r.agentConversationSentMessage;
        if (!r)
            return;
        const {clientThreadId: s} = r;
        y7e(s),
        (async () => {
            try {
                const o = Va(n, s);
                await GY( () => o.serverId$() != null);
                const i = o.serverId$();
                if (!i) {
                    Qr.warn("could not resolve server id for sent agent message");
                    return
                }
                Nh()?.userSentMessageInAgentConversation(i)
            } catch (o) {
                Qr.error("error sending notification of sent agent message", {
                    error: o
                })
            }
        }
        )()
    }
    , [t, n])
}
function HR(e, t, n, r, {name: s, value: o}) {
    const i = new URLSearchParams(e);
    i.get(s) !== o && (i.set(s, o),
    r({
        pathname: t,
        search: i.toString(),
        hash: n
    }, {
        replace: !0
    }))
}
function S7e() {
    const e = cs()
      , t = oo()
      , [n,r] = WP(l => [i6(l), $P(l)])
      , s = ue()
      , o = yn(s)
      , i = is($r.wantsAuthSessionContext$);
    C7e();
    const a = OSe();
    return h.useEffect( () => {
        a && (o ? a.recordAvailableSessionAuth() : a.onMissingSessionAuth())
    }
    , [a, o]),
    h.useEffect( () => {
        if (!i)
            return;
        $r.wantsAuthSessionContext$.set(!1);
        const l = $r.authSessionContext;
        if (l)
            switch (l.behavior) {
            case "justLoggedInAccessToken":
                o && VP(s, l.authToken.accessToken);
                break;
            case "reloadPageIfLoggedOut":
                o || window.location.reload();
                break
            }
    }
    , [o, s, i]),
    h.useEffect( () => {
        n && HR(e.search, e.pathname, e.hash, t, TZ),
        r && HR(e.search, e.pathname, e.hash, t, kZ),
        r ? document.body.setAttribute("data-window-style", "sidebar_view") : document.body.removeAttribute("data-window-style")
    }
    , [e.pathname, e.search, e.hash, t, n, r]),
    null
}
const w7e = "sourcesSidebar"
  , E7e = "initialPageLoad";
function zR(e) {
    return e.type === "summarizer"
}
function Bu(e) {
    return e.type === "searchSources"
}
function $R(e) {
    return e.type === "caterpillar"
}
function bg(e) {
    return e.type === "retrievalResults"
}
function Cg(e) {
    return e.type === "product"
}
function WR(e) {
    return e.type === "entity"
}
function KR(e) {
    return e.type === "n7jupdSources"
}
function YR(e) {
    return e.type === "codingCitations"
}
class Yl extends kh()(t => t) {
    static getIsOpen = ({isOpen: t}) => t;
    static getActiveSidebar = ({activeSidebar: t}) => t;
    openThreadSidebar = t => {
        M7e(t),
        this.setState({
            isOpen: !0,
            activeSidebar: t
        })
    }
    ;
    updateThreadSidebar = t => {
        this.setState({
            activeSidebar: t
        })
    }
    ;
    toggleThreadSidebar = (t, n) => {
        const r = this.getState()
          , s = r.activeSidebar
          , o = r.isOpen && s && x7e(t, s);
        if (Bu(t) && o && s && Bu(s) && s.scrollToHeader !== t.scrollToHeader) {
            this.updateThreadSidebar({
                ...t,
                shouldAnimateScroll: !0
            });
            return
        }
        o ? this.closeThreadSidebar() : (n?.(),
        this.openThreadSidebar(t))
    }
    ;
    closeThreadSidebar = () => {
        const t = this.getState().activeSidebar;
        t && I7e(t),
        this.setState({
            isOpen: !1,
            activeSidebar: void 0
        })
    }
}
const x7e = (e, t) => Bu(e) && Bu(t) ? t.messageId === e.messageId : $R(e) && $R(t) ? t.caterpillarId === e.caterpillarId && t.initialTab === e.initialTab : zR(e) && zR(t) ? t.clientThreadId === e.clientThreadId && t.turnIndex === e.turnIndex : bg(e) && bg(t) ? t.clientThreadId === e.clientThreadId && t.turnIndex === e.turnIndex && t.messageId === e.messageId : KR(e) && KR(t) ? t.clientThreadId === e.clientThreadId && t.messageId === e.messageId : YR(e) && YR(t) ? t.clientThreadId === e.clientThreadId && t.messageId === e.messageId && t.matchedText === e.matchedText : Cg(e) && Cg(t) ? t.clientThreadId === e.clientThreadId && t.messageId === e.messageId && t.turnIndex === e.turnIndex && t.contentReferenceStartIndex === e.contentReferenceStartIndex && t.productIndex === e.productIndex : WR(e) && WR(t) ? t.clientThreadId === e.clientThreadId && t.messageId === e.messageId && t.contentReferenceStartIndex === e.contentReferenceStartIndex && t.query === e.query && t.category === e.category : !1;
function T7e(e) {
    const {isOpen: t} = e;
    return JSON.stringify({
        isOpen: t
    })
}
function k7e({children: e}) {
    const [t] = h.useState( () => {
        let n;
        return n = {
            isOpen: new URLSearchParams(window.location.search).get(w7e) === "open",
            activeSidebar: {
                type: "searchSources",
                turnIndex: 0,
                messageId: "",
                clientThreadId: E7e
            }
        },
        new Yl(n)
    }
    );
    return h.useEffect( () => t.subscribe( (n, r) => {
        if (!(n.isOpen !== r.isOpen))
            return;
        const o = T7e(n);
        ze.setCookie(Be.ThreadSidebarState, o, {
            maxAge: 2 * 365 * 24 * 60 * 60
        })
    }
    ), [t]),
    g.jsx(Yl.Provider, {
        store: t,
        children: e
    })
}
const $Re = () => {
    const e = Yl.useStore()
      , t = h.useCallback(s => e.openThreadSidebar(s), [e])
      , n = h.useCallback( (s, o) => e.toggleThreadSidebar(s, o), [e])
      , r = h.useCallback( () => e.closeThreadSidebar(), [e]);
    return {
        openThreadSidebar: t,
        toggleThreadSidebar: n,
        closeThreadSidebar: r
    }
}
;
function O7e(e, t) {
    return e.type === t
}
function WRe() {
    return Yl.useState(Yl.getIsOpen)
}
function A7e() {
    return Yl.useState(Yl.getActiveSidebar)
}
function KRe(e) {
    const t = A7e();
    if (e && t && O7e(t, e))
        return t
}
const M7e = e => {
    if (Bu(e)) {
        const {clientThreadId: t, turnIndex: n, messageId: r} = e;
        V.logEventWithStatsig("Search Links Sidebar Shown", "search_links_sidebar_shown", Ao({
            turnIndex: n,
            clientThreadId: t,
            messageId: r
        }))
    } else if (Cg(e)) {
        const {clientThreadId: t, turnIndex: n, messageId: r, contentReferenceStartIndex: s, productIndex: o} = e;
        V.logEventWithStatsig("Product Sidebar Shown", "product_sidebar_shown", {
            ...Ao({
                turnIndex: n,
                clientThreadId: t,
                messageId: r
            }),
            content_reference_start_index: s,
            product_index: (o + 1).toString()
        })
    } else if (bg(e)) {
        const {clientThreadId: t, turnIndex: n} = e;
        V.logEventWithStatsig("File Sources Sidebar Shown", "file_sources_sidebar_shown", {
            ...Ao({
                turnIndex: n,
                clientThreadId: t
            })
        })
    }
}
  , I7e = e => {
    if (Bu(e)) {
        const {clientThreadId: t, messageId: n, turnIndex: r} = e;
        V.logEventWithStatsig("Search Links Sidebar Closed", "search_links_sidebar_closed", Ao({
            clientThreadId: t,
            messageId: n,
            turnIndex: r
        }))
    } else if (Cg(e)) {
        const {clientThreadId: t, messageId: n, turnIndex: r, contentReferenceStartIndex: s, productIndex: o} = e;
        V.logEventWithStatsig("Product Sidebar Closed", "product_sidebar_closed", {
            ...Ao({
                turnIndex: r,
                clientThreadId: t,
                messageId: n
            }),
            content_reference_start_index: s,
            product_index: (o + 1).toString()
        })
    } else if (bg(e)) {
        const {clientThreadId: t, turnIndex: n} = e;
        V.logEvent("File Sources Sidebar Closed", Ao({
            clientThreadId: t,
            turnIndex: n
        }))
    }
}
  , R7e = () => (h.useEffect( () => {
    const e = ({shiftKey: r, metaKey: s, ctrlKey: o}) => {
        D5.setState({
            shift: r,
            meta: s,
            ctrl: o
        })
    }
      , t = () => {
        D5.setState(CU)
    }
      , n = {
        passive: !0,
        capture: !0
    };
    return document.addEventListener("keydown", e, n),
    document.addEventListener("keyup", e, n),
    document.addEventListener("visibilitychange", t, n),
    () => {
        document.removeEventListener("keydown", e, n),
        document.removeEventListener("keyup", e, n),
        document.removeEventListener("visibilitychange", t, n)
    }
}
, []),
null);
class TS extends kh()( () => ({
    windowWidth: window.innerWidth,
    windowHeight: window.innerHeight
})) {
    static selectWindowWidth = ({windowWidth: t}) => t;
    static selectWindowHeight = ({windowHeight: t}) => t
}
function YRe(e, t) {
    const n = TS.useStore();
    return h.useSyncExternalStore(r => n.subscribe( (s, o) => {
        e(s) !== e(o) && r()
    }
    ), () => e(n.getState()), () => t ?? e(n.getInitialState()))
}
function N7e({children: e}) {
    const [t] = h.useState( () => new TS);
    return h.useEffect( () => jl(window, {
        resize: () => {
            t.setState({
                windowWidth: window.innerWidth,
                windowHeight: window.innerHeight
            })
        }
    }), [t]),
    g.jsx(TS.Provider, {
        store: t,
        children: e
    })
}
class Iz {
    cacheK1 = new Map;
    get(t, n) {
        return this.cacheK1.get(t)?.get(n)
    }
    set(t, n, r) {
        let s = this.cacheK1.get(t);
        s || (s = new Map,
        this.cacheK1.set(t, s)),
        s.set(n, r)
    }
    delete(t, n) {
        const r = this.cacheK1.get(t);
        r && (r.delete(n),
        r.size === 0 && this.cacheK1.delete(t))
    }
}
const ZR = new Iz
  , kS = new Iz;
function P7e(e, t) {
    const n = kS.get(e, t);
    if (n == null) {
        const r = JQ(e, t).catch( () => Qd);
        return kS.set(e, t, r),
        r
    }
    return n
}
function D7e(e, t) {
    if (e === Xg)
        return Qd;
    const n = ZR.get(e, t);
    if (n != null)
        return n;
    const r = P7e(e, t)
      , s = h.use(r);
    return s === Qd ? Qd : (ZR.set(e, t, s),
    kS.delete(e, t),
    s)
}
function L7e({children: e, locale: t}) {
    const n = ue()
      , r = KD(t) && $t(n, "2884982660").get("load-machine-translated", !1)
      , s = D7e(t, r);
    return g.jsx(p$, {
        defaultLocale: Xg,
        locale: t,
        messages: s,
        children: g.jsx(Ase, {
            dir: WD.has(t) ? "rtl" : "ltr",
            children: e
        })
    })
}
const F7e = ({children: e}) => {
    const t = T$().locale;
    return h.useEffect( () => {
        const n = navigator.language ?? ""
          , r = R6(n);
        V.logEvent("Locale Loaded", {
            loaded_locale: t,
            raw_browser_locale: navigator.language,
            suggested_locale: r
        }),
        ft.logEvent("chatgpt_locale_loaded", t, {
            loaded_locale: t,
            raw_browser_locale: navigator.language,
            suggested_locale: r ?? ""
        })
    }
    , [t]),
    g.jsx(L7e, {
        locale: t,
        children: e
    })
}
;
var A3, JR;
function j7e() {
    if (JR)
        return A3;
    JR = 1;
    var e = Ku()
      , t = ks()
      , n = La()
      , r = "[object String]";
    function s(o) {
        return typeof o == "string" || !t(o) && n(o) && e(o) == r
    }
    return A3 = s,
    A3
}
var U7e = j7e();
const B7e = mn(U7e);
function q7e(e, t=0) {
    return new Promise(n => {
        requestAnimationFrame( () => {
            setTimeout( () => {
                n(e())
            }
            , t)
        }
        )
    }
    )
}
const Lh = Ct("livekit")
  , ZRe = () => is( () => Lh())
  , JRe = () => q7e( () => Lh())
  , Fh = Ct("")
  , XRe = () => is( () => Fh())
  , QRe = () => {
    requestAnimationFrame( () => {
        Fh.set("")
    }
    )
}
;
function Pe(e, t, n) {
    return r => {
        requestAnimationFrame( () => {
            const s = Lh()
              , o = r?.voice_session_id ?? Fh()
              , i = {
                ...r,
                message: t,
                protocol: s,
                voice_session_id: o
            };
            q.addAction(e, i),
            n && bm(Ot(), n, void 0, DH(i, a => B7e(a)))
        }
        )
    }
}
function qp(e, t) {
    return (n, r) => {
        requestAnimationFrame( () => {
            const s = Lh()
              , o = r?.voice_session_id ?? Fh()
              , i = {
                ...r,
                ...t ? {
                    message: t
                } : {},
                protocol: s,
                voice_session_id: o
            };
            try {
                const a = n.name
                  , l = n.message;
                i.error = a,
                i.errMessage = l
            } catch {
                i.error = String(n)
            }
            q.addAction(e, i)
        }
        )
    }
}
function Bc(e) {
    return (t, n) => {
        requestAnimationFrame( () => {
            const r = Lh()
              , s = n?.voice_session_id ?? Fh();
            t instanceof _t || q.addError(t, {
                ...n,
                status: "error",
                name: e,
                protocol: r,
                voice_session_id: s
            })
        }
        )
    }
}
const XR = {
    audioPlayer: {
        error: Bc("audio-player")
    },
    readAloud: {
        click: Pe("read-aloud", "click"),
        error: Bc("read-aloud")
    },
    messagePlayback: {
        click: Pe("message-playback", "click")
    },
    toggleVideoButton: {
        click: Pe("toggle-video-button", "click")
    },
    toggleMuteButton: {
        click: Pe("toggle-mute-button", "click")
    },
    toggleScreenShareButton: {
        click: Pe("toggle-screenshare-button", "click")
    },
    composerSpeechButton: {
        hover: Pe("composer-speech-button", "hover")
    },
    voiceSessionEndedByUser: {
        click: Pe("voice-session-ended-by-user", "click")
    },
    voiceSessionStarted: {
        click: Pe("voice-session-started", "click")
    },
    voiceSessionDuration: {
        duration: Pe("voice-session-duration", "duration")
    },
    voiceSessionListening: {
        stateChange: Pe("voice-session-listening", "stateChange")
    },
    voiceSessionListeningIntently: {
        stateChange: Pe("voice-session-listening-intently", "stateChange")
    },
    voiceSessionThinking: {
        stateChange: Pe("voice-session-thinking", "stateChange")
    },
    voiceSessionSpeaking: {
        stateChange: Pe("voice-session-speaking", "stateChange")
    },
    voiceSessionHalted: {
        stateChange: Pe("voice-session-halted", "stateChange")
    },
    voiceSessionDisconnected: {
        stateChange: Pe("voice-session-disconnected", "stateChange")
    },
    voiceMode: {
        connect: Pe("voice-mode", "connect"),
        error: Pe("voice-mode", "error")
    },
    previews: {
        click: Pe("previews", "click"),
        error: Bc("previews")
    },
    getToken: {
        request: Pe("get-token", "request"),
        success: Pe("get-token", "success"),
        failure: Pe("get-token", "failure")
    },
    getVoiceStatus: {
        request: Pe("get-voice-status", "request"),
        success: Pe("get-voice-status", "success"),
        failure: Pe("get-voice-status", "failure")
    },
    livekit: {
        connectCalled: Pe("livekit", "connectCalled"),
        success: Pe("livekit", "success"),
        failure: Bc("livekit")
    },
    bloop: {
        performance: Pe("bloop", "performance")
    },
    voiceSelectionShown: {
        click: Pe("voice-selection-shown", "click", "voice_selection_shown")
    },
    voiceSelected: {
        click: Pe("voice-selected", "click")
    },
    voiceAdvancedDisclosureShown: {
        success: Pe("voice-advanced-disclosure-shown", "success")
    },
    voiceAdvancedDisclosureAccepted: {
        click: Pe("voice-advanced-disclosure-accepted", "click")
    },
    rateLimitReached: {
        success: Pe("rate-limit-reached", "success"),
        modalShown: Pe("rate-limit-reached", "modalShown")
    },
    upsell: {
        upgradeToPlus: Pe("upsell", "upgradeToPlus"),
        upgradeToPro: Pe("upsell", "upgradeToPro"),
        upgradeToApp: Pe("upsell", "upgradeToApp"),
        appUpsellShown: Pe("upsell", "appUpsellShown"),
        appUpsellDismissed: Pe("upsell", "appUpsellDismissed")
    },
    feedbackShown: {
        success: Pe("feedback-shown", "success")
    },
    feedbackThumbsUp: {
        success: Pe("feedback-thumbs-up", "success")
    },
    feedbackThumbsDown: {
        success: Pe("feedback-thumbs-down", "success")
    },
    feedbackDetails: {
        audio_issues: Pe("feedback-details", "audio_issues"),
        response_quality: Pe("feedback-details", "response_quality"),
        interruptions: Pe("feedback-details", "interruptions"),
        transcription_issues: Pe("feedback-details", "transcription_issues"),
        inaudible_issues: Pe("feedback-details", "inaudible_issues"),
        other: Pe("feedback-details", "other"),
        inputText: Pe("feedback-details", "inputText")
    },
    connectionLatency: {
        success: Pe("connection-latency", "success"),
        failure: Bc("connection-latency")
    },
    firstListeningLatency: {
        success: Pe("first-listening-latency", "success")
    },
    permissions: {
        denied: Pe("permissions-denied")
    },
    voiceSessionFirstListening: {
        stateChange: Pe("voice-session-first-listening", "stateChange")
    },
    voiceSessionFirstSpeaking: {
        stateChange: Pe("voice-session-first-speaking", "stateChange")
    },
    defaultMediaDeviceChanged: {
        success: Pe("default-media-device-changed", "success"),
        failure: Bc("default-media-device-changed")
    },
    voiceStatusCache: {
        hit: Pe("voice-status-cache", "hit"),
        failed: Pe("voice-status-cache", "failed"),
        ineligible: Pe("voice-status-cache", "ineligible"),
        skipped: Pe("voice-status-cache", "skipped")
    },
    certificateCache: {
        hit: Pe("certificate-cache", "hit"),
        miss: Pe("certificate-cache", "miss"),
        disabled: Pe("certificate-cache", "disabled"),
        unsupported: qp("certificate-cache", "unsupported")
    },
    peerConnectionCache: {
        hit: Pe("peer-connection-cache", "hit"),
        miss: Pe("peer-connection-cache", "miss"),
        unsupported: qp("peer-connection-cache", "unsupported")
    },
    certificateLocalDb: {
        hit: Pe("certificate-local-db", "hit"),
        generated: Pe("certificate-local-db", "generated"),
        saveFailed: qp("certificate-local-db", "saveFailed"),
        loadFailed: qp("certificate-local-db", "loadFailed")
    }
}
  , Or = dn(Sle(Da( () => ({
    playerNode: null,
    playerApi: null,
    playerState: {
        sourceUrl: null,
        isPlaying: !1
    }
}))));
function eNe() {
    return Or(e => e.playerApi)
}
function tNe(e) {
    return Or(t => e(t.playerState))
}
function nNe() {
    return Or.getState().playerApi
}
function rNe() {
    return Or.getState().playerState
}
const G7e = h.memo(function() {
    const t = h.useRef(null)
      , n = Or(r => r.playerNode);
    return h.useEffect( () => {
        const r = t.current;
        r && !n && (r.onplay = () => {
            Or.setState(s => {
                s.playerState.isPlaying = !0
            }
            )
        }
        ,
        r.onpause = () => {
            Or.setState(s => {
                s.playerState.isPlaying = !1
            }
            )
        }
        ,
        r.ontimeupdate = () => {
            Or.setState(s => {
                s.playerState.currentTime = r.currentTime
            }
            )
        }
        ,
        r.ondurationchange = () => {
            Or.setState(s => {
                s.playerState.duration = r.duration
            }
            )
        }
        ,
        r.onerror = s => {
            typeof s == "string" ? XR.audioPlayer.error(new Error(s)) : s.target && "error"in s.target && XR.audioPlayer.error(s.target.error)
        }
        ,
        Or.setState({
            playerNode: r,
            playerApi: new V7e(r)
        }))
    }
    , [n]),
    g.jsx("audio", {
        className: "fixed start-0 bottom-0 hidden h-0 w-0",
        autoPlay: !0,
        crossOrigin: "anonymous",
        ref: t
    })
});
class V7e {
    constructor(t) {
        this.player = t
    }
    get state() {
        return Or.getState().playerState
    }
    changeSource(t) {
        this.player.src && this.player.src !== t && this.stop(),
        this.player.src = t,
        Or.setState(n => {
            n.playerState.sourceUrl = t
        }
        )
    }
    async play() {
        this.state.isPlaying || await this.player.play()
    }
    pause() {
        this.state.isPlaying && this.player.pause()
    }
    stop() {
        this.pause(),
        this.player.removeAttribute("src"),
        Or.setState(t => {
            t.playerState.sourceUrl = null,
            t.playerState.currentTime = void 0,
            t.playerState.duration = void 0
        }
        )
    }
    setCurrentTime(t) {
        this.player.currentTime = t
    }
    setSpeed(t) {
        this.player.playbackRate = t,
        this.player.defaultPlaybackRate = t
    }
}
function sNe(e) {
    const t = Or.getState().playerNode;
    if (!t)
        return !1;
    const n = t.canPlayType(e);
    return n === "probably" || n === "maybe"
}
const H7e = ({children: e}) => {
    const t = ao();
    return g.jsx($ie, {
        children: g.jsx(F7e, {
            children: g.jsx(Vae, {
                children: g.jsxs(k7e, {
                    children: [g.jsx(C3e, {
                        children: g.jsx(N7e, {
                            children: e
                        })
                    }), g.jsx(G7e, {}), g.jsx(R7e, {}), null, t ? g.jsx(S7e, {}) : null]
                })
            })
        })
    })
}
  , OS = ({resetError: e, componentStack: t, error: n}) => (h.useEffect( () => {
    q.addError(n),
    qn?.publish(Sa.ERROR_THROWN, {
        error: n
    })
}
, [n]),
g.jsxs("div", {
    className: "flex h-full w-full flex-col items-center justify-center gap-4",
    children: [g.jsx("h2", {
        children: "Content failed to load"
    }), !1, g.jsx(an, {
        color: "secondary",
        onClick: e,
        children: "Try again"
    }), !1]
}))
  , gE = Ct(!1)
  , oNe = gE;
function z7e(e) {
    const t = jl(e.document, {
        keydown: W7e,
        keyup: _m,
        visibilitychange: _m
    })
      , n = jl(e, {
        blur: _m
    });
    return () => {
        t(),
        n()
    }
}
const $7e = 500;
let Sg;
function W7e(e) {
    K7e(e) ? Sg ??= setTimeout( () => {
        gE.set(!0)
    }
    , $7e) : Sg && _m()
}
function K7e(e) {
    return !b1(e) && e.key === (SN() ? "Meta" : "Control") && fF(e) === hse()
}
function _m() {
    clearTimeout(Sg),
    Sg = void 0,
    gE.set(!1)
}
var Ls = {}, QR;
function Y7e() {
    if (QR)
        return Ls;
    QR = 1,
    Object.defineProperty(Ls, "__esModule", {
        value: !0
    });
    for (var e = typeof window < "u" && /Mac|iPod|iPhone|iPad/.test(window.navigator.platform), t = {
        alt: "altKey",
        control: "ctrlKey",
        meta: "metaKey",
        shift: "shiftKey"
    }, n = {
        add: "+",
        break: "pause",
        cmd: "meta",
        command: "meta",
        ctl: "control",
        ctrl: "control",
        del: "delete",
        down: "arrowdown",
        esc: "escape",
        ins: "insert",
        left: "arrowleft",
        mod: e ? "meta" : "control",
        opt: "alt",
        option: "alt",
        return: "enter",
        right: "arrowright",
        space: " ",
        spacebar: " ",
        up: "arrowup",
        win: "meta",
        windows: "meta"
    }, r = {
        backspace: 8,
        tab: 9,
        enter: 13,
        shift: 16,
        control: 17,
        alt: 18,
        pause: 19,
        capslock: 20,
        escape: 27,
        " ": 32,
        pageup: 33,
        pagedown: 34,
        end: 35,
        home: 36,
        arrowleft: 37,
        arrowup: 38,
        arrowright: 39,
        arrowdown: 40,
        insert: 45,
        delete: 46,
        meta: 91,
        numlock: 144,
        scrolllock: 145,
        ";": 186,
        "=": 187,
        ",": 188,
        "-": 189,
        ".": 190,
        "/": 191,
        "`": 192,
        "[": 219,
        "\\": 220,
        "]": 221,
        "'": 222
    }, s = 1; s < 20; s++)
        r["f" + s] = 111 + s;
    function o(f, p, m) {
        p && !("byKey"in p) && (m = p,
        p = null),
        Array.isArray(f) || (f = [f]);
        var v = f.map(function(b) {
            return l(b, p)
        })
          , _ = function(S) {
            return v.some(function(C) {
                return c(C, S)
            })
        }
          , y = m == null ? _ : _(m);
        return y
    }
    function i(f, p) {
        return o(f, p)
    }
    function a(f, p) {
        return o(f, {
            byKey: !0
        }, p)
    }
    function l(f, p) {
        var m = p && p.byKey
          , v = {};
        f = f.replace("++", "+add");
        var _ = f.split("+")
          , y = _.length;
        for (var b in t)
            v[t[b]] = !1;
        var S = !0
          , C = !1
          , w = void 0;
        try {
            for (var x = _[Symbol.iterator](), E; !(S = (E = x.next()).done); S = !0) {
                var T = E.value
                  , k = T.endsWith("?") && T.length > 1;
                k && (T = T.slice(0, -1));
                var A = d(T)
                  , O = t[A];
                if (T.length > 1 && !O && !n[T] && !r[A])
                    throw new TypeError('Unknown modifier: "' + T + '"');
                (y === 1 || !O) && (m ? v.key = A : v.which = u(T)),
                O && (v[O] = k ? null : !0)
            }
        } catch (M) {
            C = !0,
            w = M
        } finally {
            try {
                !S && x.return && x.return()
            } finally {
                if (C)
                    throw w
            }
        }
        return v
    }
    function c(f, p) {
        for (var m in f) {
            var v = f[m]
              , _ = void 0;
            if (v != null && (m === "key" && p.key != null ? _ = p.key.toLowerCase() : m === "which" ? _ = v === 91 && p.which === 93 ? 91 : p.which : _ = p[m],
            !(_ == null && v === !1) && _ !== v))
                return !1
        }
        return !0
    }
    function u(f) {
        f = d(f);
        var p = r[f] || f.toUpperCase().charCodeAt(0);
        return p
    }
    function d(f) {
        return f = f.toLowerCase(),
        f = n[f] || f,
        f
    }
    return Ls.default = o,
    Ls.isHotkey = o,
    Ls.isCodeHotkey = i,
    Ls.isKeyHotkey = a,
    Ls.parseHotkey = l,
    Ls.compareHotkey = c,
    Ls.toKeyCode = u,
    Ls.toKeyName = d,
    Ls
}
var Z7e = Y7e();
const J7e = mn(Z7e)
  , X7e = en( () => {
    const e = Ct([])
      , t = Ct(void 0)
      , n = Na( () => {
        const a = t();
        return e().filter(l => tN(l, a))
    }
    );
    function r(...a) {
        return e.set(l => [...a, ...l]),
        () => {
            e.set(l => l.filter(c => !a.includes(c)))
        }
    }
    function s(a) {
        const l = da(t);
        return t.set(a),
        () => t.set(l)
    }
    function o(a) {
        return jl(a.document, {
            keydown: i
        })
    }
    function i(a) {
        if (a.key === void 0 || a.repeat || b1(a) || a.defaultPrevented)
            return;
        const c = da(e)
          , u = da(t);
        for (const d of c)
            if (Q7e(d, a) && tN(d, u) && d.action(a) !== !1) {
                V.logEventWithStatsig("Keyboard Shortcut", "keyboard_shortcut", {
                    keyboardActionKey: d.key
                }),
                q.addAction("chatgpt_keyboard_shortcut", {
                    keyboardActionKey: d.key
                }),
                a.preventDefault();
                return
            }
    }
    return {
        actions$: n,
        addAction: r,
        limitActionGroups: s,
        registerEventListener: o
    }
}
)
  , eN = new WeakMap;
function Q7e(e, t) {
    let n = eN.get(e);
    if (!n) {
        const {keyboardBinding: r, altKeyboardBindings: s} = e
          , o = [r, ...s ?? []].map(i => i.join("+"));
        n = J7e(o, {
            byKey: !0
        }),
        eN.set(e, n)
    }
    return n(t)
}
function tN(e, t) {
    return !(e.enabled === !1 || t != null && !t.includes(e.group))
}
function e9e() {
    const [e,t] = Eg()
      , n = gt()
      , r = Tn()
      , s = e.get(O0)
      , o = e.get(A0)
      , i = ir();
    h.useEffect( () => {
        let a = !1;
        if (i && s === "true") {
            let c;
            i.isWorkspacePlan() ? c = i.name ?? "Workspace" : c = "Personal",
            r.info(n.formatMessage({
                id: "S4JoJY",
                defaultMessage: "Switched to {name}"
            }, {
                name: c
            })),
            a = !0
        }
        let l = !1;
        if (typeof o == "string" && t9e(o)) {
            const c = Rz[o];
            r.danger(n.formatMessage(c), {
                toastId: "error_query_param",
                loggingTitle: o,
                loggingDescription: c.defaultMessage ? String(c.defaultMessage) : ""
            }),
            l = !0
        }
        (e.has(O0) || e.has(A0)) && t(c => (a && c.delete(O0),
        l && c.delete(A0),
        c), {
            replace: !0
        })
    }
    , [s, i, o, n, e, t, r])
}
function t9e(e) {
    return e in Rz
}
const Rz = xt({
    invalidToken: {
        id: "UAhT32",
        defaultMessage: "The token is invalid"
    },
    continueFromApiGeneric: {
        id: "FHUH8C",
        defaultMessage: "Unable to continue your conversation"
    }
});
class vE {
    subscribers;
    constructor(t) {
        this.subscribers = vE.createTypedEmitterAllEventSubscribers(t) || {}
    }
    publish(t, n) {
        const r = this.subscribers[t] || {};
        for (const s of Object.values(r))
            s(n)
    }
    subscribe(t, n) {
        const r = Ts();
        this.subscribers[t] || (this.subscribers[t] = {});
        const s = this.subscribers[t];
        return s[r] = n,
        () => {
            delete s[r]
        }
    }
    static createTypedEmitterAllEventSubscribers(t) {
        return t.reduce( (n, r) => (n[r] = {},
        n), {})
    }
}
class n9e extends vE {
    constructor() {
        super(Object.values(cw))
    }
    getVersion() {
        return 1
    }
}
const r9e = new n9e;
function s9e() {
    const e = ue()
      , n = us(e).getContext().user
      , r = Jf(e)
      , s = bn(e);
    h.useEffect( () => {
        qn && (r?.accessToken && r?.user?.id ? qn.publish(Sa.LOGIN_CHANGED, {
            userId: r.user.id,
            accountId: s?.id,
            authToken: r.accessToken,
            statsigUser: n,
            email: r.user.email
        }) : qn.publish(Sa.LOGOUT, {
            statsigUser: n
        }))
    }
    , [s?.id, r?.accessToken, r?.user, s, n])
}
function iNe(e) {
    const t = ue()
      , n = un(t).windowStyle;
    h.useEffect( () => {
        if (qn)
            return r9e.subscribe(cw.WINDOW_VISIBILITY_STATE_CHANGED, r => {
                r.windowType === n && r.state === "hidden" && e()
            }
            )
    }
    , [e, n])
}
function aNe() {
    return qn ? qn.takePhoto() : Promise.resolve(void 0)
}
function lNe() {
    return qn ? qn.requestSystemPermission(QL.MICROPHONE) : Promise.resolve(!0)
}
function cNe() {
    return qn ? qn.takeScreenshot() : Promise.resolve(void 0)
}
function o9e({children: e}) {
    e9e(),
    TN && s9e();
    const t = ue();
    return h.useEffect( () => X7e(t).registerEventListener(window), [t]),
    h.useEffect( () => z7e(window), []),
    g.jsx(g.Fragment, {
        children: e
    })
}
const i9e = 60 * 60 * 24 * 30 * 3
  , a9e = $g( () => he( () => import("./oka0g8u378wjlih4.js"), __vite__mapDeps([20, 1, 9, 10, 21, 22, 23, 24, 25, 26, 27, 28, 29, 14, 15, 30, 31, 17, 32, 7, 8, 16, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 12, 47, 48, 49, 50, 51, 52, 53, 54])).then(e => e.GlobalModalsComponent));
LQ();
function l9e() {
    return bSe(),
    null
}
TN && he( () => import("./gfnu7rj0xqi84ryj.js"), __vite__mapDeps([55, 9, 1, 10])).then(e => e.initDesktop()),
ao() && he( () => import("./gwd1q79x97phfvtl.js"), __vite__mapDeps([56, 1])).then(e => e.initHost());
io("https://chatgpt.com", "import.meta.env.VITE_APP_URL");
function c9e({children: e}) {
    "use forget";
    ue();
    const [t,n] = h.useState(!1)
      , r = cs();
    h.useEffect( () => {
        window._oaiHandleSessionExpired = function(o, i) {
            window.location.href.includes("/auth/login") || (ao() && Nh()?.onMissingSessionAuth(),
            n(!0),
            V.logEvent("Account: Force Login Modal Shown", {
                content: `${o}: ${i}`
            }))
        }
    }
    , []);
    function s(o) {
        try {
            const i = o.match(/^\/share\/(.+)$/);
            let a = ze.getCookie(Be.SharedConversationId);
            if (!a && i && (a = i[1],
            ze.setCookie(Be.SharedConversationId, a, {
                maxAge: i9e
            })),
            typeof a == "string" && a && ft.getUser()?.customIDs) {
                const l = ft.getUser();
                l?.customIDs && (l.customIDs.shared_conversation_id = a)
            }
        } catch (i) {
            i instanceof Error ? Qr.error("Error in shared conversation cookie code:", {
                message: i.message,
                stack: i.stack
            }) : Qr.error("Unknown error in shared conversation cookie code:", {
                error: i
            })
        }
    }
    return h.useEffect( () => {
        s(r.pathname),
        V.logPageView(),
        ft.logEvent("chatgpt_page_view", null, h5()),
        LV("openaicom-did")
    }
    , [r.pathname, r.search, r.hash]),
    g.jsx(g.Fragment, {
        children: g.jsx(tw, {
            name: "ui_boundary_error",
            fallback: ({resetError: o, componentStack: i, error: a}) => g.jsx(OS, {
                resetError: o,
                componentStack: i,
                error: a
            }),
            logRequestErrors: !0,
            children: g.jsx(H7e, {
                children: g.jsxs(o9e, {
                    children: [e, null, g.jsx(l9e, {}), g.jsx(u9e, {
                        isOpen: t,
                        onLogInClick: () => {
                            n(!1)
                        }
                    }), g.jsx(a9e, {}), g.jsx(dJ, {}), g.jsx(One, {}), !1]
                })
            })
        })
    })
}
const u9e = e => {
    "use forget";
    const t = De.c(16)
      , {isOpen: n, onLogInClick: r} = e
      , s = gt();
    let o;
    t[0] !== s ? (o = s.formatMessage(M3.forceLogInModalTitle),
    t[0] = s,
    t[1] = o) : o = t[1];
    let i;
    t[2] !== s ? (i = s.formatMessage(M3.forceLogInModalDescription),
    t[2] = s,
    t[3] = i) : i = t[3];
    let a;
    t[4] !== r ? (a = async () => {
        const d = await NS.signOut({
            redirect: !1,
            callbackUrl: `/auth/login?next=${encodeURIComponent(location.pathname + location.search + location.hash)}`
        });
        location.href = d.url,
        r()
    }
    ,
    t[4] = r,
    t[5] = a) : a = t[5];
    let l;
    t[6] !== s ? (l = s.formatMessage(M3.forceLogInModalButton),
    t[6] = s,
    t[7] = l) : l = t[7];
    let c;
    t[8] !== a || t[9] !== l ? (c = g.jsx(pl.Button, {
        onClick: a,
        title: l
    }),
    t[8] = a,
    t[9] = l,
    t[10] = c) : c = t[10];
    let u;
    return t[11] !== n || t[12] !== o || t[13] !== i || t[14] !== c ? (u = g.jsx(Ti, {
        testId: "modal-expired-session",
        isOpen: n,
        icon: Pu,
        title: o,
        description: i,
        type: "warning",
        onClose: eD,
        primaryButton: c
    }),
    t[11] = n,
    t[12] = o,
    t[13] = i,
    t[14] = c,
    t[15] = u) : u = t[15],
    u
}
  , M3 = xt({
    forceLogInModalTitle: {
        id: "App.forceLogInModalTitle",
        defaultMessage: "Your session has expired"
    },
    forceLogInModalDescription: {
        id: "App.forceLogInModalDescription",
        defaultMessage: "Please log in again to continue using the app."
    },
    forceLogInModalButton: {
        id: "App.forceLogInModalButton",
        defaultMessage: "Log in"
    }
});
function d9e(e, t) {
    return e.slice(0, t.length) === t
}
var f9e = {
    log: "log",
    debug: "debug",
    info: "info",
    warn: "warn",
    error: "error"
}
  , Zc = console
  , Jc = {};
Object.keys(f9e).forEach(function(e) {
    Jc[e] = Zc[e]
});
var Nd = "Datadog Browser SDK:"
  , h9e = {
    debug: Jc.debug.bind(Zc, Nd),
    log: Jc.log.bind(Zc, Nd),
    info: Jc.info.bind(Zc, Nd),
    warn: Jc.warn.bind(Zc, Nd),
    error: Jc.error.bind(Zc, Nd)
};
function p9e(e, t, n) {
    return n === void 0 && (n = !1),
    e.some(function(r) {
        try {
            if (typeof r == "function")
                return r(t);
            if (r instanceof RegExp)
                return r.test(t);
            if (typeof r == "string")
                return n ? d9e(t, r) : r === t
        } catch (s) {
            h9e.error(s)
        }
        return !1
    })
}
function m9e(e, t) {
    try {
        return e()
    } catch (n) {
        return t(n)
    }
}
function Nz(e) {
    return e instanceof Element ? e : e.parentElement ? Nz(e.parentElement) : null
}
function ym(e) {
    const t = Nz(e);
    if (t) {
        const n = fN(t, void 0);
        if (n)
            return n
    }
    return e.nodeName
}
const g9e = e => e.type === "childList" ? e.addedNodes.length > 0 ? `added ${ym(e.addedNodes[e.addedNodes.length - 1])}` : e.removedNodes.length > 0 ? `removed ${e.removedNodes[e.removedNodes.length - 1].nodeName} from ${ym(e.target)}` : `unknown ${e.type}` : e.type === "characterData" ? `characterData in ${ym(e.target)}` : `unknown ${e.type}`
  , nN = "checkVisibility"in Element.prototype ? e => e.checkVisibility({
    opacityProperty: !0,
    visibilityProperty: !0,
    contentVisibilityAuto: !0
}) : e => !e.hasAttribute("aria-hidden") && !e.classList.contains("hidden");
function v9e(e) {
    if (document.head.contains(e))
        return !1;
    if (e instanceof Element)
        return nN(e);
    if (e instanceof Text) {
        const t = e.parentElement;
        if (t != null)
            return nN(t)
    }
    return !0
}
function _E(e) {
    const t = []
      , n = e(r => t.push(r));
    return () => (n(),
    t)
}
class _9e {
    timeouts = new Set;
    add(t, n) {
        const r = setTimeout( () => {
            this.timeouts.delete(r),
            t()
        }
        , n);
        this.timeouts.add(r)
    }
    clear() {
        for (const t of this.timeouts)
            clearTimeout(t);
        this.timeouts.clear()
    }
}
function I3(e, t) {
    try {
        if (e.type && !PerformanceObserver.supportedEntryTypes.includes(e.type))
            return () => {}
            ;
        const n = new PerformanceObserver(r => {
            for (const s of r.getEntries())
                t(s)
        }
        );
        return n.observe(e),
        () => n.disconnect()
    } catch {
        return () => {}
    }
}
function y9e({idleTimeout: e=5e3, minIdleGap: t=100, filter: n}={}) {
    return new Promise( (r, s) => {
        let o = null;
        const i = () => {
            o != null && clearTimeout(o),
            o = setTimeout(l, e)
        }
        ;
        i();
        const a = _E(c => {
            function u(f) {
                (!n || n(f)) && (c({
                    start: f.startTime,
                    end: f.startTime + f.duration
                }),
                i())
            }
            const d = [I3({
                type: "resource",
                buffered: !0
            }, u), I3({
                type: "longtask",
                buffered: !0,
                durationThreshold: 0
            }, u), I3({
                type: "navigation",
                buffered: !0
            }, u)];
            return () => {
                for (const f of d)
                    f()
            }
        }
        );
        function l() {
            try {
                const c = a();
                r(b9e(c, t))
            } catch (c) {
                s(c)
            }
        }
    }
    )
}
function b9e(e, t) {
    const n = [];
    for (const {start: s, end: o} of e)
        n.push({
            t: s,
            delta: 1
        }),
        n.push({
            t: o,
            delta: -1
        });
    n.sort( (s, o) => s.t === o.t ? s.delta - o.delta : s.t - o.t);
    let r = 0;
    for (let s = 0; s < n.length; s++)
        if (r += n[s].delta,
        r === 0) {
            const o = n[s].t
              , i = n[s + 1];
            if (!i || i.t - o >= t)
                return o
        }
    throw new Error("no idle gap found")
}
function C9e(e) {
    return `${e.type} ${e.targetinstanceof Node ? ym(e.target) : `(unknown target ${e.target})`}`
}
function S9e(e) {
    return _E(t => {
        const n = new _9e;
        function r(s) {
            const o = performance.now();
            n.add( () => {
                t({
                    start: o,
                    end: performance.now(),
                    label: C9e(s)
                })
            }
            )
        }
        for (const s of e)
            window.addEventListener(s, r, {
                capture: !0
            });
        return () => {
            for (const s of e)
                window.removeEventListener(s, r, {
                    capture: !0
                });
            n.clear()
        }
    }
    )
}
function w9e(e) {
    return _E(t => {
        const n = new MutationObserver(r => {
            const s = Yp(r, e);
            s && t({
                time: performance.now(),
                label: m9e( () => g9e(s), o => `error describing mutation: ${o}`)
            })
        }
        );
        return n.observe(document, {
            childList: !0,
            subtree: !0,
            characterData: !0,
            attributes: !1
        }),
        () => n.disconnect()
    }
    )
}
const E9e = ["pointerdown", "touchend", "input", "keydown", "mouseleave", "mouseenter", "drop", "beforeinput", "pointerenter", "dragend", "pointercancel", "compositionupdate", "mousedown", "dragleave", "dragover", "mouseup", "pointerover", "lostpointercapture", "mouseover", "gotpointercapture", "dblclick", "keyup", "keypress", "pointerup", "compositionstart", "auxclick", "dragstart", "touchstart", "compositionend", "pointerout", "dragenter", "touchcancel", "click", "contextmenu", "mouseout", "pointerleave"];
function x9e(e) {
    return e instanceof Element && e.hasAttribute("data-ignore-for-page-load")
}
function Pz(e) {
    return v9e(e) && !x9e(e)
}
function T9e(e) {
    for (const t of e)
        if (Pz(t))
            return !0;
    return !1
}
async function k9e() {
    if (typeof PerformanceObserver != "function")
        return {
            label: "no performance observer"
        };
    const e = E9e.filter(c => !/(enter|leave|over|out)$/.test(c))
      , t = S9e(e)
      , n = w9e(c => c.type === "childList" && T9e(c.addedNodes) || c.type === "characterData" && Pz(c.target))
      , r = await y9e({
        filter: c => c.duration !== 0 && !(c.entryType === "resource" && p9e(ON, c.name))
    })
      , s = t()
      , o = n()
      , i = s.find(c => o.some(u => c.start < u.time && u.time <= c.end));
    if (i != null && i.start < r)
        return {
            label: "mutating input before page loaded",
            firstMutatingInput: i,
            pageIdle: r
        };
    const a = o.filter(c => c.time < r + 200)
      , l = a.at(-1);
    return l ? {
        ...l,
        mutationsBeforeIdle: a.length,
        mutationsBeforeIdleList: a,
        pageIdle: r,
        firstMutatingInput: i
    } : {
        label: "no mutations before page idle",
        pageIdle: r,
        firstMutatingInput: i
    }
}
const O9e = 5 * 60 * 1e3;
function A9e(e) {
    return Math.min(Math.max(e, 0), O9e)
}
function rN(e) {
    return {
        entryType: e.entryType,
        duration: e.duration,
        name: e.name,
        startTime: e.startTime,
        target: e.target instanceof Element ? fN(e.target, void 0) : void 0
    }
}
async function M9e(e) {
    const t = await he( () => import("./c0zax7gkhjidj8rn.js"), []);
    if (!t)
        return;
    const {onCLS: n, onFCP: r, onLCP: s, onINP: o} = t
      , i = new Promise(S => n(S))
      , a = new Promise(S => r(S))
      , l = new Promise(S => s(S));
    Xe(e, "622488229") && o(S => {
        try {
            q.addAction("web-vitals.inp-long", {
                id: S.id,
                delta: S.delta,
                rating: S.rating,
                attribution: {
                    interactionTarget: S.attribution.interactionTarget,
                    nextPaintTime: S.attribution.nextPaintTime,
                    interactionTime: S.attribution.interactionTime,
                    interactionType: S.attribution.interactionType,
                    processedEventEntries: S.attribution.processedEventEntries.map(rN),
                    inputDelay: S.attribution.inputDelay,
                    processingDuration: S.attribution.processingDuration,
                    presentationDelay: S.attribution.presentationDelay,
                    loadState: S.attribution.loadState
                },
                navigationType: S.navigationType,
                name: S.name,
                value: S.value,
                entries: S.entries.map(rN)
            })
        } catch {}
    }
    , {
        durationThreshold: 500
    });
    const c = un(e)
      , u = {
        country: c.userCountry ?? "unknown",
        continent: c.userContinent ?? "unknown",
        device: xg() ? "mobile" : "desktop",
        track: "stable",
        cluster: c.cluster
    }
      , d = S => C => dr.hist(er.DEFAULT, `web.vitals.${S}`, u, C.value);
    i.then(d("cls")),
    a.then(d("fcp")),
    l.then(d("lcp"));
    const [f,p,m] = await Promise.all([i, a, l])
      , v = S => Math.min(Math.max(S, 0), 5 * 60 * 1e3)
      , _ = v(f.value)
      , y = v(p.value)
      , b = v(m.value);
    ft.logEvent("chatgpt_web_vitals", b, {
        cls: String(f.value),
        fcp: String(p.value),
        lcp: String(m.value),
        cls_trimmed: String(_),
        fcp_trimmed: String(y),
        lcp_trimmed: String(b)
    })
}
function I9e(e) {
    const t = window.__reactRouterManifest
      , n = new Set([t.entry].concat(e.map(s => t.routes[s])).flatMap(s => [s.module, ...s.imports].map(o => new URL(o,location.origin).toString())))
      , r = performance.getEntriesByType("resource").filter(s => n.has(s.name));
    if (r.length === n.size) {
        const s = {
            transfer_size: r.reduce( (o, i) => o + i.transferSize, 0),
            encoded_body_size: r.reduce( (o, i) => o + i.encodedBodySize, 0),
            decoded_body_size: r.reduce( (o, i) => o + i.decodedBodySize, 0)
        };
        q.addAction("pageLoad.jsResourceSizes", {
            ...s,
            count: r.length,
            route_id: e[e.length - 1],
            route_ids: e
        })
    } else
        q.addAction("pageLoad.jsResourceSizes.missing", {
            missing: n.difference ? Array.from(n.difference(new Set(r.map(s => s.name)))) : null
        })
}
function R9e() {
    const e = h.useRef([])
      , t = h.useRef( (n, r) => {
        const s = setTimeout(n, r);
        return e.current.push(s),
        s
    }
    );
    return h.useEffect( () => {
        const n = e.current;
        return () => {
            n.forEach(r => {
                clearTimeout(r)
            }
            )
        }
    }
    , []),
    t.current
}
function N9e(e) {
    const {speed: t=100, value: n="", typing: r, onTyped: s, initTyped: o, chunk: i} = e
      , [a,l] = h.useState(0)
      , c = h.useRef(void 0)
      , u = R9e()
      , d = rSe();
    function f(p, m, v) {
        c.current = u(function() {
            p >= m.length || (l(p + v),
            s?.(),
            f(p + v, m, v))
        }, t)
    }
    return h.useEffect( () => (l(o ? n.length : 0),
    r && f(0, n, i ? 4 : 1),
    () => {
        clearTimeout(c.current)
    }
    ), [r, n]),
    g.jsxs(g.Fragment, {
        children: [g.jsx("span", {
            className: we("whitespace-pre-wrap", a < n.length && "result-streaming no-flow", d ? "dark" : "light"),
            children: g.jsx("span", {
                children: n.slice(0, a)
            })
        }), g.jsx("span", {
            className: "whitespace-pre-wrap text-transparent",
            children: n.slice(a)
        })]
    })
}
function P9e({showReturnHome: e=!1}) {
    const t = h.useId()
      , n = oo()
      , [r] = h.useState( () => {
        {
            const s = document.getElementById(t)?.dataset.index;
            if (s != null)
                return parseInt(s)
        }
        return Math.floor(Math.random() * sN.length)
    }
    );
    return g.jsx("section", {
        className: "flex h-screen flex-col items-center justify-center",
        "data-index": r,
        id: t,
        children: g.jsxs("div", {
            children: [g.jsxs("h3", {
                children: [g.jsx(I4, {
                    className: "mb-2 h-6 w-6 align-baseline"
                }), "404 Not Found"]
            }), g.jsx("p", {
                className: "mt-2 max-w-lg pb-6",
                children: g.jsx(N9e, {
                    value: sN[r].message,
                    typing: !0,
                    speed: 150,
                    chunk: !0
                })
            }), e && g.jsx(an, {
                color: "primary",
                onClick: () => {
                    V.logEventWithStatsig("404 Page Return Home Button Clicked", "chatgpt_404_page_return_home_button_clicked"),
                    n("/")
                }
                ,
                children: g.jsx(de, {
                    id: "Cc1py2",
                    defaultMessage: "Go to ChatGPT"
                })
            })]
        })
    })
}
const sN = [{
    message: `Lost in the vast web,
Where you sought, there's only voidâ€”
Nothingness awaits.`
}, {
    message: `Paths cross empty void
Seeking what once existed
Silence answers all.`
}, {
    message: `Where we are, there's only air,
A page misplaced, it isn't there.
In the void where data fades,
Questions linger, answers evade.
Not all paths lead where we care.`
}, {
    message: `Where the page should be,
Empty space and missing wordsâ€”
A void in the code.`
}, {
    message: `The link was a dream,
A shadow of what once wasâ€”
Now, nothing remains.`
}, {
    message: `In the heat of day,
The path dissolves to nothingâ€”
An empty mirage.`
}]
  , D9e = h.createContext({
    cspNonce: ""
});
function L9e() {
    "use forget";
    const e = De.c(8)
      , t = aN()
      , {cspNonce: n} = h.useContext(D9e);
    let r;
    e[0] === Symbol.for("react.memo_cache_sentinel") ? (r = g.jsxs("head", {
        children: [g.jsx("meta", {
            charSet: "UTF-8"
        }), g.jsx(hN, {})]
    }),
    e[0] = r) : r = e[0];
    let s;
    e[1] !== t ? (s = m$(t) ? t.status === 404 ? g.jsx(P9e, {}) : g.jsx(OS, {
        error: new Error(`Route Error (${t.status} ${t.statusText}): ${t.message}`),
        resetError: j9e
    }) : g.jsx(OS, {
        error: t,
        resetError: F9e
    }),
    e[1] = t,
    e[2] = s) : s = e[2];
    let o;
    e[3] !== n ? (o = g.jsx(pN, {
        nonce: n
    }),
    e[3] = n,
    e[4] = o) : o = e[4];
    let i;
    return e[5] !== s || e[6] !== o ? (i = g.jsxs("html", {
        "data-build": Hu,
        suppressHydrationWarning: !0,
        children: [r, g.jsxs("body", {
            children: [s, o]
        })]
    }),
    e[5] = s,
    e[6] = o,
    e[7] = i) : i = e[7],
    i
}
function F9e() {
    return location.reload()
}
function j9e() {
    return location.reload()
}
const U9e = 30;
function B9e() {
    const e = Wt.getItem(Ft.LastPageLoadDate)
      , t = new Date
      , n = typeof e == "string" ? new Date(e) : null
      , r = Math.min(n != null ? Math.floor((t.getTime() - n.getTime()) / (1e3 * 60 * 60)) : 1 / 0, U9e * 24)
      , s = Math.floor(r / 24);
    Wt.setItem(Ft.LastPageLoadDate, t.toISOString()),
    q.addAction("time_since_last_page_load", {
        hoursSinceLastPageLoad: r,
        daysSinceLastPageLoad: s
    })
}
function q9e() {
    const e = window.document;
    let t, n;
    const r = o => {
        t = o,
        cancelAnimationFrame(n),
        requestAnimationFrame( () => {
            n = requestAnimationFrame( () => {
                t = void 0
            }
            )
        }
        )
    }
      , s = {
        capture: !0,
        passive: !0
    };
    e.addEventListener("pointerdown", o => {
        r(o.pointerType === "touch" ? "touch" : "mouse")
    }
    , s),
    e.addEventListener("keydown", () => {
        r("keyboard")
    }
    , s),
    e.addEventListener("focusin", () => {
        dF(e.documentElement, "data-focus-mode", t)
    }
    , s)
}
const oN = "rq:";
function G9e(e) {
    const t = []
      , n = [];
    for (const r of e)
        if (r.data) {
            for (const [s,o] of Object.entries(r.data))
                if (s.startsWith(oN)) {
                    const i = s.substring(oN.length);
                    Sz(o) ? n.push({
                        queryHash: i,
                        queryKey: JSON.parse(i),
                        state: {
                            fetchStatus: "fetching",
                            status: "pending"
                        },
                        promise: o
                    }) : t.push({
                        queryHash: i,
                        queryKey: JSON.parse(i),
                        state: {
                            ...o,
                            data: o.data
                        }
                    })
                }
        }
    return {
        staticQueries: t,
        promiseQueries: n
    }
}
function V9e() {
    const e = wg();
    return h.useMemo( () => G9e(e), [e])
}
function iN(e) {
    return new Promise(t => {
        setTimeout( () => t(e()), 0)
    }
    )
}
function H9e() {
    const e = "scheduler"in globalThis;
    if (!e)
        return {
            supportsScheduler: e,
            supportsYield: !1
        };
    const n = "yield"in globalThis.scheduler;
    return {
        supportsScheduler: e,
        supportsYield: n
    }
}
let R3;
function z9e() {
    const e = globalThis.scheduler
      , {supportsScheduler: t, supportsYield: n} = H9e();
    return e && n ? e : t && !n ? (Object.defineProperty(e, "yield", {
        value: () => e.postTask( () => {}
        )
    }),
    e) : (R3 || (R3 = {
        postTask: iN,
        yield: () => iN( () => {}
        )
    }),
    R3)
}
class $9e {
    scheduler;
    setScheduler() {
        this.scheduler || (this.scheduler = z9e())
    }
    postTask(t, n) {
        return this.setScheduler(),
        this.scheduler.postTask(t, n)
    }
    yield() {
        return this.setScheduler(),
        this.scheduler.yield()
    }
}
const W9e = new $9e
  , N3 = [];
function K9e(e, t) {
    for (const n of t)
        if (e.getQueryState(n.queryKey) == null) {
            let r;
            const s = new Promise(o => {
                r = o
            }
            );
            N3.push(r),
            mN(e, {
                queries: [{
                    ...n,
                    promise: s.then( () => io(n.promise, "missing react-query hydration promise")).catch(o => {
                        throw W9e.yield().then( () => {
                            e.refetchQueries({
                                queryKey: n.queryKey,
                                exact: !0
                            })
                        }
                        ),
                        q.addAction("react-query.prefetch-hydration.error", {
                            queryKey: JSON.stringify(n.queryKey),
                            error: o
                        }),
                        o
                    }
                    )
                }]
            })
        }
    Cj( () => {
        for (const n of N3)
            n();
        N3.length = 0
    }
    , [t])
}
W5e(),
q9e();
const uNe = () => !1
  , dNe = () => [{
    title: "ChatGPT"
}, ...kne]
  , fNe = C$(L9e);
function Y9e(e) {
    "use forget";
    const t = De.c(48)
      , {children: n, isSearchPage: r, isOrla: s, isEdgeToEdge: o, isElectron: i, isIos: a, isAndroidChrome: l, windowStyle: c, isContainerOTR: u, ddTraceMetadata: d, cspScriptNonce: f, lang: p, pathname: m, promoteCss: v} = e
      , _ = (p && WD.has(p),
    "ltr")
      , y = i === !0 || !1;
    let b;
    t[0] !== s || t[1] !== r || t[2] !== y ? (b = we({
        "snc-root": r,
        "mini-root": s,
        "sdtrn-root": y
    }),
    t[0] = s,
    t[1] = r,
    t[2] = y,
    t[3] = b) : b = t[3];
    let S;
    t[4] === Symbol.for("react.memo_cache_sentinel") ? (S = g.jsx("meta", {
        charSet: "UTF-8"
    }),
    t[4] = S) : S = t[4];
    const C = `width=device-width, initial-scale=1${a ? ", maximum-scale=1" : ""}${o ? ", viewport-fit=cover" : ""}`;
    let w;
    t[5] !== C ? (w = g.jsx("meta", {
        name: "viewport",
        content: C
    }),
    t[5] = C,
    t[6] = w) : w = t[6];
    let x;
    t[7] === Symbol.for("react.memo_cache_sentinel") ? (x = g.jsx(y$, {}),
    t[7] = x) : x = t[7];
    let E;
    t[8] !== l ? (E = l ? g.jsx(Ane, {}) : null,
    t[8] = l,
    t[9] = E) : E = t[9];
    let T;
    t[10] === Symbol.for("react.memo_cache_sentinel") ? (T = g.jsx(Ine, {}),
    t[10] = T) : T = t[10];
    const k = m ?? "";
    let A;
    t[11] !== k ? (A = g.jsx(Mne, {
        pathname: k
    }),
    t[11] = k,
    t[12] = A) : A = t[12];
    let O;
    t[13] !== d ? (O = d ? g.jsxs(g.Fragment, {
        children: [g.jsx("meta", {
            name: "dd-trace-id",
            content: d.traceId
        }), g.jsx("meta", {
            name: "dd-trace-time",
            content: `${d.traceTime}`
        })]
    }) : null,
    t[13] = d,
    t[14] = O) : O = t[14];
    let M, I;
    t[15] === Symbol.for("react.memo_cache_sentinel") ? (M = g.jsx(Rne, {}),
    I = g.jsx(hN, {}),
    t[15] = M,
    t[16] = I) : (M = t[15],
    I = t[16]);
    let R;
    t[17] !== f ? (R = g.jsx("script", {
        nonce: f,
        suppressHydrationWarning: !0,
        children: '!function initScrollTimelineInline(){try{if(CSS.supports("animation-timeline: --works"))return;var t=new Map;document.addEventListener("animationstart",(n=>{if(!(n.target instanceof HTMLElement))return;const e=n.target.getAnimations().filter((t=>t.animationName===n.animationName));t.set(n.target,e)})),document.addEventListener("scrolltimelineload",(n=>{t.forEach(((t,e)=>{t.forEach((t=>{n.detail.upgradeAnimation(t,e)}))})),t.clear()}),{once:!0})}catch{}}();'
    }),
    t[17] = f,
    t[18] = R) : R = t[18];
    let D;
    t[19] !== A || t[20] !== O || t[21] !== R || t[22] !== w || t[23] !== E ? (D = g.jsxs("head", {
        children: [S, w, x, E, T, A, O, M, I, R]
    }),
    t[19] = A,
    t[20] = O,
    t[21] = R,
    t[22] = w,
    t[23] = E,
    t[24] = D) : D = t[24];
    let P;
    t[25] !== s || t[26] !== r ? (P = we({
        snc: r,
        mini: s
    }),
    t[25] = s,
    t[26] = r,
    t[27] = P) : P = t[27];
    let L;
    t[28] !== f || t[29] !== u ? (L = {
        cspScriptNonce: f,
        isContainerOTR: u
    },
    t[28] = f,
    t[29] = u,
    t[30] = L) : L = t[30];
    let N;
    t[31] !== n || t[32] !== L ? (N = g.jsx(_Se.Provider, {
        value: L,
        children: n
    }),
    t[31] = n,
    t[32] = L,
    t[33] = N) : N = t[33];
    let B;
    t[34] !== f || t[35] !== v ? (B = g.jsx(pN, {
        nonce: f,
        promoteCss: v
    }),
    t[34] = f,
    t[35] = v,
    t[36] = B) : B = t[36];
    let H;
    t[37] !== P || t[38] !== N || t[39] !== B || t[40] !== c ? (H = g.jsxs("body", {
        className: P,
        "data-window-style": c,
        children: [N, B]
    }),
    t[37] = P,
    t[38] = N,
    t[39] = B,
    t[40] = c,
    t[41] = H) : H = t[41];
    let ye;
    return t[42] !== _ || t[43] !== p || t[44] !== D || t[45] !== b || t[46] !== H ? (ye = g.jsxs("html", {
        lang: p,
        "data-build": Hu,
        dir: _,
        className: b,
        suppressHydrationWarning: !0,
        children: [D, H]
    }),
    t[42] = _,
    t[43] = p,
    t[44] = D,
    t[45] = b,
    t[46] = H,
    t[47] = ye) : ye = t[47],
    ye
}
const hNe = b$(function(t) {
    "use forget";
    const {clientBootstrap: n, cspScriptNonce: r, dd: s, statsigGateEvaluationsPromise: o, promoteCss: i} = AS();
    {
        br.setGlobalContextProperty("cluster", n.cluster),
        q.addFeatureFlagEvaluation("promote_css", i);
        for (const [C,w] of Object.entries(n.session?.rumViewTags ?? {}))
            br.setViewContextProperty(C, w)
    }
    const a = h.useCallback( () => {
        const C = Ot() ?? vN();
        return O$(C, n),
        C
    }
    , [n])
      , [l,c] = h.useState( () => a());
    l || (q.addError(new Error("Context not generated during intialization.")),
    c(a()));
    const u = Aa(l);
    h.useEffect( () => {
        vSe(l)
    }
    , [l]),
    HY(),
    h.useEffect( () => {
        B9e(),
        M9e(l),
        k9e().then(C => {
            if ("pageIdle"in C && q.addFirstTiming("pageLoad.pageIdle", performance.timeOrigin + C.pageIdle),
            "time"in C && C.time != null) {
                const w = C.time
                  , x = A9e(w);
                q.addFirstTiming("pageLoad.lastMutation", performance.timeOrigin + w),
                q.addAction("pageLoad.lastMutation", C),
                ft.logEvent("chatgpt_web_last_mutation_time", void 0, {
                    raw_duration_ms: String(w),
                    trimmed_duration_ms: String(x)
                })
            } else
                q.addAction("pageLoad.withoutTiming", C);
            if ("mutationsBeforeIdleList"in C)
                for (const w of C.mutationsBeforeIdleList)
                    q.addAction("pageLoad.mutation", w)
        }
        ),
        J9e(l)
    }
    , [l]);
    const {staticQueries: d, promiseQueries: f} = V9e()
      , p = h.useMemo( () => ({
        queries: [...d],
        mutations: []
    }), [d]);
    Z9e(u, f);
    const m = wg().map(C => C.id)
      , [v] = h.useState( () => {
        {
            mN(u, p),
            B3e(l, u),
            P3e(l, n, u),
            o.then(C => {
                for (const [w,x] of Object.entries(C))
                    q.addFeatureFlagEvaluation(w, x)
            }
            );
            try {
                I9e(m)
            } catch (C) {
                q.addError(C)
            }
        }
        return !0
    }
    )
      , {pathname: _} = cs()
      , y = _.startsWith("/search")
      , b = Bg(l)
      , S = us(l).checkGate("1536947154");
    return g.jsx(w$, {
        sessionContext: l,
        children: g.jsx(Y9e, {
            lang: n.locale,
            isIos: n.isIos,
            isAndroidChrome: n.isAndroidChrome,
            isElectron: n.isElectron,
            isEdgeToEdge: S,
            isOrla: b,
            isSearchPage: y,
            cspScriptNonce: r,
            ddTraceMetadata: s,
            windowStyle: n.windowStyle,
            isContainerOTR: n.isContainerOTR,
            pathname: _,
            promoteCss: i,
            children: g.jsx(k3e, {
                children: g.jsx(Z5e, {
                    attribute: "class",
                    children: g.jsxs(g$, {
                        client: u,
                        children: [g.jsx(tne, {
                            cspScriptNonce: r
                        }), g.jsx(v$, {
                            state: p,
                            children: g.jsx(c9e, {
                                children: g.jsx(_$, {})
                            })
                        })]
                    })
                })
            })
        })
    })
})
  , Z9e = K9e;
function J9e(e) {
    une(e).composer.autofocusDisabled$() && requestAnimationFrame( () => {
        requestAnimationFrame( () => {
            const n = document.querySelector("h1") ?? D3e({
                root: document.body
            });
            n instanceof HTMLElement && typeof n.focus == "function" && n.focus()
        }
        )
    }
    )
}
export {yB as $, Tz as A, an as B, Ti as C, q8e as D, yn as E, $Ce as F, li as G, vf as H, Wt as I, Au as J, nAe as K, Ft as L, iAe as M, er as N, lt as O, V as P, o2e as Q, ie as R, Nhe as S, Ce as T, zu as U, _t as V, q as W, gf as X, t4 as Y, U6 as Z, l1 as _, ue as a, Gt as a$, L1 as a0, r4 as a1, kfe as a2, Dfe as a3, Ofe as a4, jfe as a5, $6 as a6, ks as a7, W6 as a8, pL as a9, MD as aA, ID as aB, Dt as aC, $fe as aD, Qt as aE, Du as aF, dl as aG, wo as aH, f1 as aI, $t as aJ, YCe as aK, Dp as aL, ah as aM, L6e as aN, gRe as aO, _8e as aP, NZ as aQ, E8e as aR, AZ as aS, LL as aT, Fxe as aU, sge as aV, p3e as aW, x3e as aX, EQ as aY, Fc as aZ, V6e as a_, Bo as aa, SL as ab, G6 as ac, yhe as ad, aw as ae, Wbe as af, Jbe as ag, K6 as ah, dRe as ai, lMe as aj, ft as ak, Jke as al, rV as am, Nn as an, f2e as ao, eD as ap, $g as aq, he as ar, xIe as as, TD as at, kD as au, rD as av, OD as aw, AD as ax, RD as ay, ja as az, E6 as b, uF as b$, mQ as b0, nCe as b1, Ai as b2, $re as b3, G8e as b4, Zs as b5, lhe as b6, oke as b7, Nf as b8, hTe as b9, d8e as bA, Qr as bB, A9e as bC, Qf as bD, lJ as bE, Ql as bF, Vt as bG, Qe as bH, vw as bI, S1 as bJ, kF as bK, _w as bL, TF as bM, K2e as bN, Gye as bO, I4 as bP, ir as bQ, un as bR, us as bS, vCe as bT, Dr as bU, Tn as bV, Cxe as bW, jx as bX, L6 as bY, ki as bZ, g4 as b_, dh as ba, pl as bb, QEe as bc, kh as bd, _Ce as be, cn as bf, h1 as bg, bRe as bh, IIe as bi, bt as bj, ATe as bk, MTe as bl, Xg as bm, Qd as bn, af as bo, fQ as bp, Ke as bq, ine as br, YRe as bs, TS as bt, ML as bu, u1 as bv, Jd as bw, xV as bx, Tg as by, s8e as bz, Xe as c, Pxe as c$, RL as c0, xxe as c1, qf as c2, Pw as c3, ND as c4, yF as c5, $u as c6, co as c7, xs as c8, xn as c9, l4 as cA, td as cB, hbe as cC, mr as cD, pV as cE, U as cF, jG as cG, Xxe as cH, nF as cI, Bye as cJ, jye as cK, Hye as cL, Xd as cM, bCe as cN, Sxe as cO, op as cP, mw as cQ, dn as cR, bhe as cS, Kbe as cT, Bs as cU, O8e as cV, A8e as cW, iJ as cX, R8e as cY, aJ as cZ, jl as c_, L8e as ca, D8e as cb, w6 as cc, rh as cd, oD as ce, Dl as cf, kX as cg, NX as ch, sD as ci, FX as cj, L3e as ck, l8e as cl, k0 as cm, zA as cn, RCe as co, fTe as cp, uae as cq, uA as cr, nc as cs, fhe as ct, o4 as cu, _h as cv, Ake as cw, Zye as cx, Nye as cy, GAe as cz, we as d, Zxe as d$, io as d0, ls as d1, UH as d2, O6e as d3, She as d4, g1 as d5, KL as d6, iw as d7, ih as d8, Z6 as d9, sCe as dA, Nte as dB, oCe as dC, pMe as dD, SV as dE, aCe as dF, JCe as dG, y1 as dH, ipe as dI, en as dJ, Zf as dK, r1 as dL, EOe as dM, Gg as dN, vae as dO, s6e as dP, to as dQ, Q9e as dR, du as dS, jH as dT, lRe as dU, Lw as dV, X7e as dW, A4 as dX, ERe as dY, m1 as dZ, Yxe as d_, Hbe as da, Da as db, Iu as dc, t1 as dd, owe as de, CS as df, TRe as dg, Cn as dh, KMe as di, JZ as dj, aTe as dk, lTe as dl, Gse as dm, cMe as dn, kR as dp, sE as dq, kt as dr, c5 as ds, xCe as dt, d6e as du, Mi as dv, $l as dw, zr as dx, at as dy, tRe as dz, Phe as e, cCe as e$, Jxe as e0, Z$ as e1, FS as e2, tw as e3, Tre as e4, Pye as e5, Np as e6, jB as e7, POe as e8, G_e as e9, Xf as eA, T4 as eB, WAe as eC, T1 as eD, Mw as eE, Ro as eF, cj as eG, TX as eH, u6 as eI, xu as eJ, uD as eK, c6 as eL, nh as eM, uj as eN, dj as eO, XCe as eP, OV as eQ, iCe as eR, tCe as eS, rse as eT, sse as eU, Dle as eV, _V as eW, uCe as eX, hh as eY, qQ as eZ, lh as e_, ka as ea, Ske as eb, EIe as ec, xke as ed, Zhe as ee, RB as ef, jke as eg, xh as eh, ao as ei, th as ej, bV as ek, UD as el, Vl as em, jTe as en, VTe as eo, bm as ep, SB as eq, Qae as er, P$ as es, zTe as et, AEe as eu, kr as ev, o7e as ew, Yp as ex, Mge as ey, zZ as ez, ze as f, Exe as f$, Lre as f0, Ff as f1, X2e as f2, MCe as f3, kCe as f4, lw as f5, $P as f6, hw as f7, oMe as f8, Cz as f9, upe as fA, gke as fB, zS as fC, is as fD, nke as fE, sJ as fF, ECe as fG, E2e as fH, ske as fI, CRe as fJ, wCe as fK, Lye as fL, Y8e as fM, PMe as fN, Lj as fO, DMe as fP, iIe as fQ, bIe as fR, qA as fS, yIe as fT, CIe as fU, OMe as fV, TMe as fW, AMe as fX, CMe as fY, fMe as fZ, hMe as f_, zD as fa, R6e as fb, VQ as fc, g8e as fd, lIe as fe, Pge as ff, $r as fg, HTe as fh, CV as fi, yke as fj, wAe as fk, lAe as fl, dAe as fm, Bn as fn, rAe as fo, Jn as fp, rt as fq, Sle as fr, aV as fs, tz as ft, Wd as fu, LH as fv, FL as fw, Ba as fx, Ct as fy, Na as fz, sn as g, DD as g$, Fge as g0, LMe as g1, i6 as g2, y8e as g3, kOe as g4, SN as g5, kB as g6, SG as g7, Cse as g8, hF as g9, BZ as gA, xOe as gB, TOe as gC, __e as gD, FY as gE, bte as gF, xre as gG, XP as gH, DB as gI, RIe as gJ, ySe as gK, M8e as gL, N8e as gM, k8e as gN, I8e as gO, bl as gP, T8e as gQ, KIe as gR, vIe as gS, t3e as gT, HIe as gU, ere as gV, rCe as gW, LD as gX, Do as gY, Re as gZ, V8e as g_, JL as ga, o9 as gb, gxe as gc, Fee as gd, mxe as ge, jee as gf, vxe as gg, pxe as gh, CTe as gi, xg as gj, rTe as gk, Pu as gl, MB as gm, We as gn, _F as go, Es as gp, Vke as gq, jme as gr, qIe as gs, MH as gt, Ar as gu, uIe as gv, dIe as gw, eT as gx, Aae as gy, n1 as gz, Be as h, lne as h$, Nh as h0, GRe as h1, lxe as h2, lF as h3, yV as h4, cu as h5, Wne as h6, $Re as h7, bo as h8, ige as h9, Mu as hA, Gp as hB, h7e as hC, Lxe as hD, mie as hE, bie as hF, vie as hG, _ie as hH, aie as hI, F8e as hJ, zRe as hK, dse as hL, Are as hM, nw as hN, Xl as hO, Ei as hP, Hxe as hQ, Fj as hR, _Ae as hS, wxe as hT, F4 as hU, $Oe as hV, u2e as hW, hAe as hX, GOe as hY, yAe as hZ, Jce as h_, vbe as ha, mbe as hb, _be as hc, pbe as hd, gbe as he, bh as hf, sr as hg, qTe as hh, qhe as hi, Ihe as hj, a4 as hk, Mhe as hl, Rhe as hm, jhe as hn, z_e as ho, qle as hp, Axe as hq, Q8e as hr, Va as hs, hae as ht, W0e as hu, Wl as hv, Ao as hw, ZG as hx, eAe as hy, QOe as hz, IL as i, Al as i$, E$ as i0, mAe as i1, XOe as i2, _N as i3, J1 as i4, n3e as i5, BRe as i6, nTe as i7, zEe as i8, uQ as i9, ny as iA, kSe as iB, YTe as iC, T$ as iD, uL as iE, nJ as iF, zre as iG, dw as iH, Ot as iI, TIe as iJ, G4 as iK, fae as iL, gTe as iM, kIe as iN, c2 as iO, Nw as iP, Oj as iQ, Y$ as iR, gse as iS, _se as iT, _Me as iU, PCe as iV, $Ie as iW, Hke as iX, Rr as iY, z8 as iZ, LS as i_, Wxe as ia, Kxe as ib, R6 as ic, L7e as id, Ca as ie, _Ie as ig, SIe as ih, kle as ii, JH as ij, sz as ik, DOe as il, T6 as im, ale as io, J3 as ip, z2e as iq, o8e as ir, VIe as is, UG as it, AOe as iu, URe as iv, rw as iw, KRe as ix, WRe as iy, Ble as iz, u6e as j, qCe as j$, da as j0, oE as j1, ph as j2, Fw as j3, ane as j4, BH as j5, Qke as j6, eTe as j7, GMe as j8, Aa as j9, fke as jA, LB as jB, qY as jC, BTe as jD, FRe as jE, Vg as jF, rE as jG, RP as jH, Iee as jI, fL as jJ, UZ as jK, sxe as jL, dxe as jM, zl as jN, CCe as jO, U8e as jP, Ime as jQ, Dme as jR, vRe as jS, cQ as jT, wQ as jU, E3e as jV, lQ as jW, fRe as jX, GQ as jY, NTe as jZ, Vc as j_, Coe as ja, cTe as jb, Cie as jc, wie as jd, Sie as je, yie as jf, bae as jg, NOe as jh, aQ as ji, RTe as jj, yae as jk, ca as jl, W2e as jm, jS as jn, oNe as jo, qn as jp, Bxe as jq, qxe as jr, ISe as js, nRe as jt, rRe as ju, l6e as jv, ii as jw, H8e as jx, hke as jy, pke as jz, xee as k, x7e as k$, GCe as k0, pIe as k1, K8e as k2, uOe as k3, t4e as k4, yRe as k5, kTe as k6, pRe as k7, mRe as k8, Hx as k9, WG as kA, Sbe as kB, JOe as kC, pAe as kD, Txe as kE, uke as kF, L4 as kG, lV as kH, XTe as kI, pse as kJ, hRe as kK, Jg as kL, $8e as kM, exe as kN, W8e as kO, Tbe as kP, VOe as kQ, HOe as kR, cNe as kS, aNe as kT, Z8e as kU, GY as kV, PP as kW, tTe as kX, NV as kY, VY as kZ, A7e as k_, p7e as ka, Bne as kb, c7e as kc, SRe as kd, wRe as ke, W9e as kf, O2e as kg, Uke as kh, x2e as ki, wj as kj, TZ as kk, p8e as kl, kZ as km, h8e as kn, Uxe as ko, Ae as kp, o2 as kq, _f as kr, KAe as ks, YAe as kt, dS as ku, WOe as kv, zOe as kw, F1 as kx, fbe as ky, KG as kz, WP as l, U1 as l$, zbe as l0, Yu as l1, sTe as l2, Rxe as l3, Ur as l4, Wr as l5, K1 as l6, o1e as l7, jge as l8, ibe as l9, nz as lA, IRe as lB, cpe as lC, vke as lD, t7 as lE, lNe as lF, bU as lG, ake as lH, dke as lI, lke as lJ, qke as lK, Gke as lL, Mq as lM, ape as lN, fse as lO, ou as lP, yse as lQ, Fme as lR, CO as lS, Nme as lT, R9e as lU, MIe as lV, xpe as lW, Zke as lX, yMe as lY, ghe as lZ, b$ as l_, AAe as la, fh as lb, Jae as lc, mse as ld, b1 as le, zhe as lf, $he as lg, j1 as lh, Dke as li, q7e as lj, Ywe as lk, SS as ll, XR as lm, xi as ln, Lh as lo, ule as lp, PV as lq, Th as lr, ZRe as ls, i8e as lt, SAe as lu, lpe as lv, MRe as lw, _Se as lx, une as ly, Rt as lz, Bg as m, t7e as m$, hre as m0, Ci as m1, Rye as m2, fr as m3, sOe as m4, J0e as m5, XEe as m6, WH as m7, pz as m8, $H as m9, iE as mA, zne as mB, C8e as mC, e7e as mD, hg as mE, TH as mF, MEe as mG, e6e as mH, o7 as mI, fF as mJ, FIe as mK, BIe as mL, u8e as mM, N2e as mN, Yhe as mO, Qxe as mP, AB as mQ, axe as mR, lCe as mS, vMe as mT, wMe as mU, X5 as mV, w3 as mW, qRe as mX, E7e as mY, hhe as mZ, xye as m_, Dye as ma, qSe as mb, x8e as mc, l1e as md, i1e as me, Jf as mf, iQ as mg, jm as mh, sAe as mi, Eee as mj, QZ as mk, XZ as ml, O7e as mm, GH as mn, A6e as mo, y6e as mp, OIe as mq, Yc as mr, zH as ms, _Re as mt, SSe as mu, uc as mv, HZ as mw, fIe as mx, hIe as my, che as mz, hT as n, f8e as n$, Ixe as n0, Ahe as n1, sne as n2, FD as n3, SMe as n4, jRe as n5, mhe as n6, hQ as n7, dQ as n8, kke as n9, fNe as nA, hNe as nB, Qc as nC, Jhe as nD, tMe as nE, LTe as nF, t2e as nG, P8e as nH, UOe as nI, qG as nJ, mIe as nK, cIe as nL, DCe as nM, nT as nN, z8e as nO, WIe as nP, Nbe as nQ, WTe as nR, KTe as nS, jIe as nT, ike as nU, UIe as nV, PIe as nW, CAe as nX, Oye as nY, Dte as nZ, _xe as n_, Tke as na, cRe as nb, zIe as nc, s1e as nd, Vse as ne, Gxe as nf, OCe as ng, eCe as nh, k6 as ni, VZ as nj, iMe as nk, Ehe as nl, kL as nm, Oke as nn, Nae as no, Tye as np, OSe as nq, m8e as nr, Vye as ns, rQ as nt, JRe as nu, Yl as nv, pp as nw, MN as nx, uNe as ny, dNe as nz, rSe as o, vAe as o$, kne as o0, bxe as o1, Rj as o2, FTe as o3, Ij as o4, rJ as o5, yxe as o6, jte as o7, v6e as o8, hee as o9, $D as oA, phe as oB, i4 as oC, EB as oD, Aee as oE, hxe as oF, cJ as oG, sNe as oH, eNe as oI, tNe as oJ, nNe as oK, rNe as oL, ZCe as oM, YOe as oN, pA as oO, fAe as oP, uAe as oQ, ZOe as oR, QAe as oS, Ej as oT, VAe as oU, xte as oV, c1 as oW, X6 as oX, zxe as oY, pre as oZ, l2e as o_, Px as oa, Hs as ob, Lke as oc, B2e as od, TB as oe, P9e as of, Sa as og, r9e as oh, cw as oi, NIe as oj, To as ok, HQ as ol, sh as om, zQ as on, pQ as oo, wZ as op, oAe as oq, on as or, T6e as os, JTe as ot, ZZ as ou, YZ as ov, KZ as ow, Me as ox, pe as oy, KQ as oz, Tee as p, Qge as p$, bAe as p0, l5 as p1, di as p2, Fre as p3, rc as p4, Mke as p5, Ike as p6, Rke as p7, x5 as p8, Mye as p9, mMe as pA, uMe as pB, dMe as pC, nIe as pD, gMe as pE, eIe as pF, UMe as pG, D6e as pH, VH as pI, B8e as pJ, cAe as pK, hl as pL, x6 as pM, vS as pN, GIe as pO, $Te as pP, Xwe as pQ, VR as pR, gV as pS, Ere as pT, XL as pU, Cbe as pV, $Me as pW, rIe as pX, oQ as pY, wV as pZ, k3e as p_, OAe as pa, Pre as pb, VMe as pc, zMe as pd, Gne as pe, u5 as pf, uRe as pg, Eke as ph, BAe as pi, JAe as pj, XAe as pk, pue as pl, Ta as pm, Jm as pn, Cae as po, rT as pp, PTe as pq, Dee as pr, uxe as ps, cxe as pt, Nee as pu, zL as pv, jxe as pw, v8e as px, M6e as py, sIe as pz, Vn as q, HRe as q$, ZTe as q0, ahe as q1, Z5 as q2, nQ as q3, mfe as q4, ho as q5, Cce as q6, dU as q7, eke as q8, dCe as q9, GTe as qA, sRe as qB, I6e as qC, gIe as qD, Ug as qE, KY as qF, Hu as qG, jg as qH, GZ as qI, b8e as qJ, qZ as qK, RH as qL, dTe as qM, tQ as qN, fne as qO, Cpe as qP, FB as qQ, iOe as qR, zke as qS, uhe as qT, aRe as qU, bke as qV, J6 as qW, _re as qX, fre as qY, xae as qZ, VRe as q_, kMe as qa, FMe as qb, MMe as qc, YMe as qd, ZMe as qe, JMe as qf, jMe as qg, CZ as qh, wOe as qi, Wi as qj, IB as qk, ed as ql, mOe as qm, pOe as qn, gOe as qo, vOe as qp, _Oe as qq, bOe as qr, COe as qs, fOe as qt, SOe as qu, dOe as qv, oRe as qw, $Ae as qx, OH as qy, MAe as qz, bn as r, oOe as r$, v7e as r0, OOe as r1, ele as r2, she as r3, _fe as r4, mke as r5, Xk as r6, Zfe as r7, _ke as r8, qMe as r9, ixe as rA, oxe as rB, Dhe as rC, Lhe as rD, Qne as rE, ur as rF, Go as rG, rn as rH, Nr as rI, LEe as rJ, HMe as rK, WB as rL, UX as rM, j8e as rN, iRe as rO, hOe as rP, yOe as rQ, DH as rR, w2e as rS, bMe as rT, IMe as rU, WMe as rV, XMe as rW, QMe as rX, d5 as rY, J7e as rZ, la as r_, BMe as ra, P4 as rb, Kn as rc, TAe as rd, GG as re, Pke as rf, BOe as rg, sbe as rh, obe as ri, U6e as rj, J8e as rk, Nke as rl, rMe as rm, Bke as rn, oIe as ro, EAe as rp, RMe as rq, KOe as rr, ORe as rs, xRe as rt, DIe as ru, LIe as rv, gfe as rw, ARe as rx, kRe as ry, gB as rz, dr as s, Gce as s$, BG as s0, $ye as s1, Wye as s2, Kye as s3, jOe as s4, M4 as s5, K0e as s6, kye as s7, Jye as s8, Xye as s9, aOe as sA, rg as sB, Yke as sC, Ope as sD, Xke as sE, Wke as sF, nOe as sG, $ke as sH, tOe as sI, Fke as sJ, mS as sK, xAe as sL, yTe as sM, UAe as sN, nbe as sO, MOe as sP, X0e as sQ, QIe as sR, aIe as sS, BSe as sT, ld as sU, JIe as sV, XIe as sW, eRe as sX, ZIe as sY, YIe as sZ, QTe as s_, dA as sa, ebe as sb, bTe as sc, $Z as sd, aMe as se, ETe as sf, STe as sg, wTe as sh, TTe as si, Wae as sj, fxe as sk, ITe as sl, xTe as sm, xMe as sn, fp as so, eOe as sp, So as sq, bu as sr, S6e as ss, E6e as st, qH as su, Kke as sv, cOe as sw, tge as sx, rOe as sy, lOe as sz, xe as t, Q4e as t$, R1 as t0, sue as t1, tke as t2, ns as t3, Et as t4, tm as t5, $le as t6, Uw as t7, cke as t8, zSe as t9, rke as tA, efe as tB, Yde as tC, kf as tD, vB as tE, nSe as tF, QRe as tG, NSe as tH, Fh as tI, yte as tJ, r8e as tK, fo as tL, IA as tM, tAe as tN, S8e as tO, tJ as tP, eJ as tQ, oz as tR, RRe as tS, LRe as tT, PRe as tU, Hr as tV, vEe as tW, cz as tX, xS as tY, DRe as tZ, jR as t_, XRe as ta, w8e as tb, iNe as tc, AIe as td, d1 as te, rne as tf, rre as tg, T5 as th, DTe as ti, Gm as tj, X8e as tk, $xe as tl, CQ as tm, sa as tn, Oo as to, fu as tp, st as tq, rs as tr, FT as ts, _ue as tt, oce as tu, oJ as tv, Gn as tw, mB as tx, Pce as ty, ru as tz, l7e as u, Vxe as u$, NRe as u0, W4e as u1, FR as u2, LR as u3, E4e as u4, Kd as u5, _ae as u6, OTe as u7, JP as u8, ZAe as u9, qAe as uA, kAe as uB, _Te as uC, jAe as uD, Cke as uE, I2e as uF, FAe as uG, LAe as uH, x6e as uI, pTe as uJ, vTe as uK, kxe as uL, Qte as uM, a8e as uN, tIe as uO, Wre as uP, RAe as uQ, NAe as uR, PAe as uS, IAe as uT, mTe as uU, NL as uV, QQ as uW, txe as uX, nxe as uY, rxe as uZ, EMe as u_, UTe as ua, U2e as ub, Fhe as uc, Uhe as ud, Bhe as ue, dae as uf, WZ as ug, Ibe as uh, uV as ui, Xae as uj, qOe as uk, V_e as ul, DAe as um, G2e as un, P2e as uo, eMe as up, A2e as uq, M2e as ur, HAe as us, L2e as ut, xB as uu, zAe as uv, nMe as uw, wbe as ux, Ebe as uy, wke as uz, Cj as v, ROe as v0, aAe as v1, qB as v2, gAe as v3, gre as v4, Nge as v5, xbe as v6, B7e as v7, gte as v8, ZL as v9, Cre as va, cre as vb, LOe as vc, jY as vd, c8e as ve, xP as vf, mP as vg, gP as vh, Xs as vi, Pn as vj, Tm as vk, Wf as vl, Pg as vm, iu as vn, qe as vo, Ag as vp, YS as vq, or as vr, rr as vs, Fr as vt, NMe as vu, Xge as vv, FOe as vw, sMe as vx, Ku as w, La as x, hpe as y, sQ as z};
//# sourceMappingURL=bmsuaglt5ba8i900.js.map
